// HdmDes.cpp: implementation of the HdmDes class.
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "HdmDes.h"
#include "XLDataBase.h"
#include "hdmdaohang.h"
#include "HDMTdlg.h"
#include   <direct.h> 
#include "DrawGCSLBandDYT.h"
#include "MyLayout.h"
#ifdef VERSION_CAD2016
#include "acedCmdNF.h"
#endif // VERSION_CAD2016

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

double Sfactor;
double CML;
CHdmDaoHang* daohang = NULL;
extern CString Cworkdir, Pro;
extern AcDbVoidPtrArray DesLineInfor;
extern struct ent_Id_Des {
	AcDbObjectId entityId;
	double cml;
	double zory;
	CString roadname;
};
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

HdmDes::HdmDes()
{
	If_end = false;
	road = NULL;
	Zroad = Yroad = NULL;
	RoadSum = 0;
	ZRoadSum = YRoadSum = 0;
	SCALE = 200;
	Sfactor = 1000.0 / SCALE;
	StartPt.x = 0.0;
	StartPt.y = 0.0;
	MAPSUM = 0;
	CurRoad = 0;
	MAP = NULL;
	Ifpage = false;
	m_ljdist = 10.0;
	m_ljdh = 1.0;

	m_IsModifyGutter = false;
	m_GutterPath = L"";
	m_GutterThick = 0.0;

	m_FrameHeight = 554.0;
	m_FrameWid = 780.0;

	m_IsDrawCrossEarthPile = false;
	m_Isbuju_HDm = 0;
	NCM = 0;
	CM = NULL;

	RoadLen = 0, FillEarWok = 0, CutEarWok = 0, CutStnWok = 0, C25 = 0, BrkStn = 0, BrkPav = 0, C15 = 0, GutLen = 0, EarWok = 0, M75 = 0, B = 0, Steel = 0, GreAre = 0, HanGuan = 0,YDAllArea=0;
}

HdmDes::~HdmDes()
{

}

int HdmDes::ReadFile(bool IsForDes, CString mdbfname)
{
	ACHAR pszLabel[256];
	_tcscpy(pszLabel, L"正在读取横断面数据库");
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);
	CString Erro;

	ReadWorkdir();
	//CString  HdmFname;
	if (_tcslen(mdbfname) > 0)
	{
		mdbFname = mdbfname;
	}
	else
	{
		mdbFname = Cworkdir + "\\data\\" + Pro + ".mdb";
	}

	//读道路总数
	XLDataBase mdb;
	mdb.ReadAllRoadName(mdbFname);//读取线路数据库中断链表的数据
	//对所有道路循环，读取地面线，

	if (mdb.m_RoadSum < 1)
	{
		AfxMessageBox(L"当前道路总数为0，请先指定当前方案名称和道路名!");
		return 0;
	}
	if (road) { delete[]road; road = NULL; }
	if (mdb.m_RoadSum > 0)
	{
		if (road) delete[]road; road = NULL;
		road = new RoadHdmdata[mdb.m_RoadSum];
	}

	RoadSum = mdb.m_RoadSum;
	int i;
	for (i = 0; i < mdb.m_RoadSum; i++)
	{
		//   acedSetStatusBarProgressMeterPos(0);    		
		InitRoadData(i);
		road[i].roadname = mdb.Road[i].RoadName;//左绕行段线路性质为-1
		ads_printf(L"\n正在读取%s横断面数据....", road[i].roadname);
		//读平面
		road[i].pm = ReadPm(mdbFname, road[i].roadname);
		if (!road[i].pm)
		{
			Erro.Format(L"读%s平面失败!",mdbFname);
			AfxMessageBox(Erro);
			return 0;
		}
		acedSetStatusBarProgressMeterPos(10);

		//读纵面
		ReadZm(mdbFname, road[i].roadname, L"全幅", road[i]);
		ReadZm(mdbFname, road[i].roadname, L"左幅", road[i]);
		ReadZm(mdbFname, road[i].roadname, L"右幅", road[i]);

		if (!road[i].AllZM && !road[i].ZZM && !road[i].YZM)
		{
			Erro.Format(L"读%s纵面失败!", mdbFname);
			AfxMessageBox(Erro);
			return 0;
		}
		acedSetStatusBarProgressMeterPos(30);
		//读桥梁

		ReadBri(mdbFname, road[i].roadname, L"全幅", road[i]);
		ReadBri(mdbFname, road[i].roadname, L"左幅", road[i]);
		ReadBri(mdbFname, road[i].roadname, L"右幅", road[i]);
		acedSetStatusBarProgressMeterPos(50);

		//读隧道
		ReadTun(mdbFname, road[i].roadname, L"全幅", road[i]);
		ReadTun(mdbFname, road[i].roadname, L"左幅", road[i]);
		ReadTun(mdbFname, road[i].roadname, L"右幅", road[i]);
		acedSetStatusBarProgressMeterPos(70);

		//读超高
		ReadCG(mdbFname, road[i].roadname, L"左超高分段表", road[i]);
		ReadCG(mdbFname, road[i].roadname, L"右超高分段表", road[i]);

		//读加宽
		ReadJK(mdbFname, road[i].roadname, L"左加宽分段表", road[i]);
		ReadJK(mdbFname, road[i].roadname, L"右加宽分段表", road[i]);
		acedSetStatusBarProgressMeterPos(80);

		//读地面线
		if (!ReadHdmdmx(road[i].roadname, mdbFname, road[i]))
		{
			Erro.Format(L"读%s地面线失败，请先提取地面线!", mdbFname);
			AfxMessageBox(Erro);
			return 0;
		}
		if (IsForDes)//为设计读取台阶数据时，此时台阶数据还没有计算出来，应该初始化台阶数据
		{
			if (road[i].NCRS > 0)
			{
				road[i].hdmBench = new HDMDMXdata[2 * road[i].NCRS];//????
				InitHdmBench(road[i].hdmBench, 2 * road[i].NCRS);
			}

		}
		else//为绘图读取台阶数据时，可直接从文件中读取
		{
			ReadHdmBench(road[i].roadname, mdbFname, road[i]);
		}

		acedSetStatusBarProgressMeterPos(90);

		//读横断面标准
		road[i].hdmbz.Read_AllHdmDataFromDbs(mdbFname, road[i].roadname);

		CString  bplzfname;
		bplzfname = Cworkdir + "\\data\\hdmbplz." + Pro;
		FILE *fpr = NULL;
		fpr = _wfopen(bplzfname, L"r");
		if (fpr)
		{
			fwscanf(fpr, L"%lf%lf", &m_ljdist, &m_ljdh);
			fclose(fpr);
		}

		//	   acedSetStatusBarProgressMeterPos(100);    			
		//acedSetStatusBarProgressMeterPos(10 + 80*i*1.0/mdb.m_RoadSum);    			   
		//读横断面路面宽分段

		ReadLMK(mdbFname, road[i].roadname, L"左路面宽分段表", road[i]);

		ReadLMK(mdbFname, road[i].roadname, L"右路面宽分段表", road[i]);

		acedSetStatusBarProgressMeterPos(100);
		ads_printf(L"\nOK!");
	}
	acedSetStatusBarProgressMeterPos(100);

	//
	JD_CENTER *zxpm = NULL, *flxpm = NULL;
	//计算各分离段在主线的左右侧ZxOrYx（与主线重合时取为右侧）
	for (i = 1; i < mdb.m_RoadSum; i++)
	{
		// 	  zxpm =  road[0].pm;
		// 	  flxpm = road[i].pm;
		// 	  double cmlonflx;
		// 	  cmlonflx = flxpm->DLArray[0].BLC + 0.5*(flxpm->XLLength-flxpm->DLArray[0].BLC);
		// 	  struct xlpoint PZ;
		// 	  PZ.lc = cmlonflx;
		// 	  flxpm->xlpoint_pz(&PZ);
		// 	  double dist;
		// 	  road[i].ZxOrYx = zxpm->JudgePTLorR(PZ.x,PZ.y,dist,zxpm->XYArray,zxpm->XYNum);
		// 	  if(road[i].ZxOrYx==0)
		// 		  road[i].ZxOrYx = 1;
		//ads_printf(L"i=%d %lf %lf %lf %d\n",i,PZ.lc,PZ.y,PZ.x,road[i].ZxOrYx);

		//road[0].pm =  road[0].pm;
		//road[i].pm = road[i].pm;
		double cmlonflx;
		cmlonflx = road[i].pm->DLArray[0].BLC + 0.5*(road[i].pm->XLLength - road[i].pm->DLArray[0].BLC);
		struct xlpoint PZ;
		PZ.lc = cmlonflx;
		road[i].pm->xlpoint_pz(&PZ);
		double dist;
		road[i].ZxOrYx = road[0].pm->JudgePTLorR(PZ.x, PZ.y, dist, road[0].pm->XYArray, road[0].pm->XYNum);
		if (road[i].ZxOrYx == 0)
			road[i].ZxOrYx = 1;

	}

	acedRestoreStatusBar();

	return 1;
}

int HdmDes::ReadRoaDFile(JD_CENTER *pm, GLROAD &ZGLR, GLROAD &YGLR)
{
	ACHAR pszLabel[256];
	_tcscpy(pszLabel, L"正在读取横断面数据库");
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);

	//CString  HdmFname;
	//	mdbFname = Cworkdir+"\\data\\"+Pro+".mdb";
	//读道路总数
	XLDataBase mdb;
	int pos, len;
	//	mdb.ReadAllRoadName(mdbFname);//读取线路数据库中断链表的数据
	//对所有道路循环，读取地面线，
	CString MdbName[3];

	if (road) { delete[]road; road = NULL; }
	road = new RoadHdmdata[3];
	int i;
	for (i = 0; i < 3; i++)
	{
		InitRoadData(i);
		MdbName[i] = "";
	}
	road[0].roadname = pm->RoadName;
	MdbName[0] = pm->mdbname;

	if (ZGLR.glxl != "")
	{
		pos = ZGLR.glxl.FindOneOf(L",");
		MdbName[1] = ZGLR.glxl.Left(pos);
		len = ZGLR.glxl.GetLength();
		road[1].roadname = ZGLR.glxl.Right(len - pos - 1);
	}

	if (YGLR.glxl != "")
	{
		pos = YGLR.glxl.FindOneOf(L",");
		MdbName[2] = YGLR.glxl.Left(pos);
		len = YGLR.glxl.GetLength();
		road[2].roadname = YGLR.glxl.Right(len - pos - 1);
	}

	for (i = 0; i < 3; i++)
	{
		acedSetStatusBarProgressMeterPos(0);
		ads_printf(L"\n正在读取%s数据库中%s道路的横断面数据....", MdbName[i], road[i].roadname);
		//读平面
		if (MdbName[i] == "" || road[i].roadname == "")
			continue;
		road[i].pm = ReadPm(MdbName[i], road[i].roadname);
		if (!road[i].pm)
		{
			ads_printf(L"%s %s\n", MdbName[i], road[i].roadname);
			ads_printf(L"读平面失败!\n");
			continue;
		}
		acedSetStatusBarProgressMeterPos(10);

		//读纵面
		ReadZm(MdbName[i], road[i].roadname, L"全幅", road[i]);
		ReadZm(MdbName[i], road[i].roadname, L"左幅", road[i]);
		ReadZm(MdbName[i], road[i].roadname, L"右幅", road[i]);

		if (!road[i].AllZM && !road[i].ZZM && !road[i].YZM)
		{
			ads_printf(L"读纵面失败!\n");
			return 0;
		}
		acedSetStatusBarProgressMeterPos(30);
		//读桥梁
		ReadBri(MdbName[i], road[i].roadname, L"全幅", road[i]);
		ReadBri(MdbName[i], road[i].roadname, L"左幅", road[i]);
		ReadBri(MdbName[i], road[i].roadname, L"右幅", road[i]);
		acedSetStatusBarProgressMeterPos(50);
		//读隧道
		ReadTun(MdbName[i], road[i].roadname, L"全幅", road[i]);
		ReadTun(MdbName[i], road[i].roadname, L"左幅", road[i]);
		ReadTun(MdbName[i], road[i].roadname, L"右幅", road[i]);
		acedSetStatusBarProgressMeterPos(70);
		//读超高
		ReadCG(MdbName[i], road[i].roadname, L"左超高分段表", road[i]);
		ReadCG(MdbName[i], road[i].roadname, L"右超高分段表", road[i]);
		//读加宽
		ReadJK(MdbName[i], road[i].roadname, L"左加宽分段表", road[i]);
		ReadJK(MdbName[i], road[i].roadname, L"右加宽分段表", road[i]);
		acedSetStatusBarProgressMeterPos(80);

		//读地面线
		//	ReadHdmdmx(road[i].roadname,i);
		//	acedSetStatusBarProgressMeterPos(90);    		
		//读横断面标准
		//	road[i].hdmbz.Read_AllHdmDataFromDbs(MdbName[i],road[i].roadname);
		//	acedSetStatusBarProgressMeterPos(100);    			
		//acedSetStatusBarProgressMeterPos(10 + 80*i*1.0/mdb.m_RoadSum);    			   
		//读横断面路面宽分段
		ReadLMK(MdbName[i], road[i].roadname, L"左路面宽分段表", road[i]);
		ReadLMK(MdbName[i], road[i].roadname, L"右路面宽分段表", road[i]);

		acedSetStatusBarProgressMeterPos(100);
		ads_printf(L"\nOK!");
	}
	//	ReadBDFile();
	acedSetStatusBarProgressMeterPos(100);
	acedRestoreStatusBar();
	return 1;
}

void HdmDes::InitRoadData(int i)
{
	road[i].roadname = "";//道路名
	road[i].pm = NULL;
	road[i].AllZM = NULL;
	road[i].ZZM = NULL;
	road[i].YZM = NULL;//整幅纵面,左幅纵面,右幅纵面
	road[i].NAllBri = road[i].NZBri = road[i].NYBri = 0;
	road[i].AllBri = NULL;
	road[i].ZBri = NULL;
	road[i].YBri = NULL;//整幅桥,左幅桥,右幅桥
	road[i].AllTun = NULL;
	road[i].NAllTun = road[i].NZTun = road[i].NYTun = 0;
	road[i].ZTun = NULL;
	road[i].YTun = NULL;//整幅隧,左幅隧,右幅隧
	road[i].ZcgNm = 0;
	road[i].YcgNm = 0;
	road[i].ZjkNm = 0;
	road[i].YjkNm = 0;//超高加宽
	road[i].Zcg = NULL;
	road[i].Ycg = NULL;
	road[i].Zjk = NULL;
	road[i].Yjk = NULL;

	road[i].NCRS = 0;
	road[i].hdmdmx = NULL;
	road[i].hdmBench = NULL;
	road[i].hdmdes = NULL;

	road[i].NZLMK = 0;
	road[i].NYLMK = 0;
	road[i].ZLMK = NULL;
	road[i].YLMK = NULL;
	road[i].BxNum = 0;
	road[i].LorR = 1;
	road[i].ZxOrYx = 1;
}

JD_CENTER *HdmDes::ReadPm(CString mdbname, CString RoadName)
{
	XLDataBase mdb;
	JD_CENTER *pm;
	// 创建每一道路平面对象
	//	mdb.Read_XLDbs(mdbname,L"控制点表",RoadName);
	mdb.Read_XLDbs(mdbname, L"线元表", RoadName);
	mdb.Read_XLDbs(mdbname, L"断链表", RoadName);
	pm = NULL;
	//	ads_printf(L"NJD=%d\n",mdb.NJdCen);
	if (mdb.XYNum > 0)
	{
		pm = (JD_CENTER *)new JD_CENTER(mdb.XYArray, mdb.XYNum);//主线对象
		//    	pm->SetJdCenterArray(mdb.JdCenArray,mdb.NJdCen);
		if (mdb.NDL > 0)
			pm->setDLB(mdb.DLArray, mdb.NDL);
		_tcscpy(pm->mdbname, mdbname);
		_tcscpy(pm->RoadName, RoadName);
	}
	return pm;
}

void HdmDes::ReadZm(CString mdbname, CString RoadName, CString XZ, RoadHdmdata &RoadData)
{
	XLDataBase DBS;
	double PD_array[MAXBPDNUM][4], *dmx = NULL;
	int deshxsw, pdxsw;
	ACHAR GH[8];

	JD_CENTER *pm;
	pm = RoadData.pm;
	int res = DBS.Read_XLDbs(mdbname, L"坡度表", RoadName, XZ);
	int res1 = DBS.Read_XLDbs(mdbname, L"纵断链表", RoadName);
	if (res&&res1)//读坡度
	{
		int NBPD = DBS.NPD;

		for (int i = 0; i < NBPD; i++)
		{
			PD_array[i][0] = TYLC1(DBS.PDB[i].ml, DBS.NZDL, DBS.ZDLArray);
			PD_array[i][1] = DBS.PDB[i].Level;
			PD_array[i][2] = DBS.PDB[i].Rshu;
			PD_array[i][3] = 0.0;
		}

		if (DBS.PDB)
		{
			deshxsw = (int)(PD_array[0][2] + 0.1);
			pdxsw = int(DBS.PDB[0].RLen + 0.001);
			if (DBS.PDB) delete[]DBS.PDB;
			DBS.PDB = NULL;
		}
		if (NBPD > 0)
		{
			pzLinep = RoadData.pm;
			_tcscpy(pzLinep->mdbname, mdbname);
			_tcscpy(pzLinep->RoadName, RoadName);
			if (XZ == "全幅")
			{
				_tcscpy(GH, L"K");
				if (RoadData.AllZM) delete RoadData.AllZM;
				RoadData.AllZM = new GTZDM_ROAD(NBPD, PD_array, &GH[0], 0, deshxsw);
				RoadData.AllZM->setINIT(3, 3, 1, 4, 10);
				RoadData.AllZM->Property = XZ;
			}
			else if (XZ == "左幅")
			{
				if (RoadData.ZZM) delete RoadData.ZZM;
				RoadData.ZZM = new GTZDM_ROAD(NBPD, PD_array, L"K", 0, deshxsw);
				RoadData.ZZM->setINIT(3, 3, 1, 4, 10);
				//断链表		  
				RoadData.ZZM->Property = XZ;
			}
			else if (XZ == "右幅")
			{
				if (RoadData.YZM) delete RoadData.YZM;
				RoadData.YZM = new GTZDM_ROAD(NBPD, PD_array, L"K", 0, deshxsw);
				RoadData.YZM->setINIT(3, 3, 1, 4, 10);
				//断链表
				RoadData.YZM->Property = XZ;
			}
		}
	}
	else
	{
		//		ads_printf(L"\n读坡度表失败!");
		return;
	}
	return;
}
////////////////////////////////////////////////////////////////////////////////
void HdmDes::ReadBri(CString mdbname, CString RoadName, CString XZ, RoadHdmdata &RoadData)
{
	XLDataBase DBS;
	int nbri;

	nbri = 0;
	int res = DBS.Read_XLDbs(mdbname, L"大中桥", RoadName, XZ);
	if (res)//读桥梁
	{
		nbri = DBS.BriNum;
		if (nbri > 0)
		{
			if (XZ == "全幅")
			{
				RoadData.AllBri = new BRITAB[nbri];
				RoadData.NAllBri = nbri;
				for (int i = 0; i < nbri; i++)
					RoadData.AllBri[i] = DBS.Bri[i];
			}
			else if (XZ == "左幅")
			{
				RoadData.ZBri = new BRITAB[nbri];
				RoadData.NZBri = nbri;
				for (int i = 0; i < nbri; i++)
					RoadData.ZBri[i] = DBS.Bri[i];
			}
			else if (XZ == "右幅")
			{
				RoadData.YBri = new BRITAB[nbri];
				RoadData.NYBri = nbri;
				for (int i = 0; i < nbri; i++)
					RoadData.YBri[i] = DBS.Bri[i];
			}
		}

		if (DBS.Bri)
			delete[]DBS.Bri;
		DBS.Bri = NULL;
	}

}

void HdmDes::ReadTun(CString mdbname, CString RoadName, CString XZ, RoadHdmdata &RoadData)
{
	XLDataBase DBS;
	int ntun = 0;

	int res = DBS.Read_XLDbs(mdbname, L"隧道", RoadName, XZ);
	if (res)//读隧道
	{
		ntun = DBS.TunNum;
		if (ntun > 0)
		{
			if (ntun > 0)
			{
				if (XZ == "全幅")
				{
					RoadData.AllTun = new TUNTAB[ntun];
					RoadData.NAllTun = ntun;
					for (int i = 0; i < ntun; i++)
						RoadData.AllTun[i] = DBS.Tun[i];
				}
				else if (XZ == "左幅")
				{
					RoadData.ZTun = new TUNTAB[ntun];
					RoadData.NZTun = ntun;
					for (int i = 0; i < ntun; i++)
						RoadData.ZTun[i] = DBS.Tun[i];
				}
				else if (XZ == "右幅")
				{
					RoadData.YTun = new TUNTAB[ntun];
					RoadData.NYTun = ntun;
					for (int i = 0; i < ntun; i++)
						RoadData.YTun[i] = DBS.Tun[i];
				}
			}
			if (DBS.Tun)
				delete[]DBS.Tun;
			DBS.Tun = NULL;
		}

	}
}

void HdmDes::ReadCG(CString mdbname, CString RoadName, CString CGTABname, RoadHdmdata &RoadData)
{
	XLDataBase xlmdb;
	JD_CENTER *pm;
	xlmdb.Read_XLDbs(mdbname, CGTABname, RoadName);

	pm = RoadData.pm;
	if (xlmdb.NCG < 1)
		return;

	if (CGTABname == "左超高分段表")
	{
		RoadData.ZcgNm = xlmdb.NCG;
		RoadData.Zcg = new CgSZ[RoadData.ZcgNm];
		for (int i = 0; i < RoadData.ZcgNm; i++)
		{
			RoadData.Zcg[i] = xlmdb.CG[i];
			RoadData.Zcg[i].cml = pm->TYLC(RoadData.Zcg[i].xlc);
		}
	}
	else
	{
		RoadData.YcgNm = xlmdb.NCG;
		RoadData.Ycg = new CgSZ[RoadData.YcgNm];
		for (int i = 0; i < RoadData.YcgNm; i++)
		{
			RoadData.Ycg[i] = xlmdb.CG[i];
			RoadData.Ycg[i].cml = pm->TYLC(RoadData.Ycg[i].xlc);
		}
	}

}
void HdmDes::ReadJK(CString mdbname, CString RoadName, CString JKTABname, RoadHdmdata &RoadData)
{
	XLDataBase xlmdb;
	xlmdb.Read_XLDbs(mdbname, JKTABname, RoadName);

	JD_CENTER *pm;

	pm = RoadData.pm;
	if (xlmdb.NCG < 1)
		return;

	if (JKTABname == "左加宽分段表")
	{
		RoadData.ZjkNm = xlmdb.NCG;
		RoadData.Zjk = new CgSZ[RoadData.ZjkNm];
		for (int i = 0; i < RoadData.ZjkNm; i++)
		{
			RoadData.Zjk[i] = xlmdb.CG[i];
			RoadData.Zjk[i].cml = pm->TYLC(RoadData.Zjk[i].xlc);
		}
	}
	else
	{
		RoadData.YjkNm = xlmdb.NCG;
		RoadData.Yjk = new CgSZ[RoadData.YjkNm];
		for (int i = 0; i < RoadData.YjkNm; i++)
		{
			RoadData.Yjk[i] = xlmdb.CG[i];
			RoadData.Yjk[i].cml = pm->TYLC(RoadData.Yjk[i].xlc);
		}
	}
}

int HdmDes::ReadHdmdmx(CString RoadName, CString mdbname, RoadHdmdata &RoadData)
{
	FILE *fpr;
	CString DmxFname;
	int NCRS;

	CString name;
	mdbname.MakeUpper();
	name = mdbname;
	name.Replace(Cworkdir, NULL);
	name.Replace(L"\\DATA\\", NULL);
	name.Replace(L".MDB", NULL);
	DmxFname = Cworkdir + "\\data\\" + "hdmdmx." + name + "." + RoadName;

	fpr = _wfopen(DmxFname, L"r");
	if (fpr)
	{
		fwscanf(fpr, L"%d", &NCRS);

		if (NCRS > 0)
		{
			if (RoadData.NCRS > 0 && RoadData.hdmdmx)
			{
				for (int j = 0; j < RoadData.NCRS; j++)
				{
					RoadData.hdmdmx[j].ZEarPtAry.RemoveAll();
					RoadData.hdmdmx[j].ZEarPtNum = 0;
					RoadData.hdmdmx[j].YEarPtAry.RemoveAll();
					RoadData.hdmdmx[j].YEarPtNum = 0;
				}
				delete[]RoadData.hdmdmx;
				RoadData.hdmdmx = NULL;
			}
			RoadData.NCRS = NCRS;
			RoadData.hdmdmx = new HDMDMXdata[2 * RoadData.NCRS];//1111
		}
		else
			return 0;

		Point pt;
		for (int j = 0; j < RoadData.NCRS; j++)
		{
			fwscanf(fpr, L"%lf%lf%d%d", &RoadData.hdmdmx[j].lc, &RoadData.hdmdmx[j].EarH, &RoadData.hdmdmx[j].ZEarPtNum, &RoadData.hdmdmx[j].YEarPtNum);
			RoadData.hdmdmx[j].ZEarPtAry.RemoveAll();
			int k;
			for (k = 0; k < RoadData.hdmdmx[j].ZEarPtNum; k++)
			{
				fwscanf(fpr, L"%lf%lf", &pt.x, &pt.y);
				RoadData.hdmdmx[j].ZEarPtAry.Add(pt);
			}
			RoadData.hdmdmx[j].YEarPtAry.RemoveAll();
			for (k = 0; k < RoadData.hdmdmx[j].YEarPtNum; k++)
			{
				fwscanf(fpr, L"%lf%lf", &pt.x, &pt.y);
				RoadData.hdmdmx[j].YEarPtAry.Add(pt);
			}
		}
		fclose(fpr);
		return 1;
	}
	else
		return 0;
		//ads_printf(L"打开横断面地面线文件失败!");

}


void HdmDes::ReadHdmBench(CString RoadName, CString mdbname, RoadHdmdata &RoadData)
{
	FILE *fpr;
	CString DmxFname;
	int NCRS;

	CString name;
	mdbname.MakeUpper();
	name = mdbname;
	name.Replace(Cworkdir, NULL);
	name.Replace(L"\\DATA\\", NULL);
	name.Replace(L".MDB", NULL);

	//////////////////////////////////////////////////////////////////////////
	DmxFname = Cworkdir + "\\data\\" + "hdmBench." + name + "." + RoadName;

	fpr = _wfopen(DmxFname, L"r");
	if (fpr)
	{
		fwscanf(fpr, L"%d", &NCRS);

		if (NCRS > 0)
		{
			if (RoadData.NCRS > 0 && RoadData.hdmBench)
			{
				for (int j = 0; j < RoadData.NCRS; j++)
				{
					RoadData.hdmBench[j].ZEarPtAry.RemoveAll();
					RoadData.hdmBench[j].ZEarPtNum = 0;
					RoadData.hdmBench[j].YEarPtAry.RemoveAll();
					RoadData.hdmBench[j].YEarPtNum = 0;
				}
				delete[]RoadData.hdmBench;
				RoadData.hdmBench = NULL;
			}
			RoadData.NCRS = NCRS;
			RoadData.hdmBench = new HDMDMXdata[2 * RoadData.NCRS];//22222
			InitHdmBench(RoadData.hdmBench, 2 * RoadData.NCRS);
		}
		else
			return;

		Point pt;
		for (int j = 0; j < RoadData.NCRS; j++)
		{
			fwscanf(fpr, L"%lf%lf%d%d", &RoadData.hdmBench[j].lc, &RoadData.hdmBench[j].EarH, &RoadData.hdmBench[j].ZEarPtNum, &RoadData.hdmBench[j].YEarPtNum);
			RoadData.hdmBench[j].ZEarPtAry.RemoveAll();
			int k;
			for (k = 0; k < RoadData.hdmBench[j].ZEarPtNum; k++)
			{
				fwscanf(fpr, L"%lf%lf", &pt.x, &pt.y);
				RoadData.hdmBench[j].ZEarPtAry.Add(pt);
			}
			RoadData.hdmBench[j].YEarPtAry.RemoveAll();
			for (k = 0; k < RoadData.hdmBench[j].YEarPtNum; k++)
			{
				fwscanf(fpr, L"%lf%lf", &pt.x, &pt.y);
				RoadData.hdmBench[j].YEarPtAry.Add(pt);
			}
		}
		fclose(fpr);

	}
	else
		ads_printf(L"打开横断面台阶线文件失败!");
	//////////////////////////////////////////////////////////////////////////
}


void HdmDes::ReadLMK(CString mdbname, CString RoadName, CString LMKTABname, RoadHdmdata &RoadData)
{
	XLDataBase xlmdb;
	JD_CENTER *pm;

	pm = RoadData.pm;

	xlmdb.Read_XLDbs(mdbname, LMKTABname, RoadName);
	//   ads_printf(L"lmk=%d\n",xlmdb.NLMK);
	FILE *fpr;
	CString name = mdbname;
	name.MakeUpper();
	int pos, len, k;
	pos = name.Find(L"DATA");
	len = name.GetLength();
	name = name.Right(len - pos - 5);
	CString fname;
	ReadWorkdir();
	fname = Cworkdir + "\\DATA\\" + "BXLMKD." + name + RoadName;
	if ((fpr = _wfopen(fname, L"r")) != NULL)
	{
		BXLMKD bxtmp;
		fwscanf(fpr, L"%d", &RoadData.BxNum);
		RoadData.pBXArr = new BXLMKD[RoadData.BxNum];
		for (k = 0; k < RoadData.BxNum; k++)
		{
			fwscanf(fpr, L"%lf%lf%d%d%d", &RoadData.pBXArr[k].bxsml, &RoadData.pBXArr[k].bxeml,
				&RoadData.pBXArr[k].LorR, &RoadData.pBXArr[k].bxinf, &RoadData.pBXArr[k].ptnum);
			RoadData.pBXArr[k].ptarr = new double[RoadData.pBXArr[k].ptnum * 3];
			for (int j = 0; j < RoadData.pBXArr[k].ptnum; j++)
				fwscanf(fpr, L"%lf%lf%lf", &RoadData.pBXArr[k].ptarr[j * 3], &RoadData.pBXArr[k].ptarr[j * 3 + 1], &RoadData.pBXArr[k].ptarr[j * 3 + 2]);
		}
		fclose(fpr);
	}

	if (xlmdb.NLMK < 1)
		return;

	if (LMKTABname == "左路面宽分段表")
	{
		RoadData.NZLMK = xlmdb.NLMK;
		RoadData.ZLMK = new LMKdata[xlmdb.NLMK];
		for (int i = 0; i < xlmdb.NLMK; i++)
		{
			RoadData.ZLMK[i] = xlmdb.lmk[i];
			RoadData.ZLMK[i].cml = pm->TYLC(RoadData.ZLMK[i].xlc);
		}
	}
	else
	{
		RoadData.NYLMK = xlmdb.NLMK;
		RoadData.YLMK = new LMKdata[xlmdb.NLMK];
		for (int i = 0; i < xlmdb.NLMK; i++)
		{
			RoadData.YLMK[i] = xlmdb.lmk[i];
			RoadData.YLMK[i].cml = pm->TYLC(RoadData.YLMK[i].xlc);
		}
	}

	if (xlmdb.lmk)
		delete[]xlmdb.lmk;
	xlmdb.lmk = NULL;
	xlmdb.NLMK = 0;

}


void HdmDes::DesignHdm()
{
	//0-一般断面,-1-桥头,-2-隧头
	//         1-桥尾  2-隧尾
	//         3-桥中
	//         4-隧中
	acdbHostApplicationServices()->workingDatabase()->loadLineTypeFile(L"*.*", L"acadiso.lin");
	acdbHostApplicationServices()->workingDatabase()->setLtscale(0.1);
	CreateLayer(L"清表土");
	int i;
	if (!ReadFile(true))//读文件
		return;

	ReadBDFile();


	//从鼻端文件中读取左右关联道路，若道路总数>0按互通处理，否则按分离式处理
	CString xl1;
	xl1.Format(L"%s,%s", road[0].pm->mdbname, road[0].roadname);

	if (!SetHdmLm())
		return;//求路面

	FindAndReadLinkRoad(xl1);

	ads_printf(L"读数据库OK!\n");

	ads_printf(L"计算路面线OK!\n");

	if (ZRoadSum + YRoadSum < 1)//主线无关联道路,只考虑分离式路基设计
	{
		//设计主线横断面
		if (RoadSum > 0)
		{

			//if(!ptriDTM)
			//	ptriDTM = (triDTM_road *)new triDTM_road;

			if (ptriDTM.DTMHasRead == 0)
			{
				ptriDTM.Read_Dtm();

			}

			Cal_FLD_Fendml();
			ads_printf(L"计算分离点OK!\n");

			//往主线中插入分离段起终断面
			for (int i = 1; i < RoadSum; i++)
			{
				InsertFLDStartOrEndHdm(i, -1);
				InsertFLDStartOrEndHdm(i, 1);
			}


			Design_ZX_Hdm();

			Design_FLD_Hdm();

			if (ptriDTM.DTMHasRead == 1)
			{
				ptriDTM.ReleaseDtm();
			}

			WriteFile();

			if (road[0].NCRS > 0)
				Draw_ZX_Hdm(road[0].hdmdes[0].cml, road[0].hdmdes[road[0].NCRS - 1].cml);

			for (i = 1; i < RoadSum; i++)
			{

				Draw_FLD_Hdm(i);
			}

			ads_printf(L"输出成果数据OK!\n");
		}
	}
	else//主线有关联道路,按互通立交路基设计
	{
		//设计主线横断面
		if (RoadSum > 0)
		{
			Design_ZD_Hdm();

			WriteFile();
			if (road[0].NCRS > 0)
				Draw_ZD_Hdm(road[0].hdmdes[0].cml, road[0].hdmdes[road[0].NCRS - 1].cml);

			ads_printf(L"输出成果数据OK!\n");
		}
	}


	if (daohang)
	{
		delete daohang;
	}
	daohang = NULL;
	daohang = new CHdmDaoHang();

	daohang->Create(IDD_GENZHONG, acedGetAcadFrame());
	daohang->ShowWindow(SW_SHOW);


}

/************************************************************************/
//设置横断面road[i].hdmdes[j]的初始值
//计算路面点
//计算横断面桥隧信息
//计算线间距
//计算road[i]是左线还是右线
/************************************************************************/
bool HdmDes::SetHdmLm()
{
	double cml, dml, Zdesh, Ydesh;
	CString  GH;
	XLDataBase mdb;
	int i;
	for (i = 0; i < RoadSum; i++)
	{
		if (road[i].NCRS > 0)
		{
			if (road[i].hdmdes) delete[]road[i].hdmdes;
			road[i].hdmdes = new CRSDAT[2 * road[i].NCRS];
		}
		else
			continue;

		for (int j = 0; j < road[i].NCRS; j++)
		{
			InitHdmData(i, j);//设置初值

			dml = road[i].hdmdmx[j].lc;
			cml = road[i].pm->TYLC(dml);
			road[i].hdmdes[j].cml = cml;
			road[i].hdmdes[j].dml = dml;
			road[i].hdmdes[j].glRoadName = "无";
			road[i].hdmdes[j].glcml = -1;

			road[i].hdmdes[j].xjj = 0.0;//初始值
			dml = road[i].pm->XLC(cml, GH);
			_tcscpy(road[i].hdmdes[j].ckml, road[i].pm->LCchr(GH, dml, 3));
			//计算路面标高
			//1.计算左幅右幅设计标高			  

			double DesHOnFGDBY;
			Zdesh = CalDesH(cml, road[i].ZZM, road[i].AllZM);
			Ydesh = CalDesH(cml, road[i].YZM, road[i].AllZM);

			//计算路基中线相对于线路中线的偏移量
			double OffsetByXLZX = 0.0;
			CalOffsetByXLZX(cml, road[i].NZLMK, road[i].ZLMK, OffsetByXLZX);
			road[i].hdmdes[j].OffsetByXLZX = OffsetByXLZX;
			if (OffsetByXLZX > 0.001)//线路中线在路基中线的左边，利用左侧的路面宽数据和线路中线标高计算分隔带边缘的标高，修正Zdesh，Ydesh
			{
				DesHOnFGDBY = CalDesHOnFGDBY(cml, Zdesh, road[i].ZcgNm, road[i].Zcg, road[i].ZjkNm,
					road[i].Zjk, road[i].NZLMK, road[i].ZLMK,
					-1, road[i].BxNum, road[i].pBXArr, road[i].pm);
				Zdesh = Ydesh = DesHOnFGDBY;
			}
			if (OffsetByXLZX < -0.001)//线路中线在路基中线的右边，利用右侧侧的路面宽数据和线路中线标高计算分隔带边缘的标高，修正Zdesh，Ydesh
			{
				DesHOnFGDBY = CalDesHOnFGDBY(cml, Ydesh, road[i].YcgNm, road[i].Ycg, road[i].YjkNm,
					road[i].Yjk, road[i].NYLMK, road[i].YLMK,
					1, road[i].BxNum, road[i].pBXArr, road[i].pm);
				Zdesh = Ydesh = DesHOnFGDBY;
			}
			if (road[i].ZcgNm > 0)
			{
				CalLMPT(cml, Zdesh, road[i].ZcgNm, road[i].Zcg, road[i].ZjkNm,
					road[i].Zjk, road[i].NZLMK, road[i].ZLMK, road[i].hdmdes[j].RHFL,
					-1, road[i].BxNum, road[i].pBXArr, road[i].pm);

			}
			else
			{
				CString mes;
				mes.Format(L"请先计算%s左侧超高分段数据!", road[i].roadname);
				ads_alert(mes);
				return false;
			}

			//计算断面属性

			if (j > 0)
				road[i].hdmdes[j].ZDMXZ = SetDmProperty(cml, road[i].pm, road[i].NZBri, road[i].ZBri,
					road[i].NAllBri, road[i].AllBri,
					road[i].NZTun, road[i].ZTun,
					road[i].NAllTun, road[i].AllTun, -1, road[i].hdmdes[j].BriZZDK, road[i].hdmdes[j - 1].ZDMXZ);
			else
				road[i].hdmdes[j].ZDMXZ = SetDmProperty(cml, road[i].pm, road[i].NZBri, road[i].ZBri,
					road[i].NAllBri, road[i].AllBri,
					road[i].NZTun, road[i].ZTun,
					road[i].NAllTun, road[i].AllTun, -1, road[i].hdmdes[j].BriZZDK, 0);

			if (road[i].YcgNm > 0)
				CalLMPT(cml, Ydesh, road[i].YcgNm, road[i].Ycg, road[i].YjkNm,
					road[i].Yjk, road[i].NYLMK, road[i].YLMK, road[i].hdmdes[j].RHFR,
					1, road[i].BxNum, road[i].pBXArr, road[i].pm);
			else
			{
				CString mes;
				mes.Format(L"请先计算%s右侧超高分段数据!", road[i].roadname);
				ads_alert(mes);
				return false;
			}


			if (j > 0)
				road[i].hdmdes[j].YDMXZ = SetDmProperty(cml, road[i].pm, road[i].NYBri, road[i].YBri,
					road[i].NAllBri, road[i].AllBri,
					road[i].NYTun, road[i].YTun,
					road[i].NAllTun, road[i].AllTun, 1, road[i].hdmdes[j].BriYZDK, road[i].hdmdes[j - 1].YDMXZ);
			else
				road[i].hdmdes[j].YDMXZ = SetDmProperty(cml, road[i].pm, road[i].NYBri, road[i].YBri,
					road[i].NAllBri, road[i].AllBri,
					road[i].NYTun, road[i].YTun,
					road[i].NAllTun, road[i].AllTun, 1, road[i].hdmdes[j].BriYZDK, 0);

			double fgdhp, fgdk;

			if (road[i].hdmdes[j].RHFL[8]<0.001 && road[i].hdmdes[j].RHFR[8]>0.01)
			{
				//修正
				Zdesh = road[i].hdmdes[j].RHFR[1];
				for (int k = 0; k < 5; k++)
					road[i].hdmdes[j].RHFL[k * 2 + 1] = Zdesh;
			}
			if (road[i].hdmdes[j].RHFR[8]<0.001 && road[i].hdmdes[j].RHFL[8]>0.01)
			{
				//修正
				Ydesh = Zdesh = road[i].hdmdes[j].RHFL[1];
				for (int k = 0; k < 5; k++)
					road[i].hdmdes[j].RHFR[k * 2 + 1] = Ydesh;
			}
			//  if(i==0 && road[i].hdmdes[j].cml<33950 && road[i].hdmdes[j].cml>33940)
			//   ads_printf(L"XXXXXXcml=%lf  %d %d\n",road[i].hdmdes[j].cml,road[i].hdmdes[j].ZDMXZ , road[i].hdmdes[j].YDMXZ );

		}

	}

	if (RoadSum > 0)//有分离段
	{
		//设置线间距（线间距垂直于主线）
		SetZxXJJ();//设置主线线间距（以主线为一线）
		SetFLDXJJ();//设置分离线线间距（以分离线为一线）
		//判别road[i]在主线的边侧
		int j;
		for (i = 1; i < RoadSum; i++)
		{
			j = 0;
			while (j < road[i].NCRS && fabs(road[i].hdmdes[j].xjj) < 0.001)
				j++;

			if (road[i].hdmdes[j].xjj < 0)
				road[i].LorR = 1;//road[i]为右线
			else
				road[i].LorR = -1;//road[i]为左线			
		}
	}
	return true;
}


void HdmDes::CalHDmLm(int iRoad, double cml, double RHFL[10], double RHFR[10])
{
	double DesHOnFGDBY;
	double Zdesh, Ydesh;
	Zdesh = CalDesH(cml, road[iRoad].ZZM, road[iRoad].AllZM);
	Ydesh = CalDesH(cml, road[iRoad].YZM, road[iRoad].AllZM);

	//计算路基中线相对于线路中线的偏移量
	double OffsetByXLZX = 0.0;
	CalOffsetByXLZX(cml, road[iRoad].NZLMK, road[iRoad].ZLMK, OffsetByXLZX);
	if (OffsetByXLZX > 0.001)//线路中线在路基中线的左边，利用左侧的路面宽数据和线路中线标高计算分隔带边缘的标高，修正Zdesh，Ydesh
	{
		DesHOnFGDBY = CalDesHOnFGDBY(cml, Zdesh, road[iRoad].ZcgNm, road[iRoad].Zcg, road[iRoad].ZjkNm,
			road[iRoad].Zjk, road[iRoad].NZLMK, road[iRoad].ZLMK,
			-1, road[iRoad].BxNum, road[iRoad].pBXArr, road[iRoad].pm);
		Zdesh = Ydesh = DesHOnFGDBY;
	}
	if (OffsetByXLZX < -0.001)//线路中线在路基中线的右边，利用右侧侧的路面宽数据和线路中线标高计算分隔带边缘的标高，修正Zdesh，Ydesh
	{
		DesHOnFGDBY = CalDesHOnFGDBY(cml, Ydesh, road[iRoad].YcgNm, road[iRoad].Ycg, road[iRoad].YjkNm,
			road[iRoad].Yjk, road[iRoad].NYLMK, road[iRoad].YLMK,
			1, road[iRoad].BxNum, road[iRoad].pBXArr, road[iRoad].pm);
		Zdesh = Ydesh = DesHOnFGDBY;
	}
	if (road[iRoad].ZcgNm > 0)
	{
		CalLMPT(cml, Zdesh, road[iRoad].ZcgNm, road[iRoad].Zcg, road[iRoad].ZjkNm,
			road[iRoad].Zjk, road[iRoad].NZLMK, road[iRoad].ZLMK, RHFL,
			-1, road[iRoad].BxNum, road[iRoad].pBXArr, road[iRoad].pm);

	}
	else
	{
		CString mes;
		mes.Format(L"请先计算%s左侧超高分段数据!", road[iRoad].roadname);
		ads_alert(mes);
		return;
	}

	if (road[iRoad].YcgNm > 0)
		CalLMPT(cml, Ydesh, road[iRoad].YcgNm, road[iRoad].Ycg, road[iRoad].YjkNm,
			road[iRoad].Yjk, road[iRoad].NYLMK, road[iRoad].YLMK, RHFR,
			1, road[iRoad].BxNum, road[iRoad].pBXArr, road[iRoad].pm);
	else
	{
		CString mes;
		mes.Format(L"请先计算%s右侧超高分段数据!", road[iRoad].roadname);
		ads_alert(mes);
		return;
	}

	double fgdhp, fgdk;

	if (RHFL[8]<0.001 && RHFR[8]>0.01)
	{
		//修正
		Zdesh = RHFR[1];
		for (int k = 0; k < 5; k++)
			RHFL[k * 2 + 1] = Zdesh;
	}
	if (RHFR[8]<0.001 && RHFL[8]>0.01)
	{
		//修正
		Ydesh = Zdesh = RHFL[1];
		for (int k = 0; k < 5; k++)
			RHFR[k * 2 + 1] = Ydesh;
	}
}

void HdmDes::SetHdmLm(RoadHdmdata &CurXL)
{
	double cml, dml, Zdesh, Ydesh;
	CString  GH;
	XLDataBase mdb;
	int i;

	if (CurXL.NCRS > 0)
		CurXL.hdmdes = new CRSDAT[2 * CurXL.NCRS];

	for (int j = 0; j < CurXL.NCRS; j++)
	{
		InitHdmData(CurXL.hdmdes[j]);//设置初值

		dml = CurXL.hdmdmx[j].lc;
		cml = CurXL.pm->TYLC(dml);
		CurXL.hdmdes[j].cml = cml;

		CurXL.hdmdes[j].dml = dml;
		CurXL.hdmdes[j].glRoadName = "无";
		CurXL.hdmdes[j].glcml = -1;

		CurXL.hdmdes[j].xjj = 0.0;//初始值
		dml = CurXL.pm->XLC(cml, GH);
		_tcscpy(CurXL.hdmdes[j].ckml, CurXL.pm->LCchr(GH, dml, 3));

		//计算路面标高
		//1.计算左幅右幅设计标高			  

		Zdesh = CalDesH(cml, CurXL.ZZM, CurXL.AllZM);

		if (CurXL.ZcgNm > 0)
			CalLMPT(cml, Zdesh, CurXL.ZcgNm, CurXL.Zcg, CurXL.ZjkNm,
				CurXL.Zjk, CurXL.NZLMK, CurXL.ZLMK, CurXL.hdmdes[j].RHFL,
				-1, CurXL.BxNum, CurXL.pBXArr, CurXL.pm);
		else
		{
			CString mes;
			mes.Format(L"请先计算%s左侧超高分段数据!", CurXL.roadname);
			ads_alert(mes);
			return;
		}

		//计算断面属性

		CurXL.hdmdes[j].ZDMXZ = SetDmProperty(cml, CurXL.pm, CurXL.NZBri, CurXL.ZBri,
			CurXL.NAllBri, CurXL.AllBri,
			CurXL.NZTun, CurXL.ZTun,
			CurXL.NAllTun, CurXL.AllTun, -1, CurXL.hdmdes[j].BriZZDK);

		Ydesh = CalDesH(cml, CurXL.YZM, CurXL.AllZM);
		if (CurXL.YcgNm > 0)
			CalLMPT(cml, Ydesh, CurXL.YcgNm, CurXL.Ycg, CurXL.YjkNm,
				CurXL.Yjk, CurXL.NYLMK, CurXL.YLMK, CurXL.hdmdes[j].RHFR,
				1, CurXL.BxNum, CurXL.pBXArr, CurXL.pm);
		else
		{
			CString mes;
			mes.Format(L"请先计算%s右侧超高分段数据!", CurXL.roadname);
			ads_alert(mes);
			return;
		}

		CurXL.hdmdes[j].YDMXZ = SetDmProperty(cml, CurXL.pm, CurXL.NYBri, CurXL.YBri,
			CurXL.NAllBri, CurXL.AllBri,
			CurXL.NYTun, CurXL.YTun,
			CurXL.NAllTun, CurXL.AllTun, 1, CurXL.hdmdes[j].BriYZDK);

		double fgdhp, fgdk;

		if (CurXL.hdmdes[j].RHFL[8]<0.001 && CurXL.hdmdes[j].RHFR[8]>0.01)
		{
			//修正
			Zdesh = CurXL.hdmdes[j].RHFR[1];
			for (int k = 0; k < 5; k++)
				CurXL.hdmdes[j].RHFL[k * 2 + 1] = Zdesh;
		}
		if (CurXL.hdmdes[j].RHFR[8]<0.001 && CurXL.hdmdes[j].RHFL[8]>0.01)
		{
			//修正
			Ydesh = Zdesh = CurXL.hdmdes[j].RHFL[1];
			for (int k = 0; k < 5; k++)
				CurXL.hdmdes[j].RHFR[k * 2 + 1] = Ydesh;
		}


	}
}

/*
void HdmDes::CalHdmBp()
{
double LDesPoint[50],RDesPoint[50],LFillArea,LCutArea,RFillArea,RCutArea,FillArea,CutArea;
double TWH;
double LGouH,LGouX,RGouH,RGouX;
double LFillBetterSoilArea,LFillSSTArea,LQBTArea,LGouTarea,LGouWarea,LHJarea,LSGJQarea,LDQlength,LGrasslength;
double RFillBetterSoilArea,RFillSSTArea,RQBTArea,RGouTarea,RGouWarea,RHJarea,RSGJQarea,RDQlength,RGrasslength;
int Lnpt,Rnpt,j;
double TW[2];//填挖信息
//double LgouTarea,LgouWarea,RgouTarea,RgouWarea;
double ZDesBG,YDesBG;
double cml;

for(int i=0; i<RoadSum; i++)
{
char pszLabel[256];
_stprintf(pszLabel,L"%s横断面自动设计",road[i].roadname);
acedSetStatusBarProgressMeter(pszLabel,0,100);

for(int j=0; j<road[i].NCRS; j++)
{
//计算左幅
road[i].hdmdes[j].DorS = 1;//单路面

//		InitHdmData(i,j);//设置初值

cml = road[i].hdmdes[j].cml;
if(road[i].hdmdes[j].ZDMXZ == 3)//桥中
{
road[i].hdmdes[j].LZDK=road[i].hdmdes[j].RHFL[7]+road[i].hdmdes[j].BriZZDK;//桥梁用地
if(road[i].NCRS==1)
ads_alert(L"指定里程位于桥梁范围内!");
continue;
}

if(road[i].hdmdes[j].ZDMXZ == 4)//隧中
{
road[i].hdmdes[j].LZDK=road[i].hdmdes[j].RHFL[7]+road[i].hdmdes[j].TunZZDK;//桥梁用地
if(road[i].NCRS==1)
ads_alert(L"指定里程位于隧道范围内!");
continue;
}
if(road[i].hdmdes[j].YDMXZ == 3)//桥中
{
road[i].hdmdes[j].RZDK=road[i].hdmdes[j].RHFR[7]+road[i].hdmdes[j].BriYZDK;//桥梁用地
if(road[i].NCRS==1)
ads_alert(L"指定里程位于桥梁范围内!");
continue;
}

if(road[i].hdmdes[j].YDMXZ == 4)//隧中
{
road[i].hdmdes[j].RZDK=road[i].hdmdes[j].RHFR[7]+road[i].hdmdes[j].TunYZDK;//桥梁用地
if(road[i].NCRS==1)
ads_alert(L"指定里程位于隧道范围内!");
continue;
}

//还需考虑桥隧相连的情况
LFillArea=RFillArea=FillArea=LCutArea=RCutArea=CutArea = 0.0;
double NewYd,NewLearpt[400],NewRearpt[400];
int newNumL,newNumR;
NewYd = road[i].hdmdmx[j].EarH;
newNumL = road[i].hdmdmx[j].ZEarPtNum;
for(int k=0; k<newNumL; k++)
{
NewLearpt[k*2] = road[i].hdmdmx[j].ZEarPtAry[k].x;
NewLearpt[k*2+1] = road[i].hdmdmx[j].ZEarPtAry[k].y;
}
CrosNew(i,-1,cml,NewYd,newNumL,NewLearpt,road[i].hdmdes[j].RHFL,road[i].hdmdes[j].zlmhd,1000,
road[i].hdmdes[j].Ldeltah,road[i].hdmdes[j].Zt,road[i].hdmdes[j].ZHc,Lnpt,LDesPoint,
LFillArea,LFillBetterSoilArea,LQBTArea,LCutArea,
road[i].hdmdes[j].LZDK,
road[i].hdmdes[j].LIfSetGouH,road[i].hdmdes[j].LGouH,road[i].hdmdes[j].LGouProperty,road[i].hdmdes[j].LGouPtNum,road[i].hdmdes[j].Lgou,LGouH,LGouX,LGouTarea,LGouWarea,
road[i].hdmdes[j].LJSGouPtNum, road[i].hdmdes[j].LJSgou,
LSGJQarea,LDQlength,LGrasslength);

newNumR = road[i].hdmdmx[j].YEarPtNum;
for(k=0; k<newNumR; k++)
{
NewRearpt[k*2] = road[i].hdmdmx[j].YEarPtAry[k].x;
NewRearpt[k*2+1] = road[i].hdmdmx[j].YEarPtAry[k].y;
}
CrosNew(i,1,cml,NewYd,newNumR,NewRearpt,road[i].hdmdes[j].RHFR,road[i].hdmdes[j].ylmhd,1000,
road[i].hdmdes[j].Rdeltah,road[i].hdmdes[j].Yt,road[i].hdmdes[j].YHc,Rnpt,RDesPoint,
RFillArea,RFillBetterSoilArea,RQBTArea,RCutArea,
road[i].hdmdes[j].RZDK,
road[i].hdmdes[j].RIfSetGouH,road[i].hdmdes[j].RGouH,road[i].hdmdes[j].RGouProperty,road[i].hdmdes[j].RGouPtNum,road[i].hdmdes[j].Rgou,RGouH,RGouX,RGouTarea,RGouWarea,
road[i].hdmdes[j].RJSGouPtNum, road[i].hdmdes[j].RJSgou,
RSGJQarea,RDQlength,RGrasslength);

//计算左右两侧面积

road[i].hdmdes[j].QBTArea = LQBTArea + RQBTArea;//清表土面积
road[i].hdmdes[j].GouTarea = LGouTarea + RGouTarea;//水沟填面积
road[i].hdmdes[j].GouWarea = LGouWarea + RGouWarea;//水沟挖面积
road[i].hdmdes[j].FillArea = LFillArea + RFillArea + road[i].hdmdes[j].GouTarea + road[i].hdmdes[j].QBTArea;//填面积
road[i].hdmdes[j].CutArea = LCutArea + RCutArea + road[i].hdmdes[j].GouWarea; //挖面积
road[i].hdmdes[j].aw = road[i].hdmdes[j].CutArea;
road[i].hdmdes[j].at = road[i].hdmdes[j].FillArea;
road[i].hdmdes[j].FillBetterSoilArea = LFillBetterSoilArea+RFillBetterSoilArea;//填改良土面积
road[i].hdmdes[j].HJarea =  LHJarea + RHJarea;//护肩面积
road[i].hdmdes[j].SGJQarea = LSGJQarea + RSGJQarea;//浆砌面积
road[i].hdmdes[j].DQlength = LDQlength + RDQlength;//挡墙坡长
road[i].hdmdes[j].Grasslength = LGrasslength + RGrasslength;//铺草坡长
//；用于交互设计
road[i].hdmdes[j].Z_LFillArea=LFillArea ; road[i].hdmdes[j].MidFillArea=0.0 ;road[i].hdmdes[j].Y_RFillArea=RFillArea;
road[i].hdmdes[j].Z_LCutArea=LCutArea ;road[i].hdmdes[j].MidCutArea=0.0; road[i].hdmdes[j].Y_RCutArea=RCutArea;
road[i].hdmdes[j].Z_LFillSSTArea = LFillSSTArea ;road[i].hdmdes[j].MidFillSSTArea=0.0;road[i].hdmdes[j].Y_RFillSSTArea=RFillSSTArea;//填渗水土面积
road[i].hdmdes[j].Z_LQBTArea=LQBTArea ;road[i].hdmdes[j].MidQBTArea=0.0;road[i].hdmdes[j].Y_RQBTArea=RQBTArea;
road[i].hdmdes[j].Z_LFillBetterSoilArea=LFillBetterSoilArea ; road[i].hdmdes[j].MidFillGLTArea=0.0 ;road[i].hdmdes[j].Y_RFillBetterSoilArea=RFillBetterSoilArea;
road[i].hdmdes[j].Z_LHJarea=LHJarea ;road[i].hdmdes[j].MidHJarea=0.0 ;road[i].hdmdes[j].Y_RHJarea=RHJarea;
road[i].hdmdes[j].Z_LSGJQarea=LSGJQarea ;road[i].hdmdes[j].MidGouJQarea=0.0;road[i].hdmdes[j].Y_RSGJQarea=RSGJQarea;
road[i].hdmdes[j].Z_LDQlength=LDQlength ;road[i].hdmdes[j].MidDQlength=0.0;road[i].hdmdes[j].Y_RDQlength=RDQlength;//挡墙坡长
road[i].hdmdes[j].Z_LGrasslength=LGrasslength ;road[i].hdmdes[j].MidGrasslength=0.0;road[i].hdmdes[j].Y_RGrasslength=RGrasslength;//铺草坡长
road[i].hdmdes[j].Z_LGouTarea=LGouTarea ; road[i].hdmdes[j].Y_RGouTarea=RGouTarea;
road[i].hdmdes[j].Z_LGouWarea=LGouWarea ;road[i].hdmdes[j].Y_RGouWarea=RGouWarea;


road[i].hdmdes[j].Lnpt = Lnpt;
road[i].hdmdes[j].at = road[i].hdmdes[j].FillArea;
road[i].hdmdes[j].aw = road[i].hdmdes[j].CutArea;
AcGePoint3d pt;

for(k=0; k<Lnpt; k++)
{
pt.x = -1.0*LDesPoint[k*2];
pt.y =  LDesPoint[k*2+1];
road[i].hdmdes[j].RPTL.append(pt);

}

road[i].hdmdes[j].Rnpt = Rnpt;
for(k=0; k<Rnpt; k++)
{
pt.x = RDesPoint[k*2];
pt.y = RDesPoint[k*2+1];
road[i].hdmdes[j].RPTR.append(pt);
}

road[i].hdmdes[j].Ljdnum = road[i].hdmdes[j].Lnpt-1;
road[i].hdmdes[j].Rjdnum = road[i].hdmdes[j].Rnpt-1;
for(k=0;k<road[i].hdmdes[j].LJSGouPtNum;k++)
road[i].hdmdes[j].LJSgou[k*2]=-1*road[i].hdmdes[j].LJSgou[k*2];
for(int kk=0; kk<road[i].hdmdes[j].LGouPtNum; kk++)
road[i].hdmdes[j].Lgou[kk*2] = -1*road[i].hdmdes[j].Lgou[kk*2];
int Pos = (int)(j*100.0/road[i].NCRS);
acedSetStatusBarProgressMeterPos(Pos);
}
acedSetStatusBarProgressMeterPos(100);
acedRestoreStatusBar();
}
}
*/

//填土，改良土，挖（I-VI），渗水土，用地宽,清基，植草(填挖边坡系数>0.5)，三沟(水沟、侧沟、截沟浆砌面积),护肩面积,挡墙面积(填挖边坡系数<0.5)
//左侧或右侧  里程   地面高程   地面点数  地面点坐标  路面点坐标        
int HdmDes::CrosNew(//输入
	int iroad,//道路号
	int MR, int iCross,//MR左右标记-1为左，+1为右
	double Yd, int EarPtSum, double EarPtList[],//Yd 中心地面高程
	double RHF[10],//路面点
	double lmhd[3],//路面厚度
	double InZJ,//支距
	double PJPT[2],//坡脚点
	//输出
	double &deltah,//路面边缘与其对应地面点的高差
	double& FillORCut, double& TWH,
	int& DesPtSum, double DesPtList[],
	//填土面积，填石面积，清表土面积,挖方面积
	double& FillArea, double &FillGLTArea, double& QBTArea, double& CutArea,
	//用地宽
	double& ZDK,
	//排水沟性质(1-水沟，0-坡脚墙)，点数,坐标，沟中心x,y,填面积（包括排水沟和天沟），挖面积（包括排水沟和天沟）
	int &IfSetGouBotH, double &GouBotH, int &GouProperty, int &GouPtNum, double gou[], double &GouH, double &GouX, double &GouTarea, double &GouWarea,
	//截水沟点数,坐标
	int &JSGouPtNum, double JSgou[],
	//三沟浆砌面积,挡墙长度,铺草长度
	double &AllGouJQArea, double &DQlength, double &Grasslength,
	double &CG_GDR)

{
	int DQinf, i, BPptSum;
	double T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, PSG_GDR;
	double D, GK, GS, GP1, GP2, GDR;
	double LUZLMK, LUTLMK, LJXK, LTJK, LZJK, ZWW[2], YWW[2];//ZWW[2]左路堤，路堑加宽；YWW[2]右路堤，路堑加宽
	double ZW, RW, XZ, YZ;//ZW左路基限宽，RW右路基限宽
	int inf, EarPtNum1, EarPtNum2, desinf, k;
	double EarH_LT, EarH_LZ, DesH_LT, DesH_LZ, dh, BJX, BJY;
	double StartDesPt[2], BPpt[50];
	double WallType, WallH, WallTopSoilH, hthd;
	double TM[30], TH[30], TPTW[30], TPTI[30], WM[30], PH[30], ZPTW[30], ZPTI[30];
	int nLTBPJS, nLZBPJS;
	double hjwid, glthd;//渗水土厚度,护肩宽度,改良土厚度
	double PSGouJQarea, CGouJQarea, JSGouJQarea, PJWallJQArea, XJGouJQarea;
	double PSG_JQHD, CG_JQHD, TG_JQHD;
	int IfTG;//是否有天沟
	double TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_GDR;
	double HJarea;
	double ZJ;
	double ArcBP_R;//弧形边坡半径
	double CTwid;//超填宽度
	double WideXJG, HighXJG, NBPXJG, WBPXJG, JQHDXJG, GDRXJG;
	double TmpCG_GDR = 0.0;
	double TmpPSG_GDR = 0.0;
	bool IsAutoLDTP, IsAutoLQTP, IsAutoJKTLJ;
	IsAutoLDTP = IsAutoLQTP = IsAutoJKTLJ = false;
	double cml = road[iroad].hdmdes[iCross].cml;
	double OffsetByXLZX = road[iroad].hdmdes[iCross].OffsetByXLZX;
	//////////////////////////////////////////////////////////////////////////
	road[iroad].hdmBench[iCross].BTxz = road[iroad].hdmdmx[iCross].BTxz;
	road[iroad].hdmBench[iCross].EarH = road[iroad].hdmdmx[iCross].EarH;
	// 	_tcscpy(road[iroad].hdmBench[iCross].flag , road[iroad].hdmdmx[iCross].flag);
	_tcscpy(road[iroad].hdmBench[iCross].flag, L"\0");
	road[iroad].hdmBench[iCross].lc = road[iroad].hdmdmx[iCross].lc;
	road[iroad].hdmBench[iCross].lcflag = road[iroad].hdmdmx[iCross].lcflag;
	// 	if (MR<0)//左侧
	// 	{
	// 		road[iroad].hdmBench[iCross].ZEarPtNum = 0;
	// 		road[iroad].hdmBench[iCross].ZEarPtAry.RemoveAll();
	// 	}
	// 	else
	// 	{
	// 		road[iroad].hdmBench[iCross].YEarPtNum = 0;
	// 		road[iroad].hdmBench[iCross].YEarPtAry.RemoveAll();
	// 	}
	//////////////////////////////////////////////////////////////////////////
	hjwid = 0.0;
	PSGouJQarea = CGouJQarea = JSGouJQarea = PJWallJQArea = XJGouJQarea = 0;
	ArcBP_R = 0.0;
	///////////////////////设置初始值////////////////////////////////////////////////////
	//水沟初始值
	GouProperty = -1;
	GouPtNum = 0;
	GouH = GouX = GouTarea = GouWarea = 0.0;
	JSGouPtNum = 0;//截水沟点数 
	CTwid = 0.0;

	for (i = 0; i < 34; i++)
	{
		gou[i] = 0.0;
		JSgou[i] = 0.0;
	}
	//面积初始值
	FillArea = 0.0;
	FillGLTArea = 0.0;
	QBTArea = 0.0;
	CutArea = 0.0;
	//挡墙及铺草边坡长度初始值
	DQlength = 0.0;
	Grasslength = 0.0;
	//水沟浆砌面积
	AllGouJQArea = 0.0;
	///////////////////////设置初始值////////////////////////////////////////////////////
	if (fabs(OffsetByXLZX) < 0.001)
		TWH = RHF[1] - Yd;//填挖高
	else
	{
		double DesHOnXLZX = RHF[1];
		if (MR < 0)
			DesHOnXLZX = CalDesH(cml, road[iroad].ZZM, road[iroad].AllZM);
		else
			DesHOnXLZX = CalDesH(cml, road[iroad].YZM, road[iroad].AllZM);
		TWH = DesHOnXLZX - road[iroad].hdmdmx[iCross].EarH;
	}

	ZW = FindIljxk(cml, road[iroad].pm, road[iroad].hdmbz.NZDM, road[iroad].hdmbz.ZDM);//左侧限制宽
	RW = FindIljxk(cml, road[iroad].pm, road[iroad].hdmbz.NYDM, road[iroad].hdmbz.YDM);//右侧限制宽
	FindIljjk(cml, road[iroad].pm, road[iroad].hdmbz.NZPWD, road[iroad].hdmbz.ZPWD, ZWW[0], ZWW[1]);//左侧占地加宽
	FindIljjk(cml, road[iroad].pm, road[iroad].hdmbz.NYPWD, road[iroad].hdmbz.YPWD, YWW[0], YWW[1]);//右侧占地加宽

	WallType = -1;
	WallH = 0.0;
	WallTopSoilH = 0.0;

	//2.改良土厚度
	//glthd = FindGLTHD(cml,road[iroad].pm,road[iroad].hdmbz.NLDTL,road[iroad].hdmbz.LDTL);
	glthd = 0.0;
	double fgdhp, fgdk;//分隔带横坡，宽度


	if (MR < 0)//左侧
	{
		//1.排水沟
		//取出护坡道宽，横坡，沟宽，沟深，内侧坡，外侧坡，浆汽厚度
		FindSG(cml, road[iroad].pm, road[iroad].hdmbz.NZLDSG, road[iroad].hdmbz.ZLDSG, GouProperty,
			PSG_JQHD, T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, PSG_GDR);
		//GouProperty=1 排水沟
		//GouProperty=2 路堤路肩沟

		IfSetGouBotH = FindGouBotH(cml, road[iroad].pm, road[iroad].hdmbz.NZGouPD, road[iroad].hdmbz.ZGouPD, GouBotH);


		GouBotH = GouBotH - Yd;



		//2.天沟(0-无天沟,1-有天沟) 
		IfTG = FindTG(cml, road[iroad].pm, road[iroad].hdmbz.NZTG, road[iroad].hdmbz.ZTG, TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_JQHD, TG_GDR);
		DQinf = 0;

		//3.侧沟
		Cal_D(cml, road[iroad].pm, road[iroad].hdmbz.NZLQSG, road[iroad].hdmbz.ZLQSG, &D, &GK, &GS, &GP1, &GP2, &CG_JQHD, &CG_GDR);//路堑边沟宽度

		nLTBPJS = FindWichBP(cml, road[iroad].pm, road[iroad].hdmbz.NZLDBP, road[iroad].hdmbz.ZLDBP, TM, TH, TPTW, TPTI);//左路堤边坡

		nLZBPJS = FindWichBP(cml, road[iroad].pm, road[iroad].hdmbz.NZLQBP, road[iroad].hdmbz.ZLQBP, WM, PH, ZPTW, ZPTI);//左路堑边坡

		//判别是否做弧形边坡，半径记录在最后一级边坡限制高<0, 如：-2表示2m半径
		if (nLZBPJS > 0 && PH[nLZBPJS - 1] < -0.001)//
		{
			ArcBP_R = fabs(PH[nLZBPJS - 1]);
			PH[nLZBPJS - 1] = 100.0;
		}

		LJXK = ZW;//路基限宽
		LTJK = ZWW[0];//路堤加宽
		LZJK = ZWW[1];//路堑加宽
		//清表土厚度
		hthd = FindWichHTHD(cml, road[iroad].pm, road[iroad].hdmbz.NZHTHD, road[iroad].hdmbz.ZHTHD);
		ZJ = FindWichDQ(cml, road[iroad].pm, road[iroad].hdmbz.NZDQ, road[iroad].hdmbz.ZDQ);
		//路面厚
		FindWichHD(cml, road[iroad].pm, road[iroad].hdmbz.NZLMHD, road[iroad].hdmbz.ZLMHD, lmhd);
		CalFgdHp(cml, road[iroad].NZLMK, road[iroad].ZLMK, fgdhp, fgdk);
		//超填宽度
		FindWichCTK(cml, road[iroad].pm, road[iroad].hdmbz.NZCTKD, road[iroad].hdmbz.ZCTKD, CTwid);
		//低填路堤自动填平
		IsAutoLDTP = FindIsAutoLDTP(cml, road[iroad].pm, road[iroad].hdmbz.NZLDTP, road[iroad].hdmbz.ZLDTP);
		//低挖路堑自动推平
		IsAutoLQTP = FindIsAutoLQTP(cml, road[iroad].pm, road[iroad].hdmbz.NZLQTP, road[iroad].hdmbz.ZLQTP);
		//自动加宽土路肩
		IsAutoJKTLJ = FindIsAutoJKTLJ(cml, road[iroad].pm, road[iroad].hdmbz.NZTLJJK, road[iroad].hdmbz.ZTLJJK);
	}
	else//右侧
	{
		//1.排水沟
		FindSG(cml, road[iroad].pm, road[iroad].hdmbz.NYLDSG, road[iroad].hdmbz.YLDSG, GouProperty,
			PSG_JQHD, T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, PSG_GDR);
		IfSetGouBotH = FindGouBotH(cml, road[iroad].pm, road[iroad].hdmbz.NYGouPD, road[iroad].hdmbz.YGouPD, GouBotH);//若设置了水沟底标高，则按照沟底标高计算
		GouBotH = GouBotH - Yd;
		//2.天沟 
		IfTG = FindTG(cml, road[iroad].pm, road[iroad].hdmbz.NYTG, road[iroad].hdmbz.YTG, TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_JQHD, TG_GDR);
		DQinf = 0;
		//3.侧沟
		Cal_D(cml, road[iroad].pm, road[iroad].hdmbz.NYLQSG, road[iroad].hdmbz.YLQSG, &D, &GK, &GS, &GP1, &GP2, &CG_JQHD, &CG_GDR);//路堑边沟宽度
		nLTBPJS = FindWichBP(cml, road[iroad].pm, road[iroad].hdmbz.NYLDBP, road[iroad].hdmbz.YLDBP, TM, TH, TPTW, TPTI);//左路堤边坡
		nLZBPJS = FindWichBP(cml, road[iroad].pm, road[iroad].hdmbz.NYLQBP, road[iroad].hdmbz.YLQBP, WM, PH, ZPTW, ZPTI);//左路堑边坡
		if (nLZBPJS > 0 && PH[nLZBPJS - 1] < -0.001)//
		{
			ArcBP_R = fabs(PH[nLZBPJS - 1]);
			PH[nLZBPJS - 1] = 100.0;
		}
		LTJK = YWW[0];
		LZJK = YWW[1];
		LJXK = RW;//路基限宽
		//清表土厚度
		hthd = FindWichHTHD(cml, road[iroad].pm, road[iroad].hdmbz.NYHTHD, road[iroad].hdmbz.YHTHD);
		ZJ = FindWichDQ(cml, road[iroad].pm, road[iroad].hdmbz.NYDQ, road[iroad].hdmbz.YDQ);
		FindWichHD(cml, road[iroad].pm, road[iroad].hdmbz.NYLMHD, road[iroad].hdmbz.YLMHD, lmhd);
		CalFgdHp(cml, road[iroad].NYLMK, road[iroad].YLMK, fgdhp, fgdk);
		FindWichCTK(cml, road[iroad].pm, road[iroad].hdmbz.NYCTKD, road[iroad].hdmbz.YCTKD, CTwid);
		//低填路堤自动填平
		IsAutoLDTP = FindIsAutoLDTP(cml, road[iroad].pm, road[iroad].hdmbz.NYLDTP, road[iroad].hdmbz.YLDTP);
		//低挖路堑自动推平
		IsAutoLQTP = FindIsAutoLQTP(cml, road[iroad].pm, road[iroad].hdmbz.NYLQTP, road[iroad].hdmbz.YLQTP);
		//自动加宽土路肩
		IsAutoJKTLJ = FindIsAutoJKTLJ(cml, road[iroad].pm, road[iroad].hdmbz.NYTLJJK, road[iroad].hdmbz.YTLJJK);
	}

	//ads_printf(L"@@@@@@@@@@@ %lf %lf %lf %lf\n",cml,lmhd[0],lmhd[1],lmhd[2]);
	ZJ = ZJ < fabs(InZJ) ? ZJ : fabs(InZJ);
	if (InZJ < -0.001 && iroad == 0)
		GouProperty = -1;
	//	if(iroad==1 && MR==1 && fabs(cml-31650)<0.1)
	//	ads_printf(L"zj=%lf InZJ=%lf\n",ZJ,InZJ);

	//PSGouJQarea,CGouJQarea,JSGouPtNumarea,AllGouJQArea;
	//计算标准面积
	//排水沟浆砌
	PSGouJQarea = CalGouJQArea(GH, GW, SP1, SP2, PSG_JQHD);
	//侧沟浆砌
	CGouJQarea = CalGouJQArea(GS, GK, GP1, GP2, CG_JQHD);
	//截水沟浆砌
	JSGouJQarea = CalGouJQArea(TG_GS, TG_GW, TG_SP1, TG_SP2, TG_JQHD);
	//坡脚墙浆砌
	PJWallJQArea = 0.5 * 1;
	FillArea = 0.0;
	//FillRockArea=0.0;
	CutArea = 5.0;

	//建立统一坐标系,原点X=0,Y=RHF[1];
	DesPtSum = 5;

	//	Ymlev = RHF[7];
	//考虑分隔带横坡

	for (i = 0; i < 5; i++)
	{
		DesPtList[i * 2] = RHF[i * 2];
		DesPtList[i * 2 + 1] = RHF[i * 2 + 1] - Yd;//都相对中桩
	}
	//初值

	GouH = GouBotH;
	GouX = DesPtList[4 * 2] + GS * SP1 + 0.5*GK;
	ZDK = DesPtList[(DesPtSum - 1) * 2] + LTJK;


	CalDesArea(0, DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, FillArea, CutArea);


	/*	 for(i=0; i<EarPtSum; i++)
	{
	EarPtList[i*2+1] -= TWH;
	}*/


	//  	if (fabs(RHF[4*2])<0.001)
	//  		return 1;

	if (PJPT[0] > -0.001 && InZJ > -1e-6)//设置坡脚点
	{
		DesPtList[5 * 2] = PJPT[0];
		DesPtList[5 * 2 + 1] = PJPT[1] - Yd;//都相对中桩
		DesPtSum = 6;

		StartDesPt[0] = DesPtList[4 * 2];
		ZJ = DesPtList[5 * 2];
		StartDesPt[1] = DesPtList[4 * 2 + 1];
		ZDK = DesPtList[5 * 2] + LTJK;
		CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
			StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
			FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
		FillORCut = 0.0;//填方

		GouBotH = 0.0;
		GouH = 0.0;
		GouX = GouTarea = GouWarea = 0.0;
		GouProperty = -1;
		GouPtNum = 0;
		//截水沟点数,坐标
		JSGouPtNum = 0;
		//三沟浆砌面积,挡墙长度,铺草长度
		AllGouJQArea = DQlength = Grasslength = 0.0;

		return 1;
	}


	//////////////////////////////////////////////////////////////////////////
	//有土路肩要考虑自动推平和填平
	if (fabs(DesPtList[4 * 2] - DesPtList[3 * 2]) > 0.1 && (IsAutoLDTP || IsAutoLQTP))
	{
		double TLJYd;//土路肩处Yd
		inf = Gety(DesPtList[2 * 4], EarPtSum, EarPtList, TLJYd, EarPtNum2);
		if (inf == 0)
		{
			return -1;
		}
		dh = DesPtList[2 * 4 + 1] - TLJYd;
		deltah = dh;
		if (dh >= 0.0 && IsAutoLDTP)
		{
			bool AutoTP = false;//是否自动填平
			double JDPt[2];//推平交点坐标
			double TPDist = 0.0;//推平后交点与土路肩水平距离
			double GouWide;//推平沟宽
			GouWide = GK + GS * (GP1 + GP2);
			double TLJPt[2];
			double TLJPL = (DesPtList[3 * 2 + 1] - DesPtList[4 * 2 + 1]) / (DesPtList[4 * 2] - DesPtList[3 * 2]);//土路肩坡率
			TLJPt[0] = DesPtList[4 * 2];
			TLJPt[1] = DesPtList[4 * 2 + 1];
			AutoTP = IsAutoTP(-1, EarPtSum, EarPtList, TLJPt, TLJPL, GouWide, JDPt, TPDist);
			if (AutoTP)//需要自动填平
			{
				FillORCut = 0;//推平
				int AutoTPDesInf;
				AutoTPDesInf = AutoTPLQDes(TPDist, DesPtSum, DesPtList, EarPtSum, EarPtList, GK, GS, GP1, GP2, CG_GDR, WM[0], ZPTI[0], GouH, GouX, GouPtNum, gou);//设计自动填平路堑
				if (AutoTPDesInf == 1)//正常完成
				{
					GouProperty = 1;
					BJX = gou[(GouPtNum - 1) * 2];
					BJY = gou[(GouPtNum - 1) * 2 + 1];
					ZDK = gou[(GouPtNum - 1) * 2] + LZJK;
					double NewDmxPtList[400];
					int NewDmxPtNum;
					FormNewDmx(EarPtSum, EarPtList, DesPtSum, DesPtList, NewDmxPtNum, NewDmxPtList);
					CalGouArea(NewDmxPtNum, NewDmxPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
					DQlength = 0.0;
					Grasslength = 0.0;
					//				ads_printf(L"\n路堤填平断面cml=%lf,DesPtSum=%d",cml,DesPtSum);
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
						StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					return 1;
				}
			}
		}

		if (dh < 0.0 && IsAutoLQTP)
		{
			bool AutoTP = false;//是否自动填平
			double JDPt[2];//填平交点坐标
			double TPDist = 0.0;//填平后交点与土路肩水平距离
			double GouWide;//填平沟宽
			GouWide = GK + GS * (GP1 + GP2);
			double TLJPt[2];
			double TLJPL = (DesPtList[3 * 2 + 1] - DesPtList[4 * 2 + 1]) / (DesPtList[4 * 2] - DesPtList[3 * 2]);//土路肩坡率
			TLJPt[0] = DesPtList[4 * 2];
			TLJPt[1] = DesPtList[4 * 2 + 1];
			AutoTP = IsAutoTP(1, EarPtSum, EarPtList, TLJPt, TLJPL, GouWide, JDPt, TPDist);
			if (AutoTP)//需要自动推平
			{
				FillORCut = 0;//推平
				int AutoTPDesInf;
				AutoTPDesInf = AutoTPLDDes(TPDist, DesPtSum, DesPtList, EarPtSum, EarPtList, GK, GS, GP1, GP2, CG_GDR, TPTI[0], GouH, GouX, GouPtNum, gou);//设计自动填平路堑
				if (AutoTPDesInf == 1)//正常完成推平设计
				{
					if (GouPtNum == 0)
					{
						GouProperty = -1;
						BJX = DesPtList[(DesPtSum - 1) * 2];
						BJY = DesPtList[(DesPtSum - 1) * 2 + 1];
						ZDK = DesPtList[(DesPtSum - 1) * 2] + LTJK;
					}
					else
					{
						GouProperty = 1;
						BJX = gou[(GouPtNum - 1) * 2];
						BJY = gou[(GouPtNum - 1) * 2 + 1];
						ZDK = gou[(GouPtNum - 1) * 2] + LTJK;
						double NewDmxPtList[400];
						int NewDmxPtNum;
						FormNewDmx(EarPtSum, EarPtList, DesPtSum, DesPtList, NewDmxPtNum, NewDmxPtList);
						CalGouArea(NewDmxPtNum, NewDmxPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
					}

					DQlength = 0.0;
					Grasslength = 0.0;
					//				ads_printf(L"\n路堑推平断面cml=%lf,DesPtSum=%d",cml,DesPtSum);
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, 1,
						StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
					return 1;
				}
				else//设计失败，清空生成的设计点和水沟点
				{
					int Index = 0;
					for (Index = 5; Index < DesPtSum; Index++)
					{
						DesPtList[2 * Index] = 0.0;
						DesPtList[2 * Index + 1] = 0.0;
					}
					for (Index = 0; Index < GouPtNum; Index++)
					{
						gou[2 * Index] = 0.0;
						gou[2 * Index + 1] = 0.0;
					}
					DesPtSum = 5;
					GouPtNum = 0;
				}
			}
		}
	}
	//////////////////////////////////////////////////////////////////////////


	//计算LUTLMK处地面高
	LUTLMK = RHF[8];
	//DesH_LT = RHF[7] - Ymlev;
	DesH_LT = RHF[9] - Yd;
	LUZLMK = LUTLMK + D + ZPTW[0];
	//DesH_LZ = RHF[7] - Ymlev + D*ZPTI[0]*0.01;//考虑平台
	DesH_LZ = RHF[9] - Yd + ZPTW[0] * ZPTI[0] * 0.01;//考虑平台???liwei是否应该是DesH_LZ = RHF[9] - Yd + D+ZPTI[0]*0.01

	inf = Gety(LUTLMK, EarPtSum, EarPtList, EarH_LT, EarPtNum1);
	if (inf == 0)
	{
		//  WrErrFile(inf,MR,ckml);
		return -1;
	}

	dh = DesH_LT - EarH_LT;
	deltah = dh;
	//	 if(dh>0.0)//路堤路面宽处设计高大于地面高,路堤

	double InfactGS = GS;
	if (CG_GDR > 0.001)
	{
		InfactGS = GS + CG_GDR - sqrt(CG_GDR*CG_GDR - 0.25*GK*GK);
	}
	//if(dh>InfactGS || GouProperty==2&&dh>0.0)//（路堤路面宽处设计高高于地面一个路堑沟深）或（按路肩沟设计，且路堤路面宽处设计高大于地面高）
	if (dh > 0.0 || GouProperty == 2 && dh > 0.0) // 拟修改 
	{

		//////////////////////////////////////////////////////////////////////////
		//考虑开挖台阶
		// 				 double CutBenchStartPt[2];//开挖台阶起点，暂定为坡脚点
		// 				 CutBenchStartPt[0] = CutBenchStartPt[1] = 0.0;
		//////////////////////////////////////////////////////////////////////////

		FillORCut = 0.0;//填方
		//护肩面积
		StartDesPt[0] = DesPtList[4 * 2];
		StartDesPt[1] = DesPtList[4 * 2 + 1];
		if (DQinf != 1)//未设置挡墙
		{
			desinf = DesBPnew(-1, StartDesPt, TM, TH, TPTW, TPTI, EarPtNum1, EarPtSum, EarPtList, LJXK, BPpt, BPptSum, ZJ, nLTBPJS);//路堤
			BPptToDESpt(BPptSum, BPpt, DesPtSum, DesPtList, LTJK, BJX, BJY, ZDK, DQlength, Grasslength);
			//////////////////////////////////////////////////////////////////////////
			//线间沟
			if (iroad && InZJ < 1e-6)//有线间沟
			{
				FindGLDMXJG(cml, road[iroad].pm, road[iroad].hdmbz.NGLDMXJG, road[iroad].hdmbz.GLDMXJG,
					WideXJG, HighXJG, NBPXJG, WBPXJG, JQHDXJG, GDRXJG);
				XJGDes(DesPtSum, DesPtList, WideXJG, HighXJG, NBPXJG, WBPXJG, GDRXJG, GouH, GouX, GouPtNum, gou);
				//线间沟浆砌
				GouProperty = 1;
				FillORCut = 0;//路堤做路堑沟
				BJX = gou[(GouPtNum - 1) * 2];
				BJY = gou[(GouPtNum - 1) * 2 + 1];
				ZDK = gou[(GouPtNum - 1) * 2] + LZJK;
				DQlength = 0.0;
				Grasslength = 0.0;
				//						 ads_printf(L"\n路堤做路堑沟cml=%lf,DesPtSum=%d",cml,DesPtSum);		 
				CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
					StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
					FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
				double NewDmxPtList[400];
				int NewDmxPtNum;
				FormNewDmx(EarPtSum, EarPtList, DesPtSum, DesPtList, NewDmxPtNum, NewDmxPtList);
				CalGouArea(NewDmxPtNum, NewDmxPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
				return 1;
			}
			//计算断面积
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
				StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
			CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改


			if (CTwid > 0.001)//有超填
			{
				StartDesPt[0] = DesPtList[4 * 2] + CTwid;
				if (DesPtList[4 * 2] - DesPtList[3 * 2] > 0.0001)//有土路肩
					StartDesPt[1] = DesPtList[4 * 2 + 1] + CTwid * (DesPtList[4 * 2 + 1] - DesPtList[3 * 2 + 1]) / (DesPtList[4 * 2] - DesPtList[3 * 2]);//按土路肩顺延
				else//无土路肩
					StartDesPt[1] = DesPtList[4 * 2 + 1];//做成平的

				//设计超填后边坡
				desinf = DesBPnew(-1, StartDesPt, TM, TH, TPTW, TPTI, EarPtNum1, EarPtSum, EarPtList, LJXK, BPpt, BPptSum, ZJ, nLTBPJS);//路堤

				int desptsum;
				double desptlist[200];
				double dtmp;
				//建立统一坐标系,原点X=0,Y=RHF[1];
				desptsum = 5;
				for (i = 0; i < 5; i++)
				{
					desptlist[i * 2] = DesPtList[i * 2];
					desptlist[i * 2 + 1] = DesPtList[i * 2 + 1];
				}

				BPptToDESpt(BPptSum, BPpt, desptsum, desptlist, LTJK, dtmp, dtmp, dtmp, dtmp, dtmp);

				//计算断面积
				CalDesAllArea(desptsum, desptlist, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
					StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
					FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
				CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改

				DesPtSum = desptsum;
				for (int i = 0; i < desptsum; i++)
				{
					DesPtList[i * 2] = desptlist[i * 2];
					DesPtList[i * 2 + 1] = desptlist[i * 2 + 1];
				}

			}
		}

		if (desinf != 1)
			GouProperty = -1;
		if (desinf == 1)//找到交点,先判断是否需要自动加宽土路肩再做水沟、脚墙和路肩沟
		{
			//////////////////////////////////////////////////////////////////////////
			//考虑低填方路堤自动加宽土路肩
			if (IsAutoJKTLJ && DesPtList[4 * 2 + 1] - DesPtList[(DesPtSum - 1) * 2 + 1]<3.0 && DesPtList[4 * 2 + 1] - DesPtList[(DesPtSum - 1) * 2 + 1]>0.0)//填方高度小于3.0m
			{
				double JKPt[2];//土路肩加宽点
				double JDPt[2];//加宽路堤与地面线的交点
				JKPt[0] = DesPtList[4 * 2] + 1.0;
				JKPt[1] = DesPtList[4 * 2 + 1] - 1.0 / 6.0;
				double JKPtYd;//加宽点Yd
				desinf = Gety(JKPt[0], EarPtSum, EarPtList, JKPtYd, EarPtNum1);
				inf = CALXY(EarPtNum1, EarPtSum, -1, 1.5, JKPt[0], JKPt[1], 100.0, &JDPt[0], &JDPt[1], EarPtList);
				if (inf == 0 && (DesPtList[4 * 2 + 1] - JDPt[1]) < 4.0)//有交点且按自动加宽设计后填方高度小于4.0m
				{
					TM[0] = 6.0;
					TH[0] = 1.0 / 6.0;
					TPTW[0] = 0.0;
					TPTI[0] = 0.0;
					TM[1] = 1.5;
					TH[1] = 100.0;
					TPTW[1] = 0.0;
					TPTI[1] = 0.0;
					nLTBPJS = 2;
					desinf = Gety(DesPtList[4 * 2], EarPtSum, EarPtList, EarH_LT, EarPtNum1);
					desinf = DesBPnew(-1, StartDesPt, TM, TH, TPTW, TPTI, EarPtNum1, EarPtSum, EarPtList, LJXK, BPpt, BPptSum, ZJ, nLTBPJS);//路堤
					DesPtSum = 5;
					BPptToDESpt(BPptSum, BPpt, DesPtSum, DesPtList, LTJK, BJX, BJY, ZDK, DQlength, Grasslength);
					T1W = 0.0;
					HH = 0.0;
					//							 ads_printf(L"\n土路肩加宽断面cml=%lf,DesPtSum=%d",cml,DesPtSum);
				}
			}
			//////////////////////////////////////////////////////////////////////////


			//计算断面积
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
				StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
			CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
			//////////////////////////////////////////////////////////////////////////
			//考虑是否需要在填方地段自动设计挖方水沟
			// 					 int AutoDesTFLQSGHdmInf;
			// 					 AutoDesTFLQSGHdmInf = AutoDesTFLQSGHdm(DesPtSum,DesPtList,EarPtSum,EarPtList,GK,GS,GP1,GP2,CG_GDR,ZPTI[0],GouH,GouX,GouPtNum,gou);			
			// 					 if (AutoDesTFLQSGHdmInf==1)//正常完成
			// 					 {
			// 						 GouProperty = 1;
			// 						 FillORCut = 0;//路堤做路堑沟
			// 						 BJX = gou[(GouPtNum-1)*2];
			// 						 BJY = gou[(GouPtNum-1)*2+1];		
			// 						 ZDK = gou[(GouPtNum-1)*2] + LZJK;
			// 						 DQlength = 0.0;
			// 						 Grasslength = 0.0;
			// //						 ads_printf(L"\n路堤做路堑沟cml=%lf,DesPtSum=%d",cml,DesPtSum);
			// 
			// 					
			// 						 CalDesAllArea(DesPtSum,DesPtList,EarPtSum,EarPtList,lmhd,hthd,glthd,0,ZJ,-1,
			//						 StartDesPt,TM,TH,TPTW,TPTI,nLTBPJS,
			//						 FillArea,CutArea,QBTArea,FillGLTArea,HJarea);	
			// 						 double NewDmxPtList[400];
			// 						 int NewDmxPtNum;
			// 						 FormNewDmx(EarPtSum,EarPtList,DesPtSum,DesPtList,NewDmxPtNum,NewDmxPtList);
			// 						 CalGouArea(NewDmxPtNum,NewDmxPtList,GouPtNum,gou,GouTarea,GouWarea);//计算水沟面积
			// 
			// 						 return 1;
			//					 }
			// 					 //////////////////////////////////////////////////////////////////////////


			//////////////////////////////////////////////////////////////////////////
			//考虑开挖台阶
			// 					 CutBenchStartPt[0] = DesPtList[2*(DesPtSum-1)];
			// 					 CutBenchStartPt[1] = DesPtList[2*(DesPtSum-1)+1];
			//////////////////////////////////////////////////////////////////////////
			if (GouProperty == 1)//水沟
			{
				double GouWide = GK + GS * (GP1 + GP2);
				double dmhp = GetDmhp(DesPtList[(DesPtSum - 1) * 2], DesPtList[(DesPtSum - 1) * 2] + (GouWide + 2.0) * 2, EarPtList, EarPtSum);
				int wfsginf = 0;
				inf = 0;
				if (dmhp < 0.15)//地面线向下倾斜
					inf = DesLTGou(IfSetGouBotH, GouBotH, T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, gou, DesPtList, DesPtSum, EarPtList, EarPtSum, WM[0], GouH, GouX, BJX, PSG_JQHD, PSG_GDR);
				else
				{
					//	 wfsginf = AutoDesTFLQSGHdm(DesPtSum,DesPtList,EarPtSum,EarPtList,GK,GS,GP1,GP2,CG_GDR,ZPTI[0],GouH,GouX,GouPtNum,gou);			
					wfsginf = AutoDesTFLQSGHdm(DesPtSum, DesPtList, EarPtSum, EarPtList, GW, GH, SP1, SP2, CG_GDR, ZPTI[0], GouH, GouX, GouPtNum, gou);
					if (wfsginf != 1)
						inf = DesLTGou(IfSetGouBotH, GouBotH, T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, gou, DesPtList, DesPtSum, EarPtList, EarPtSum, WM[0], GouH, GouX, BJX, PSG_JQHD, PSG_GDR);
					else
					{
						BJX = gou[(GouPtNum - 1) * 2];//占地宽计算用
						BJY = gou[(GouPtNum - 1) * 2 + 1];
					}

				}


				//排水沟


				//		if(inf<0)//有问题
				//		WrErrFile(inf,MR,ckml);
				double NewDmxPtList[400];
				int NewDmxPtNum;
				//将设计线与地面线合成新的地面线
				if (inf == 1 || wfsginf == 1)
				{

					int t = 0;
					while (t<18 && fabs(gou[t * 2])>0.001)
						t++;
					GouPtNum = t;

					vector<double> watchGut;
					for (int i = 0; i < 18 * 2; i++)
						watchGut.push_back(gou[i]);

					if (inf == 1)
					{
						FormNewDmx(EarPtSum, EarPtList, DesPtSum, DesPtList, NewDmxPtNum, NewDmxPtList);
						CalGouArea(NewDmxPtNum, NewDmxPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
					}
					else
					{
						CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
					}

					AllGouJQArea += PSGouJQarea;//统计浆汽面积
					ZDK = BJX + LTJK;
				}
			}
			else if (GouProperty == 0)//脚墙
			{
				GouPtNum = 0;
				AllGouJQArea += PJWallJQArea;//统计浆汽面积
			}
			else if (GouProperty == 2)//路肩沟
			{
				FillORCut = 3.0;
				//做路堑水沟
				if ((DesPtList[4 * 2] + GH * SP1 + GH * SP2 + GW) <= ZJ)
				{
					FillORCut = 3.0;
					DesPtList[5 * 2] = DesPtList[4 * 2] + GH * SP1;
					DesPtList[5 * 2 + 1] = DesPtList[4 * 2 + 1] - GH;
					DesPtList[6 * 2] = DesPtList[5 * 2] + GW;
					DesPtList[6 * 2 + 1] = DesPtList[5 * 2 + 1];
					DesPtList[7 * 2] = DesPtList[6 * 2] + GH * SP2;
					DesPtList[7 * 2 + 1] = DesPtList[6 * 2 + 1] + GH;
					DesPtList[8 * 2] = DesPtList[7 * 2];//+ 0.5;//土埂
					DesPtList[8 * 2 + 1] = DesPtList[7 * 2 + 1];
					GouH = DesPtList[5 * 2 + 1];
					GouX = DesPtList[4 * 2] + GH * SP1 + 0.5*GW;
					DesPtSum = 9;
					AllGouJQArea += CGouJQarea;//统计侧沟浆汽面积
					//拟修改
					gou[2 * GouPtNum] = DesPtList[4 * 2];
					gou[2 * GouPtNum + 1] = DesPtList[4 * 2 + 1];
					GouPtNum++;
					gou[2 * GouPtNum] = DesPtList[5 * 2];
					gou[2 * GouPtNum + 1] = DesPtList[5 * 2 + 1];
					GouPtNum++;
					gou[2 * GouPtNum] = DesPtList[6 * 2];
					gou[2 * GouPtNum + 1] = DesPtList[6 * 2 + 1];
					GouPtNum++;
					gou[2 * GouPtNum] = DesPtList[7 * 2];
					gou[2 * GouPtNum + 1] = DesPtList[7 * 2 + 1];
					GouPtNum++;
					//////////////////////////////////////////////////////////////////////////
					if (TmpCG_GDR > 0.001)//有沟底半径
					{
						//1计算出沟底弧形点
						double spt[2], ept[2], pt[20];
						spt[0] = DesPtList[5 * 2], spt[1] = DesPtList[5 * 2 + 1];
						ept[0] = DesPtList[6 * 2], ept[1] = DesPtList[6 * 2 + 1];
						GetArcPt(spt, ept, TmpCG_GDR, 10, pt);
						//2修正设计点
						int npt;
						double despt[200];
						npt = 0;
						for (i = 0; i <= 5; i++)
						{
							despt[npt * 2] = DesPtList[i * 2];
							despt[npt * 2 + 1] = DesPtList[i * 2 + 1];
							npt++;
						}
						for (i = 0; i < 10; i++)
						{
							despt[npt * 2] = pt[i * 2];
							despt[npt * 2 + 1] = pt[i * 2 + 1];

							npt++;
						}
						for (i = 6; i < DesPtSum; i++)
						{
							despt[npt * 2] = DesPtList[i * 2];
							despt[npt * 2 + 1] = DesPtList[i * 2 + 1];
							npt++;
						}


						DesPtSum = npt;
						for (i = 0; i < DesPtSum; i++)
						{
							DesPtList[i * 2] = despt[i * 2];
							DesPtList[i * 2 + 1] = despt[i * 2 + 1];

						}
					}
					//////////////////////////////////////////////////////////////////////////
					StartDesPt[0] = DesPtList[(DesPtSum - 1) * 2];
					StartDesPt[1] = DesPtList[(DesPtSum - 1) * 2 + 1];
					inf = Gety(DesPtList[(DesPtSum - 1) * 2], EarPtSum, EarPtList, EarH_LZ, EarPtNum2);
					if (inf == 0)//找不到对应点
					{
						//    WrErrFile(inf,MR,ckml);
						ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
						CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
						CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, -1,
							StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
							FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
						return -1;
					}

					dh = DesPtList[(DesPtSum - 1) * 2 + 1] - EarH_LZ;
					if (dh < 0.0)//设计高小于地面高,路堑
						inf = CALXY(EarPtNum2, EarPtSum, 1, SP3, StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);
					else  //路堤
						inf = CALXY(EarPtNum2, EarPtSum, -1, SP3, StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);

					if (inf == 0)//找到交点
					{
						DesPtList[DesPtSum * 2] = XZ;
						DesPtList[DesPtSum * 2 + 1] = YZ;
						DesPtSum++;
						//////////////////////////////////////////////////////////////////////////
						//考虑开挖台阶
						// 								 if (dh>0.0)
						// 								 {
						// 									 CutBenchStartPt[0] = DesPtList[(DesPtSum-1)*2];
						// 									 CutBenchStartPt[1] = DesPtList[(DesPtSum-1)*2+1];
						// 								 }
						//////////////////////////////////////////////////////////////////////////
					}
					else
					{
						//    WrErrFile(-3,MR,ckml);
						return -1;
					}
				}
				else
					FillORCut = 0.0;
				ZDK = DesPtList[(DesPtSum - 1) * 2] + LTJK;
				CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
				CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, 1,//1-挖方
					StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
					FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
			}

			//////////////////////////////////////////////////////////////////////////
			//考虑开挖台阶
			// 					 int CutBenchInf = 0;
			// 					 double CutBenchArea = 0.0;
			// 					 int BenchPtSum = 0;
			// 					 double BenchPtList[400];
			// 					 for (int i=0; i<200; i++)
			// 					 {
			// 						 BenchPtList[2*i] = 0.0;
			// 						 BenchPtList[2*i+1] = 0.0;
			// 					 }
			// 					 
			// 					 double LMPtList[10];//路面点数组
			// 					 for(i=0; i<5; i++)
			// 					 {
			// 						 LMPtList[i*2] = DesPtList[i*2];
			// 						 LMPtList[i*2+1] = DesPtList[i*2+1];
			// 					 }
			// 					 CutBenchInf = AutoCutBench(CutBenchStartPt,BenchPtSum,BenchPtList,EarPtSum,EarPtList,LMPtList,lmhd,CutBenchArea);
			// 					 
			// 					 if (CutBenchInf==1)
			// 					 {
			// 					//	 CutArea += CutBenchArea;
			// 					//	 FillArea += CutBenchArea;
			// 						 if (MR<0)
			// 						 {
			// 							 road[iroad].hdmBench[iCross].ZEarPtAry.RemoveAll();
			// 							 road[iroad].hdmBench[iCross].ZEarPtNum = BenchPtSum;
			// 							 road[iroad].hdmBench[iCross].ZEarPtAry.SetSize(BenchPtSum);
			// 							 for (int iPt=0; iPt<BenchPtSum; iPt++)
			// 							 {
			// 								 road[iroad].hdmBench[iCross].ZEarPtAry[iPt].x = BenchPtList[2*iPt];
			// 								 road[iroad].hdmBench[iCross].ZEarPtAry[iPt].y = BenchPtList[2*iPt+1];
			// 							 }
			// 						 }
			// 						 else
			// 						 {
			// 							 road[iroad].hdmBench[iCross].YEarPtAry.RemoveAll();
			// 							 road[iroad].hdmBench[iCross].YEarPtNum = BenchPtSum;
			// 							 road[iroad].hdmBench[iCross].YEarPtAry.SetSize(BenchPtSum);
			// 							 for (int iPt=0; iPt<BenchPtSum; iPt++)
			// 							 {
			// 								 road[iroad].hdmBench[iCross].YEarPtAry[iPt].x = BenchPtList[2*iPt];
			// 								 road[iroad].hdmBench[iCross].YEarPtAry[iPt].y = BenchPtList[2*iPt+1];
			// 							 }
			// 						 }
			// 					 }
			//////////////////////////////////////////////////////////////////////////
		}



		if (desinf == 0 || desinf == -1)//调整参数或设挡后仍然交不上，则将最后一个设计点与其对应的地面点直接连接起来
		{
			inf = Gety(DesPtList[(DesPtSum - 1) * 2], EarPtSum, EarPtList, EarH_LT, EarPtNum1);
			if (inf != 0)
			{
				DesPtSum++;
				if (EarPtNum1 < EarPtSum)
				{
					if (EarPtSum > 1)
						k = EarPtNum1 + 1;
					else
						k = 0;
				}
				else
					k = EarPtSum - 1;

				DesPtList[(DesPtSum - 1) * 2] = EarPtList[k * 2];
				DesPtList[(DesPtSum - 1) * 2 + 1] = EarPtList[k * 2 + 1];
			}
			// 	   WrErrFile(1,MR,ckml);//边坡交不上
			return -1;
		}
		return 1;//正常
	}
	else //考虑路堑
	{
		GouProperty = -1;//初值
		inf = Gety(LUZLMK, EarPtSum, EarPtList, EarH_LZ, EarPtNum2);
		if (inf == 0)
		{
			//  WrErrFile(inf,MR,ckml);
			return -1;
		}

		AllGouJQArea += CGouJQarea;//统计侧沟浆汽面积
		dh = DesH_LZ - EarH_LZ;

		if (dh < 0.0)//设计高小于地面高,路堑
		{


			StartDesPt[0] = LUZLMK;
			StartDesPt[1] = DesPtList[4 * 2 + 1];

			if (ZJ > LUZLMK)
			{
				desinf = DesLZ(GouPtNum, gou, GS, GK, GP1, GP2, DesH_LZ, LUZLMK, WM, PH, ZPTW, ZPTI, EarPtNum2, EarPtSum, EarPtList, LJXK, DesPtList, DesPtSum, FillORCut, ZJ, DQinf, WallType, WallH, nLZBPJS, DQlength, Grasslength);
				//////////////////////////////////////////////////////////////////////////
				//线间沟
				if (iroad && InZJ < 1e-6)//路堑边坡需要推平
				{
					double GLDMLQTPDist;//关联断面路堑推平水平距离
					FindGLDMLQBPTP(cml, road[iroad].pm, road[iroad].hdmbz.NGLDMLQBPTP, road[iroad].hdmbz.GLDMLQBPTP, GLDMLQTPDist);
					DesPtSum++;
					DesPtList[2 * (DesPtSum - 1)] = DesPtList[2 * (DesPtSum - 2)] + GLDMLQTPDist;
					DesPtList[2 * (DesPtSum - 1) + 1] = DesPtList[2 * (DesPtSum - 2) + 1];
					BJX = DesPtList[(DesPtSum - 1) * 2];
					BJY = DesPtList[(DesPtSum - 1) * 2 + 1];
					ZDK = DesPtList[(DesPtSum - 1) * 2] + LTJK;
					DQlength = 0.0;
					Grasslength = 0.0;
					//				ads_printf(L"\n路堑推平断面cml=%lf,DesPtSum=%d",cml,DesPtSum);
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
						StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					return 1;
				}
				//////////////////////////////////////////////////////////////////////////

				//设计弧形边坡
				//	 DesArcBp(ArcBP_R,EarPtNum2,EarPtSum,EarPtList,DesPtList,DesPtSum);			 

				if (desinf == -1 || desinf == 0)//如果边坡交不到地面线，则将最后一个设计点与对于地面点直接连接
				{
					inf = Gety(DesPtList[(DesPtSum - 1) * 2], EarPtSum, EarPtList, EarH_LT, EarPtNum1);
					if (inf != 0)
					{
						DesPtSum++;
						if (EarPtNum1 < EarPtSum)
							k = EarPtNum1 + 1;
						else
							k = EarPtSum - 1;
						DesPtList[(DesPtSum - 1) * 2] = EarPtList[k * 2];
						DesPtList[(DesPtSum - 1) * 2 + 1] = EarPtList[k * 2 + 1];
					}
					//    WrErrFile(1,MR,ckml);
					//	 return -1;
				}

				if (IfTG)//要做天沟
				{
					//					 double dmhp = GetDmhp(DesPtList[(DesPtSum-1)*2],EarPtList[(EarPtSum-1)*2],EarPtList,EarPtSum);
					//					 if(dmhp<0.0)//地面线向下倾斜
					//					 {
					//						 JSGouPtNum=0;
					//					 }
					//					 else
					//					 {
					inf = DesTGou(TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_GDR, DesPtList, DesPtSum, EarPtList, EarPtSum, JSGouPtNum, JSgou);
					if (inf == 1 && JSGouPtNum > 3)//成功设计水沟
					{
						GouProperty = 2;//成功设置天沟
						BJX = JSgou[(JSGouPtNum - 1) * 2];//边界线					 
						ZDK = BJX + LZJK;

						CalGouArea(EarPtSum, EarPtList, JSGouPtNum, JSgou, GouTarea, GouWarea);//计算水沟面积
						AllGouJQArea += JSGouJQarea;//统计浆汽面积

						//	 return 1;
					}
					else
					{
						IfTG = FALSE;
						JSGouPtNum = 0;
					}

					//					 }
				}


			}
			else
			{
				FillORCut = 0.0;
				DesPtSum += 1;
				DesPtList[(DesPtSum - 1) * 2] = ZJ;
				DesPtList[(DesPtSum - 1) * 2 + 1] = DesPtList[(DesPtSum - 2) * 2 + 1] + (DesPtList[(DesPtSum - 1) * 2] - DesPtList[(DesPtSum - 2) * 2]) / WM[0];
			}

			if (TmpCG_GDR < 0.001)//非蝶形沟
			{
				//CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
				double tempGouTarea = 0.0, tempGouWarea = 0.0;
				CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, tempGouTarea, tempGouWarea);//计算水沟面积 拟修改	20200510	当同时存在侧沟和天沟时，会将天沟填挖数据覆盖
				GouTarea += tempGouTarea;
				GouWarea += tempGouWarea;

				CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, 1,
					StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
					FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
			}
			else//蝶形沟
			{
				if (DesPtSum > 7)//有路堑水沟
				{
					//1计算出沟底弧形点
					double spt[2], ept[2], pt[20];
					spt[0] = DesPtList[5 * 2], spt[1] = DesPtList[5 * 2 + 1];
					ept[0] = DesPtList[6 * 2], ept[1] = DesPtList[6 * 2 + 1];
					GetArcPt(spt, ept, TmpCG_GDR, 10, pt);
					//2修正设计点
					int npt;
					double despt[200];
					npt = 0;
					for (i = 0; i <= 5; i++)
					{
						despt[npt * 2] = DesPtList[i * 2];
						despt[npt * 2 + 1] = DesPtList[i * 2 + 1];
						npt++;
					}
					for (i = 0; i < 10; i++)
					{
						despt[npt * 2] = pt[i * 2];
						despt[npt * 2 + 1] = pt[i * 2 + 1];

						npt++;
					}
					for (i = 6; i < DesPtSum; i++)
					{
						despt[npt * 2] = DesPtList[i * 2];
						despt[npt * 2 + 1] = DesPtList[i * 2 + 1];
						npt++;
					}


					DesPtSum = npt;
					for (i = 0; i < DesPtSum; i++)
					{
						DesPtList[i * 2] = despt[i * 2];
						DesPtList[i * 2 + 1] = despt[i * 2 + 1];

					}
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
					//3计算面积
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, 1,
						StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
				}


			}
			if (!IfTG)//要做天沟
				ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
			return 1;
		}
		else//路堤宽处,填高小于沟深,路堑宽处,判断为做路堤
		{
			GouProperty = -1;//初值
			FillORCut = 3.0;
			//做路堑水沟
			if ((DesPtList[4 * 2] + GS * SP1 + GS * SP2 + GK) <= ZJ)
			{
				FillORCut = 3.0;
				DesPtList[5 * 2] = DesPtList[4 * 2] + GS * GP1;
				DesPtList[5 * 2 + 1] = DesPtList[4 * 2 + 1] - GS;
				DesPtList[6 * 2] = DesPtList[5 * 2] + GK;
				DesPtList[6 * 2 + 1] = DesPtList[5 * 2 + 1];
				DesPtList[7 * 2] = DesPtList[6 * 2] + GS * GP2;
				DesPtList[7 * 2 + 1] = DesPtList[6 * 2 + 1] + GS;
				DesPtList[8 * 2] = DesPtList[7 * 2] + 0.5;//土埂
				DesPtList[8 * 2 + 1] = DesPtList[7 * 2 + 1];
				GouH = DesPtList[5 * 2 + 1];
				GouX = DesPtList[4 * 2] + GS * SP1 + 0.5*GK;
				DesPtSum = 9;
				AllGouJQArea += CGouJQarea;//统计侧沟浆汽面积
				//拟修改
				gou[2 * GouPtNum] = DesPtList[4 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[4 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[5 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[5 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[6 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[6 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[7 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[7 * 2 + 1];
				GouPtNum++;
				//////////////////////////////////////////////////////////////////////////
				if (TmpCG_GDR > 0.001)//有沟底半径
				{
					//1计算出沟底弧形点
					double spt[2], ept[2], pt[20];
					spt[0] = DesPtList[5 * 2], spt[1] = DesPtList[5 * 2 + 1];
					ept[0] = DesPtList[6 * 2], ept[1] = DesPtList[6 * 2 + 1];
					GetArcPt(spt, ept, TmpCG_GDR, 10, pt);
					//2修正设计点
					int npt;
					double despt[200];
					npt = 0;
					for (i = 0; i <= 5; i++)
					{
						despt[npt * 2] = DesPtList[i * 2];
						despt[npt * 2 + 1] = DesPtList[i * 2 + 1];
						npt++;
					}
					for (i = 0; i < 10; i++)
					{
						despt[npt * 2] = pt[i * 2];
						despt[npt * 2 + 1] = pt[i * 2 + 1];

						npt++;
					}
					for (i = 6; i < DesPtSum; i++)
					{
						despt[npt * 2] = DesPtList[i * 2];
						despt[npt * 2 + 1] = DesPtList[i * 2 + 1];
						npt++;
					}


					DesPtSum = npt;
					for (i = 0; i < DesPtSum; i++)
					{
						DesPtList[i * 2] = despt[i * 2];
						DesPtList[i * 2 + 1] = despt[i * 2 + 1];

					}
				}
				//////////////////////////////////////////////////////////////////////////
				StartDesPt[0] = DesPtList[(DesPtSum - 1) * 2];
				StartDesPt[1] = DesPtList[(DesPtSum - 1) * 2 + 1];
				inf = Gety(DesPtList[(DesPtSum - 1) * 2], EarPtSum, EarPtList, EarH_LZ, EarPtNum2);
				if (inf == 0)//找不到对应点
				{
					//    WrErrFile(inf,MR,ckml);
					ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, -1,
						StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					return -1;
				}

				dh = DesPtList[(DesPtSum - 1) * 2 + 1] - EarH_LZ;
				if (dh < 0.0)//设计高小于地面高,路堑
					inf = CALXY(EarPtNum2, EarPtSum, 1, WM[0], StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);
				else  //路堤
					inf = CALXY(EarPtNum2, EarPtSum, -1, 1, StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);

				if (inf == 0)//找到交点
				{
					DesPtList[DesPtSum * 2] = XZ;
					DesPtList[DesPtSum * 2 + 1] = YZ;
					DesPtSum++;
				}
				else
				{
					//    WrErrFile(-3,MR,ckml);
					return -1;
				}
			}
			else
				FillORCut = 0.0;
			ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
			//水沟处可能出现填方需向下刷坡情况，因此需判断水沟处填挖方
			double EarthY; int ptnum;
			int TorW = 0;//1-挖方，-1-填方
			inf = Gety(StartDesPt[0], EarPtSum, EarPtList, EarthY, ptnum);
			if (EarthY > StartDesPt[1])//挖方
				TorW = 1;
			else
				TorW = -1;
			CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, TorW,//1-挖方
				StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
		}

	}
	return 1;



}

//填土，改良土，挖（I-VI），渗水土，用地宽,清基，植草(填挖边坡系数>0.5)，三沟(水沟、侧沟、截沟浆砌面积),护肩面积,挡墙面积(填挖边坡系数<0.5)
//左侧或右侧  里程   地面高程   地面点数  地面点坐标  路面点坐标        
int HdmDes::CrosNew1(//输入
	RoadHdmdata &ZDroad,//道路号
	int MR, double cml,
	double Yd, int EarPtSum, double EarPtList[],
	double RHF[8],
	double lmhd[3],
	double InZJ,
	double PJPT[2],
	//输出
	double &deltah,
	double& FillORCut, double& TWH,
	int& DesPtSum, double DesPtList[],
	//填土面积，填石面积，清表土面积,挖方面积
	double& FillArea, double &FillGLTArea, double& QBTArea, double& CutArea,
	//用地宽
	double& ZDK,
	//排水沟性质(1-水沟，0-坡脚墙)，点数,坐标，沟中心x,y,填面积（包括排水沟和天沟），挖面积（包括排水沟和天沟）
	int &IfSetGouBotH, double &GouBotH, int &GouProperty, int &GouPtNum, double gou[], double &GouH, double &GouX, double &GouTarea, double &GouWarea,
	//截水沟点数,坐标
	int &JSGouPtNum, double JSgou[],
	//三沟浆砌面积,挡墙长度,铺草长度
	double &AllGouJQArea, double &DQlength, double &Grasslength)

{
	int DQinf, i, BPptSum;
	double T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, PSG_GDR;
	double D, GK, GS, GP1, GP2;
	double LUZLMK, LUTLMK, LJXK, LTJK, LZJK, ZWW[2], YWW[2];
	double ZW, RW, XZ, YZ;
	int inf, EarPtNum1, EarPtNum2, desinf, k;
	double EarH_LT, EarH_LZ, DesH_LT, DesH_LZ, dh, BJX, BJY;
	double StartDesPt[2], BPpt[50];
	double WallType, WallH, WallTopSoilH, hthd;
	double TM[30], TH[30], TPTW[30], TPTI[30], WM[30], PH[30], ZPTW[30], ZPTI[30];
	int nLTBPJS, nLZBPJS;
	double hjwid, glthd;//渗水土厚度,护肩宽度,改良土厚度
	double PSGouJQarea, CGouJQarea, JSGouJQarea, PJWallJQArea;
	double PSG_JQHD, CG_JQHD, TG_JQHD;
	int IfTG;//是否有天沟
	double TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_GDR;
	double HJarea;
	double ZJ;
	double CG_GDR;
	double CTwid;


	PSGouJQarea = CGouJQarea = JSGouJQarea = PJWallJQArea = 0;

	///////////////////////设置初始值////////////////////////////////////////////////////
	//水沟初始值
	GouProperty = GouPtNum = 0;
	GouH = GouX = GouTarea = GouWarea = 0.0;
	JSGouPtNum = 0;//截水沟点数 

	for (i = 0; i < 14; i++)
	{
		gou[i] = 0.0;
		JSgou[i] = 0.0;
	}
	//面积初始值
	FillArea = 0.0;
	FillGLTArea = 0.0;
	QBTArea = 0.0;
	CutArea = 0.0;
	//挡墙及铺草边坡长度初始值
	DQlength = 0.0;
	Grasslength = 0;
	//水沟浆砌面积
	AllGouJQArea = 0.0;
	///////////////////////设置初始值////////////////////////////////////////////////////
	TWH = RHF[1] - Yd;//填挖高
	ZW = FindIljxk(cml, ZDroad.pm, ZDroad.hdmbz.NZDM, ZDroad.hdmbz.ZDM);//左侧限制宽
	RW = FindIljxk(cml, ZDroad.pm, ZDroad.hdmbz.NYDM, ZDroad.hdmbz.YDM);//右侧限制宽
	FindIljjk(cml, ZDroad.pm, ZDroad.hdmbz.NZPWD, ZDroad.hdmbz.ZPWD, ZWW[0], ZWW[1]);//左侧占地加宽
	FindIljjk(cml, ZDroad.pm, ZDroad.hdmbz.NYPWD, ZDroad.hdmbz.YPWD, YWW[0], YWW[1]);//右侧占地加宽

	WallType = -1;
	WallH = 0.0;
	WallTopSoilH = 0.0;
	CTwid = 0.0;
	//2.改良土厚度
	//glthd = FindGLTHD(cml,road[iroad].pm,road[iroad].hdmbz.NLDTL,road[iroad].hdmbz.LDTL);
	glthd = 0.0;
	if (MR < 0)//左侧
	{
		//1.排水沟
		//取出护坡道宽，横坡，沟宽，沟深，内侧坡，外侧坡，浆汽厚度
		FindSG(cml, ZDroad.pm, ZDroad.hdmbz.NZLDSG, ZDroad.hdmbz.ZLDSG, GouProperty,
			PSG_JQHD, T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, PSG_GDR);

		IfSetGouBotH = FindGouBotH(cml, ZDroad.pm, ZDroad.hdmbz.NZGouPD, ZDroad.hdmbz.ZGouPD, GouBotH);
		GouBotH = GouBotH - Yd;
		//2.天沟(0-无天沟,1-有天沟) 
		IfTG = FindTG(cml, ZDroad.pm, ZDroad.hdmbz.NZTG, ZDroad.hdmbz.ZTG, TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_JQHD, TG_GDR);
		DQinf = 0;
		//3.侧沟
		Cal_D(cml, ZDroad.pm, ZDroad.hdmbz.NZLQSG, ZDroad.hdmbz.ZLQSG, &D, &GK, &GS, &GP1, &GP2, &CG_JQHD, &CG_GDR);//路堑边沟宽度
		nLTBPJS = FindWichBP(cml, ZDroad.pm, ZDroad.hdmbz.NZLDBP, ZDroad.hdmbz.ZLDBP, TM, TH, TPTW, TPTI);//左路堤边坡
		nLZBPJS = FindWichBP(cml, ZDroad.pm, ZDroad.hdmbz.NZLQBP, ZDroad.hdmbz.ZLQBP, WM, PH, ZPTW, ZPTI);//左路堑边坡
		LJXK = ZW;//路基限宽
		LTJK = ZWW[0];//路堤加宽
		LZJK = ZWW[1];//路堑加宽
		//清表土厚度
		hthd = FindWichHTHD(cml, ZDroad.pm, ZDroad.hdmbz.NZHTHD, ZDroad.hdmbz.ZHTHD);
		ZJ = FindWichDQ(cml, ZDroad.pm, ZDroad.hdmbz.NZDQ, ZDroad.hdmbz.ZDQ);
		//路面厚
		FindWichHD(cml, ZDroad.pm, ZDroad.hdmbz.NZLMHD, ZDroad.hdmbz.ZLMHD, lmhd);
		//超填宽度
		FindWichCTK(cml, ZDroad.pm, ZDroad.hdmbz.NZCTKD, ZDroad.hdmbz.ZCTKD, CTwid);


	}
	else//右侧
	{
		//排水沟
		FindSG(cml, ZDroad.pm, ZDroad.hdmbz.NYLDSG, ZDroad.hdmbz.YLDSG, GouProperty,
			PSG_JQHD, T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, PSG_GDR);
		IfSetGouBotH = FindGouBotH(cml, ZDroad.pm, ZDroad.hdmbz.NYGouPD, ZDroad.hdmbz.YGouPD, GouBotH);//若设置了水沟底标高，则按照沟底标高计算
		GouBotH = GouBotH - Yd;
		//1.天沟 
		IfTG = FindTG(cml, ZDroad.pm, ZDroad.hdmbz.NYTG, ZDroad.hdmbz.YTG, TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_JQHD, TG_GDR);
		DQinf = 0;
		Cal_D(cml, ZDroad.pm, ZDroad.hdmbz.NYLQSG, ZDroad.hdmbz.YLQSG, &D, &GK, &GS, &GP1, &GP2, &CG_JQHD, &CG_GDR);//路堑边沟宽度
		nLTBPJS = FindWichBP(cml, ZDroad.pm, ZDroad.hdmbz.NYLDBP, ZDroad.hdmbz.YLDBP, TM, TH, TPTW, TPTI);//左路堤边坡
		nLZBPJS = FindWichBP(cml, ZDroad.pm, ZDroad.hdmbz.NYLQBP, ZDroad.hdmbz.YLQBP, WM, PH, ZPTW, ZPTI);//左路堑边坡
		LTJK = YWW[0];
		LZJK = YWW[1];
		LJXK = RW;//路基限宽
		//清表土厚度
		hthd = FindWichHTHD(cml, ZDroad.pm, ZDroad.hdmbz.NYHTHD, ZDroad.hdmbz.YHTHD);
		ZJ = FindWichDQ(cml, ZDroad.pm, ZDroad.hdmbz.NYDQ, ZDroad.hdmbz.YDQ);
		FindWichHD(cml, ZDroad.pm, ZDroad.hdmbz.NYLMHD, ZDroad.hdmbz.YLMHD, lmhd);
		//超填宽度
		FindWichCTK(cml, ZDroad.pm, ZDroad.hdmbz.NYCTKD, ZDroad.hdmbz.YCTKD, CTwid);

	}

	ZJ = ZJ < InZJ ? ZJ : InZJ;

	//PSGouJQarea,CGouJQarea,JSGouPtNumarea,AllGouJQArea;
	//计算标准面积
	//排水沟浆砌
	PSGouJQarea = CalGouJQArea(GH, GW, SP1, SP2, PSG_JQHD);
	//侧沟浆砌
	CGouJQarea = CalGouJQArea(GS, GK, GP1, GP2, CG_JQHD);
	//截水沟浆砌
	JSGouJQarea = CalGouJQArea(TG_GS, TG_GW, TG_SP1, TG_SP2, TG_JQHD);
	//坡脚墙浆砌
	PJWallJQArea = 0.5 * 1;
	FillArea = 0.0;
	//FillRockArea=0.0;
	CutArea = 0.0;

	//建立统一坐标系,原点X=0,Y=RHF[1];
	DesPtSum = 5;
	//	Ymlev = RHF[7];
	for (i = 0; i < 5; i++)
	{
		DesPtList[i * 2] = RHF[i * 2];
		DesPtList[i * 2 + 1] = RHF[i * 2 + 1] - Yd;//都相对中桩

		//	 ads_printf(L"\n~~~~~des=%lf,%lf,%lf,%lf,%lf",RHF[i*2],RHF[i*2+1],Yd,DesPtList[(i+1)*2],DesPtList[(i+1)*2+1]);
	}


	//初值
	GouH = GouBotH;
	GouX = DesPtList[4 * 2] + GS * SP1 + 0.5*GK;
	ZDK = DesPtList[(DesPtSum - 1) * 2] + LTJK;

	CalDesArea(0, DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, FillArea, CutArea);

	/*	 for(i=0; i<EarPtSum; i++)
	{
	EarPtList[i*2+1] -= TWH;
	}*/

	//计算LUTLMK处地面高
	LUTLMK = RHF[8];
	//DesH_LT = RHF[7] - Ymlev;
	DesH_LT = RHF[9] - Yd;
	LUZLMK = LUTLMK + D + ZPTW[0];
	//DesH_LZ = RHF[7] - Ymlev + D*ZPTI[0]*0.01;//考虑平台
	DesH_LZ = RHF[9] - Yd + D * ZPTI[0] * 0.01;//考虑平台

	inf = Gety(LUTLMK, EarPtSum, EarPtList, EarH_LT, EarPtNum1);
	if (inf == 0)
	{
		//  WrErrFile(inf,MR,ckml);
		return -1;
	}

	dh = DesH_LT - EarH_LT;
	deltah = dh;
	//	 if(dh>0.0)//路堤路面宽处设计高大于地面高,路堤

	if (PJPT[0] > -0.001)
	{
		DesPtList[5 * 2] = PJPT[0];
		DesPtList[5 * 2 + 1] = PJPT[1] - Yd;//都相对中桩
		DesPtSum = 6;

		StartDesPt[0] = DesPtList[4 * 2];
		StartDesPt[1] = DesPtList[4 * 2 + 1];
		if (DesPtList[5 * 2 + 1] > DesPtList[4 * 2 + 1])
		{
			ZDK = DesPtList[5 * 2] + LZJK;
			FillORCut = 0.0;//填方
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, 1,
				StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
		}
		else
		{
			ZDK = DesPtList[5 * 2] + LTJK;
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
				StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
			FillORCut = 0.0;//填方
		}

		GouBotH = GouH = GouX = GouTarea = GouWarea = 0.0;
		GouProperty = -1;
		GouPtNum = 0;
		//截水沟点数,坐标
		JSGouPtNum = 0;
		//三沟浆砌面积,挡墙长度,铺草长度
		AllGouJQArea = DQlength = Grasslength = 0.0;

		return 1;
	}


	if (dh > GS)//路堤路面宽处设计高大于地面高,且高差大于路堑沟深
	{
		FillORCut = 0.0;//填方
		//护肩面积
		//ads_printf(L"HJarea=%lf hjwid=%lf ssthd=%lf\n",HJarea,hjwid,ssthd);
		StartDesPt[0] = DesPtList[4 * 2];
		StartDesPt[1] = DesPtList[4 * 2 + 1];
		if (DQinf != 1)
		{

			desinf = DesBPnew(-1, StartDesPt, TM, TH, TPTW, TPTI, EarPtNum1, EarPtSum, EarPtList, LJXK, BPpt, BPptSum, ZJ, nLTBPJS);//路堤
			BPptToDESpt(BPptSum, BPpt, DesPtSum, DesPtList, LTJK, BJX, BJY, ZDK, DQlength, Grasslength);
			//计算断面积
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
				StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
			if (CTwid > 0.001)//有超填
			{
				StartDesPt[0] = DesPtList[4 * 2] + CTwid;
				if (DesPtList[4 * 2] - DesPtList[3 * 2] > 0.0001)
					StartDesPt[1] = DesPtList[4 * 2 + 1] + CTwid * (DesPtList[4 * 2 + 1] - DesPtList[3 * 2 + 1]) / (DesPtList[4 * 2] - DesPtList[3 * 2]);
				else
					StartDesPt[1] = DesPtList[4 * 2 + 1];
				//设计超填后边坡
				desinf = DesBPnew(-1, StartDesPt, TM, TH, TPTW, TPTI, EarPtNum1, EarPtSum, EarPtList, LJXK, BPpt, BPptSum, ZJ, nLTBPJS);//路堤
				int desptsum;
				double desptlist[200];
				double dtmp;
				BPptToDESpt(BPptSum, BPpt, desptsum, desptlist, LTJK, dtmp, dtmp, dtmp, dtmp, dtmp);
				//计算断面积
				CalDesAllArea(desptsum, desptlist, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
					StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
					FillArea, CutArea, QBTArea, FillGLTArea, HJarea);

			}

		}

		if (desinf != 1)
			GouProperty = -1;
		if (desinf == 1)//找到交点,做水沟或脚墙
		{
			if (GouProperty == 1)//水沟
			{
				//排水沟
				inf = DesLTGou(IfSetGouBotH, GouBotH, T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, gou, DesPtList, DesPtSum, EarPtList, EarPtSum, WM[0], GouH, GouX, BJX, PSG_JQHD, PSG_GDR);
				i = 0;
				while (i<8 && fabs(gou[i * 2])>0.001)
					i++;
				GouPtNum = i;
				//		if(inf<0)//有问题
				//		WrErrFile(inf,MR,ckml);
				double NewDmxPtList[400];
				int NewDmxPtNum;
				//将设计线与地面线合成新的地面线
				FormNewDmx(EarPtSum, EarPtList, DesPtSum, DesPtList, NewDmxPtNum, NewDmxPtList);
				CalGouArea(NewDmxPtNum, NewDmxPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
				//CalGouArea(EarPtSum,EarPtList,GouPtNum,gou,GouTarea,GouWarea);//加上水沟面积
				if (inf)
					AllGouJQArea += PSGouJQarea;//统计浆汽面积
			}
			else if (GouProperty == 0)//脚墙
			{
				GouPtNum = 0;
				AllGouJQArea += PJWallJQArea;//统计浆汽面积
			}
		}

		ZDK = BJX + LTJK;
		if (desinf == 0 || desinf == -1)//调整参数或设挡后仍然交不上
		{
			inf = Gety(DesPtList[(DesPtSum - 1) * 2], EarPtSum, EarPtList, EarH_LT, EarPtNum1);
			if (inf != 0)
			{
				DesPtSum++;
				if (EarPtNum1 < EarPtSum)
				{
					if (EarPtSum > 1)
						k = EarPtNum1 + 1;
					else
						k = 0;
				}
				else
					k = EarPtSum - 1;


				DesPtList[(DesPtSum - 1) * 2] = EarPtList[k * 2];
				DesPtList[(DesPtSum - 1) * 2 + 1] = EarPtList[k * 2 + 1];
			}
			// 	   WrErrFile(1,MR,ckml);//边坡交不上
			return -1;
		}
		return 1;//正常
	}
	else //考虑路堑
	{
		GouProperty = -1;//初值
		inf = Gety(LUZLMK, EarPtSum, EarPtList, EarH_LZ, EarPtNum2);
		if (inf == 0)
		{
			//  WrErrFile(inf,MR,ckml);
			return -1;
		}

		AllGouJQArea += CGouJQarea;//统计侧沟浆汽面积
		dh = DesH_LZ - EarH_LZ;
		if (dh < 0.0)//设计高小于地面高,路堑
		{
			StartDesPt[0] = LUZLMK;
			StartDesPt[1] = DesPtList[4 * 2 + 1];

			//ads_printf(L"\n@@cml=%lf",cml);

			if (ZJ > LUZLMK)
			{
				desinf = DesLZ(GouPtNum, gou, GS, GK, GP1, GP2, DesH_LZ, LUZLMK, WM, PH, ZPTW, ZPTI, EarPtNum2, EarPtSum, EarPtList, LJXK, DesPtList, DesPtSum, FillORCut, ZJ, DQinf, WallType, WallH, nLZBPJS, DQlength, Grasslength);

				if (desinf == -1 || desinf == 0)
				{
					inf = Gety(DesPtList[(DesPtSum - 1) * 2], EarPtSum, EarPtList, EarH_LT, EarPtNum1);
					if (inf != 0)
					{
						DesPtSum++;
						if (EarPtNum1 < EarPtSum)
							k = EarPtNum1 + 1;
						else
							k = EarPtSum - 1;
						DesPtList[(DesPtSum - 1) * 2] = EarPtList[k * 2];
						DesPtList[(DesPtSum - 1) * 2 + 1] = EarPtList[k * 2 + 1];
					}
					//    WrErrFile(1,MR,ckml);
					//	 return -1;
				}

				if (IfTG)//要做天沟
				{
					double dmhp = GetDmhp(DesPtList[(DesPtSum - 1) * 2], EarPtList[(EarPtSum - 1) * 2], EarPtList, EarPtSum);
					if (dmhp < 0.0)//地面线向下倾斜
					{
						JSGouPtNum = 0;
					}
					else
					{
						inf = DesTGou(TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_GDR, DesPtList, DesPtSum, EarPtList, EarPtSum, JSGouPtNum, JSgou);
						if (inf == 1 && JSGouPtNum > 3)//成功设计水沟
						{

							GouProperty = 2;//成功设置天沟
							BJX = JSgou[(JSGouPtNum - 1) * 2];//边界线					 
							ZDK = BJX + LZJK;

							CalGouArea(EarPtSum, EarPtList, JSGouPtNum, JSgou, GouTarea, GouWarea);//计算水沟面积
							AllGouJQArea += JSGouJQarea;//统计浆汽面积
						}
						else
						{
							JSGouPtNum = 0;
						}
					}
				}


			}
			else
			{
				FillORCut = 0.0;

			}
			CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, 1,
				StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);

			ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
			return 1;
		}
		else//路堤宽处,填高小于沟深,路堑宽处,判断为做路堤
		{
			GouProperty = -1;//初值
			FillORCut = 3.0;
			//做路堑水沟
			if ((DesPtList[4 * 2] + GS * SP1 + GS * SP2 + GK) <= ZJ)
			{
				FillORCut = 3.0;
				DesPtList[5 * 2] = DesPtList[4 * 2] + GS * GP1;
				DesPtList[5 * 2 + 1] = DesPtList[4 * 2 + 1] - GS;
				DesPtList[6 * 2] = DesPtList[5 * 2] + GK;
				DesPtList[6 * 2 + 1] = DesPtList[5 * 2 + 1];
				DesPtList[7 * 2] = DesPtList[6 * 2] + GS * GP2;
				DesPtList[7 * 2 + 1] = DesPtList[6 * 2 + 1] + GS;
				DesPtList[8 * 2] = DesPtList[7 * 2] + 0.5;//土埂
				DesPtList[8 * 2 + 1] = DesPtList[7 * 2 + 1];
				GouH = DesPtList[5 * 2 + 1];
				GouX = DesPtList[4 * 2] + GS * SP1 + 0.5*GK;
				DesPtSum = 9;
				AllGouJQArea += CGouJQarea;//统计侧沟浆汽面积
				//拟修改
				gou[2 * GouPtNum] = DesPtList[4 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[4 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[5 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[5 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[6 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[6 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[7 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[7 * 2 + 1];
				GouPtNum++;

				StartDesPt[0] = DesPtList[8 * 2];
				StartDesPt[1] = DesPtList[8 * 2 + 1];
				inf = Gety(DesPtList[8 * 2], EarPtSum, EarPtList, EarH_LZ, EarPtNum2);
				if (inf == 0)//找不到对应点
				{
					//    WrErrFile(inf,MR,ckml);
					ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, -1,
						StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					return -1;
				}

				dh = DesPtList[8 * 2 + 1] - EarH_LZ;
				if (dh < 0.0)//设计高小于地面高,路堑
					inf = CALXY(EarPtNum2, EarPtSum, 1, WM[0], StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);
				else  //路堤
					inf = CALXY(EarPtNum2, EarPtSum, -1, 1, StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);

				if (inf == 0)//找到交点
				{
					DesPtList[9 * 2] = XZ;
					DesPtList[9 * 2 + 1] = YZ;
					DesPtSum = 10;
				}
				else
				{
					//    WrErrFile(-3,MR,ckml);
					return -1;
				}
			}
			else
				FillORCut = 0.0;

			ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
			CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, 1,//1-挖方
				StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
		}

	}
	return 1;
}



double HdmDes::CalDesH(double cml, GTZDM_ROAD *ZM1, GTZDM_ROAD *AllZM)
{
	double desh;
	double sml, eml;

	desh = 0.0;
	if (ZM1)
	{
		sml = ZM1->CM[0];//起始连续里程
		eml = ZM1->CM[(ZM1->NCM - 2) * 5];
		if (cml > sml - 0.001 && cml < eml + 0.01)
		{
			desh = ZM1->rdes_level(cml);//从左幅取
			if (desh > -0.9)
				return desh;
		}
	}
	if (AllZM)
		desh = AllZM->rdes_level(cml);
	return desh;
}

//////////////////////////////////////////////////////////////////////////
//通过超高数据计算路面横坡和硬露肩横坡
//ncg=1时，循环求解cml所在的分段时i=0，此时不能认为找不到而直接LMHP=-2 李伟修正
//////////////////////////////////////////////////////////////////////////
void HdmDes::CalLMHP(double cml, int ncg, CgSZ cg[], double &LMHP, double &YLJHP)
{
	double k;

	LMHP = -2;

	int i;
	for (i = 0; i < ncg; i++)
	{
		if (cml < cg[i].cml + 0.1)
			break;
	}

	//////////////////////////////////////////////////////////////////////////
	//李伟修正
	// 	if(i==0)
	//        LMHP = -2;
	if (i == ncg)//搜索不到区间
		LMHP = -2;
	else if (i == 0)
		LMHP = cg[0].cg;
	//////////////////////////////////////////////////////////////////////////
	else if (i > 0 && i<ncg && fabs(cg[i].cml - cg[i - 1].cml)>0.0001)
	{
		k = (cml - cg[i - 1].cml) / (cg[i].cml - cg[i - 1].cml);
		LMHP = cg[i - 1].cg + k * (cg[i].cg - cg[i - 1].cg);
	}
	else
		LMHP = cg[i - 1].cg;

	YLJHP = LMHP;
}
//不考虑加宽计算的路面宽
void HdmDes::CalLMKNoJK(double cml, int NLMK, LMKdata lmk[], double &half_fgdk,
	double &lydk, double &cxdk, double &yljk, double &tljk,
	double &lmhp, double &yljhp, double &tljhp,
	int &bkmode, int &sjbgmode, double& OffsetByXLZX)
{
	double k;

	if (NLMK == 1)
	{
		bkmode = lmk[0].bkmode;
		sjbgmode = lmk[0].sjbgmode;

		half_fgdk = lmk[0].fgdk;
		lydk = lmk[0].lydk;
		cxdk = lmk[0].cxdk;
		yljk = lmk[0].yljk;
		tljk = lmk[0].tljk;
		lmhp = lmk[0].lmhp;
		yljhp = lmk[0].yljhp;
		if (yljhp > 0.1)//非爬坡车道
			yljhp = lmhp;
		else
		{
			if (fabs(lmhp) <= 4.0)
				yljhp = lmhp;
			else
				yljhp = sgn(lmhp)*4.0;

		}
		tljhp = lmk[0].tljhp;
		OffsetByXLZX = lmk[0].OffsetByXLZX;
		return;
	}

	int i;
	for (i = 0; i < NLMK; i++)
	{
		if (cml < lmk[i].cml + 0.1)
			break;
	}

	if (i > 0 && i<NLMK && fabs(lmk[i].cml - lmk[i - 1].cml)>0.0001)
		k = (cml - lmk[i - 1].cml) / (lmk[i].cml - lmk[i - 1].cml);
	else
		k = 0;

	if (i == 0)
		i = 1;
	else if (i == NLMK)
		i = NLMK - 1;

	OffsetByXLZX = lmk[i - 1].OffsetByXLZX + k * (lmk[i].OffsetByXLZX - lmk[i - 1].OffsetByXLZX);

	if (lmk[i].bkmode != 0)
		k = 4 * k*k*k - 3 * k*k*k*k;
	bkmode = lmk[i].bkmode;
	sjbgmode = lmk[i].sjbgmode;

	half_fgdk = lmk[i - 1].fgdk + k * (lmk[i].fgdk - lmk[i - 1].fgdk);
	lydk = lmk[i - 1].lydk + k * (lmk[i].lydk - lmk[i - 1].lydk);
	cxdk = lmk[i - 1].cxdk + k * (lmk[i].cxdk - lmk[i - 1].cxdk);

	yljk = lmk[i - 1].yljk + k * (lmk[i].yljk - lmk[i - 1].yljk);
	tljk = lmk[i - 1].tljk + k * (lmk[i].tljk - lmk[i - 1].tljk);
	lmhp = lmk[i].lmhp;
	yljhp = lmk[i].yljhp;
	if (yljhp > 0.1)//非爬坡车道
		yljhp = lmhp;
	else
	{
		if (fabs(lmhp) <= 4.0)
			yljhp = lmhp;
		else
			yljhp = sgn(lmhp)*4.0;

	}
	tljhp = lmk[i].tljhp;


}

//考虑加宽计算的路面宽
void HdmDes::CalLMK_JK(double cml, int NLMK, LMKdata lmk[], int ncg, CgSZ cg[], int njk, CgSZ jk[], double &half_fgdk,
	double &lydk, double &cxdk, double &yljk, double &tljk, double &tljhp,
	int &bkmode, int &sjbgmode)
{
	double k;
	double addwid;

	int i;
	for (i = 0; i < NLMK; i++)
	{
		if (cml < lmk[i].cml + 0.001)
			break;
	}

	if (i == NLMK)
		i--;

	if (i > 0 && i<NLMK && fabs(lmk[i].cml - lmk[i - 1].cml)>0.0001)
		k = (cml - lmk[i - 1].cml) / (lmk[i].cml - lmk[i - 1].cml);
	else
		k = 0;

	if (lmk[i].bkmode != 0)
		k = 4 * k*k*k - 3 * k*k*k*k;
	bkmode = lmk[i].bkmode;
	sjbgmode = lmk[i].sjbgmode;
	double kk = 0.0;
	addwid = 0.0;
	int j;
	for (j = 0; j < njk; j++)
	{
		if (cml < jk[j].cml + 0.1)
			break;
	}

	if (j > 0 && j < njk)
	{
		if (fabs(jk[j].cml - jk[j - 1].cml) > 0.0001)
		{
			kk = (cml - jk[j - 1].cml) / (jk[j].cml - jk[j - 1].cml);
			addwid = jk[j - 1].cg + kk * (jk[j].cg - jk[j - 1].cg);
		}
		else
			addwid = jk[j - 1].cg;
	}

	if (i > 0 && i < NLMK)
	{
		half_fgdk = lmk[i - 1].fgdk + k * (lmk[i].fgdk - lmk[i - 1].fgdk);
		lydk = lmk[i - 1].lydk + k * (lmk[i].lydk - lmk[i - 1].lydk);
		cxdk = lmk[i - 1].cxdk + k * (lmk[i].cxdk - lmk[i - 1].cxdk) + addwid;

		yljk = lmk[i - 1].yljk + k * (lmk[i].yljk - lmk[i - 1].yljk);
		tljk = lmk[i - 1].tljk + k * (lmk[i].tljk - lmk[i - 1].tljk);
		tljhp = lmk[i].tljhp;
	}
	else if (i == 0)
	{
		i = 1;
		half_fgdk = lmk[i - 1].fgdk;
		lydk = lmk[i - 1].lydk;
		cxdk = lmk[i - 1].cxdk + addwid;
		yljk = lmk[i - 1].yljk;
		tljk = lmk[i - 1].tljk;
		tljhp = lmk[i - 1].tljhp;
	}
	else
	{
		i = NLMK - 1;
		half_fgdk = lmk[i].fgdk;
		lydk = lmk[i].lydk;
		cxdk = lmk[i].cxdk + addwid;
		yljk = lmk[i].yljk;
		tljk = lmk[i].tljk;
		tljhp = lmk[i].tljhp;
	}

	if (tljhp > 90)//与车行道同坡
	{
		double lmhp, dtmp;
		CalLMHP(cml, ncg, cg, lmhp, dtmp);
		tljhp = -lmhp;
	}

}

void HdmDes::CalFgdHp(double cml, int NLMK, LMKdata lmk[], double &fgdhp, double &fgdk)
{
	int i;
	for (i = 0; i < NLMK; i++)
	{
		if (cml < lmk[i].cml + 0.1)
			break;
	}

	if (i == NLMK)
		i--;

	fgdhp = lmk[i].fgdhp;
	fgdk = lmk[i].fgdk;
}


void HdmDes::CalYljHp(double cml, int NLMK, LMKdata lmk[], double lmhp, double &yljhp)
{
	int i;
	for (i = 0; i < NLMK; i++)
	{
		if (cml < lmk[i].cml + 0.1)
			break;
	}

	if (i == NLMK)
		i--;

	yljhp = lmk[i].yljhp;
	if (yljhp > 0.1)//非爬坡车道
		yljhp = lmhp;
	else
	{
		if (fabs(lmhp) <= 4.0)
			yljhp = lmhp;
		else
			yljhp = sgn(lmhp)*4.0;

	}
}


void HdmDes::CalLMKbyFile(double cml, int ZorY, JD_CENTER *pm, BXLMKD *pBXArr, int BxNum, double &half_fgdk, double &lydk, double &cxdk, double &yljk, double &tljk)
{
	int i, j;
	double ToZFD, ToLYD, ToCXD, ToYLJ, ToTlj;
	AcGePoint2d Apt;

	ToZFD = half_fgdk;
	ToLYD = half_fgdk + lydk;
	ToCXD = half_fgdk + lydk + cxdk;
	ToYLJ = ToCXD + yljk;
	ToTlj = ToYLJ + tljk;
	xlpoint PZ;
	PZ.lc = cml;
	pm->xlpoint_pz(&PZ);
	double x1, y1, x2, y2, dis;
	x1 = PZ.x;
	y1 = PZ.y;
	x2 = x1 + 100 * cos(PZ.a + ZorY * PI*0.5);
	y2 = y1 + 100 * sin(PZ.a + ZorY * PI*0.5);

	for (i = 0; i < BxNum; i++)
	{
		if (cml > pBXArr[i].bxsml&&cml < pBXArr[i].bxeml&&ZorY == pBXArr[i].LorR)
		{
			AcDbPolyline *pPline = new AcDbPolyline(pBXArr[i].ptnum);
			for (j = 0; j < pBXArr[i].ptnum; j++)
			{
				Apt.x = pBXArr[i].ptarr[j * 3];
				Apt.y = pBXArr[i].ptarr[j * 3 + 1];
				pPline->addVertexAt(j, Apt);
				pPline->setWidthsAt(j, 0.0, 0.0);
			}

			AcDbLine *Line = new AcDbLine(AcGePoint3d(x1, y1, 0.0), AcGePoint3d(x2, y2, 0.0));
			AcGePoint3dArray interPt;
			Line->intersectWith(pPline, AcDb::kOnBothOperands, interPt, 0, 0);
			if (interPt.length() > 0)
			{
				double dx, dy;
				dx = interPt[0].x - x1, dy = interPt[0].y - y1;
				dis = sqrt(dx*dx + dy * dy);
				if (pBXArr[i].bxinf == 0)
					ToZFD = dis;
				else if (pBXArr[i].bxinf == 1)
					ToLYD = dis;
				else if (pBXArr[i].bxinf == 2)
					ToCXD = dis;
				else if (pBXArr[i].bxinf == 3)
					ToYLJ = dis;
				else
					ToTlj = dis;
			}
		}
	}

	half_fgdk = ToZFD;
	lydk = ToLYD - ToZFD;
	cxdk = ToCXD - ToLYD;
	yljk = ToYLJ - ToCXD;
	tljk = ToTlj - ToYLJ;
}
//计算路面四点
void HdmDes::CalLMPT(double cml, double DesH, int cgNm, CgSZ cg[],
	int jkNm, CgSZ jk[], int NLMK, LMKdata *LMK, double RHF[10], int ZorY,
	int BxNum, BXLMKD *pBXArr, JD_CENTER *pm)
{
	double LMHP, YLJHP;
	double half_fgdk, lydk, cxdk, yljk, tljk, tljhp;
	int bkmode, sjbgmode;
	double fgdhp, fgdk;
	//计算路面横坡
	if (NLMK < 1)
	{
		ads_alert(L"请先输入路面宽数据!");
		return;
	}
	if (cgNm < 1)
	{
		ads_alert(L"请先计算超高分段数据!");
		return;
	}


	CalLMHP(cml, cgNm, cg, LMHP, YLJHP);
	CalFgdHp(cml, NLMK, LMK, fgdhp, fgdk);
	CalYljHp(cml, NLMK, LMK, LMHP, YLJHP);
	//计算路面宽(考虑加宽)
	CalLMK_JK(cml, NLMK, LMK, cgNm, cg, jkNm, jk, half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
	CalLMKbyFile(cml, ZorY, pm, pBXArr, BxNum, half_fgdk, lydk, cxdk, yljk, tljk);

	//依据路面横坡调整土路肩横坡
	//	ads_printf(L"cml=%lf zory=%d lmhp=%lf tljhp=%lf\n",cml,ZorY,LMHP,tljhp);
	if (LMHP < -1.0*tljhp)
		tljhp = -1.0*LMHP;

	if (fgdhp > 90)//99为与车行道同坡
		fgdhp = LMHP;
	if (tljhp > 90)//99为与车行道同坡
		tljhp = LMHP;

	//ads_printf(L"cml=%lf fdghp=%lf LMHP=%lf YLJHP=%lf \n",cml,fgdhp,LMHP,YLJHP);
	if (sjbgmode == 0)//分隔带边缘
	{
		RHF[2] = half_fgdk, RHF[3] = DesH;
		RHF[4] = RHF[2] + lydk + cxdk, RHF[5] = DesH + (lydk + cxdk)* LMHP * 0.01;
		RHF[6] = RHF[4] + yljk, RHF[7] = RHF[5] + yljk * YLJHP * 0.01;
		RHF[8] = RHF[6] + tljk, RHF[9] = RHF[7] - tljk * tljhp * 0.01;
		RHF[0] = 0.0; RHF[1] = RHF[3] - fgdk * fgdhp * 0.01;
		//ads_printf(L"+++++++++%lf %lf %lf %lf\n",RHF[5],tljk,tljhp,RHF[7]);	  

	}
	else//路肩
	{
		//先计算出设置超高加宽前的路面点
		double OffsetByXLZX = 0.0;//路基中线相对于线路中线的偏移量（左负右正）
		CalLMKNoJK(cml, NLMK, LMK, half_fgdk, lydk, cxdk, yljk, tljk,
			LMHP, YLJHP, tljhp, bkmode, sjbgmode, OffsetByXLZX);
		CalLMKbyFile(cml, ZorY, pm, pBXArr, BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
		RHF[8] = half_fgdk + lydk + cxdk + yljk + tljk;
		RHF[9] = DesH;
		RHF[6] = half_fgdk + lydk + cxdk + yljk;
		RHF[7] = DesH - tljhp * 0.01*tljk;
		RHF[4] = half_fgdk + lydk + cxdk;
		RHF[5] = RHF[7] - YLJHP * 0.01*yljk;
		RHF[2] = half_fgdk;
		RHF[3] = RHF[5] - LMHP * 0.01*(cxdk + lydk);
		//考虑超高加宽重新计算
		CalLMK_JK(cml, NLMK, LMK, cgNm, cg, jkNm, jk, half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		CalLMKbyFile(cml, ZorY, pm, pBXArr, BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
		RHF[4] = RHF[2] + lydk + cxdk, RHF[5] = RHF[3] + (lydk + cxdk)* LMHP * 0.01;
		RHF[6] = RHF[4] + yljk, RHF[7] = RHF[5] + yljk * YLJHP * 0.01;
		RHF[8] = RHF[6] + tljk, RHF[9] = RHF[7] - tljk * tljhp * 0.01;
		RHF[0] = 0.0; RHF[1] = RHF[3] - fgdk * fgdhp * 0.01;
	}
}
void HdmDes::CalLMJK(double cml, int ncg, CgSZ cg[], double &addwid)
{
	double k;
	addwid = 0.0;
	int i;
	for (i = 0; i < ncg; i++)
	{
		if (cml < cg[i].cml)
			break;
	}

	if (i == 0)
		addwid = cg[0].cg;
	else if (i > 0 && i<ncg && fabs(cg[i].cml - cg[i - 1].cml)>0.0001)
	{
		k = (cml - cg[i - 1].cml) / (cg[i].cml - cg[i - 1].cml);
		addwid = cg[i - 1].cg + k * (cg[i].cg - cg[i - 1].cg);
	}
	else
		addwid = cg[i - 1].cg;
}
//设置断面属性
//int HdmDes::SetDmProperty(double cml,JD_CENTER *pm,int NBRI1,BRITAB Bri1[],int NBRI2,BRITAB Bri2[],
//						  int NTUN1,TUNTAB Tun1[],int NTUN2,TUNTAB Tun2[],int ZorY)
//{
//	int dmxz;
//	int i;
//	double sml,eml;
//	if(NBRI1>0)
//	{
//		for(i=0; i<NBRI1; i++)
//		{
//			sml = pm->TYLC(Bri1[i].StDml);
//			eml = pm->TYLC(Bri1[i].EdDml);
//			if(fabs(cml-sml)<0.001)
//			{
//				if(ZorY==-1)//左桥头
//					return -2;
//				else
//					return -3;
//			}
//			else if(fabs(cml-eml)<0.001)
//			{
//				if(ZorY==-1)//左桥尾
//					return 2;
//				else
//					return 3;
//			}
//			else if(cml>sml && cml<eml)
//			{
//				if(ZorY==-1)//左桥中
//					return 8;
//				else//右桥中
//					return 9;
//			}
//		}
//	}
//	if(NBRI2>0)
//	{
//		for(i=0; i<NBRI2; i++)
//		{
//			sml = pm->TYLC(Bri2[i].StDml);
//			eml = pm->TYLC(Bri2[i].EdDml);
//			if(fabs(cml-sml)<0.001)
//				return -1;//全桥头
//			else if(fabs(cml-eml)<0.001)
//				return 1;//全桥尾
//			else if(cml>sml && cml<eml)
//				return 7;//全桥中
//		}
//	}
//	if(NTUN1>0)
//	{
//		for(i=0; i<NTUN1; i++)
//		{
//			sml = pm->TYLC(Tun1[i].StDml);
//			eml = pm->TYLC(Tun1[i].EdDml);
//			if(fabs(cml-sml)<0.001)
//			{
//				if(ZorY==-1)//左桥头
//					return -5;
//				else
//					return -6;
//			}
//			else if(fabs(cml-eml)<0.001)
//			{
//				if(ZorY==-1)//左桥尾
//					return 5;
//				else
//					return 6;
//			}
//			else if(cml>sml && cml<eml)
//			{
//				if(ZorY==-1)//左隧中
//					return 11;
//				else//右隧中
//					return 12;
//			}
//		}
//	}
//	if(NTUN2>0)
//	{
//		for(i=0; i<NTUN2; i++)
//		{
//			sml = pm->TYLC(Tun2[i].StDml);
//			eml = pm->TYLC(Tun2[i].EdDml);
//			if(fabs(cml-sml)<0.001)
//				return -4;//全隧头
//			else if(fabs(cml-eml)<0.001)
//				return 4;//全隧尾
//			else if(cml>sml && cml<eml)
//				return 10;//全隧中
//		}
//	}
//	return 0;
//}
//设置断面属性
int HdmDes::SetDmProperty(double cml, JD_CENTER *pm, int NBRI1, BRITAB Bri1[], int NBRI2, BRITAB Bri2[],
	int NTUN1, TUNTAB Tun1[], int NTUN2, TUNTAB Tun2[], int ZorY, double &ZDK, int qdmxz)
{
	int i, counter = 0, dmxz[100];
	double sml, eml;

	ZDK = 1.0;
	if (NBRI1 > 0)
	{
		for (i = 0; i < NBRI1; i++)
		{
			sml = pm->TYLC(Bri1[i].StDml);
			eml = pm->TYLC(Bri1[i].EdDml);
			//			if(fabs(cml-37600)<0.1)
			//ads_printf(L"cml=%lf sdml=%lf edml=%lf sml=%lf eml=%lf\n",cml,Bri1[i].StDml,Bri1[i].EdDml,sml,eml);
			if (fabs(cml - sml) < 0.001)
			{
				//return -1;
				dmxz[counter] = -1;
				counter++;
			}
			else if (fabs(cml - eml) < 0.001)
			{
				//				return 1;
				dmxz[counter] = 1;
				counter++;
			}
			else if (cml > sml && cml < eml)
			{
				if (ZorY == -1)
					ZDK = Bri1[i].ZZDK;
				else
					ZDK = Bri1[i].YZDK;
				//				return 3;
				dmxz[counter] = 3;
				counter++;
			}
		}
	}
	if (NBRI2 > 0)
	{
		for (i = 0; i < NBRI2; i++)
		{
			sml = pm->TYLC(Bri2[i].StDml);
			eml = pm->TYLC(Bri2[i].EdDml);

			if (fabs(cml - sml) < 0.001)
			{
				dmxz[counter] = -1;
				counter++;
				//	return -1;//全桥头
			}
			else if (fabs(cml - eml) < 0.001)
			{
				//				return 1;//全桥尾
				dmxz[counter] = 1;
				counter++;
			}
			else if (cml > sml && cml < eml)
			{
				if (ZorY == -1)
					ZDK = Bri2[i].ZZDK;
				else
					ZDK = Bri2[i].YZDK;
				//				return 3;//全桥中
				dmxz[counter] = 3;
				counter++;
			}

		}
	}
	if (NTUN1 > 0)
	{
		for (i = 0; i < NTUN1; i++)
		{
			sml = pm->TYLC(Tun1[i].StDml);
			eml = pm->TYLC(Tun1[i].EdDml);
			if (fabs(cml - sml) < 0.001)
			{
				//				return -2;
				dmxz[counter] = -2;
				counter++;
			}
			else if (fabs(cml - eml) < 0.001)
			{
				//				return 2;
				dmxz[counter] = 2;
				counter++;
			}
			else if (cml > sml && cml < eml)
			{
				if (ZorY == -1)
					ZDK = Tun1[i].ZZDK;
				else
					ZDK = Tun1[i].YZDK;
				//				return 4;
				dmxz[counter] = 4;
				counter++;
			}
		}
	}
	if (NTUN2 > 0)
	{
		for (i = 0; i < NTUN2; i++)
		{
			sml = pm->TYLC(Tun2[i].StDml);
			eml = pm->TYLC(Tun2[i].EdDml);
			if (fabs(cml - sml) < 0.001)
			{
				//				return -2;//全隧头
				dmxz[counter] = -2;
				counter++;
			}
			else if (fabs(cml - eml) < 0.001)
			{
				//				return 2;//全隧尾
				dmxz[counter] = 2;
				counter++;
			}
			else if (cml > sml && cml < eml)
			{
				if (ZorY == -1)
					ZDK = Tun2[i].ZZDK;
				else
					ZDK = Tun2[i].YZDK;
				//				return 4;//全隧中
				dmxz[counter] = 4;
				counter++;
			}
		}
	}

	if (counter == 1 || counter > 2)
		return dmxz[0];
	else if (counter == 2)
	{
		if ((dmxz[0] == 1 && dmxz[1] == -2) || (dmxz[0] == -2 && dmxz[1] == 1) || (dmxz[0] == 2 && dmxz[1] == -1) || (dmxz[0] == -1 && dmxz[1] == 2))
		{
			if (qdmxz == 1)//桥尾
				return -2;
			else if (qdmxz == 3)
				return 1;
			else if (qdmxz == 2)//隧尾
				return -1;
			else if (qdmxz == 4)
				return 2;
		}

	}

	return 0;
}

//输入里程cml，天沟分段总数，天沟数据
//输出支距BJ，沟宽GW,沟深GS，内侧坡SP1,外侧坡SP2,将汽厚度TG_JQHD
int HdmDes::FindTG(double cml, JD_CENTER *pm, int ntg, TGdata gou[], double &BJ, double &GW, double &GS, double &SP1, double &SP2, double &TG_JQHD, double &TG_GDR)
{
	int inf, i;
	inf = 0;
	double SBJ, SGW, SGS, EBJ, EGW, EGS;
	double sml, eml;

	for (i = 0; i < ntg; i++)
	{
		sml = pm->TYLC(gou[i].sdml);
		eml = pm->TYLC(gou[i].edml);
		if (cml<eml + 0.001 && cml>sml - 0.001)
		{
			inf = 1;
			break;
		}
	}

	if (inf == 1)
	{
		SBJ = gou[i].sbj;//土埂宽
		SGW = gou[i].sgw;//土埂高
		SGS = gou[i].sgs;//植树宽
		EBJ = gou[i].ebj;      //植树高
		EGW = gou[i].egw;//水沟深
		EGS = gou[i].egs;//水沟底宽
		if (fabs(eml - sml) > 0.001)
		{
			BJ = SBJ + (EBJ - SBJ)*(cml - sml) / (eml - sml);
			GW = SGW + (EGW - SGW)*(cml - sml) / (eml - sml);
			GS = SGS + (EGS - SGS)*(cml - sml) / (eml - sml);
		}
		else
		{
			BJ = SBJ;
			GW = SGW;
			GS = SGS;
		}
		SP1 = gou[i].nbp;
		SP2 = gou[i].wbp;
		TG_JQHD = gou[i].jqhd;
		TG_GDR = gou[i].TG_GDR;

	}
	else
	{
		SBJ = 0.0;
		SGW = 0.0;
		SGS = 0.0;
		EBJ = 0.0;
		EGW = 0.0;
		EGS = 0.0;
		SP1 = 0.0;
		SP2 = 0.0;
		TG_JQHD = 0.0;
		TG_GDR = 0.0;
	}
	return inf;
}

//输入里程cml，路基填料分段总数，路基填料数据
//输出改良土厚度
/////////////////////////////////////////////////////////////////////
double HdmDes::FindIljxk(double cml, JD_CENTER *pm, int nljxk, dmdata ljxk[])//宽
{
	int i;
	double ml;

	for (i = 0; i < nljxk; i++)
	{
		ml = pm->TYLC(ljxk[i].dml);//分段终里程

		if (cml < ml || fabs(ml - cml) < 0.001)
			//所给里程处于第I个分段内
			return ljxk[i].xk;
	}

	return ljxk[i - 1].xk;
}
//------------------------------------------------------------------------
int HdmDes::FindSG(double cml, JD_CENTER *pm, int nldsg, LDSGdata gou[], int &WallorGou,
	double &PSG_JQHD, double &T2W, double &T1W, double &T2H, double &GH, double &GW,
	double &HH, double &SP1, double &SP2, double &SP3, double &PSG_GDR)
{
	int inf, i;
	double x, y;
	double sml, eml;
	inf = -1;
	for (i = 0; i < nldsg; i++)
	{
		sml = pm->TYLC(gou[i].sdml);//分段终里程
		eml = pm->TYLC(gou[i].edml);//分段终里程

		if (cml <= eml && cml >= sml)
		{
			inf = 1;
			break;
		}
	}

	if (inf == 1)
	{
		x = cml - sml;
		y = eml - cml;
		WallorGou = gou[i].WallorGou;
		PSG_JQHD = gou[i].jh;//浆汽厚度		
		T2W = (gou[i].S_DSYK*y + gou[i].E_DSYK*x) / (x + y);//挡水堰宽
		T1W = (gou[i].S_HPDK*y + gou[i].E_HPDK*x) / (x + y);//植树宽
		T2H = (gou[i].S_DSYH*y + gou[i].E_DSYH*x) / (x + y);//土埂高
		GH = (gou[i].S_GS*y + gou[i].E_GS*x) / (x + y);//水沟深
		GW = (gou[i].S_GK*y + gou[i].E_GK*x) / (x + y);//水沟底宽
		HH = (gou[i].S_HPDH*y + gou[i].E_HPDH*x) / (x + y);//植树高
		SP1 = gou[i].nbp;
		SP2 = gou[i].wbp;
		SP3 = gou[i].DSYP;
		PSG_GDR = gou[i].LDSG_GDR;
	}
	else
	{
		WallorGou = 0;
		PSG_JQHD = 0.0;//浆汽厚度				
		T2W = 0.0;
		T1W = 0.0;
		T2H = 0.0;
		GH = 0.0;
		GW = 0.0;
		HH = 0.0;
		SP1 = 0.0;
		SP2 = 0.0;
		SP3 = 0.0;
		PSG_GDR = 0.0;
	}

	return inf;
}

//void HdmDes::FindSG(double cml,JD_CENTER *pm,int nldsg,LDSGdata gou[],int &WallorGou,double &HPDK,double &HPDI,
//					double &GH,double &GW,double &SP1,double &SP2,double &PSG_JQHD)//加浆砌厚度
//{
//	int i;
////	char mes[80];
//	double ml;
//	
//    for(i=0; i<nldsg; i++)
//	{
//		ml = pm->TYLC(gou[i].dml);//分段终里程
//			
//		if(cml<ml || fabs(ml-cml)<0.001)
//		{
//			//所给里程处于第I个分段内
//            WallorGou = gou[i].WallorGou;
//			HPDK = gou[i].hpw;//护坡道宽
//			HPDI = gou[i].hpi/100.0;//护坡道横坡
//			GH = gou[i].gs;//沟深
//			GW = gou[i].gk;//沟宽
//			SP1 = gou[i].nbp;//内侧坡
//			SP2 = gou[i].wbp;//外侧坡
//            PSG_JQHD = gou[i].jh;//浆汽厚度			
//			return;
//		}
//	}
//	i--;
//	WallorGou = gou[i].WallorGou;
//	HPDK = gou[i].hpw;//护坡道宽
//	HPDI = gou[i].hpi/100.0;//护坡道横坡
//	GH = gou[i].gs;//沟深
//	GW = gou[i].gk;//沟宽
//	SP1 = gou[i].nbp;//内侧坡
//	SP2 = gou[i].wbp;//外侧坡
//	PSG_JQHD = gou[i].jh;//浆汽厚度				
//}

void HdmDes::FindIljjk(double cml, JD_CENTER *pm, int nljjk, pwddata ljjk[], double &ltjk, double &lqjk)//宽
{
	int i;
	double ml;

	for (i = 0; i < nljjk; i++)
	{
		ml = pm->TYLC(ljjk[i].dml);//分段终里程

		if (cml < ml || fabs(ml - cml) < 0.001)
		{
			//所给里程处于第I个分段内
			ltjk = ljjk[i].ltjk;
			lqjk = ljjk[i].lqjk;
			return;
		}
	}
	ltjk = ljjk[i - 1].ltjk;
	lqjk = ljjk[i - 1].lqjk;

	return;
}

int HdmDes::FindWichBP(double cml, JD_CENTER *pm, int nltbp, LDBPdata ltbp[], double tm[], double th[], double tptw[], double tpti[])//左路堤边坡
{
	int i, nbpjs, j;
	double ml;

	for (i = 0; i < nltbp; i++)
	{
		ml = pm->TYLC(ltbp[i].dml);//分段终里程
		if (cml < ml || fabs(ml - cml) < 0.001)
			//所给里程处于第I个分段内
		{
			nbpjs = ltbp[i].BPJS;
			//---------------------------------------------------------------------------------------
			for (j = 0; j < nbpjs; j++)
			{
				tm[j] = ltbp[i].bpdata[j * 4];
				th[j] = ltbp[i].bpdata[j * 4 + 1];
				tptw[j] = ltbp[i].bpdata[j * 4 + 2];
				tpti[j] = ltbp[i].bpdata[j * 4 + 3];
			}
			//	GlobalBPdata = ltbp[i];
			return nbpjs;
		}
	}
	i = nltbp - 1;//没有找到
	nbpjs = ltbp[i].BPJS;
	//---------------------------------------------------------------------------------------
	for (j = 0; j < nbpjs; j++)
	{
		tm[j] = ltbp[i].bpdata[j * 4];
		th[j] = ltbp[i].bpdata[j * 4 + 1];
		tptw[j] = ltbp[i].bpdata[j * 4 + 2];
		tpti[j] = ltbp[i].bpdata[j * 4 + 3];
	}
	return nbpjs;
}

double HdmDes::FindWichHTHD(double cml, JD_CENTER *pm, int nhthd, hthddata hthd[])
{
	int i;
	double ml;

	for (i = 0; i < nhthd; i++)
	{
		ml = pm->TYLC(hthd[i].dml);//分段终里程
		if (cml < ml || fabs(ml - cml) < 0.001)
			//所给里程处于第I个分段内
			return hthd[i].hthd;
	}
	return hthd[i - 1].hthd;
}

void HdmDes::FindWichHTHD(double cml, JD_CENTER *pm, int nhthd, hthddata hthd[], double &hthdnew, int &xz)
{
	int i;
	double ml;

	for (i = 0; i < nhthd; i++)
	{
		ml = pm->TYLC(hthd[i].dml);//分段终里程
		if (cml < ml || fabs(ml - cml) < 0.001)
		{
			//所给里程处于第I个分段内
			hthdnew = hthd[i].hthd;
			xz = hthd[i].xz;
			return;
		}
	}

	hthdnew = hthd[i - 1].hthd;
	xz = hthd[i - 1].xz;

	return;
}

//-----------------------------------------------------------------------------
void HdmDes::Cal_D(double cml, JD_CENTER *pm, int nlzsg, LQSGdata lzsg[], double *D, double *GK, double *GS, double *GP1, double *GP2, double *JQHD, double *GDR)
{
	int i;
	double ml;

	for (i = 0; i < nlzsg; i++)
	{
		ml = pm->TYLC(lzsg[i].dml);
		if (cml < ml + 0.001)
		{
			*GK = lzsg[i].gw;
			*GS = lzsg[i].gs;
			*GP1 = lzsg[i].nbp;
			*GP2 = lzsg[i].wbp;
			*D = *GK + *GS*(*GP1 + *GP2);
			*JQHD = lzsg[i].Jh;
			*GDR = lzsg[i].GDR;
			if (*JQHD < -0.001)//浆砌朝外
			{
				*GS += fabs(*JQHD);
				*GK += fabs(*JQHD) / tan(0.5*(pi - atan(1.0 / (*GP2)))) + fabs(*JQHD) / tan(0.5*(pi - atan(1.0 / (*GP1))));
			}
			return;
		}
	}
	i--;
	*GK = lzsg[i].gw;
	*GS = lzsg[i].gs;
	*GP1 = lzsg[i].nbp;
	*GP2 = lzsg[i].wbp;
	*D = *GK + *GS*(*GP1 + *GP2);
	*JQHD = lzsg[i].Jh;
	*GDR = lzsg[i].GDR;

	if (*JQHD < -0.001)//浆砌朝外
	{
		*GS += fabs(*JQHD);
		*GK += fabs(*JQHD) / tan(0.5*(pi - atan(1.0 / (*GP2)))) + fabs(*JQHD) / tan(0.5*(pi - atan(1.0 / (*GP1))));
	}

}
//输入沟宽，沟深，内侧坡系数，外侧坡系数，浆砌厚度
double HdmDes::CalGouJQArea(double GH, double GW, double SP1, double SP2, double JQHD)
{
	double UpLen;
	UpLen = GW + sqrt(GH*SP1*GH*SP1 + GH * GH) + sqrt(GH*SP2*GH*SP2 + GH * GH);//顶边斜长
	double DownXC1, DownXC2;
	DownXC1 = sqrt((GH + JQHD)*SP1*(GH + JQHD)*SP1 + (GH + JQHD)*(GH + JQHD));//底边斜长
	DownXC2 = sqrt((GH + JQHD)*SP2*(GH + JQHD)*SP2 + (GH + JQHD)*(GH + JQHD));//底边斜长

	double GKadd1, GKadd2;
	if (SP1 > 0.001)//不能为0
		GKadd1 = JQHD * tan(0.5*atan(1.0 / SP1));
	else
		GKadd1 = 0;
	if (SP2 > 0.001)
		GKadd2 = JQHD * tan(0.5*atan(1.0 / SP2));
	else
		GKadd2 = 0;

	double DownLen = GKadd1 + GKadd2 + GW + DownXC1 + DownXC2;//底边斜长
	double JQarea = 0.5*(UpLen + DownLen)*JQHD;
	return JQarea;
}
void  HdmDes::CalDesArea(int TorW, int DesPtSum, double DesPtList[], int EarPtSum, double EarPtList[], double lmhd[3], double& FillArea, double& CutArea)
{
	int npt;
	double LJFillArea, LJCutArea;
	double despoints[500];

	FillArea = 0.0;
	CutArea = 0.0;
	int i;
	for (i = 0; i < 4; i++)
		despoints[i] = DesPtList[i];
	npt = 2;
	despoints[npt * 2] = DesPtList[2];
	despoints[npt * 2 + 1] = DesPtList[3] - lmhd[0];
	npt++;
	despoints[npt * 2] = DesPtList[4];
	despoints[npt * 2 + 1] = DesPtList[5] - lmhd[0];
	npt++;
	despoints[npt * 2] = DesPtList[4];
	despoints[npt * 2 + 1] = DesPtList[5] - lmhd[1];
	npt++;
	despoints[npt * 2] = DesPtList[6];
	despoints[npt * 2 + 1] = DesPtList[7] - lmhd[1];
	npt++;
	despoints[npt * 2] = DesPtList[6];
	despoints[npt * 2 + 1] = DesPtList[7] - lmhd[2];
	npt++;
	despoints[npt * 2] = DesPtList[8];
	despoints[npt * 2 + 1] = DesPtList[9] - lmhd[2];
	npt++;

	for (i = 4; i < DesPtSum; i++)
	{
		despoints[npt * 2] = DesPtList[i * 2];
		despoints[npt * 2 + 1] = DesPtList[i * 2 + 1];
		npt++;
	}

	cal_polygon_area(npt, despoints, EarPtSum, EarPtList, LJFillArea, LJCutArea);
	FillArea += LJFillArea;
	CutArea += LJCutArea;
	//ads_printf(L"\nLjfia=%lf,filla=%lf,Ljcuta=%lf,cuta=%lf",LJFillArea,FillArea,LJCutArea,CutArea);
}

//给定厚度，按4%的排水坡计算新的设计线
//int HdmDes::CalNewDesline(int TorW,int DesPtSum,double DesPtList[],double hd[3],int &NewPtNum,double NewDesPtList[])
//{
//	int inf,j;
//	NewPtNum = 0;
//
////厚度不为0
//	//先取路面点
//	NewDesPtList[0] = DesPtList[0];
//	NewDesPtList[1] = DesPtList[1];//基床表层厚度
//	
//	NewDesPtList[2] = DesPtList[2];
//	NewDesPtList[3] = DesPtList[3];//4%的排水坡
//	
//	NewDesPtList[4] = DesPtList[4];
//	NewDesPtList[5] = DesPtList[5]-DesPtList[4]*0.04;
//	
//	NewDesPtList[6] = DesPtList[6];
//	NewDesPtList[7] = NewDesPtList[1]-DesPtList[6]*0.04;
//	
//	NewDesPtList[8] = DesPtList[8];
//	NewDesPtList[9] = NewDesPtList[1]-DesPtList[8]*0.04;
//	
//	NewPtNum = 5; 
//	if(DesPtSum>5)
//	{
//		//与边坡线找交点
//		inf = 0;
//		if(TorW==-1)//填方
//		{
//			for( j=5; j<DesPtSum; j++)
//			{
//				double jdx,jdy;
//				INTERS(&jdx,&jdy,DesPtList[(j-1)*2],DesPtList[(j-1)*2+1],DesPtList[j*2],DesPtList[j*2+1],
//					NewDesPtList[0],NewDesPtList[1],NewDesPtList[6],NewDesPtList[7]);
//				if(jdx>DesPtList[(j-1)*2]-0.001&&jdx<DesPtList[j*2]+0.001&&
//					jdy<DesPtList[(j-1)*2+1]+0.001&&jdy>DesPtList[j*2+1]-0.001)//有效
//				{
//					NewDesPtList[8] = jdx;
//					NewDesPtList[9] = jdy;
//					inf = 1;
//					break;//j号点
//				}		
//			}
//			if(inf==0)
//				return inf;//没有交点			
//		}
//		else//挖方
//		  j=4;//从路肩取点
//		
//		//从j以后取点
//		for(int i=j; i<DesPtSum; i++)
//		{
//				NewDesPtList[NewPtNum*2] = DesPtList[i*2];
//				NewDesPtList[NewPtNum*2+1] = DesPtList[i*2+1];
//				NewPtNum++;
//						
//		}
//		return inf;
//	}
//	
//	return 0;
//}
int HdmDes::Gety(double x, int ptsum, double ptlist[], double &Yd, int &ptnum)
{
	int i;

	i = 0;
	Yd = ptlist[1];
	ptnum = 0;

	while (x > ptlist[i * 2] + 0.0001&& i < ptsum)
		i++;

	if (i == ptsum)
	{
		Yd = ptlist[(i - 1) * 2];
		ptnum = i - 1;
		return 0;//找不到
	}
	if (i == 0)
		return -1;

	ptnum = i - 1;
	Yd = ptlist[(i - 1) * 2 + 1] + (x - ptlist[(i - 1) * 2])*(ptlist[i * 2 + 1] - ptlist[(i - 1) * 2 + 1]) / (ptlist[i * 2] - ptlist[(i - 1) * 2]);
	return 1;//找到
}

int HdmDes::DesBPnew(int NA, double StartDesPt[2], double WM[30], double PH[30], double PTW[30], double PTI[30],
	int EarPtNum2, int EarPtSum, double EarPtList[], double ljxk, double BPpt[50], int& BPptSum,
	double ZJ, int bpjs)
{
	int inf, ibp, nbppt;
	double XZ, YZ, spt[2];


	nbppt = 0;
	spt[0] = StartDesPt[0], spt[1] = StartDesPt[1];

	if (ZJ < StartDesPt[0] + 0.001)//支距比路面还窄
	{
		BPptSum = 0;
		return -2;
	}
	if (StartDesPt[0] > EarPtList[2 * (EarPtSum - 1)])//路面超过地面线
	{
		ads_printf(L"\n路面超过地面线");
		BPptSum = 0;
		return -2;
	}
	for (ibp = 0; ibp < bpjs; ibp++)
	{
		inf = CALXY(EarPtNum2, EarPtSum, NA, WM[ibp], spt[0], spt[1], PH[ibp], &XZ, &YZ, EarPtList);

		if (inf == 0)//找到交点,则一级边坡搞定
		{
			BPptSum = nbppt + 1;
			if (ZJ < XZ)//交点超出水平支距,修正
			{
				BPpt[nbppt * 2] = ZJ;
				BPpt[nbppt * 2 + 1] = spt[1] + NA * (BPpt[nbppt * 2] - spt[0]) / WM[ibp];
				return -2;
			}
			BPpt[nbppt * 2] = XZ;
			BPpt[nbppt * 2 + 1] = YZ;

			if (XZ > ljxk) return -1;
			return 1;
		}
		else if (ibp != bpjs - 1)//找不到交点,则考虑二级边坡
		{

			BPpt[nbppt * 2] = spt[0] + PH[ibp] * WM[ibp];
			BPpt[nbppt * 2 + 1] = spt[1] + NA * PH[ibp];

			if (ZJ < BPpt[nbppt * 2])//超出水平支距,修正
			{
				BPptSum = nbppt + 1;
				BPpt[nbppt * 2] = ZJ;
				BPpt[nbppt * 2 + 1] = spt[1] + NA * (ZJ - spt[0]) / WM[ibp];
				return -2;
			}
			nbppt++;
			BPpt[nbppt * 2] = BPpt[(nbppt - 1) * 2] + PTW[ibp];
			BPpt[nbppt * 2 + 1] = BPpt[(nbppt - 1) * 2 + 1] + NA * PTW[ibp] * PTI[ibp] * 0.01;
			if (ZJ < BPpt[nbppt * 2])//超出水平支距,修正
			{
				BPptSum = nbppt + 1;
				BPpt[nbppt * 2] = ZJ;
				BPpt[nbppt * 2 + 1] = BPpt[(nbppt - 1) * 2 + 1];
				return -2;
			}
			//判别平台是否与地面线相交
			inf = CALPTJD(EarPtNum2, EarPtSum, BPpt[(nbppt - 1) * 2], BPpt[(nbppt - 1) * 2 + 1], BPpt[nbppt * 2], BPpt[nbppt * 2 + 1], &XZ, &YZ, EarPtList);
			if (inf == 0)//找到交点,则平台与地面线相交
			{
				BPptSum = nbppt + 1;
				BPpt[nbppt * 2] = XZ;
				BPpt[nbppt * 2 + 1] = YZ;
				return 1;
			}

			spt[0] = BPpt[nbppt * 2];
			spt[1] = BPpt[nbppt * 2 + 1];
			nbppt++;
		}
	}

	BPptSum = nbppt;
	return 0;
}
void HdmDes::BPptToDESpt(int BPptSum, double BPpt[], int &DesPtSum,
	double DesPtList[], double LTJK, double &BJX,
	double &BJY, double &ZDK, double &DQlength, double &GrassLength)
{
	int i;
	for (i = 0; i < BPptSum; i++)
	{
		DesPtList[DesPtSum * 2] = BPpt[i * 2];
		DesPtList[DesPtSum * 2 + 1] = BPpt[i * 2 + 1];
		DesPtSum++;
	}
	BJX = DesPtList[(DesPtSum - 1) * 2];
	BJY = DesPtList[(DesPtSum - 1) * 2 + 1];
	ZDK = BJX + LTJK;
	//计算边坡长度
	double bpxs, deltaY, deltaX, len;
	DQlength = 0;
	GrassLength = 0;
	//一级边坡
	deltaY = fabs(DesPtList[5 * 2 + 1] - DesPtList[4 + 1]);
	deltaX = fabs(DesPtList[5 * 2] - DesPtList[4 * 2]);
	len = sqrt(deltaX*deltaX + deltaY * deltaY);
	///////////////////////////////wwq5.16
	if (deltaY > 0.001)
	{
		bpxs = deltaX / deltaY;
		if (bpxs >= 0.5)//坡比较缓时
			GrassLength += len;
		else
			DQlength += len;
	}
	else
		GrassLength += len;

	for (i = 5; i < DesPtSum - 1; i++)
	{
		deltaY = fabs(DesPtList[(i + 1) * 2 + 1] - DesPtList[i * 2 + 1]);
		deltaX = fabs(DesPtList[(i + 1) * 2] - DesPtList[i * 2]);
		len = sqrt(deltaX*deltaX + deltaY * deltaY);
		///////////////////////////////wwq5.16
		if (deltaY > 0.001)
		{
			bpxs = deltaX / deltaY;
			if (bpxs >= 0.5)//坡比较缓时
				GrassLength += len;
			else
				DQlength += len;
		}
		else
			GrassLength += len;
	}
	/////////////////////wwq5.16
	//	ads_printf(L"1: DesPtSum=%d  %lf %lf\n",DesPtSum,DesPtList[(DesPtSum-1)*2],DesPtList[(DesPtSum-1)*2+1]);

}
void HdmDes::CalDesAllArea(int nDespt, double DesPoint[], int NearPt, double earpt[],
	double lmhd[3], double hthd, double glthd, double hjwid,
	double ZJ, int TorW,
	double StartDesPt[], double TM[], double TH[], double TPTW[], double TPTI[], int NBPJS,
	double &FillArea, double &CutArea, double &QBTArea, double &FillGLTArea, double &HJarea)
{
	double *newEarPtList;
	int newBPptSum;
	double newBPpt[50], TFBPpt[50];
	double oldFillArea, oldCutArea;
	oldFillArea = FillArea;
	oldCutArea = CutArea;
	FillArea = 0.0;
	CutArea = 0.0;
	QBTArea = 0.0;
	FillGLTArea = 0.0;
	HJarea = 0.0;

	if (TorW < 0 && nDespt < 5)//填
		return;
	if (TorW > 0 && nDespt < 9)
		return;

	double PJZJ;
	//计算清表土面积
	if (hthd > 0.001)
	{
		PJZJ = DesPoint[(nDespt - 1) * 2];
		QBTArea = CalQBTArea(PJZJ, hthd, NearPt, earpt);

		newEarPtList = new double[2 * NearPt];
		int j;
		for (j = 0; j < NearPt; j++)
		{
			newEarPtList[j * 2] = earpt[j * 2];
			newEarPtList[j * 2 + 1] = earpt[j * 2 + 1] - hthd;
		}
		int newdesinf = DesBPnew(TorW, StartDesPt, TM, TH, TPTW, TPTI, 0,
			NearPt, newEarPtList, 100.0, newBPpt, newBPptSum, ZJ, NBPJS);//地面线下降后重新设计边坡

		int startBPptnum;
		if (TorW < 0)//填
			startBPptnum = 5;
		else
			startBPptnum = 9;

		if (newdesinf == 1 || newdesinf == -2)//表示正常边坡有交点
		{
			for (j = 0; j < startBPptnum; j++)
			{
				TFBPpt[j * 2] = DesPoint[j * 2];
				TFBPpt[j * 2 + 1] = DesPoint[j * 2 + 1];
			}
			for (j = 0; j < newBPptSum; j++)
			{
				TFBPpt[(startBPptnum + j) * 2] = newBPpt[j * 2];
				TFBPpt[(startBPptnum + j) * 2 + 1] = newBPpt[j * 2 + 1];
			}
			CalDesArea(TorW, newBPptSum + startBPptnum, TFBPpt, NearPt, newEarPtList, lmhd, FillArea, CutArea);
		}

		delete[]newEarPtList;
		newEarPtList = NULL;
		return;
	}

	//计算填挖面积
	CalDesArea(TorW, nDespt, DesPoint, NearPt, earpt, lmhd, FillArea, CutArea);

	if (FillArea < 0.0)
		FillArea = 0.0;

}

int HdmDes::DesLTGou(int IfSetGouBotH, double GouBotH, double TGK, double ZSDK, double TGH, double GS, double GDK, double ZSDH, double SP1, double SP2, double SP3, double gou[], double DesPtList[], int DesPtSum, double EarthPt[], int EarPtSum, double lzbp, double &gouH, double &gouX, double &BJX, double PSG_JQHD, double PSG_GDR)
{
	double GouStartPt[2], EarH, XZ, YZ, x;
	int inf, yinf, jdinf, EarPtNum1;

	int GouPtSum = 0;
	//	if(fabs(ZSDH)>0.001)//要做植树带,植树带可能为负
	//	{
	BJX = DesPtList[(DesPtSum - 1) * 2];
	inf = Cal_GouStartPt(GouStartPt, DesPtList, DesPtSum, ZSDH);
	//  ads_printf(L"1: %lf  des1=%lf %lf des2=%lf %lf\n",
	//	   ZSDH,DesPtList[(DesPtSum-1)*2],DesPtList[(DesPtSum-1)*2+1],DesPtList[(DesPtSum-2)*2],DesPtList[(DesPtSum-2)*2+1]);

	if (!inf)
		return -1;
	gou[0] = GouStartPt[0], gou[1] = GouStartPt[1];
	gou[2] = gou[0] + ZSDK, gou[3] = gou[1] - 0.04*ZSDK;
	gou[4] = gou[2] + (GS + PSG_JQHD)*SP1, gou[5] = gou[3] - GS - PSG_JQHD;
	double a1, b1;
	a1 = SP1 > 0.01 ? 0.5*atan(1 / SP1) : 0.25*pi;
	b1 = SP2 > 0.01 ? 0.5*atan(1 / SP2) : 0.25*pi;
	gou[6] = gou[4] + PSG_JQHD * (tan(a1) + tan(b1)) + GDK, gou[7] = gou[5];
	gou[8] = gou[6] + (GS + PSG_JQHD)*SP2, gou[9] = gou[7] + GS + PSG_JQHD;

	gou[10] = gou[8] + TGH * SP3, gou[11] = gou[9] + TGH;

	gou[12] = gou[10] + TGK, gou[13] = gou[11];
	BJX = gou[12];
	gouH = gou[5] + PSG_JQHD;

	GouPtSum = 7;

	if (IfSetGouBotH == 1)//依据给定标高调整水沟
	{
		//		   if(gouH >  GouBotH)//水沟下移,相当于改沟深
		//		   {
		//			   gou[4] = gou[2] + (GS+PSG_JQHD)*SP1 , gou[5] = gou[3] - GS - PSG_JQHD;
		//			   double a1,b1;
		//			   a1 = SP1 > 0.01 ? 0.5*atan(1/SP1) : 0.25*pi;
		//			   b1 = SP2 > 0.01 ? 0.5*atan(1/SP2) : 0.25*pi;
		//			   gou[6] = gou[4] + PSG_JQHD * (tan(a1)+tan(b1)) + GDK, gou[7] = gou[5];
		//			   gou[8] = gou[6] +  (GS+PSG_JQHD)*SP2, gou[9] = gou[7] + GS+PSG_JQHD;	   
		//			   
		//			   gou[10] = gou[8] +  TGH*SP3, gou[11] = gou[9] + TGH;	   
		//			   
		//			   gou[12] = gou[10] + TGK , gou[13] = gou[11];
		//			   BJX = gou[12];
		//			   gouH = gou[5];
		//		   }
		//		   else//水沟上移，相当于改植树带高
		//		   {

		ZSDH = ZSDH + GouBotH - gouH;

		inf = Cal_GouStartPt(GouStartPt, DesPtList, DesPtSum, ZSDH);

		if (!inf)
			return -1;
		gou[0] = GouStartPt[0], gou[1] = GouStartPt[1];
		gou[2] = gou[0] + ZSDK - PSG_JQHD, gou[3] = gou[1] - 0.04*ZSDK;
		gou[4] = gou[2] + (GS + PSG_JQHD)*SP1, gou[5] = gou[3] - GS - PSG_JQHD;

		double a1, b1;
		a1 = SP1 > 0.01 ? 0.5*atan(1 / SP1) : 0.25*pi;
		b1 = SP2 > 0.01 ? 0.5*atan(1 / SP2) : 0.25*pi;
		gou[6] = gou[4] + PSG_JQHD * (tan(a1) + tan(b1)) + GDK, gou[7] = gou[5];
		gou[8] = gou[6] + (GS + PSG_JQHD)*SP2, gou[9] = gou[7] + GS + PSG_JQHD;

		gou[10] = gou[8] + TGH * SP3, gou[11] = gou[9] + TGH;

		gou[12] = gou[10] + TGK, gou[13] = gou[11];
		BJX = gou[12];
		gouH = gou[5] + PSG_JQHD;
		GouPtSum = 7;
		//	   }
	}
	gouX = 0.5*(gou[4] + gou[6]);
	yinf = Gety(gou[12], EarPtSum, EarthPt, EarH, EarPtNum1);
	if (yinf == 0) //水沟点已经超出地面线范围
		return -2;

	if (EarH > gou[13])//路堑
		//jdinf=CALXY(EarPtNum1,EarPtSum,1,lzbp,gou[10],gou[11],100.0,&XZ,&YZ,EarthPt);
		jdinf = CALXY(EarPtNum1, EarPtSum, 1, SP3, gou[12], gou[13], 100.0, &XZ, &YZ, EarthPt);
	else
		jdinf = CALXY(EarPtNum1, EarPtSum, -1, SP3, gou[12], gou[13], 100.0, &XZ, &YZ, EarthPt);

	if (jdinf == 0)//交上
	{
		gou[14] = XZ, gou[15] = YZ;
		GouPtSum = 8;
	}
	else // 交不上
		return -3;//不能做土埂外侧坡
	BJX = gou[14];

	//////////////////////////////////////////////////////////////////////////
	if (PSG_GDR > 0.001)//如果有沟底半径，需内插水沟点
	{
		double spt[2], ept[2];
		spt[0] = gou[4];
		spt[1] = gou[5];
		ept[0] = gou[6];
		ept[1] = gou[7];

		double pt[20];
		GetArcPt(spt, ept, PSG_GDR, 10, pt);
		//2修正设计点
		int ptsum = 10, npt, i;
		double despt[200];
		npt = 0;
		for (i = 0; i <= 2; i++)
		{
			despt[npt * 2] = gou[i * 2];
			despt[npt * 2 + 1] = gou[i * 2 + 1];
			npt++;
		}
		for (i = 0; i < 10; i++)
		{
			despt[npt * 2] = pt[i * 2];
			despt[npt * 2 + 1] = pt[i * 2 + 1];

			npt++;
		}
		for (i = 3; i < GouPtSum; i++)
		{
			despt[npt * 2] = gou[i * 2];
			despt[npt * 2 + 1] = gou[i * 2 + 1];
			npt++;
		}

		GouPtSum = npt;
		for (i = 0; i < GouPtSum; i++)
		{
			gou[i * 2] = despt[i * 2];
			gou[i * 2 + 1] = despt[i * 2 + 1];
		}
	}
	//////////////////////////////////////////////////////////////////////////
	/*
	}
	else//不要做植树带
	{
	x = DesPtList[(DesPtSum-1)*2]+ZSDK;
	yinf = Gety(x,EarPtSum,EarthPt,EarH,EarPtNum1);
	if(yinf == 0) //水沟点已经超出地面线范围
	return -2;
	gou[0] = x , gou[1] = EarH;
	gou[2] = gou[0] + GS*SP1 , gou[3] = gou[1] - GS;
	gou[4] = gou[2] + GDK , gou[5] = gou[3];
	gou[6] = gou[4] + GS*SP2 , gou[7] = gou[5] + GS;
	gou[8] = gou[6] + TGK , gou[9] = gou[7];
	yinf = Gety(gou[8],EarPtSum,EarthPt,EarH,EarPtNum1);
	gouH = gou[3];
	gouX = 0.5*(gou[2]+gou[4]);
	BJX = gou[8];
	if(yinf == 0) //水沟点已经超出地面线范围
	return -2;
	if(EarH > gou[9])//路堑
	// jdinf=CALXY(EarPtNum1,EarPtSum,1,lzbp,gou[8],gou[9],100.0,&XZ,&YZ,EarthPt);
	jdinf=CALXY(EarPtNum1,EarPtSum,1,SP3,gou[8],gou[9],100.0,&XZ,&YZ,EarthPt);
	else
	jdinf=CALXY(EarPtNum1,EarPtSum,-1,SP3,gou[8],gou[9],100.0,&XZ,&YZ,EarthPt);

	if(jdinf==0)//交上
	gou[10] = XZ , gou[11] = YZ;
	else // 交不上
	return -3;//不能做土埂外侧坡
	BJX = gou[10];


	if(IfSetGouBotH)//依据给定标高调整水沟
	{
	if(gouH >  GouBotH)//水沟下移,相当于改沟深
	{
	GS = GS + gouH - GouBotH;
	gou[2] = gou[0] + GS*SP1 , gou[3] = gou[1] - GS;
	gou[4] = gou[2] + GDK , gou[5] = gou[3];
	gou[6] = gou[4] + GS*SP2 , gou[7] = gou[5] + GS;
	gou[8] = gou[6] + TGK , gou[9] = gou[7];
	yinf = Gety(gou[8],EarPtSum,EarthPt,EarH,EarPtNum1);
	gouH = gou[3];
	gouX = 0.5*(gou[2]+gou[4]);
	BJX = gou[8];
	if(yinf == 0) //水沟点已经超出地面线范围
	return -2;
	if(EarH > gou[9])//路堑
	//	   jdinf=CALXY(EarPtNum1,EarPtSum,1,lzbp,gou[8],gou[9],100.0,&XZ,&YZ,EarthPt);
	jdinf=CALXY(EarPtNum1,EarPtSum,1,SP3,gou[8],gou[9],100.0,&XZ,&YZ,EarthPt);
	else
	jdinf=CALXY(EarPtNum1,EarPtSum,-1,SP3,gou[8],gou[9],100.0,&XZ,&YZ,EarthPt);

	if(jdinf==0)//交上
	gou[10] = XZ , gou[11] = YZ;
	else // 交不上
	return -3;//不能做土埂外侧坡
	BJX = gou[10];

	}
	else//水沟上移，相当于改植树带高
	{
	ZSDH = GouBotH - gouH  ;
	inf = Cal_GouStartPt(GouStartPt,DesPtList,DesPtSum,ZSDH);
	if(!inf)
	return -1;
	gou[0] = GouStartPt[0] , gou[1] = GouStartPt[1];
	gou[2] = gou[0] + ZSDK , gou[3] = gou[1] - 0.04*ZSDK;
	gou[4] = gou[2] + GS*SP1 , gou[5] = gou[3] - GS;
	gou[6] = gou[4] + GDK , gou[7] = gou[5];
	gou[8] = gou[6] + GS*SP2 , gou[9] = gou[7] + GS;
	gou[10] = gou[8] + TGK , gou[11] = gou[9];
	BJX = gou[10];
	gouH = gou[5];
	gouX = 0.5*(gou[4]+gou[6]);
	yinf = Gety(gou[10],EarPtSum,EarthPt,EarH,EarPtNum1);
	if(yinf == 0) //水沟点已经超出地面线范围
	return -2;
	if(EarH > gou[11])//路堑
	//	   jdinf=CALXY(EarPtNum1,EarPtSum,1,lzbp,gou[10],gou[11],100.0,&XZ,&YZ,EarthPt);
	jdinf=CALXY(EarPtNum1,EarPtSum,1,SP3,gou[10],gou[11],100.0,&XZ,&YZ,EarthPt);
	else
	jdinf=CALXY(EarPtNum1,EarPtSum,-1,SP3,gou[10],gou[11],100.0,&XZ,&YZ,EarthPt);

	if(jdinf==0)//交上
	gou[12] = XZ , gou[13] = YZ;
	else // 交不上
	return -3;//不能做土埂外侧坡
	BJX = gou[12];
	}
	}
	}
	*/
	return 1;
}

int  HdmDes::Cal_GouStartPt(double GouStartPt[2], double DesPtList[], int DesPtSum, double ZSDH)
{
	int inf;
	double x1, y1, x2, y2, dh;

	inf = 0;
	if (DesPtSum > 2)
	{
		x1 = DesPtList[(DesPtSum - 1) * 2];
		y1 = DesPtList[(DesPtSum - 1) * 2 + 1];
		x2 = DesPtList[(DesPtSum - 2) * 2];
		y2 = DesPtList[(DesPtSum - 2) * 2 + 1];

		dh = fabs(y1 - y2);

		if (dh >= ZSDH)
		{
			GouStartPt[0] = x1 + ZSDH * (x2 - x1) / (y2 - y1);
			GouStartPt[1] = y1 + ZSDH;

			//		 if(ZSDH<-0.0001)//植树带为负在地面以下，修正边坡角点
			//		 {
			//              DesPtList[(DesPtSum-1)*2] = GouStartPt[0];
			//			  DesPtList[(DesPtSum-1)*2+1] = GouStartPt[1];
			//		 }
		}
		else if (DesPtSum > 7 && fabs(y2 - y1) > 1.0e-4)//表示不只一级边坡
		{
			GouStartPt[1] = y1 + ZSDH;
			x1 = DesPtList[(DesPtSum - 3) * 2];
			y1 = DesPtList[(DesPtSum - 3) * 2 + 1];
			x2 = DesPtList[(DesPtSum - 4) * 2];
			y2 = DesPtList[(DesPtSum - 4) * 2 + 1];

			GouStartPt[0] = x1 + (ZSDH - dh)*(x2 - x1) / (y2 - y1);
			//GouStartPt[0] = x1 + (ZSDH-(DesPtList[(DesPtSum-3)*2+1]-DesPtList[(DesPtSum-1)*2+1]))*(x2-x1)/(y2-y1);
		}
		else // //表示只有一级边坡,且路肩处添高不满足植树带高,取路肩点
		{
			GouStartPt[0] = x2;
			GouStartPt[1] = y2;
		}
		inf = 1;
	}
	return inf;
}

//int HdmDes::DesLTGou(double GC,double desh,double HPDK,double HPDI,double GDK,double GS,double SP1,double SP2,double DesPtList[],int DesPtSum,double EarthPt[],int EarPtSum,int &GouPtNum,double GouPt[])
//{			 
//	int inf;
//
//	double D = GS*(SP1+SP2)+GDK;//沟宽
//	double offsetX = D + HPDK;//平移动距离
//    //ads_printf(L"\n^^^d=%lf,hpdk=%lf",D,HPDK);
//	AcGePoint3d PJD,PrePJD;
//	GouPtNum = 0;//点数为0
//	PJD.x = DesPtList[(DesPtSum-1)*2];//坡脚点
//    PJD.y = DesPtList[(DesPtSum-1)*2+1];
//	PJD.z = 0.0;
//	PrePJD.x = DesPtList[(DesPtSum-2)*2];//坡脚点的前一点
//    PrePJD.y = DesPtList[(DesPtSum-2)*2+1];
//	PrePJD.z = 0.0;
//	 AcGePoint3d pt;
//	//从坡脚处平移边坡线（D+HPDK），与地面线找出水沟外侧边坡与地面线交点pt	
//	
//	inf=CalGouOutPt(offsetX,PrePJD,PJD,EarthPt,EarPtSum,pt);
//	if(inf==0)
//		return 0;//找不到交点
//	else if(inf==2)//重新找
//	{
//		if(DesPtSum>=7)//至少有两及边坡
//		{
//			PJD.x = DesPtList[(DesPtSum-3)*2];//坡脚点
//			PJD.y = DesPtList[(DesPtSum-3)*2+1];
//			PJD.z = 0.0;
//			PrePJD.x = DesPtList[(DesPtSum-4)*2];//坡脚点的前一点
//			PrePJD.y = DesPtList[(DesPtSum-4)*2+1];
//			PrePJD.z = 0.0;	
//			if(CalGouOutPt(offsetX,PrePJD,PJD,EarthPt,EarPtSum,pt)!=1)//第二级还找不到交点,不做填方水沟
//				return 0;//非正常退出
//		}
//		else
//			return 3;//GouOuth大于（路肩高程-换填厚度-护坡道宽*护坡道坡度）应做侧沟
//      
//	}
//    //找出了水沟外侧点pt
//    double PJDbg = PJD.y + desh;//坡脚点标高
//	double GouOuth = pt.y + desh;
//	if(GouOuth>=PJDbg)//外侧边坡与地面线交点pt的高程大于坡脚点标高
//	{
//	   //2.依据水沟外侧点标高GouOuth是否小于（路肩高程-换填厚度-护坡道宽*护坡道坡度）判别是水沟还是侧沟
//       if(GouOuth < GC)//GouOuth小于（路肩高程-换填厚度-护坡道宽*护坡道坡度）可做水沟
//	   {
//		 CalGouAllPt(GouPtNum,GouPt,HPDI,GS,GDK,SP1,SP2,pt,PrePJD,PJD);//计算水沟各点
//		 return 1;//正常退出
//	   }
//	   else//GouOuth大于（路肩高程-换填厚度-护坡道宽*护坡道坡度）应做侧沟
//		   return 3;//特殊处理成挖方，性质为3
//	}
//	else//3.else 取出pt与坡脚点之间的地面点前后加一个点，拟合成一个直线，判别直线斜率是否大于0。04，若大于则坡脚墙，否则水沟，由外及内计算各点
//	{        
//		double dmhp;//地面横坡
//		dmhp = GetDmhp(PJD.x,pt.x,EarthPt,EarPtSum);
//		if(dmhp <-0.04)
//		{
//			return 4;//坡脚墙
//		}
//		else
//		{
//		  CalGouAllPt(GouPtNum,GouPt,HPDI,GS,GDK,SP1,SP2,pt,PrePJD,PJD);//计算水沟各点
//          return 1;//正常退出
//		}
//	}
//	return 0;//非正常退出
//}
void HdmDes::FormNewDmx(int EarPtSum, double EarPtList[], int DesPtSum, double DesPtList[], int &NewDmxPtNum, double NewDmxPtList[])
{
	NewDmxPtNum = DesPtSum;
	int i;
	for (i = 0; i < DesPtSum; i++)
	{
		NewDmxPtList[i * 2] = DesPtList[i * 2];
		NewDmxPtList[i * 2 + 1] = DesPtList[i * 2 + 1];
	}//先取设计点
	double pjx;
	pjx = DesPtList[(i - 1) * 2];
	//再取地面点

	for (i = 0; i < EarPtSum; i++)
	{
		if (EarPtList[i * 2] > pjx)
		{
			NewDmxPtList[NewDmxPtNum * 2] = EarPtList[i * 2];
			NewDmxPtList[NewDmxPtNum * 2 + 1] = EarPtList[i * 2 + 1];
			NewDmxPtNum++;
		}
	}
}
void  HdmDes::CalGouArea(int EarPtSum, double EarPtList[], int npt, double gou[], double& SGFillArea, double& SGCutArea)
{

	//计算水沟面积
	if (gou[0] < 0.01)//无水沟
		return;

	vector<double> wacthEar, wacthGut;
	for (int i = 0; i < EarPtSum; i++)
		wacthEar.push_back(EarPtList[i]);
	for (int i = 0; i < npt * 2; i++)
		wacthGut.push_back(gou[i]);

	//	for(i=0; i<npt; i++)
	//		TRACE("i=%d x=%lf y=%lf\n",i,gou[i*2],gou[i*2+1]);
	cal_polygon_area(npt, gou, EarPtSum, EarPtList, SGFillArea, SGCutArea);


	//20190906	修改水沟计算规则	不是直接延伸到地面线

	//double tempGutter[4];
	//tempGutter[0] = gou[0];
	//tempGutter[1] = gou[1];
	//tempGutter[2] = gou[6];
	//tempGutter[3] = gou[7];
	//double tempFillArea = 0.0, tempCutArea = 0.0;
	//cal_polygon_area(2, tempGutter, EarPtSum, EarPtList, tempFillArea, tempCutArea);
	//SGCutArea -= tempCutArea;


	//	FillArea += SGFillArea;
	//	CutArea += SGCutArea;
}
int HdmDes::DesLZ(int& npt, double gou[], double GS, double GK, double SP1, double SP2, double DesH_LZ, double LUZLMK, double WM[30], double PH[30], double ZPTW[30], double ZPTI[30], int EarPtNum2, int EarPtSum, double EarPtList[], double LJXK, double DesPtList[], int& DesPtSum, double& FillORCut, double ZJ, double DQinf, double WallType, double WallH, int BPJS, double &DQlength, double &Grasslength)
{
	double PTW[30], PTI[30], StartDesPt[2], BPpt[50];
	int BPptSum, desinf, i;
	DesPtList[5 * 2] = DesPtList[4 * 2] + GS * SP1;
	DesPtList[5 * 2 + 1] = DesPtList[4 * 2 + 1] - GS;
	DesPtList[6 * 2] = DesPtList[5 * 2] + GK;
	DesPtList[6 * 2 + 1] = DesPtList[5 * 2 + 1];
	// 拟修改
	gou[2 * npt] = DesPtList[4 * 2];
	gou[2 * npt + 1] = DesPtList[4 * 2 + 1];
	npt++;
	gou[2 * npt] = DesPtList[5 * 2];
	gou[2 * npt + 1] = DesPtList[5 * 2 + 1];
	npt++;
	gou[2 * npt] = DesPtList[6 * 2];
	gou[2 * npt + 1] = DesPtList[6 * 2 + 1];
	npt++;
	if (DQinf == 0.0)//不设挡墙
	{
		DesPtList[7 * 2] = DesPtList[6 * 2] + GS * SP2;
		DesPtList[7 * 2 + 1] = DesPtList[6 * 2 + 1] + GS;
		DesPtList[8 * 2] = LUZLMK;
		DesPtList[8 * 2 + 1] = DesH_LZ;
		DesPtSum = 9;
		StartDesPt[0] = DesPtList[8 * 2];
		StartDesPt[1] = DesPtList[8 * 2 + 1];
		for (i = 0; i < BPJS - 1; i++)
		{
			PTW[i] = ZPTW[i + 1];
			PTI[i] = ZPTI[i + 1];
		}
		PTW[i] = PTI[i] = 0.0;
		desinf = DesBPnew(1, StartDesPt, WM, PH, PTW, PTI, EarPtNum2, EarPtSum, EarPtList, LJXK, BPpt, BPptSum, ZJ, BPJS);

		// 拟修改
		gou[2 * npt] = DesPtList[7 * 2];
		gou[2 * npt + 1] = DesPtList[7 * 2 + 1];
		npt++;
	}

	/*    if(DQinf==1.0)//设挡墙
	{
	FindWFWallData(WallType,WallH,B1,PH0,BPXS);

	DesPtList[5*2] = DesPtList[4*2] + GS*SP1;
	DesPtList[5*2+1] = DesPtList[4*2+1] - GS;
	DesPtList[6*2] = DesPtList[5*2] + GK;
	DesPtList[6*2+1] = DesPtList[5*2+1];
	DesPtList[7*2] = DesPtList[6*2] +  GS*BPXS;
	DesPtList[7*2+1] = DesPtList[6*2+1] + GS;
	DesPtList[8*2] = DesPtList[7*2];
	DesPtList[8*2+1] = DesPtList[7*2+1];
	DesPtSum = 9;
	StartDesPt[0]=DesPtList[8*2];
	StartDesPt[1]=DesPtList[8*2+1];

	PTW[0] = B1;

	PTI[0] = 0.0;
	for(i=1; i<BPJS-1; i++)
	{
	PTW[i] = ZPTW[i];
	PTI[i] = ZPTI[i];
	WM[i] = WM[i-1];
	PH[i] = PH[i-1];
	}
	WM[0]=BPXS;
	PH[0] = PH0 - GS;
	desinf=DesBPnew(1,StartDesPt,WM,PH,PTW,PTI,EarPtNum2,EarPtSum,EarPtList,LJXK,BPpt,BPptSum,ZJ,BPJS);
	}*/

	for (i = 0; i < BPptSum; i++)
	{
		DesPtList[DesPtSum * 2] = BPpt[i * 2];
		DesPtList[DesPtSum * 2 + 1] = BPpt[i * 2 + 1];
		//ads_printf(L"\n^^^^des=%lf,des=%lf,%d",DesPtList[DesPtSum*2], DesPtList[DesPtSum*2+1],DesPtSum);
		DesPtSum++;
	}
	//////////////////////////////////wwq5.16
	double bpxs, deltaY, deltaX, len;
	DQlength = 0;
	Grasslength = 0;
	deltaY = fabs(BPpt[0 * 2 + 1] - StartDesPt[1]);
	deltaX = fabs(BPpt[0 * 2] - StartDesPt[0]);
	len = sqrt(deltaX*deltaX + deltaY * deltaY);
	if (deltaY > 0.001)
	{
		bpxs = deltaX / deltaY;
		if (bpxs >= 0.5)
			Grasslength += len;
		else
			DQlength += len;
	}
	else
		Grasslength += len;
	for (i = 0; i < BPptSum - 1; i++)
	{
		deltaY = fabs(BPpt[(i + 1) * 2 + 1] - BPpt[i * 2 + 1]);
		deltaX = fabs(BPpt[(i + 1) * 2] - BPpt[i * 2]);
		//ads_printf(L"\n##bp=%lf,bpy=%lf",BPpt[(i+1)*2+1],BPpt[i*2+1]);
		len = sqrt(deltaX*deltaX + deltaY * deltaY);
		if (deltaY > 0.001)
		{
			bpxs = deltaX / deltaY;
			if (bpxs >= 0.5)
				Grasslength += len;
			else
				DQlength += len;
		}
		else
			Grasslength += len;

	}
	//////////////////////////////wwq5.16
	if (DQinf == 0.0)//不设挡墙
		FillORCut = 1.0;//挖方			
	/*	else//挡墙
	{
	//修正
	if(BPptSum==1)
	{
	DesPtList[DesPtSum*2] = StartDesPt[0] + PH[0]*BPXS;
	DesPtList[DesPtSum*2+1] = StartDesPt[1]+PH[0];
	DesPtSum++;
	DesPtList[DesPtSum*2] = DesPtList[(DesPtSum-1)*2]+B1;
	DesPtList[DesPtSum*2+1] = DesPtList[(DesPtSum-1)*2+1];
	DesPtSum++;
	}

	if(WallType==1.0)
	FillORCut = 2.0+WallH/100.0;//衡重挖方挡墙
	else if(WallType==2.0)
	FillORCut = 4.0+WallH/100.0;//仰斜挖方挡墙
	}*/
	//截水沟

	return desinf;
}
//取出sx-ex之间的地面点，拟合成一条直线
double HdmDes::GetDmhp(double sx, double ex, double EarthPt[], int EarPtSum)
{
	AcGePoint3dArray dmptArray;
	AcGePoint3d dmpt;
	double SYd, EYd;
	int Ptnum;
	int ib, ie;//起终点号
	Gety(sx, EarPtSum, EarthPt, SYd, Ptnum);
	int i = 0;
	// 	while(i<EarPtSum && sx > EarthPt[i*2])
	// 		i++;
	// 	if(i>EarPtSum-2)
	// 		return -1.0;//找不到起点,无法拟合
	// 	ib = i;
	//	if(ib>1)
	// 		ib--;//往前推一个

	ib = Ptnum;
	//	i = ib;
	// 	while(i<EarPtSum && ex > EarthPt[i*2])
	// 		i++;
	// 	ie = i;
	// 	if(i==EarPtSum)
	// 		ie--;

	Gety(ex, EarPtSum, EarthPt, EYd, Ptnum);
	ie = Ptnum + 1;
	if (ie == EarPtSum)
		ie--;

	double ptx[200], pty[200], sig[200];
	int j = 0;
	for (i = ib; i <= ie; i++)
	{
		ptx[j + 1] = EarthPt[i * 2], pty[j + 1] = EarthPt[i * 2 + 1];
		if (i == ib)
		{
			ptx[j + 1] = sx;
			pty[j + 1] = SYd;
		}

		if (i == ie)
		{
			ptx[j + 1] = ex;
			pty[j + 1] = EYd;
		}

		sig[j + 1] = 0.01;
		j++;
	}
	double mwt = 0, a, b, siga, sigb, chi2, q;
	//	medfit(ptx, pty, j, a, b, abdev);
	fit(ptx, pty, j, sig, mwt, a, b, siga, sigb, chi2, q);
	return b;

}
//-----------------------------------------------------------------------------
int HdmDes::CALXY(int N1, int NP, int NA, double CC, double C1, double C2, double xh,
	double *XZ, double *YZ, double PCROS[])
{
	int i, inf;
	double X1, Y1, X2, Y2, C3, C4;
	//CC---1:CC,xh---边坡限高

	inf = 100;
	for (i = N1; i < NP - 1; i++)
	{
		X1 = PCROS[i * 2];
		Y1 = PCROS[i * 2 + 1];
		X2 = PCROS[(i + 1) * 2];
		Y2 = PCROS[(i + 1) * 2 + 1];
		C3 = C1 + (xh*1.1)*CC;
		C4 = C2 + NA * (xh*1.1);
		*XZ = 0.0;
		*YZ = 0.0;
		inf = INTERS(XZ, YZ, X1, Y1, X2, Y2, C1, C2, C3, C4);

		if (inf == 0)
			return inf;
	}
	return inf;
}
void  HdmDes::cal_polygon_area(int npt, double ptlist[], int EarPtSum, double EarPtList[], double &FillArea, double &CutArea)
{
	int i, j, desptnum1, desptnum2, bnum, jdinf, inf;
	double EarthPt1[2], EarthPt2[2], DesPt1[2], DesPt2[2], earpt1[2], earpt2[2], despt1[2], despt2[2], IntPt[2];
	double Area, dh1, dh2, EarthArea, DesArea, fillarea, cutarea;

	FillArea = 0.0;
	CutArea = 0.0;
	for (i = 0; i < npt - 1; i++)
	{
		fillarea = 0.0;
		cutarea = 0.0;
		DesPt1[0] = ptlist[i * 2], DesPt1[1] = ptlist[i * 2 + 1];
		inf = Gety(DesPt1[0], EarPtSum, EarPtList, dh1, desptnum1);
		//	TRACE("x=%lf dh1=%lf desptnum1=%d inf=%d\n",DesPt1[0],dh1,desptnum1,inf);
		if (inf == 0)  
			return;
		DesPt2[0] = ptlist[(i + 1) * 2], DesPt2[1] = ptlist[(i + 1) * 2 + 1];
		inf = Gety(DesPt2[0], EarPtSum, EarPtList, dh2, desptnum2);
		desptnum2++;
		if (desptnum2 > EarPtSum - 1)
			desptnum2 = EarPtSum - 1;

		//	TRACE("x=%lf dh2=%lf desptnum2=%d inf=%d\n",DesPt2[0],dh2,desptnum2,inf);
		if (inf == 0)  
			return;
		if (fabs(DesPt2[0] - DesPt1[0]) < 0.00001)
			continue;

		for (j = desptnum1; j < desptnum2 && j < EarPtSum; j++)
		{
			EarthArea = 0.0;
			DesArea = 0.0;

			EarthPt1[0] = EarPtList[j * 2];
			EarthPt1[1] = EarPtList[j * 2 + 1];
			if (EarthPt1[0] < DesPt1[0])//修正
			{
				EarthPt1[0] = DesPt1[0];
				EarthPt1[1] = dh1;
			}
			bnum = j + 1;
			if (bnum >= EarPtSum)
				bnum = EarPtSum - 1;
			EarthPt2[0] = EarPtList[bnum * 2];
			EarthPt2[1] = EarPtList[bnum * 2 + 1];

			if (EarthPt2[0] > DesPt2[0])//修正
			{
				EarthPt2[0] = DesPt2[0];
				EarthPt2[1] = dh2;
			}
			//检查在EarthPt1与EarthPt2之间是否存在交点        
			jdinf = INTERS(&IntPt[0], &IntPt[1], DesPt1[0], DesPt1[1], DesPt2[0], DesPt2[1], EarthPt1[0], EarthPt1[1], EarthPt2[0], EarthPt2[1]);
			if (jdinf == 0)//有交点
			{
				despt1[0] = EarthPt1[0];
				despt1[1] = DesPt1[1] + (despt1[0] - DesPt1[0])*(DesPt2[1] - DesPt1[1]) / (DesPt2[0] - DesPt1[0]);
				earpt1[0] = EarthPt1[0], earpt1[1] = EarthPt1[1];
				despt2[0] = IntPt[0], despt2[1] = IntPt[1];
				earpt2[0] = IntPt[0], earpt2[1] = IntPt[1];
				EarthArea = 0.5*(earpt1[1] + 10000 + earpt2[1] + 10000)*(earpt2[0] - earpt1[0]);
				DesArea = 0.5*(despt1[1] + 10000 + despt2[1] + 10000)*(despt2[0] - despt1[0]);
				Area = DesArea - EarthArea;
				if (Area > 0.0)
					fillarea += Area;
				else
					cutarea += fabs(Area);

				earpt1[0] = earpt2[0], earpt1[1] = earpt2[1];
				earpt2[0] = EarthPt2[0], earpt2[1] = EarthPt2[1];

				despt1[0] = despt2[0], despt1[1] = despt2[1];
				despt2[0] = earpt2[0];
				despt2[1] = DesPt1[1] + (despt2[0] - DesPt1[0])*(DesPt2[1] - DesPt1[1]) / (DesPt2[0] - DesPt1[0]);

				EarthArea = 0.5*(earpt1[1] + 10000 + earpt2[1] + 10000)*fabs(earpt2[0] - earpt1[0]);
				DesArea = 0.5*(despt1[1] + 10000 + despt2[1] + 10000)*fabs(despt2[0] - despt1[0]);
				Area = DesArea - EarthArea;
				//	TRACE("EarthArea=%lf DesArea=%lf AREA=%lf\n",EarthArea,DesArea,Area);
				if (Area > 0.0)
					fillarea += Area;
				else
					cutarea += fabs(Area);
			}
			else//无交点
			{
				despt1[0] = EarthPt1[0];
				despt1[1] = DesPt1[1] + (despt1[0] - DesPt1[0])*(DesPt2[1] - DesPt1[1]) / (DesPt2[0] - DesPt1[0]);
				despt2[0] = EarthPt2[0];
				despt2[1] = DesPt1[1] + (despt2[0] - DesPt1[0])*(DesPt2[1] - DesPt1[1]) / (DesPt2[0] - DesPt1[0]);

				EarthArea = 0.5*(EarthPt1[1] + 10000 + EarthPt2[1] + 10000)*fabs(EarthPt2[0] - EarthPt1[0]);
				DesArea = 0.5*(despt1[1] + 10000 + despt2[1] + 10000)*fabs(despt2[0] - despt1[0]);
				//				TRACE("##despt1.x=%lf despt1.y=%lf despt2.x=%lf despt2.y=%lf\n",despt1[0],despt1[1],despt2[0],despt2[1]);				
				Area = DesArea - EarthArea;
				//			TRACE("EarthArea=%lf DesArea=%lf AREA=%lf\n",EarthArea,DesArea,Area);
				if (Area > 0.0001)
					fillarea += Area;
				else if (Area < -0.0001)
					cutarea += fabs(Area);
			}

		}//针对一段水沟线*/

		FillArea += fillarea;
		CutArea += cutarea;
		//			 TRACE("i=%d**************farea=%lf FillArea=%lf CutArea=%lf \n",i,fillarea,FillArea,CutArea);
	}
}

int HdmDes::CALPTJD(int N1, int NP, double sptx, double spty, double eptx, double epty, double *XZ, double *YZ, double PCROS[])
{
	int i, inf;
	double X1, Y1, X2, Y2;
	//CC---1:CC,xh---边坡限高
	inf = 100;
	for (i = N1; i < NP - 1; i++)
	{
		X1 = PCROS[i * 2];
		Y1 = PCROS[i * 2 + 1];
		X2 = PCROS[(i + 1) * 2];
		Y2 = PCROS[(i + 1) * 2 + 1];
		*XZ = 0.0;
		*YZ = 0.0;
		inf = INTERS(XZ, YZ, X1, Y1, X2, Y2, sptx, spty, eptx, epty);
		if (inf == 0)
			return inf;
	}
	return inf;
}
//double  HdmDes::CalGLTArea(int TorW,int DesPtSum,double DesPtList[],int EarPtSum,double EarPtList[],double lmhd[3],double glthd)
//{
////1.计算基床表层线，形成新的设计点
//	int UPnpt,DOWNnpt;
//	double UpLJFillArea,UpLJCutArea,DownLJFillArea,DownLJCutArea;
//    double UPdespoints[100],Downdespoints[100];
//	int inf;
//	double FillBetterSoilArea;
//
////1.计算基床表层线
//    inf = CalNewDesline(TorW,DesPtSum,DesPtList,lmhd,UPnpt,UPdespoints);//机床表层线,厚度lmhd[0]
//	if(inf==0)//找不到交点
//	{
//		return 0.0;
//	}
////2.计算面积
//    cal_polygon_area(UPnpt,UPdespoints,EarPtSum,EarPtList,UpLJFillArea,UpLJCutArea);		
////3.计算改良土表层线，形成新的设计点    
//    inf = CalNewDesline(TorW,DesPtSum,DesPtList,lmhd+glthd,DOWNnpt,Downdespoints);//改良土层,厚度glthd
//	if(inf==0)//找不到交点
//		DownLJFillArea = 0.0;
//	else//4.找到改良土层线与边坡线交点，计算改良土面积
//	   cal_polygon_area(DOWNnpt,Downdespoints,EarPtSum,EarPtList,DownLJFillArea,DownLJCutArea);		
////	ads_printf(L"%lf %lf\n",DownLJFillArea,UpLJFillArea);
////5.填方面积差
//    FillBetterSoilArea = UpLJFillArea - DownLJFillArea;
//	if(FillBetterSoilArea<0.0)
//		FillBetterSoilArea = 0.0;
//	return FillBetterSoilArea;
//}
//

//0 无交点，2 所求交点无效，换一级边坡重新求，1找到交点
int HdmDes::CalGouOutPt(double offsetX, AcGePoint3d PrePJD, AcGePoint3d PJD, double EarthPt[], int EarPtSum, AcGePoint3d &pt)
{
	AcGePoint3dArray DmxptArray;
	AcGePoint3d Dmxpt;
	int i;
	for (i = 0; i < EarPtSum; i++)
	{
		Dmxpt.set(EarthPt[i * 2], EarthPt[i * 2 + 1], 0);
		DmxptArray.append(Dmxpt);
	}

	//平行移动线路
	AcGePoint3d spt, ept;
	spt.x = PrePJD.x + offsetX;
	spt.y = PrePJD.y;
	ept.x = PJD.x + offsetX;
	ept.y = PJD.y;
	AcDbLine line(spt, ept);

	//地面线
	AcDb2dPolyline DmxLine(AcDb::k2dSimplePoly, DmxptArray);
	AcGePoint3dArray ResPts;
	//	ResPts.setLogicalLength(0);
	if (line.intersectWith(&DmxLine, AcDb::kExtendThis, ResPts) == Acad::eOk)//平移线与地面线找到交点
	{
		AcGePoint3d JDpt;
		JDpt.x = 1000.0;
		if (ResPts.length() > 1)//多个交点
		{
			//找一个X最小的点
			for (i = 0; i < ResPts.length(); i++)
			{
				//坡脚点外侧
				if (ResPts.at(i).x > PJD.x && JDpt.x > ResPts.at(i).x)
					JDpt = ResPts.at(i);
			}
			if (JDpt.x > 999.0)
				return 0;//未找到交点
		}
		else if (ResPts.length() > 0)//一个点
		{
			JDpt = ResPts[0];
		}

		if (JDpt.x > 999.0)
			return 0;//未找到交点		if(JDpt.x>999.0)

		//判别找出的交点是否有效
		if (JDpt.y >= spt.y)//所求交点无效，换一级边坡重新求
			return 2;//重新求
		else //找到交点
			pt = JDpt;
	}
	else
		return 0;
	return 1;

}
//从外及内推算水沟各点
int HdmDes::CalGouAllPt(int &GouPtNum, double GouPt[], double HPDI, double GS, double GDK, double SP1, double SP2, AcGePoint3d pt, AcGePoint3d PrePJD, AcGePoint3d PJD)//计算水沟各点
{
	GouPtNum = 5;//有5个点
	GouPt[4 * 2] = pt.x, GouPt[4 * 2 + 1] = pt.y;
	GouPt[3 * 2] = pt.x - GS * SP2, GouPt[3 * 2 + 1] = pt.y - GS;
	GouPt[2 * 2] = GouPt[3 * 2] - GDK, GouPt[2 * 2 + 1] = GouPt[3 * 2 + 1];
	GouPt[1 * 2] = GouPt[2 * 2] - GS * SP1, GouPt[1 * 2 + 1] = GouPt[4 * 2 + 1];
	AcGePoint3d spt(GouPt[1 * 2], GouPt[1 * 2 + 1], 0.0);

	AcGePoint3d ept;
	ept.x = spt.x - 100.0;
	ept.y = spt.y + 100.0*HPDI;
	ept.z = 0.0;
	double jdx, jdy;

	INTERS(&jdx, &jdy, spt.x, spt.y, ept.x, ept.y, PrePJD.x, PrePJD.y, PJD.x, PJD.y);
	if (jdy < PrePJD.y)//交点标高必须小于边坡线起点标高
	{
		if (jdy > PJD.y)//在坡脚点上方
			GouPt[0] = jdx, GouPt[1] = jdy;
		else//将坡脚点补充到水沟点
		{
			GouPt[0] = PJD.x, GouPt[1] = PJD.y;
			GouPtNum = 6;//有6个点
			for (int i = 5; i >= 2; i--)
			{
				GouPt[i * 2] = GouPt[(i - 1) * 2];
				GouPt[i * 2 + 1] = GouPt[(i - 1) * 2 + 1];
			}
			GouPt[2] = jdx, GouPt[3] = jdy;
		}

	}
	else
		GouPt[0] = PrePJD.x, GouPt[1] = PrePJD.y;

	return 0;
}

int HdmDes::DesTGou(double TG_BJ, double TG_GW, double TG_GS, double TG_SP1, double TG_SP2, double TG_GDR,
	double DesPtList[], int DesPtSum, double EarPtList[], int EarPtSum,
	int &JSGouPtNum, double JSgou[])
{
	int ptnum, inf;
	//水沟起点
	JSGouPtNum = 0;
	JSgou[0] = DesPtList[(DesPtSum - 1) * 2] + TG_BJ;

	inf = Gety(JSgou[0], EarPtSum, EarPtList, JSgou[1], ptnum);
	if (inf == 0)
	{
		//	   ads_printf(L"1:无法设计截水沟!\n");
		JSGouPtNum = 0;
		return -1;
	}
	JSGouPtNum++;
	JSgou[JSGouPtNum * 2] = JSgou[0] + TG_GS * TG_SP1;
	JSgou[JSGouPtNum * 2 + 1] = JSgou[1] - TG_GS;

	JSGouPtNum++;
	JSgou[JSGouPtNum * 2] = JSgou[(JSGouPtNum - 1) * 2] + TG_GW;
	JSgou[JSGouPtNum * 2 + 1] = JSgou[(JSGouPtNum - 1) * 2 + 1];

	double dmxh;
	inf = Gety(JSgou[JSGouPtNum * 2], EarPtSum, EarPtList, dmxh, ptnum);
	//地面线高小于沟底标高
	if (inf == 0 || dmxh < JSgou[JSGouPtNum * 2 + 1])
	{
		//	   ads_printf(L"2: 无法设计截水沟! %lf %lf \n",dmxh,JSgou[JSGouPtNum*2+1]);
		JSGouPtNum = 0;
		return -1;
	}
	//做路堑
	double XZ, YZ;
	inf = CALXY(ptnum, EarPtSum, 1, TG_SP2, JSgou[JSGouPtNum * 2], JSgou[JSGouPtNum * 2 + 1], 100, &XZ, &YZ, EarPtList);

	if (inf == 0 && YZ - JSgou[JSGouPtNum * 2 + 1] > 0.5*TG_GS)//找到交点
	{
		JSGouPtNum++;
		JSgou[JSGouPtNum * 2] = XZ;//最外侧点
		JSgou[JSGouPtNum * 2 + 1] = YZ;
		JSGouPtNum++;
	}

	//////////////////////////////////////////////////////////////////////////
	if (TG_GDR > 0.001)//如果有沟底半径，需内插水沟点
	{
		double spt[2], ept[2];
		spt[0] = JSgou[2];
		spt[1] = JSgou[3];
		ept[0] = JSgou[4];
		ept[1] = JSgou[5];

		double pt[20];
		GetArcPt(spt, ept, TG_GDR, 10, pt);
		//2修正设计点
		int ptsum = 10, npt, i;
		double despt[200];
		npt = 0;
		for (i = 0; i <= 1; i++)
		{
			despt[npt * 2] = JSgou[i * 2];
			despt[npt * 2 + 1] = JSgou[i * 2 + 1];
			npt++;
		}
		for (i = 0; i < 10; i++)
		{
			despt[npt * 2] = pt[i * 2];
			despt[npt * 2 + 1] = pt[i * 2 + 1];

			npt++;
		}
		for (i = 2; i < DesPtSum; i++)
		{
			despt[npt * 2] = JSgou[i * 2];
			despt[npt * 2 + 1] = JSgou[i * 2 + 1];
			npt++;
		}

		JSGouPtNum = npt;
		for (i = 0; i < JSGouPtNum; i++)
		{
			JSgou[i * 2] = despt[i * 2];
			JSgou[i * 2 + 1] = despt[i * 2 + 1];
		}
	}
	//////////////////////////////////////////////////////////////////////////
	return 1;

}

//--------------------------------------------------------------------------------------
//将坐标轴平移offsetX（左负右正）后，形成新的地面线坐标
void HdmDes::CalNewZB(double offsetX, double earh, double Learpt[], int lnpt, double Rearpt[], int rnpt,
	double &NewYd, double NewLearpt[], int &newLnpt, double NewRearpt[], int &newRnpt)
{
	if (fabs(offsetX) < 0.001)
	{
		NewYd = earh;
		newLnpt = lnpt;
		newRnpt = rnpt;
		int Index = 0;
		for (Index = 0; Index < lnpt * 2; Index++)
		{
			NewLearpt[Index] = Learpt[Index];
		}
		for (Index = 0; Index < rnpt * 2; Index++)
		{
			NewRearpt[Index] = Rearpt[Index];
		}
		return;
	}
	int ptnum;
	//NewYd-新的中心地面高
	if (offsetX < 0.0)//左移
		Gety(fabs(offsetX), lnpt, Learpt, NewYd, ptnum);
	else
		Gety(offsetX, rnpt, Rearpt, NewYd, ptnum);

	double earpt[800];
	int npt = 0;
	int i;
	for (i = lnpt - 1; i >= 0; i--)
	{
		earpt[npt * 2] = -1 * fabs(Learpt[i * 2]) - offsetX;
		earpt[npt * 2 + 1] = Learpt[i * 2 + 1] - NewYd;
		npt++;
	}

	for (i = 0; i < rnpt; i++)
	{
		earpt[npt * 2] = Rearpt[i * 2] - offsetX;
		earpt[npt * 2 + 1] = Rearpt[i * 2 + 1] - NewYd;
		npt++;
	}

	newLnpt = 1;
	newRnpt = 1;
	NewLearpt[0 * 2] = 0;
	NewLearpt[0 * 2 + 1] = 0;
	NewRearpt[0 * 2] = 0;
	NewRearpt[0 * 2 + 1] = 0;
	for (i = 0; i < npt; i++)
	{
		if (earpt[i * 2] < 0.0)
		{
			//NewLearpt[newLnpt*2] = fabs(earpt[i*2]);
			//NewLearpt[newLnpt*2+1] = earpt[i*2+1];
			newLnpt++;
		}
		else
		{
			NewRearpt[newRnpt * 2] = fabs(earpt[i * 2]);
			NewRearpt[newRnpt * 2 + 1] = earpt[i * 2 + 1];
			newRnpt++;
		}
	}
	int j = 1;
	for (i = newLnpt - 2; i >= 0; i--)
	{
		NewLearpt[j * 2] = fabs(earpt[i * 2]);//左为正
		NewLearpt[j * 2 + 1] = earpt[i * 2 + 1];
		j++;
	}
	NewYd = NewYd + earh;
}

double HdmDes::FindWichDQ(double cml, JD_CENTER *pm, int NDQ, dqdata DQ[])
{
	int i;
	double sml, eml, zj, x, y;
	int inf;

	zj = 1000.0;
	inf = 0;
	for (i = 0; i < NDQ; i++)
	{
		sml = pm->TYLC(DQ[i].sdml);//分段终里程
		eml = pm->TYLC(DQ[i].edml);
		if (cml <= eml && cml >= sml)
		{
			inf = 1;
			break;
		}
	}

	if (inf == 1)
	{
		x = cml - sml;
		y = eml - cml;
		if (x + y > 0)
			zj = (DQ[i].szj*y + DQ[i].ezj*x) / (x + y);//土埂宽
		else
			zj = DQ[i].szj;
	}

	return zj;
}
//-----------------------------------------------------------------------------
int HdmDes::FindWichHD(double cml, JD_CENTER *pm, int NLMHD, LMHdata lmhd[], double HD[3])
{
	int i, inf;
	double ml;

	inf = 0;
	for (i = 0; i < NLMHD; i++)
	{
		ml = pm->TYLC(lmhd[i].dml);
		if (cml <= ml + 0.001)
		{
			HD[0] = lmhd[i].cxdh;
			HD[1] = lmhd[i].yljh;
			HD[2] = lmhd[i].tljh;
			inf = 1;
			return inf;
		}
	}


	if (inf == 0)
	{
		//	_stprintf(mes,L"无法检查到%lf相应路面厚度数据,请检查hdmsj文件!",cmltockml(cml));;
		//	AfxMessageBox(mes);
		HD[0] = 0.0;
		HD[1] = 0.0;
		HD[2] = 0.0;
	}
	return inf;
}


void HdmDes::InitHdmData(CRSDAT &hdm)//设置初值
{
	int kk;

	for (kk = 0; kk < 14; kk++)
	{
		hdm.Lgou[kk] = 0.0;
		hdm.Rgou[kk] = 0.0;
		hdm.Y_Lgou[kk] = 0.0;
		hdm.Y_Rgou[kk] = 0.0;
	}

	for (kk = 0; kk < 20; kk++)
	{
		hdm.LJSgou[kk] = 0.0;
		hdm.RJSgou[kk] = 0.0;
		hdm.Y_LJSgou[kk] = 0.0;
		hdm.Y_RJSgou[kk] = 0.0;
	}
	hdm.BriYZDK = hdm.BriZZDK = 1.0;
	hdm.TunYZDK = hdm.TunZZDK = 1.0;

	hdm.LGouProperty = hdm.RGouProperty = -1;//初始化
	hdm.Y_LGouProperty = hdm.Y_RGouProperty = -1;
	hdm.LGouPtNum = hdm.RGouPtNum = hdm.Y_RGouPtNum = 0;
	hdm.LJSGouPtNum = hdm.RJSGouPtNum = hdm.Y_LJSGouPtNum = hdm.Y_RJSGouPtNum = 0;
	hdm.ZCG_GDR = hdm.YCG_GDR = 0.0;

	if (hdm.RPTL.length() > 0)
		hdm.RPTL.removeSubArray(0, hdm.RPTL.length() - 1);//清空数组
	if (hdm.RPTR.length() > 0)
		hdm.RPTR.removeSubArray(0, hdm.RPTR.length() - 1);//清空数组
	if (hdm.Y_RPTL.length() > 0)
		hdm.Y_RPTL.removeSubArray(0, hdm.Y_RPTL.length() - 1);//清空数组
	if (hdm.Y_RPTR.length() > 0)
		hdm.Y_RPTR.removeSubArray(0, hdm.Y_RPTR.length() - 1);//清空数组

	hdm.QBTArea = hdm.WYNArea = 0.0;
	hdm.ZHTHD = hdm.YHTHD = 0.0;
	hdm.ZHTXZ = hdm.YHTXZ = 0;
	hdm.Z_LQBTArea = hdm.MidQBTArea = hdm.Y_RQBTArea = 0.0;
	hdm.Z_LFillBetterSoilArea = hdm.MidFillGLTArea = hdm.Y_RFillBetterSoilArea = 0.0;
	hdm.Z_LHJarea = hdm.MidHJarea = hdm.Y_RHJarea = 0.0;
	hdm.Z_LSGJQarea = hdm.MidGouJQarea = hdm.Y_RSGJQarea = 0.0;
	hdm.Z_LDQlength = hdm.MidDQlength = hdm.Y_RDQlength = 0.0;//挡墙坡长
	hdm.Z_LGrasslength = hdm.MidGrasslength = hdm.Y_RGrasslength = 0.0;//铺草坡长
	hdm.Z_LGouTarea = hdm.Y_RGouTarea = 0.0;
	hdm.Z_LGouWarea = hdm.Y_RGouWarea = 0.0;
	hdm.Z_LFillArea = hdm.MidFillArea = hdm.Y_RFillArea = 0.0;
	hdm.Z_LCutArea = hdm.MidCutArea = hdm.Y_RCutArea = 0.0;

	hdm.Xo = 0.0;
	hdm.Yo = 0.0;
	hdm.DX = 0.0;
	hdm.Ymin = 0.0;
	hdm.Ymax = 0.0;
	hdm.ZZJ = hdm.YZJ = 1000.0;
	hdm.m_IfXJGou = false;
	hdm.DorS = 1;//单线
	hdm.offsetX = 0.0;//单线
	hdm.YoffsetX = hdm.xjj;//单线
	hdm.Lnpt = hdm.Rnpt = hdm.Y_Lnpt = hdm.Y_Rnpt = 0;
	hdm.ZHc = hdm.YHc = hdm.Y_ZHc = hdm.Y_YHc = 0.0;;//暂时标左侧	   
	hdm.FLDcml = 0.0;
	hdm.FLDname = "未命名";
	hdm.LIfSetGouH = hdm.RIfSetGouH = 0;
	hdm.LGouH = hdm.RGouH = 0.0;


	hdm.cml = 0.0;
	hdm.dml = 0.0;
	hdm.DuanLuoInf = 1;
	hdm.DorS = 1;
	hdm.Ldeltah = hdm.Rdeltah = hdm.newLYd = hdm.newRYd = hdm.xjj = 0.0;
	hdm.Y_Ldeltah = hdm.Y_Rdeltah = 0.0;
	hdm.FLDcml = 0.0;
	hdm.FLDname = "未命名";

	//1.写左线左侧
	hdm.ZDMXZ = 0;
	//写路面点
	for (kk = 0; kk < 3; kk++)
	{
		hdm.zlmhd[kk] = 0.0;
		hdm.ylmhd[kk] = 0.0;
		hdm.Y_zlmhd[kk] = 0.0;
		hdm.Y_ylmhd[kk] = 0.0;
	}

	//写路面点
	for (kk = 0; kk < 5; kk++)
		hdm.RHFL[2 * kk] = hdm.RHFL[2 * kk + 1] = 0.0;

	//左设计点
	hdm.Zt = hdm.ZHc = 0.0;
	hdm.Lnpt = 0;//换行

	//左水沟点
	hdm.LIfSetGouH = 0;
	hdm.LGouH = 0.0;
	hdm.LGouProperty = -1;
	hdm.LGouPtNum = hdm.LJSGouPtNum = 0;
	//左截水沟


	//2.写左线右侧
	//写路面点
	hdm.YDMXZ = 0;
	for (kk = 0; kk < 5; kk++)
		hdm.RHFR[2 * kk] = hdm.RHFR[2 * kk + 1] = 0.0;
	//右设计点
	hdm.Yt = 0;
	hdm.YHc = 0.0, hdm.Rnpt = 0;
	//右水沟点
	hdm.RIfSetGouH = 0;
	hdm.RGouH = 0.0;
	hdm.RGouProperty = -1;
	hdm.RGouPtNum = 0;
	hdm.RJSGouPtNum = 0;
	//右截水沟
	hdm.Y_ZDMXZ = 0;

	//3.写右线左侧
	//写路面点
	for (kk = 0; kk < 5; kk++)
		hdm.Y_RHFL[2 * kk] = hdm.Y_RHFL[2 * kk + 1] = 0.0;

	//右左设计点
	hdm.Y_Zt = 0;
	hdm.Y_ZHc = 0.0;
	hdm.Y_Lnpt = 0;
	//右左水沟点
	hdm.Y_LGouProperty = -1;
	hdm.Y_LGouPtNum = 0;
	hdm.Y_LJSGouPtNum = 0;
	//右左截水沟
	//3.写右线右侧
	hdm.Y_YDMXZ = 0;
	//写路面点
	for (kk = 0; kk < 5; kk++)
		hdm.Y_RHFR[2 * kk] = hdm.Y_RHFR[2 * kk + 1] = 0.0;

	//写地面线
	//	fwprintf(fpw,L"\n%d ",hdm.NumL);
	//	for(j=0;j<hdm.NumL;j++)
	//		fwprintf(fpw,L"%0.3lf %0.3lf ",hdm.Learpt[j*2],hdm.Learpt[j*2+1]);
	//	fwprintf(fpw,L"\n%d ",hdm.NumR);
	//	for(j=0;j<hdm.NumR;j++)
	//		fwprintf(fpw,L"%0.3lf %0.3lf ",hdm.Rearpt[j*2],hdm.Rearpt[j*2+1]);
	//右右设计点
	hdm.Y_Yt = 0;
	hdm.Y_YHc = 0.0;
	hdm.Y_Rnpt = 0;
	//右右水沟点
	hdm.RIfSetGouH = 0;
	hdm.RGouH = 0.0;
	hdm.Y_RGouProperty = 0;
	hdm.Y_RGouPtNum = hdm.Y_RJSGouPtNum = 0;

	hdm.IfLink = false;//初始不关联		
	hdm.ZPJPT[0] = hdm.ZPJPT[1] = hdm.YPJPT[0] = hdm.YPJPT[1] = -1.0;
	hdm.IfHasDes = false;

	hdm.IfHasZlink = 0;//初始不关联		
	hdm.IfHasYlink = 0;//初始不关联		
	hdm.zlink = hdm.ylink = NULL;
	hdm.IfFldSEHdm = false;
	hdm.IsInsertHdm = 0;
	hdm.IfSetDQ = 0;
	hdm.OffsetByXLZX = 0.0;

}

void HdmDes::InitHdmData(int i, int j)//设置初值
{
	int kk;

	for (kk = 0; kk < 14; kk++)
	{
		road[i].hdmdes[j].Lgou[kk] = 0.0;
		road[i].hdmdes[j].Rgou[kk] = 0.0;
		road[i].hdmdes[j].Y_Lgou[kk] = 0.0;
		road[i].hdmdes[j].Y_Rgou[kk] = 0.0;
	}

	for (kk = 0; kk < 20; kk++)
	{
		road[i].hdmdes[j].LJSgou[kk] = 0.0;
		road[i].hdmdes[j].RJSgou[kk] = 0.0;
		road[i].hdmdes[j].Y_LJSgou[kk] = 0.0;
		road[i].hdmdes[j].Y_RJSgou[kk] = 0.0;
	}
	road[i].hdmdes[j].BriYZDK = road[i].hdmdes[j].BriZZDK = 1.0;
	road[i].hdmdes[j].TunYZDK = road[i].hdmdes[j].TunZZDK = 1.0;

	road[i].hdmdes[j].ZCG_GDR = road[i].hdmdes[j].YCG_GDR = 0.0;
	road[i].hdmdes[j].LGouProperty = road[i].hdmdes[j].RGouProperty = -1;//初始化
	road[i].hdmdes[j].Y_LGouProperty = road[i].hdmdes[j].Y_RGouProperty = -1;
	road[i].hdmdes[j].LGouPtNum = road[i].hdmdes[j].RGouPtNum = road[i].hdmdes[j].Y_RGouPtNum = 0;
	road[i].hdmdes[j].LJSGouPtNum = road[i].hdmdes[j].RJSGouPtNum = road[i].hdmdes[j].Y_LJSGouPtNum = road[i].hdmdes[j].Y_RJSGouPtNum = 0;

	if (road[i].hdmdes[j].RPTL.length() > 0)
		road[i].hdmdes[j].RPTL.removeSubArray(0, road[i].hdmdes[j].RPTL.length() - 1);//清空数组
	if (road[i].hdmdes[j].RPTR.length() > 0)
		road[i].hdmdes[j].RPTR.removeSubArray(0, road[i].hdmdes[j].RPTR.length() - 1);//清空数组
	if (road[i].hdmdes[j].Y_RPTL.length() > 0)
		road[i].hdmdes[j].Y_RPTL.removeSubArray(0, road[i].hdmdes[j].Y_RPTL.length() - 1);//清空数组
	if (road[i].hdmdes[j].Y_RPTR.length() > 0)
		road[i].hdmdes[j].Y_RPTR.removeSubArray(0, road[i].hdmdes[j].Y_RPTR.length() - 1);//清空数组

	road[i].hdmdes[j].QBTArea = road[i].hdmdes[j].WYNArea = 0.0;
	road[i].hdmdes[j].ZHTHD = road[i].hdmdes[j].YHTHD = 0.0;
	road[i].hdmdes[j].ZHTXZ = road[i].hdmdes[j].YHTXZ = 0;

	road[i].hdmdes[j].Z_LQBTArea = road[i].hdmdes[j].MidQBTArea = road[i].hdmdes[j].Y_RQBTArea = 0.0;
	road[i].hdmdes[j].Z_LFillBetterSoilArea = road[i].hdmdes[j].MidFillGLTArea = road[i].hdmdes[j].Y_RFillBetterSoilArea = 0.0;
	road[i].hdmdes[j].Z_LHJarea = road[i].hdmdes[j].MidHJarea = road[i].hdmdes[j].Y_RHJarea = 0.0;
	road[i].hdmdes[j].Z_LSGJQarea = road[i].hdmdes[j].MidGouJQarea = road[i].hdmdes[j].Y_RSGJQarea = 0.0;
	road[i].hdmdes[j].Z_LDQlength = road[i].hdmdes[j].MidDQlength = road[i].hdmdes[j].Y_RDQlength = 0.0;//挡墙坡长
	road[i].hdmdes[j].Z_LGrasslength = road[i].hdmdes[j].MidGrasslength = road[i].hdmdes[j].Y_RGrasslength = 0.0;//铺草坡长
	road[i].hdmdes[j].Z_LGouTarea = road[i].hdmdes[j].Y_RGouTarea = 0.0;
	road[i].hdmdes[j].Z_LGouWarea = road[i].hdmdes[j].Y_RGouWarea = 0.0;
	road[i].hdmdes[j].Z_LFillArea = road[i].hdmdes[j].MidFillArea = road[i].hdmdes[j].Y_RFillArea = 0.0;
	road[i].hdmdes[j].Z_LCutArea = road[i].hdmdes[j].MidCutArea = road[i].hdmdes[j].Y_RCutArea = 0.0;

	road[i].hdmdes[j].Xo = 0.0;
	road[i].hdmdes[j].Yo = 0.0;
	road[i].hdmdes[j].DX = 0.0;
	road[i].hdmdes[j].Ymin = 0.0;
	road[i].hdmdes[j].Ymax = 0.0;
	road[i].hdmdes[j].ZZJ = road[i].hdmdes[j].YZJ = 1000.0;
	road[i].hdmdes[j].m_IfXJGou = false;
	road[i].hdmdes[j].DorS = 1;//单线
	road[i].hdmdes[j].offsetX = 0.0;//单线
	road[i].hdmdes[j].YoffsetX = road[i].hdmdes[j].xjj;//单线
	road[i].hdmdes[j].Lnpt = road[i].hdmdes[j].Rnpt = road[i].hdmdes[j].Y_Lnpt = road[i].hdmdes[j].Y_Rnpt = 0;
	road[i].hdmdes[j].ZHc = road[i].hdmdes[j].YHc = road[i].hdmdes[j].Y_ZHc = road[i].hdmdes[j].Y_YHc = 0.0;;//暂时标左侧	   
	road[i].hdmdes[j].FLDcml = 0.0;
	road[i].hdmdes[j].FLDname = "未命名";
	road[i].hdmdes[j].LIfSetGouH = road[i].hdmdes[j].RIfSetGouH = 0;
	road[i].hdmdes[j].LGouH = road[i].hdmdes[j].RGouH = 0.0;


	road[i].hdmdes[j].cml = 0.0;
	road[i].hdmdes[j].dml = 0.0;
	road[i].hdmdes[j].DuanLuoInf = 1;
	road[i].hdmdes[j].DorS = 1;
	road[i].hdmdes[j].ZDorS = 1.0;//1.0单路面,2.0双路面
	road[i].hdmdes[j].YDorS = 1.0;
	road[i].hdmdes[j].Ldeltah = road[i].hdmdes[j].Rdeltah = road[i].hdmdes[j].newLYd = road[i].hdmdes[j].newRYd = road[i].hdmdes[j].xjj = 0.0;
	road[i].hdmdes[j].Y_Ldeltah = road[i].hdmdes[j].Y_Rdeltah = 0.0;
	road[i].hdmdes[j].FLDcml = 0.0;
	road[i].hdmdes[j].FLDname = "未命名";

	//1.写左线左侧
	road[i].hdmdes[j].ZDMXZ = 0;
	//写路面点
	for (kk = 0; kk < 3; kk++)
	{
		road[i].hdmdes[j].zlmhd[kk] = 0.0;
		road[i].hdmdes[j].ylmhd[kk] = 0.0;
		road[i].hdmdes[j].Y_zlmhd[kk] = 0.0;
		road[i].hdmdes[j].Y_ylmhd[kk] = 0.0;
	}

	//写路面点
	for (kk = 0; kk < 5; kk++)
		road[i].hdmdes[j].RHFL[2 * kk] = road[i].hdmdes[j].RHFL[2 * kk + 1] = 0.0;

	//左设计点
	road[i].hdmdes[j].Zt = road[i].hdmdes[j].ZHc = 0.0;
	road[i].hdmdes[j].Lnpt = 0;//换行

	//左水沟点
	road[i].hdmdes[j].LIfSetGouH = 0;
	road[i].hdmdes[j].LGouH = 0.0;
	road[i].hdmdes[j].LGouProperty = -1;
	road[i].hdmdes[j].LGouPtNum = road[i].hdmdes[j].LJSGouPtNum = 0;
	//左截水沟


	//2.写左线右侧
	//写路面点
	road[i].hdmdes[j].YDMXZ = 0;
	for (kk = 0; kk < 5; kk++)
		road[i].hdmdes[j].RHFR[2 * kk] = road[i].hdmdes[j].RHFR[2 * kk + 1] = 0.0;
	//右设计点
	road[i].hdmdes[j].Yt = 0;
	road[i].hdmdes[j].YHc = 0.0, road[i].hdmdes[j].Rnpt = 0;
	//右水沟点
	road[i].hdmdes[j].RIfSetGouH = 0;
	road[i].hdmdes[j].RGouH = 0.0;
	road[i].hdmdes[j].RGouProperty = -1;
	road[i].hdmdes[j].RGouPtNum = 0;
	road[i].hdmdes[j].RJSGouPtNum = 0;
	//右截水沟
	road[i].hdmdes[j].Y_ZDMXZ = 0;

	//3.写右线左侧
	//写路面点
	for (kk = 0; kk < 5; kk++)
		road[i].hdmdes[j].Y_RHFL[2 * kk] = road[i].hdmdes[j].Y_RHFL[2 * kk + 1] = 0.0;

	//右左设计点
	road[i].hdmdes[j].Y_Zt = 0;
	road[i].hdmdes[j].Y_ZHc = 0.0;
	road[i].hdmdes[j].Y_Lnpt = 0;
	//右左水沟点
	road[i].hdmdes[j].Y_LGouProperty = -1;
	road[i].hdmdes[j].Y_LGouPtNum = 0;
	road[i].hdmdes[j].Y_LJSGouPtNum = 0;
	//右左截水沟
	//3.写右线右侧
	road[i].hdmdes[j].Y_YDMXZ = 0;
	//写路面点
	for (kk = 0; kk < 5; kk++)
		road[i].hdmdes[j].Y_RHFR[2 * kk] = road[i].hdmdes[j].Y_RHFR[2 * kk + 1] = 0.0;

	//写地面线
	//	fwprintf(fpw,L"\n%d ",road[i].hdmdes[j].NumL);
	//	for(j=0;j<road[i].hdmdes[j].NumL;j++)
	//		fwprintf(fpw,L"%0.3lf %0.3lf ",road[i].hdmdes[j].Learpt[j*2],road[i].hdmdes[j].Learpt[j*2+1]);
	//	fwprintf(fpw,L"\n%d ",road[i].hdmdes[j].NumR);
	//	for(j=0;j<road[i].hdmdes[j].NumR;j++)
	//		fwprintf(fpw,L"%0.3lf %0.3lf ",road[i].hdmdes[j].Rearpt[j*2],road[i].hdmdes[j].Rearpt[j*2+1]);
	//右右设计点
	road[i].hdmdes[j].Y_Yt = 0;
	road[i].hdmdes[j].Y_YHc = 0.0;
	road[i].hdmdes[j].Y_Rnpt = 0;
	//右右水沟点
	road[i].hdmdes[j].RIfSetGouH = 0;
	road[i].hdmdes[j].RGouH = 0.0;
	road[i].hdmdes[j].Y_RGouProperty = 0;
	road[i].hdmdes[j].Y_RGouPtNum = road[i].hdmdes[j].Y_RJSGouPtNum = 0;

	road[i].hdmdes[j].IfLink = false;//初始不关联		
	road[i].hdmdes[j].ZPJPT[0] = road[i].hdmdes[j].ZPJPT[1] = road[i].hdmdes[j].YPJPT[0] = road[i].hdmdes[j].YPJPT[1] = -1.0;
	road[i].hdmdes[j].IfHasDes = false;

	road[i].hdmdes[j].IfHasZlink = 0;//初始不关联		
	road[i].hdmdes[j].IfHasYlink = 0;//初始不关联		
	road[i].hdmdes[j].zlink = road[i].hdmdes[j].ylink = NULL;
	road[i].hdmdes[j].IfFldSEHdm = false;
	road[i].hdmdes[j].IsInsertHdm = 0;
	road[i].hdmdes[j].IfSetDQ = 0;
	road[i].hdmdes[j].OffsetByXLZX = 0.0;
}

void HdmDes::WriteHdmResFile(int iroad, int jcross, FILE* fpw)
{
	int j;
	//
	//	if(!road[iroad].hdmdes[jcross].IfLink)
	//	{
	//		road[iroad].hdmdes[jcross].glcml = -1;
	//		road[iroad].hdmdes[jcross].glRoadName = "无";
	//	}
	//	
	fwprintf(fpw, L"\n%0.3lf %0.3lf %d %d %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %s\n",
		road[iroad].hdmdes[jcross].cml,
		road[iroad].hdmdes[jcross].dml,
		//	road[iroad].hdmdes[jcross].DuanLuoInf,
		//	road[iroad].hdmdes[jcross].DorS,
		//	road[iroad].hdmdes[jcross].IfHasZlink,
		road[iroad].hdmdes[jcross].IsInsertHdm,
		road[iroad].hdmdes[jcross].IfSetDQ,
		road[iroad].hdmdes[jcross].LZDK,
		road[iroad].hdmdes[jcross].RZDK,
		road[iroad].hdmdes[jcross].Ldeltah,
		road[iroad].hdmdes[jcross].Rdeltah,
		//	road[iroad].hdmdes[jcross].Y_Ldeltah,
		//	road[iroad].hdmdes[jcross].fwj,
		road[iroad].hdmdes[jcross].ZCG_GDR,//沟底半径
		road[iroad].hdmdes[jcross].YCG_GDR,//沟底半径
		//	road[iroad].hdmdes[jcross].Y_Rdeltah,
		road[iroad].hdmdes[jcross].newLYd,
		road[iroad].hdmdes[jcross].OffsetByXLZX,
		//		road[iroad].hdmdes[jcross].newRYd,
		road[iroad].hdmdes[jcross].xjj,
		road[iroad].hdmdes[jcross].ZHTHD,
		road[iroad].hdmdes[jcross].YHTHD,
		road[iroad].hdmdes[jcross].glcml,
		road[iroad].hdmdes[jcross].glRoadName
	);
	//1.写左线左侧
	fwprintf(fpw, L"%d\n", road[iroad].hdmdes[jcross].ZDMXZ);
	//写路面点
	for (j = 0; j < 3; j++)
		fwprintf(fpw, L"%0.3lf ", road[iroad].hdmdes[jcross].zlmhd[j]);
	fwprintf(fpw, L"\n");
	//写路面点
	for (j = 0; j < 5; j++)
		fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].RHFL[2 * j], road[iroad].hdmdes[jcross].RHFL[2 * j + 1]);
	fwprintf(fpw, L"\n");
	//左设计点
	fwprintf(fpw, L"%0.3lf %0.3lf %d ", road[iroad].hdmdes[jcross].Zt, road[iroad].hdmdes[jcross].ZHc, road[iroad].hdmdes[jcross].Lnpt);//换行

	for (j = 0; j < road[iroad].hdmdes[jcross].Lnpt; j++)
		fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].RPTL[j].x, road[iroad].hdmdes[jcross].RPTL[j].y);
	fwprintf(fpw, L"\n");
	//左水沟点
	fwprintf(fpw, L"%d %0.3lf %d %d %d ", road[iroad].hdmdes[jcross].LIfSetGouH, road[iroad].hdmdes[jcross].LGouH, road[iroad].hdmdes[jcross].LGouProperty, road[iroad].hdmdes[jcross].LGouPtNum, road[iroad].hdmdes[jcross].LJSGouPtNum);
	for (j = 0; j < road[iroad].hdmdes[jcross].LGouPtNum; j++)
	{
		fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].Lgou[j * 2], road[iroad].hdmdes[jcross].Lgou[j * 2 + 1]);
	}
	//左截水沟
	for (j = 0; j < road[iroad].hdmdes[jcross].LJSGouPtNum; j++)
	{
		fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].LJSgou[j * 2], road[iroad].hdmdes[jcross].LJSgou[j * 2 + 1]);
	}
	fwprintf(fpw, L"\n");
	//2.写左线右侧
	//写路面点
	fwprintf(fpw, L"%d\n", road[iroad].hdmdes[jcross].YDMXZ);
	for (j = 0; j < 3; j++)
		fwprintf(fpw, L"%0.3lf ", road[iroad].hdmdes[jcross].ylmhd[j]);

	for (j = 0; j < 5; j++)
		fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].RHFR[2 * j], road[iroad].hdmdes[jcross].RHFR[2 * j + 1]);
	fwprintf(fpw, L"\n");
	//右设计点
	fwprintf(fpw, L"%0.3lf %0.3lf %d ", road[iroad].hdmdes[jcross].Yt, road[iroad].hdmdes[jcross].YHc, road[iroad].hdmdes[jcross].Rnpt);
	for (j = 0; j < road[iroad].hdmdes[jcross].Rnpt; j++)
		fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].RPTR[j].x, road[iroad].hdmdes[jcross].RPTR[j].y);
	fwprintf(fpw, L"\n");
	//右水沟点
	fwprintf(fpw, L"%d %0.3lf %d %d %d ", road[iroad].hdmdes[jcross].RIfSetGouH, road[iroad].hdmdes[jcross].RGouH, road[iroad].hdmdes[jcross].RGouProperty, road[iroad].hdmdes[jcross].RGouPtNum, road[iroad].hdmdes[jcross].RJSGouPtNum);
	for (j = 0; j < road[iroad].hdmdes[jcross].RGouPtNum; j++)
		fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].Rgou[j * 2], road[iroad].hdmdes[jcross].Rgou[j * 2 + 1]);
	//右截水沟
	for (j = 0; j < road[iroad].hdmdes[jcross].RJSGouPtNum; j++)
	{
		fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].RJSgou[j * 2], road[iroad].hdmdes[jcross].RJSgou[j * 2 + 1]);
	}

	//左有关联道路 写左线关联道路
	if (road[iroad].hdmdes[jcross].IfHasZlink  && road[iroad].hdmdes[jcross].zlink)//左有关联道路
	{

		fwprintf(fpw, L"\n%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf  %0.3lf  %0.3lf %0.3lf %0.3lf %s\n",
			road[iroad].hdmdes[jcross].zlink->cml,
			road[iroad].hdmdes[jcross].zlink->dml,
			road[iroad].hdmdes[jcross].zlink->newLYd,
			road[iroad].hdmdes[jcross].zlink->newRYd,
			road[iroad].hdmdes[jcross].zlink->xjj,
			road[iroad].hdmdes[jcross].zlink->FillArea,
			road[iroad].hdmdes[jcross].zlink->CutArea,
			road[iroad].hdmdes[jcross].zlink->Ldeltah,
			road[iroad].hdmdes[jcross].zlink->Rdeltah,
			road[iroad].hdmdes[jcross].zlink->glRoadName
		);
		//1.写左线左侧
		fwprintf(fpw, L"%d\n", road[iroad].hdmdes[jcross].zlink->ZDMXZ);
		//写路面点
		for (j = 0; j < 3; j++)
			fwprintf(fpw, L"%0.3lf ", road[iroad].hdmdes[jcross].zlink->zlmhd[j]);
		fwprintf(fpw, L"\n");
		//写路面点
		for (j = 0; j < 5; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].zlink->RHFL[2 * j], road[iroad].hdmdes[jcross].zlink->RHFL[2 * j + 1]);
		fwprintf(fpw, L"\n");
		//左设计点
		fwprintf(fpw, L"%0.3lf %0.3lf %d ", road[iroad].hdmdes[jcross].zlink->Zt, road[iroad].hdmdes[jcross].zlink->ZHc, road[iroad].hdmdes[jcross].zlink->Lnpt);//换行
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->Lnpt; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].zlink->RPTL[j].x, road[iroad].hdmdes[jcross].zlink->RPTL[j].y);
		fwprintf(fpw, L"\n");
		//左水沟点
		fwprintf(fpw, L"%d %0.3lf %d %d %d ", road[iroad].hdmdes[jcross].zlink->LIfSetGouH, road[iroad].hdmdes[jcross].zlink->LGouH, road[iroad].hdmdes[jcross].zlink->LGouProperty, road[iroad].hdmdes[jcross].zlink->LGouPtNum, road[iroad].hdmdes[jcross].zlink->LJSGouPtNum);
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->LGouPtNum; j++)
		{
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].zlink->Lgou[j * 2], road[iroad].hdmdes[jcross].zlink->Lgou[j * 2 + 1]);
		}
		//左截水沟
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->LJSGouPtNum; j++)
		{
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].zlink->LJSgou[j * 2], road[iroad].hdmdes[jcross].zlink->LJSgou[j * 2 + 1]);
		}
		fwprintf(fpw, L"\n");
		//2.写左线右侧
		//写路面点
		fwprintf(fpw, L"%d\n", road[iroad].hdmdes[jcross].zlink->YDMXZ);
		for (j = 0; j < 3; j++)
			fwprintf(fpw, L"%0.3lf ", road[iroad].hdmdes[jcross].zlink->ylmhd[j]);

		for (j = 0; j < 5; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].zlink->RHFR[2 * j], road[iroad].hdmdes[jcross].zlink->RHFR[2 * j + 1]);
		fwprintf(fpw, L"\n");
		//右设计点
		fwprintf(fpw, L"%0.3lf %0.3lf %d ", road[iroad].hdmdes[jcross].zlink->Yt, road[iroad].hdmdes[jcross].zlink->YHc, road[iroad].hdmdes[jcross].zlink->Rnpt);
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->Rnpt; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].zlink->RPTR[j].x, road[iroad].hdmdes[jcross].zlink->RPTR[j].y);
		fwprintf(fpw, L"\n");
		//右水沟点
		fwprintf(fpw, L"%d %0.3lf %d %d %d ", road[iroad].hdmdes[jcross].zlink->RIfSetGouH, road[iroad].hdmdes[jcross].zlink->RGouH, road[iroad].hdmdes[jcross].zlink->RGouProperty, road[iroad].hdmdes[jcross].zlink->RGouPtNum, road[iroad].hdmdes[jcross].zlink->RJSGouPtNum);
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->RGouPtNum; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].zlink->Rgou[j * 2], road[iroad].hdmdes[jcross].zlink->Rgou[j * 2 + 1]);
		//右截水沟
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->RJSGouPtNum; j++)
		{
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].zlink->RJSgou[j * 2], road[iroad].hdmdes[jcross].zlink->RJSgou[j * 2 + 1]);
		}
	}

	//左有关联道路 写左线关联道路
	if (road[iroad].hdmdes[jcross].IfHasYlink  && road[iroad].hdmdes[jcross].ylink)//左有关联道路
	{
		fwprintf(fpw, L"\n%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf  %0.3lf  %0.3lf %0.3lf %0.3lf %s\n",
			road[iroad].hdmdes[jcross].ylink->cml,
			road[iroad].hdmdes[jcross].ylink->dml,
			road[iroad].hdmdes[jcross].ylink->newLYd,
			road[iroad].hdmdes[jcross].ylink->newRYd,
			road[iroad].hdmdes[jcross].ylink->xjj,
			road[iroad].hdmdes[jcross].ylink->FillArea,
			road[iroad].hdmdes[jcross].ylink->CutArea,
			road[iroad].hdmdes[jcross].ylink->Ldeltah,
			road[iroad].hdmdes[jcross].ylink->Rdeltah,
			road[iroad].hdmdes[jcross].ylink->glRoadName
		);
		//1.写左线左侧
		fwprintf(fpw, L"%d\n", road[iroad].hdmdes[jcross].ylink->ZDMXZ);
		//写路面点
		for (j = 0; j < 3; j++)
			fwprintf(fpw, L"%0.3lf ", road[iroad].hdmdes[jcross].ylink->zlmhd[j]);
		fwprintf(fpw, L"\n");
		//写路面点
		for (j = 0; j < 5; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].ylink->RHFL[2 * j], road[iroad].hdmdes[jcross].ylink->RHFL[2 * j + 1]);
		fwprintf(fpw, L"\n");
		//左设计点
		fwprintf(fpw, L"%0.3lf %0.3lf %d ", road[iroad].hdmdes[jcross].ylink->Zt, road[iroad].hdmdes[jcross].ylink->ZHc, road[iroad].hdmdes[jcross].ylink->Lnpt);//换行
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->Lnpt; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].ylink->RPTL[j].x, road[iroad].hdmdes[jcross].ylink->RPTL[j].y);
		fwprintf(fpw, L"\n");
		//左水沟点
		fwprintf(fpw, L"%d %0.3lf %d %d %d ", road[iroad].hdmdes[jcross].ylink->LIfSetGouH, road[iroad].hdmdes[jcross].ylink->LGouH, road[iroad].hdmdes[jcross].ylink->LGouProperty, road[iroad].hdmdes[jcross].ylink->LGouPtNum, road[iroad].hdmdes[jcross].ylink->LJSGouPtNum);
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->LGouPtNum; j++)
		{
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].ylink->Lgou[j * 2], road[iroad].hdmdes[jcross].ylink->Lgou[j * 2 + 1]);
		}
		//左截水沟
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->LJSGouPtNum; j++)
		{
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].ylink->LJSgou[j * 2], road[iroad].hdmdes[jcross].ylink->LJSgou[j * 2 + 1]);
		}
		fwprintf(fpw, L"\n");
		//2.写左线右侧
		//写路面点
		fwprintf(fpw, L"%d\n", road[iroad].hdmdes[jcross].ylink->YDMXZ);
		for (j = 0; j < 3; j++)
			fwprintf(fpw, L"%0.3lf ", road[iroad].hdmdes[jcross].ylink->ylmhd[j]);

		for (j = 0; j < 5; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].ylink->RHFR[2 * j], road[iroad].hdmdes[jcross].ylink->RHFR[2 * j + 1]);
		fwprintf(fpw, L"\n");
		//右设计点
		fwprintf(fpw, L"%0.3lf %0.3lf %d ", road[iroad].hdmdes[jcross].ylink->Yt, road[iroad].hdmdes[jcross].ylink->YHc, road[iroad].hdmdes[jcross].ylink->Rnpt);
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->Rnpt; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].ylink->RPTR[j].x, road[iroad].hdmdes[jcross].ylink->RPTR[j].y);
		fwprintf(fpw, L"\n");
		//右水沟点
		fwprintf(fpw, L"%d %0.3lf %d %d %d ", road[iroad].hdmdes[jcross].ylink->RIfSetGouH, road[iroad].hdmdes[jcross].ylink->RGouH, road[iroad].hdmdes[jcross].ylink->RGouProperty, road[iroad].hdmdes[jcross].ylink->RGouPtNum, road[iroad].hdmdes[jcross].ylink->RJSGouPtNum);
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->RGouPtNum; j++)
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].ylink->Rgou[j * 2], road[iroad].hdmdes[jcross].ylink->Rgou[j * 2 + 1]);
		//右截水沟
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->RJSGouPtNum; j++)
		{
			fwprintf(fpw, L"%0.3lf %0.3lf ", road[iroad].hdmdes[jcross].ylink->RJSgou[j * 2], road[iroad].hdmdes[jcross].ylink->RJSgou[j * 2 + 1]);
		}
	}
	fwprintf(fpw, L"\n"); //一行空行
	/*
	if(road[iroad].hdmdes[jcross].DorS==2)//双路面
	{
	fwprintf(fpw,L"%d\n",road[iroad].hdmdes[jcross].Y_ZDMXZ);
	for(j=0;j<3;j++)
	fwprintf(fpw,L"%0.3lf ",road[iroad].hdmdes[jcross].Y_zlmhd[j]);

	//3.写右线左侧
	//写路面点
	for(j=0;j<4;j++)
	fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Y_RHFL[2*j],road[iroad].hdmdes[jcross].Y_RHFL[2*j+1]);
	fwprintf(fpw,L"\n"); //一行空行
	//右左设计点
	fwprintf(fpw,L"%0.3lf %0.3lf %d ",road[iroad].hdmdes[jcross].Y_Zt,road[iroad].hdmdes[jcross].Y_ZHc,road[iroad].hdmdes[jcross].Y_Lnpt);
	for(j=0;j<road[iroad].hdmdes[jcross].Y_Lnpt;j++)
	fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Y_RPTL[j].x,road[iroad].hdmdes[jcross].Y_RPTL[j].y);
	//右左水沟点
	fwprintf(fpw,L"\n0 0.000 %d %d %d ",road[iroad].hdmdes[jcross].Y_LGouProperty,road[iroad].hdmdes[jcross].Y_LGouPtNum,road[iroad].hdmdes[jcross].Y_LJSGouPtNum);
	for(j=0; j<road[iroad].hdmdes[jcross].Y_LGouPtNum; j++)
	fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Y_Lgou[j*2],road[iroad].hdmdes[jcross].Y_Lgou[j*2+1]);
	//右左截水沟
	for(j=0;j<road[iroad].hdmdes[jcross].Y_LJSGouPtNum;j++)
	fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Y_LJSgou[j*2],road[iroad].hdmdes[jcross].Y_LJSgou[j*2+1]);
	fwprintf(fpw,L"\n"); //一行空行

	//3.写右线右侧
	fwprintf(fpw,L"%d\n",road[iroad].hdmdes[jcross].Y_YDMXZ);
	for(j=0;j<3;j++)
	fwprintf(fpw,L"%0.3lf ",road[iroad].hdmdes[jcross].Y_ylmhd[j]);

	//写路面点
	for(j=0;j<4;j++)
	fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Y_RHFR[2*j],road[iroad].hdmdes[jcross].Y_RHFR[2*j+1]);
	fwprintf(fpw,L"\n"); //一行空行
	//写地面线
	//	fwprintf(fpw,L"\n%d ",road[iroad].hdmdes[jcross].NumL);
	//	for(j=0;j<road[iroad].hdmdes[jcross].NumL;j++)
	//		fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Learpt[j*2],road[iroad].hdmdes[jcross].Learpt[j*2+1]);
	//	fwprintf(fpw,L"\n%d ",road[iroad].hdmdes[jcross].NumR);
	//	for(j=0;j<road[iroad].hdmdes[jcross].NumR;j++)
	//		fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Rearpt[j*2],road[iroad].hdmdes[jcross].Rearpt[j*2+1]);

	//右右设计点
	fwprintf(fpw,L"%0.3lf %0.3lf %d ",road[iroad].hdmdes[jcross].Y_Yt,road[iroad].hdmdes[jcross].Y_YHc,road[iroad].hdmdes[jcross].Y_Rnpt);
	for(j=0;j<road[iroad].hdmdes[jcross].Y_Rnpt;j++)
	fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Y_RPTR[j].x,road[iroad].hdmdes[jcross].Y_RPTR[j].y);
	//右右水沟点
	fwprintf(fpw,L"\n%d %0.3lf %d %d %d ",road[iroad].hdmdes[jcross].RIfSetGouH,road[iroad].hdmdes[jcross].RGouH,road[iroad].hdmdes[jcross].Y_RGouProperty,road[iroad].hdmdes[jcross].Y_RGouPtNum,road[iroad].hdmdes[jcross].Y_RJSGouPtNum);
	for(j=0; j<road[iroad].hdmdes[jcross].Y_RGouPtNum; j++)
	fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Y_Rgou[j*2],road[iroad].hdmdes[jcross].Y_Rgou[j*2+1]);
	//右右截水沟
	for(j=0;j<road[iroad].hdmdes[jcross].Y_RJSGouPtNum;j++)
	{
	fwprintf(fpw,L"%0.3lf %0.3lf ",road[iroad].hdmdes[jcross].Y_RJSgou[j*2],road[iroad].hdmdes[jcross].Y_RJSgou[j*2+1]);
	}
	fwprintf(fpw,L"\n"); //一行空行
	}*/



}

void HdmDes::Write3dFile(int iroad, int jcross, FILE* fpw)
{
	//计算该横断面在平面上的位置
	xlpoint tempPZ;
	tempPZ.lc = road[iroad].hdmdes[jcross].cml;
	road[iroad].pm->xlpoint_pz(&tempPZ);

	//计算相关信息
	double Azimuth = tempPZ.a;
	double Degree = Azimuth - 0.5 * pi;
	BAS_DRAW_FUN::StdJiao(Degree);

	double MP[3];
	MP[0] = tempPZ.x;//路基中心	
	MP[1] = tempPZ.y;

	if (road[iroad].hdmdes[jcross].Lnpt > 0 && road[iroad].hdmdes[jcross].Rnpt > 0)
	{
		Write3dFile_Roadbed(MP, Azimuth, tempPZ, iroad, jcross, fpw);
	}
	else
	{
		if (road[iroad].hdmdes[jcross].ZDMXZ == 1.0)//桥中断面
		{
			Write3dFile_Bridge(MP, Azimuth, iroad, jcross, fpw);
		}
		else if (road[iroad].hdmdes[jcross].ZDMXZ == 2.0)//隧中断面
		{
			Write3dFile_Tunnel(MP, Azimuth, iroad, jcross, fpw);
		}
	}
}

void HdmDes::Write3dFile_Roadbed(double MP[3], double Azimuth, xlpoint RoadPZ, int iroad, int jcross, FILE* fpw)
{
	double LP[50][3], RP[50][3];//左线左右设计点
	double Degree = Azimuth - 0.5 * pi;
	BAS_DRAW_FUN::StdJiao(Degree);

	//中心点								 
	LP[0][0] = MP[0] + fabs(road[iroad].hdmdes[jcross].RPTL[0].x) * cos(Degree);
	LP[0][1] = MP[1] + fabs(road[iroad].hdmdes[jcross].RPTL[0].x) * sin(Degree);
	LP[0][2] = road[iroad].hdmdes[jcross].newLYd + road[iroad].hdmdes[jcross].RPTL[4].y + 0.35;

	LP[1][0] = LP[0][0] + 1.8 * cos(Degree);
	LP[1][1] = LP[0][1] + 1.8 * sin(Degree);
	LP[1][2] = LP[0][2];

	LP[2][0] = LP[0][0] + (1.8 + 0.35) * cos(Degree);
	LP[2][1] = LP[0][1] + (1.8 + 0.35) * sin(Degree);
	LP[2][2] = road[iroad].hdmdes[jcross].newLYd + road[iroad].hdmdes[jcross].RPTL[4].y;

	MP[0] = RoadPZ.x + road[iroad].hdmdes[jcross].offsetX * cos(Azimuth + 0.5 * pi);//路基中心	
	MP[1] = RoadPZ.y + road[iroad].hdmdes[jcross].offsetX * sin(Azimuth + 0.5 * pi);

	int NLP = 3;
	//左右设计点数
	for (int j = 4; j < road[iroad].hdmdes[jcross].Lnpt; j++)
	{
		LP[NLP][0] = MP[0] + fabs(road[iroad].hdmdes[jcross].RPTL[j].x) * cos(Degree);
		LP[NLP][1] = MP[1] + fabs(road[iroad].hdmdes[jcross].RPTL[j].x) * sin(Degree);
		LP[NLP][2] = road[iroad].hdmdes[jcross].newLYd + road[iroad].hdmdes[jcross].RPTL[j].y;
		NLP++;
	}

	Degree = Azimuth + 0.5 * pi;
	BAS_DRAW_FUN::StdJiao(Degree);

	MP[0] = RoadPZ.x;//路基中心	
	MP[1] = RoadPZ.y;

	//中心点
	RP[0][0] = MP[0] + fabs(road[iroad].hdmdes[jcross].RPTR[0].x) * cos(Degree);
	RP[0][1] = MP[1] + fabs(road[iroad].hdmdes[jcross].RPTR[0].x) * sin(Degree);
	RP[0][2] = road[iroad].hdmdes[jcross].newLYd + road[iroad].hdmdes[jcross].RPTR[4].y + 0.35;

	RP[1][0] = RP[0][0] + 1.8 * cos(Degree);
	RP[1][1] = RP[0][1] + 1.8 * sin(Degree);
	RP[1][2] = RP[0][2];

	RP[2][0] = RP[0][0] + (1.8 + 0.35) * cos(Degree);
	RP[2][1] = RP[0][1] + (1.8 + 0.35) * sin(Degree);
	RP[2][2] = road[iroad].hdmdes[jcross].newLYd + road[iroad].hdmdes[jcross].RPTR[4].y;

	MP[0] = RoadPZ.x + road[iroad].hdmdes[jcross].offsetX * cos(Azimuth + 0.5 * pi);//路基中心	
	MP[1] = RoadPZ.y + road[iroad].hdmdes[jcross].offsetX * sin(Azimuth + 0.5 * pi);

	int NRP = 3;
	//左右设计点数
	for (int j = 4; j < road[iroad].hdmdes[jcross].Rnpt; j++)
	{
		RP[NRP][0] = MP[0] + fabs(road[iroad].hdmdes[jcross].RPTR[j].x) * cos(Degree);
		RP[NRP][1] = MP[1] + fabs(road[iroad].hdmdes[jcross].RPTR[j].x) * sin(Degree);
		RP[NRP][2] = road[iroad].hdmdes[jcross].newLYd + road[iroad].hdmdes[jcross].RPTR[j].y;
		NRP++;
	}

	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %lf %d %0.3lf %0.3lf %d %d\n",
		road[iroad].hdmdes[jcross].cml, road[iroad].hdmdes[jcross].Zt, road[iroad].hdmdes[jcross].Yt, MP[0], MP[1], 
		road[iroad].hdmdes[jcross].ZDesH, Azimuth, road[iroad].hdmdes[jcross].ZDMXZ, road[iroad].hdmdes[jcross].Ldeltah,	//DesH改为ZDesH，BTinf改为ZDMXZ
		road[iroad].hdmdes[jcross].Rdeltah, NLP, NRP);//左右线横断面总数
	for (int j = 0; j < NLP; j++)
		fwprintf(fpw, L"%lf %lf %lf\n", LP[j][0], LP[j][1], LP[j][2]);
	for (int j = 0; j < NRP; j++)
		fwprintf(fpw, L"%lf %lf %lf\n", RP[j][0], RP[j][1], RP[j][2]);
}

void HdmDes::Write3dFile_Bridge(double MP[3], double Azimuth, int iroad, int jcross, FILE* fpw)
{
	double LP[20][3], RP[20][3], du;
	int NLP, NRP;
	double LTwid = 3.0;

	du = Azimuth - 0.5 * pi;
	BAS_DRAW_FUN::StdJiao(du);

	//中心点
	LP[0][0] = MP[0];
	LP[0][1] = MP[1];
	LP[0][2] = road[iroad].hdmdes[jcross].ZDesH + 0.35;

	LP[1][0] = LP[0][0] + 1.8 * cos(du);
	LP[1][1] = LP[0][1] + 1.8 * sin(du);
	LP[1][2] = LP[0][2];

	LP[2][0] = LP[0][0] + (1.8 + 0.35) * cos(du);
	LP[2][1] = LP[0][1] + (1.8 + 0.35) * sin(du);
	LP[2][2] = road[iroad].hdmdes[jcross].ZDesH;

	LP[3][0] = LP[0][0] + LTwid * cos(du);
	LP[3][1] = LP[0][1] + LTwid * sin(du);
	LP[3][2] = road[iroad].hdmdes[jcross].ZDesH;

	LP[4][0] = LP[3][0];
	LP[4][1] = LP[3][1];
	LP[4][2] = road[iroad].hdmdes[jcross].ZDesH - 0.2;

	LP[5][0] = LP[4][0] + 1.0 * cos(du + pi);
	LP[5][1] = LP[4][1] + 1.0 * sin(du + pi);
	LP[5][2] = road[iroad].hdmdes[jcross].ZDesH - 0.5;

	LP[6][0] = LP[5][0];
	LP[6][1] = LP[5][1];
	LP[6][2] = road[iroad].hdmdes[jcross].ZDesH - 2.5;

	LP[7][0] = LP[0][0];
	LP[7][1] = LP[0][1];
	LP[7][2] = road[iroad].hdmdes[jcross].ZDesH - 2.5;

	NLP = 8;
	//右侧
	du = Azimuth + 0.5 * pi;
	BAS_DRAW_FUN::StdJiao(du);

	RP[0][0] = MP[0];
	RP[0][1] = MP[1];
	RP[0][2] = road[iroad].hdmdes[jcross].ZDesH + 0.35;

	RP[1][0] = RP[0][0] + 1.8 * cos(du);
	RP[1][1] = RP[0][1] + 1.8 * sin(du);
	RP[1][2] = RP[0][2];

	RP[2][0] = RP[0][0] + (1.8 + 0.35) * cos(du);
	RP[2][1] = RP[0][1] + (1.8 + 0.35) * sin(du);
	RP[2][2] = road[iroad].hdmdes[jcross].ZDesH;

	RP[3][0] = RP[0][0] + LTwid * cos(du);
	RP[3][1] = RP[0][1] + LTwid * sin(du);
	RP[3][2] = road[iroad].hdmdes[jcross].ZDesH;

	RP[4][0] = RP[3][0];
	RP[4][1] = RP[3][1];
	RP[4][2] = road[iroad].hdmdes[jcross].ZDesH - 0.2;

	RP[5][0] = RP[4][0] + 1.0 * cos(du + pi);
	RP[5][1] = RP[4][1] + 1.0 * sin(du + pi);
	RP[5][2] = road[iroad].hdmdes[jcross].ZDesH - 0.5;

	RP[6][0] = RP[5][0];
	RP[6][1] = RP[5][1];
	RP[6][2] = road[iroad].hdmdes[jcross].ZDesH - 2.5;

	RP[7][0] = RP[0][0];
	RP[7][1] = RP[0][1];
	RP[7][2] = road[iroad].hdmdes[jcross].ZDesH - 2.5;
	NRP = 8;

	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %lf %d %0.3lf %0.3lf %d %d\n",
		road[iroad].hdmdes[jcross].cml, road[iroad].hdmdes[jcross].Zt, road[iroad].hdmdes[jcross].Yt, MP[0], MP[1], 
		road[iroad].hdmdes[jcross].ZDesH, Azimuth, road[iroad].hdmdes[jcross].ZDMXZ, road[iroad].hdmdes[jcross].Ldeltah,
		road[iroad].hdmdes[jcross].Rdeltah, NLP, NRP);//左右线横断面总数
	for (int j = 0; j < NLP; j++)
		fwprintf(fpw, L"%lf %lf %lf\n", LP[j][0], LP[j][1], LP[j][2]);
	for (int j = 0; j < NRP; j++)
		fwprintf(fpw, L"%lf %lf %lf\n", RP[j][0], RP[j][1], RP[j][2]);
}

void HdmDes::Write3dFile_Tunnel(double MP[3], double Azimuth, int iroad, int jcross, FILE* fpw)
{
	double h, LP[20][3], RP[20][3], du;
	int NLP, NRP;
	double LQwid = 3.0;

	du = Azimuth - 0.5 * pi;
	BAS_DRAW_FUN::StdJiao(du);

	h = 4.25;
	LP[0][0] = MP[0];
	LP[0][1] = MP[1];
	LP[0][2] = road[iroad].hdmdes[jcross].ZDesH + 0.35;

	LP[1][0] = LP[0][0] + 1.8 * cos(du);
	LP[1][1] = LP[0][1] + 1.8 * sin(du);
	LP[1][2] = LP[0][2];

	LP[2][0] = LP[0][0] + (1.8 + 0.35) * cos(du);
	LP[2][1] = LP[0][1] + (1.8 + 0.35) * sin(du);
	LP[2][2] = road[iroad].hdmdes[jcross].ZDesH;

	LP[3][0] = LP[0][0] + LQwid * cos(du);
	LP[3][1] = LP[0][1] + LQwid * sin(du);
	LP[3][2] = road[iroad].hdmdes[jcross].ZDesH;

	for (int j = 0; j <= 5; j++)
	{
		LP[4 + j][0] = LP[0][0] + LQwid * cos(j * pi * 0.5 / 5.0) * cos(du);
		LP[4 + j][1] = LP[0][1] + LQwid * cos(j * pi * 0.5 / 5.0) * sin(du);
		LP[4 + j][2] = road[iroad].hdmdes[jcross].ZDesH + h + LQwid * sin(j * pi * 0.5 / 5.0);
	}
	//--------------------------------------------------------
	du = Azimuth + 0.5 * pi;
	BAS_DRAW_FUN::StdJiao(du);

	RP[0][0] = MP[0];
	RP[0][1] = MP[1];
	RP[0][2] = road[iroad].hdmdes[jcross].ZDesH + 0.35;

	RP[1][0] = RP[0][0] + 1.8 * cos(du);
	RP[1][1] = RP[0][1] + 1.8 * sin(du);
	RP[1][2] = RP[0][2];

	RP[2][0] = RP[0][0] + (1.8 + 0.35) * cos(du);
	RP[2][1] = RP[0][1] + (1.8 + 0.35) * sin(du);
	RP[2][2] = road[iroad].hdmdes[jcross].ZDesH;

	RP[3][0] = RP[0][0] + LQwid * cos(du);
	RP[3][1] = RP[0][1] + LQwid * sin(du);
	RP[3][2] = road[iroad].hdmdes[jcross].ZDesH;

	for (int j = 0; j <= 5; j++)
	{
		RP[4 + j][0] = RP[0][0] + LQwid * cos(j * pi * 0.5 / 5.0) * cos(du);
		RP[4 + j][1] = RP[0][1] + LQwid * cos(j * pi * 0.5 / 5.0) * sin(du);
		RP[4 + j][2] = road[iroad].hdmdes[jcross].ZDesH + h + LQwid * sin(j * pi * 0.5 / 5.0);
	}
	NLP = NRP = 10;

	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %lf %d %0.3lf %0.3lf %d %d\n",
		road[iroad].hdmdes[jcross].cml, road[iroad].hdmdes[jcross].Zt, road[iroad].hdmdes[jcross].Yt, MP[0], MP[1], 
		road[iroad].hdmdes[jcross].ZDesH, Azimuth, road[iroad].hdmdes[jcross].ZDMXZ, road[iroad].hdmdes[jcross].Ldeltah,
		road[iroad].hdmdes[jcross].Rdeltah, NLP, NRP);//左右线横断面总数

	//	fwprintf(fpw,L"%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %lf %0.3lf %d %d\n",
	//	road[iroad].hdmdes[jcross].cml,road[iroad].hdmdes[jcross].Zt,road[iroad].hdmdes[jcross].Yt,MP[0],MP[1],road[iroad].hdmdes[jcross].ZDesH,Azimuth,road[iroad].hdmdes[jcross].BTinf,NLP,NRP);//左右线横断面总数
	for (int j = 0; j < NLP; j++)
		fwprintf(fpw, L"%lf %lf %lf\n", LP[j][0], LP[j][1], LP[j][2]);
	for (int j = 0; j < NRP; j++)
		fwprintf(fpw, L"%lf %lf %lf\n", RP[j][0], RP[j][1], RP[j][2]);
}

void HdmDes::WriteDetailedAreaFile(int iroad, int jcross, FILE * fpw)
{
	//计算填挖方分类
	//glthd = FindGLTHD(cml,road[iroad].pm,road[iroad].hdmbz.NLDTL,road[iroad].hdmbz.LDTL);
	int TFtype;
	TFtype = FindLTTL(road[iroad].hdmdes[jcross].cml, road[iroad].pm, road[iroad].hdmbz.NLDTL, road[iroad].hdmbz.LDTL);
	double  WFSJ[6];
	FindWFFL(road[iroad].hdmdes[jcross].cml, road[iroad].pm, road[iroad].hdmbz.NWFFL, road[iroad].hdmbz.WFFL, WFSJ);


	//	for(int j=0; j<6; j++)
	//	   WFFLArea[j] = road[iroad].hdmdes[jcross].CutArea * WFSJ[j] *0.01;
	//	
	//	for(j=5; j>=0; j++)
	//	{
	//      if(WFFLArea[j]>0.001)
	//	  {
	//		  double asum=0;
	//		  for(int k=j-1; k>=0; k++)//计算剩余的总和
	//			  asum += WFFLArea[k];
	//
	//          WFFLArea[j] = road[iroad].hdmdes[jcross].CutArea - asum;                         
	//		  break;
	//	  }		  
	//	}

	fwprintf(fpw, L"%lf %d %d %d %d %d\n",
		road[iroad].hdmdes[jcross].cml,/*road[iroad].hdmdes[jcross].DorS*/road[iroad].hdmdes[jcross].IsInsertHdm, road[iroad].hdmdes[jcross].ZDMXZ, road[iroad].hdmdes[jcross].YDMXZ, road[iroad].hdmdes[jcross].Y_ZDMXZ, road[iroad].hdmdes[jcross].Y_YDMXZ);
	fwprintf(fpw, L"%d %0.3lf %0.3lf %0.3lf %0.3lf\n", TFtype, road[iroad].hdmdes[jcross].FillArea, road[iroad].hdmdes[jcross].Z_LFillArea, road[iroad].hdmdes[jcross].MidFillArea, road[iroad].hdmdes[jcross].Y_RFillArea);
	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf %0.3lf\n", road[iroad].hdmdes[jcross].CutArea, road[iroad].hdmdes[jcross].Z_LCutArea, road[iroad].hdmdes[jcross].MidCutArea, road[iroad].hdmdes[jcross].Y_RCutArea);

	for (int j = 0; j < 6; j++)
		fwprintf(fpw, L"%0.3lf ", WFSJ[j]);
	fwprintf(fpw, L"\n");

	//fwprintf(fpw,L"%0.3lf %0.3lf %0.3lf %0.3lf\n",road[iroad].hdmdes[jcross].FillSSTArea,road[iroad].hdmdes[jcross].Z_LFillSSTArea,road[iroad].hdmdes[jcross].MidFillSSTArea,road[iroad].hdmdes[jcross].Y_RFillSSTArea);
	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf %0.3lf\n", road[iroad].hdmdes[jcross].QBTArea, road[iroad].hdmdes[jcross].Z_LQBTArea, road[iroad].hdmdes[jcross].MidQBTArea, road[iroad].hdmdes[jcross].Y_RQBTArea);
	//fwprintf(fpw,L"%0.3lf %0.3lf %0.3lf %0.3lf\n",road[iroad].hdmdes[jcross].FillBetterSoilArea,road[iroad].hdmdes[jcross].Z_LFillBetterSoilArea,road[iroad].hdmdes[jcross].MidFillGLTArea,road[iroad].hdmdes[jcross].Y_RFillBetterSoilArea);
	//ads_printf(L"%lf %0.3lf %0.3lf %0.3lf %0.3lf\n",road[iroad].hdmdes[jcross].cml,road[iroad].hdmdes[jcross].FillBetterSoilArea,road[iroad].hdmdes[jcross].Z_LFillBetterSoilArea,road[iroad].hdmdes[jcross].MidFillGLTArea,road[iroad].hdmdes[jcross].Y_RFillBetterSoilArea);
	//fwprintf(fpw,L"%0.3lf %0.3lf %0.3lf %0.3lf\n",road[iroad].hdmdes[jcross].HJarea,road[iroad].hdmdes[jcross].Z_LHJarea,road[iroad].hdmdes[jcross].MidHJarea,road[iroad].hdmdes[jcross].Y_RHJarea);
	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf %0.3lf\n", road[iroad].hdmdes[jcross].SGJQarea, road[iroad].hdmdes[jcross].Z_LSGJQarea, road[iroad].hdmdes[jcross].MidGouJQarea, road[iroad].hdmdes[jcross].Y_RSGJQarea);
	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf %0.3lf\n", road[iroad].hdmdes[jcross].DQlength, road[iroad].hdmdes[jcross].Z_LDQlength, road[iroad].hdmdes[jcross].MidDQlength, road[iroad].hdmdes[jcross].Y_RDQlength);
	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf %0.3lf\n", road[iroad].hdmdes[jcross].Grasslength, road[iroad].hdmdes[jcross].Z_LGrasslength, road[iroad].hdmdes[jcross].MidGrasslength, road[iroad].hdmdes[jcross].Y_RGrasslength);
	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf\n", road[iroad].hdmdes[jcross].GouTarea, road[iroad].hdmdes[jcross].Z_LGouTarea, road[iroad].hdmdes[jcross].Y_RGouTarea);
	fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf\n", road[iroad].hdmdes[jcross].GouWarea, road[iroad].hdmdes[jcross].Z_LGouWarea, road[iroad].hdmdes[jcross].Y_RGouWarea);
	fwprintf(fpw, L"\n"); //一行空行
}

void HdmDes::WriteHdmDmxFile(int i)
{
	FILE *fpw;
	CString DmxFname;

	DmxFname = Cworkdir + "\\data\\" + "hdmdmx." + Pro + "." + road[i].roadname;
	fpw = _wfopen(DmxFname, L"w");
	if (fpw)
	{
		fwprintf(fpw, L"%d\n", road[i].NCRS);
		int j;
		for (j = 0; j < road[i].NCRS; j++)
		{
			fwprintf(fpw, L"%0.3lf %0.3lf %d %d\n", road[i].hdmdmx[j].lc, road[i].hdmdmx[j].EarH, road[i].hdmdmx[j].ZEarPtNum, road[i].hdmdmx[j].YEarPtNum);
			int k;
			for (k = 0; k < road[i].hdmdmx[j].ZEarPtAry.GetSize(); k++)
				fwprintf(fpw, L"%0.3lf %0.3lf ", road[i].hdmdmx[j].ZEarPtAry[k].x, road[i].hdmdmx[j].ZEarPtAry[k].y);
			fwprintf(fpw, L"\n");
			for (k = 0; k < road[i].hdmdmx[j].YEarPtAry.GetSize(); k++)
				fwprintf(fpw, L"%0.3lf %0.3lf ", road[i].hdmdmx[j].YEarPtAry[k].x, road[i].hdmdmx[j].YEarPtAry[k].y);
			fwprintf(fpw, L"\n");
		}
		fclose(fpw);
		ACHAR mes[256];
		_stprintf(mes, L"\n%s横断面地面线已保存在%s中!", road[i].roadname, DmxFname);
		ads_printf(mes);
	}
}


void HdmDes::WriteHdmBenchFile(int i)
{
	FILE *fpw;
	CString DmxFname;

	//////////////////////////////////////////////////////////////////////////
	DmxFname = Cworkdir + "\\data\\" + "hdmBench." + Pro + "." + road[i].roadname;
	fpw = _wfopen(DmxFname, L"w");
	if (fpw)
	{
		fwprintf(fpw, L"%d\n", road[i].NCRS);
		for (int j = 0; j < road[i].NCRS; j++)
		{
			fwprintf(fpw, L"%0.3lf %0.3lf %d %d\n", road[i].hdmBench[j].lc, road[i].hdmBench[j].EarH, road[i].hdmBench[j].ZEarPtNum, road[i].hdmBench[j].YEarPtNum);
			int k;
			for (k = 0; k < road[i].hdmBench[j].ZEarPtAry.GetSize(); k++)
				fwprintf(fpw, L"%0.3lf %0.3lf ", road[i].hdmBench[j].ZEarPtAry[k].x, road[i].hdmBench[j].ZEarPtAry[k].y);
			fwprintf(fpw, L"\n");
			for (k = 0; k < road[i].hdmBench[j].YEarPtAry.GetSize(); k++)
				fwprintf(fpw, L"%0.3lf %0.3lf ", road[i].hdmBench[j].YEarPtAry[k].x, road[i].hdmBench[j].YEarPtAry[k].y);
			fwprintf(fpw, L"\n");
		}
		fclose(fpw);
		ACHAR mes[256];
		_stprintf(mes, L"\n%s横断面台阶线已保存在%s中!\n", road[i].roadname, DmxFname);
		ads_printf(mes);
	}
	//////////////////////////////////////////////////////////////////////////

}

void HdmDes::WriteFile()
{
	CString filename, Afilename, ZDKfilename, QBTfilename;
	FILE *fpw, *fpw1, *fpw2, *fpw3;


	for (int i = 0; i < RoadSum; i++)
	{

		WriteHdmDmxFile(i);

		WriteHdmBenchFile(i);

		filename = Cworkdir + "\\data\\" + "hdmresult." + Pro + "." + road[i].roadname;
		if ((fpw = _wfopen(filename, L"w")) == NULL)
		{
			ads_printf(L"无法打开hdmresult文件!");
			return;
		}

		Afilename = Cworkdir + "\\data\\" + "HdmDetailArea." + Pro + "." + road[i].roadname;
		if ((fpw1 = _wfopen(Afilename, L"w")) == NULL)
		{
			ads_printf(L"无法打开HdmDetailArea文件!");
			return;
		}

		ZDKfilename = Cworkdir + "\\data\\" + "hdmZDK." + Pro + "." + road[i].roadname;
		if ((fpw2 = _wfopen(ZDKfilename, L"w")) == NULL)
		{
			ads_printf(L"无法打开HdmZDK文件!");
			return;
		}

		QBTfilename = Cworkdir + "\\data\\" + "hdmQBT." + Pro + "." + road[i].roadname;
		if ((fpw3 = _wfopen(QBTfilename, L"w")) == NULL)
		{
			ads_printf(L"无法打开hdmQBT文件!");
			return;
		}

		fwprintf(fpw, L"%d\n", road[i].NCRS*road[i].ZxOrYx);
		fwprintf(fpw1, L"%d\n", road[i].NCRS);
		fwprintf(fpw2, L"%d\n", road[i].NCRS);
		fwprintf(fpw3, L"%d\n", road[i].NCRS);
		if (i > 0)//分离段
		{
			fwprintf(fpw, L"%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf\n",
				road[i].SmlOnZx, road[i].LJFLSmlOnZx, road[i].LJFLSmlOnFLD,
				road[i].EmlOnZx, road[i].LJFLEmlOnZx, road[i].LJFLEmlOnFLD);
		}
		for (int j = 0; j < road[i].NCRS; j++)
		{

			WriteHdmResFile(i, j, fpw);
			WriteDetailedAreaFile(i, j, fpw1);
			//			fwprintf(fpw2 ,L"%0.3lf %0.3lf\n",road[i].hdmdes[j].cml,road[i].hdmdes[j].LZDK);
			WriteHdmZdkFile(i, j, fpw2);
			WriteHdmQBTFile(i, j, fpw3);
		}
		/*
		for(j=0; j<road[i].NCRS; j++)
		{
		fwprintf(fpw2 ,L"%0.3lf %0.3lf\n",road[i].hdmdes[j].cml,road[i].hdmdes[j].RZDK);
		}*/

		//********************20200516新增	输出左线3d文件 start***************************
		CString ThreeDFilename = Cworkdir + "\\data\\" + "Zx3d." + Pro;
		FILE* fpw4;
		if ((fpw4 = _wfopen(ThreeDFilename, L"w")) == NULL)
		{
			ads_printf(L"无法打开Zx3d文件!三维文件输出失败\n");
		}
		else
		{
			fwprintf(fpw4, L"%10d\n", road[i].NCRS);//左右线横断面总数
			for (int j = 0; j < road[i].NCRS; j++)
			{
				Write3dFile(i, j, fpw4);
			}
		}
		fclose(fpw4);
		//********************20200516新增	输出左线3d文件 end***************************

		fclose(fpw);
		fclose(fpw1);
		fclose(fpw2);
		fclose(fpw3);

		ads_printf(L"横断面设计成果已保存在%s文件!\n", filename);
		ads_printf(L"横断面面积数据已保存在%s文件!\n", Afilename);
	}
	return;
}
//
//
//绘图分一线，左绕行段、右绕行段分别绘出
//中间绘一线，上绘左绕行段、下绘右绕行段
//int HdmDes::DrawCross()
//{
//	if(acdbHostApplicationServices()->workingDatabase()->loadLineTypeFile(L"DASHDOTX2",L"acadiso.lin") != Acad::eOk)
//		ads_printf(L"加载DASHDOTX2线形失败!\n");
//    CreateLayer(L"Hdm");//建立Hdm层
//   Cal_CrossOriPt();//得到每个横断面绘图原点
//   for(int i=0; i<RoadSum; i++)
//   {
//      DrawIRoadHdm(i,road[i].hdmdes[0].cml,road[i].hdmdes[road[i].NCRS-1].cml);
//	}
//	if(ZXSM=="双线")
//	{
//		if(NZRXD>0)
//		{
//			DrawAllRXD(ZRXD,NZRXD,L"左");
//		}
//		if(NYRXD>0)
//		{
//			
//			DrawAllRXD(YRXD,NYRXD,L"右");
//		}
//	}
//	return 1;


//画指定里程的主线(已经没有用了)
void HdmDes::DrawIRoadHdm(int iroad, double sml, double eml)
{
	double Learpt[400], Rearpt[400];
	double LBenchPt[400], RBenchPt[400];
	//int  DorS;
	int i;
	AcGePoint3d pt;
	CROSS pCross;

	//NCRS=89;
	CString pszLabel = "正在绘制主线横断面";
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);

	for (i = 0; i < road[iroad].NCRS; i++)//一线
	{
		int pos = (int)i*100.0 / road[iroad].NCRS;
		acedSetStatusBarProgressMeterPos(pos);

		if (road[iroad].hdmdes[i].cml > sml - 0.01&&road[iroad].hdmdes[i].cml < eml + 0.01)
		{

			if (road[iroad].hdmdes[i].DorS == 1)//单路面
			{

				int k;
				for (k = 0; k < road[iroad].hdmdmx[i].ZEarPtNum; k++)
				{
					Learpt[k * 2] = road[iroad].hdmdmx[i].ZEarPtAry[k].x;
					Learpt[k * 2 + 1] = road[iroad].hdmdmx[i].ZEarPtAry[k].y;
				}



				for (k = 0; k < road[iroad].hdmdmx[i].YEarPtNum; k++)
				{
					Rearpt[k * 2] = road[iroad].hdmdmx[i].YEarPtAry[k].x;
					Rearpt[k * 2 + 1] = road[iroad].hdmdmx[i].YEarPtAry[k].y;
				}


				//////////////////////////////////////////////////////////////////////////
				for (k = 0; k < road[iroad].hdmBench[i].ZEarPtNum; k++)
				{
					LBenchPt[k * 2] = road[iroad].hdmBench[i].ZEarPtAry[k].x;
					LBenchPt[k * 2 + 1] = road[iroad].hdmBench[i].ZEarPtAry[k].y;
				}

				for (k = 0; k < road[iroad].hdmBench[i].YEarPtNum; k++)
				{
					RBenchPt[k * 2] = road[iroad].hdmBench[i].YEarPtAry[k].x;
					RBenchPt[k * 2 + 1] = road[iroad].hdmBench[i].YEarPtAry[k].y;
				}
				//////////////////////////////////////////////////////////////////////////


				//		CalNewZB(road[iroad].hdmdes[i].offsetX,road[iroad].hdmdmx[i].EarH,Learpt,road[iroad].hdmdmx[i].ZEarPtNum,Rearpt,road[iroad].hdmdmx[i].YEarPtNum,
				//			NewYd,NewLearpt,NewNumL,NewRearpt,NewNumR);

				//左右都是桥
				if (road[iroad].hdmdes[i].ZDMXZ == 3 && road[iroad].hdmdes[i].YDMXZ == 3)
					continue;
				//左右都是隧
				if (road[iroad].hdmdes[i].ZDMXZ == 4 && road[iroad].hdmdes[i].YDMXZ == 4)
					continue;

				if (road[iroad].hdmdes[i].ZDMXZ == -1 || road[iroad].hdmdes[i].ZDMXZ == -2
					|| road[iroad].hdmdes[i].YDMXZ == -1 || road[iroad].hdmdes[i].YDMXZ == -2)
				{
					pt.x = road[iroad].hdmdes[i].tX0;//桥隧处标注点
					pt.y = road[iroad].hdmdes[i].tY0;
					BiaoZhuQS(iroad, road[iroad].hdmdes[i].cml, pt); //标注桥隧位置
				}

				pCross.m_OriPoint.x = road[iroad].hdmdes[i].Xo;
				pCross.m_OriPoint.y = road[iroad].hdmdes[i].Yo;	//每个断面的绘图原点
				pCross.m_BTinf = road[iroad].hdmdes[i].ZDMXZ;
				//	road[iroad].hdmdes[i].xlxz=0;road[iroad].hdmdes[i].r_bh=-1;//一线，用于交互设计

				setCROSSAutoDesignData(pCross, iroad, i, road[iroad].hdmdmx[i].EarH,
					Learpt, road[iroad].hdmdmx[i].ZEarPtNum, Rearpt, road[iroad].hdmdmx[i].YEarPtNum,
					LBenchPt, road[iroad].hdmBench[i].ZEarPtNum, RBenchPt, road[iroad].hdmBench[i].YEarPtNum);

				pCross.DorS = road[iroad].hdmdes[i].DorS;
				pCross.offset = road[iroad].hdmdes[i].offsetX;//一线中心线相对与新的地面线的移动量

			}
			if (road[iroad].hdmdes[i].DorS == 2)//双路面
			{

				//				CalNewZB(road[iroad].hdmdes[jcross].offsetX,road[iroad].hdmdes[jcross].EarH,road[iroad].hdmdes[jcross].Learpt,road[iroad].hdmdes[jcross].NumL,road[iroad].hdmdes[jcross].Rearpt,road[iroad].hdmdes[jcross].NumR,
				//					LNewYd,Z_NewLearpt,Z_NewNumL,Z_NewRearpt,Z_NewNumR);
				//				CalNewZB(road[iroad].hdmdes[jcross].YoffsetX,road[iroad].hdmdes[jcross].EarH,road[iroad].hdmdes[jcross].Learpt,road[iroad].hdmdes[jcross].NumL,road[iroad].hdmdes[jcross].Rearpt,road[iroad].hdmdes[jcross].NumR,
				//					RNewYd,Y_NewLearpt,Y_NewNumL,Y_NewRearpt,Y_NewNumR);
				//				
				//				if((fabs(road[iroad].hdmdes[jcross].BTinf-1.0)<0.1 || fabs(road[iroad].hdmdes[jcross].BTinf-2.0)<0.1||fabs(road[iroad].hdmdes[jcross].BTinf-6.0)<0.1)
				//					&&(fabs(road[iroad].hdmdes[jcross].Y_BTinf-1.0)<0.1 || fabs(road[iroad].hdmdes[jcross].Y_BTinf-2.0)<0.1||fabs(road[iroad].hdmdes[jcross].Y_BTinf-6.0)<0.1))
				//				{
				//					
				//					if(i>1&&(Crs[i-1].BTinf!=1&&Crs[i-1].BTinf!=2&&Crs[i-1].BTinf!=6&&Crs[i-1].Lnpt!=0)||(Crs[i-1].Y_BTinf!=1&&Crs[i-1].Y_BTinf!=2&&Crs[i-1].Y_BTinf!=6&&Crs[i-1].Y_Lnpt!=0))	
				//					{
				//						position.x=Crs[i-1].tX0;//桥隧处标注点
				//						position.y=Crs[i-1].tY0;
				//						BaiZhuQS(i,position); //标注桥隧位置
				//					}
				//					continue;
				//				}
				//				pCross.m_OriPoint.x = road[iroad].hdmdes[jcross].Xo;	//每个断面的绘图原点
				//				pCross.m_OriPoint.y = road[iroad].hdmdes[jcross].Yo;
				//				pCross.m_BTinf = road[iroad].hdmdes[jcross].BTinf;
				//				road[iroad].hdmdes[jcross].xlxz=0;road[iroad].hdmdes[jcross].r_bh=-1;//一线，用于交互设计
				//				setCROSSAutoDesignData(pCross,i,LNewYd,Z_NewLearpt,Z_NewNumL,Z_NewRearpt,Z_NewNumR);//左线
				//				
				//				//pCross.m_YBTinf = road[iroad].hdmdes[jcross].Y_BTinf;	//右线是一线
				//				Y_setCROSSAutoDesignData(pCross,i,RNewYd);
				//				
				//				pCross.DorS=road[iroad].hdmdes[jcross].DorS;
				//				pCross.offset=road[iroad].hdmdes[jcross].offsetX;//一线中心线相对与新的地面线的移动量
				//				pCross.Yoffset=road[iroad].hdmdes[jcross].YoffsetX;
			}
			//////////////绘图部分 
			//			for(j=0;j<NZRXD;j++)//如果里程在左线的完全绕开的里程段，线间距视为0
			//			{
			//				if(road[iroad].hdmdes[jcross].DorS==1&&road[iroad].hdmdes[jcross].cml>ZRXD[j].RXDsml2-0.1 &&road[iroad].hdmdes[jcross].cml<ZRXD[j].RXDeml2+0.1)
			//				{road[iroad].hdmdes[jcross].Zxjj=0;break;}
			//				
			//			}
			//			
			//			for(j=0;j<NYRXD;j++)//如果里程在左（右）线的完全绕开的里程段，线间距视为0
			//			{
			//				if(road[iroad].hdmdes[jcross].DorS==1&&road[iroad].hdmdes[jcross].cml>YRXD[j].RXDsml2-0.1 &&road[iroad].hdmdes[jcross].cml<YRXD[j].RXDeml2+0.1)
			//				{road[iroad].hdmdes[jcross].Yxjj=0;	break;}//出循环
			//			}
			//			
			//			if(ZXSM=="单线")
			//			{  road[iroad].hdmdes[jcross].Zxjj=0.0;  road[iroad].hdmdes[jcross].Yxjj=0.0;}
			pCross.xjj = road[iroad].hdmdes[i].xjj;
			//pCross.yxjj = 0.0;//road[iroad].hdmdes[jcross].Yxjj;	//绘制中心线

			pCross.Draw();
			road[iroad].hdmdes[i].LgouId = pCross.LgouId;
			road[iroad].hdmdes[i].RgouId = pCross.RgouId;
			//画图框	
		}
	}
	acedSetStatusBarProgressMeterPos(100);
	acedRestoreStatusBar();

}
//------------------------------------------------------------------------
//计算所有断面的绘图原点
void HdmDes::Cal_CrossOriPt(int iroad, AcGePoint3d StartPt)
{
	double Yllev, Ymlev, Yrlev, YY, Ymin, Xmin, Ymax, Xmax, Xo, Yo;
	double hi, wi, h, wmax = 0;
	int j;
	double x_start, y_start, tx, ty, DX, DY, dx, dy;
	double WIDE;
	int jcross;
	double ZYmin, YYmin;
	double ZYmax, YYmax;

	WIDE = 53 * Sfactor;//265
	DX = 8 * Sfactor, DY = 16 * Sfactor;
	dx = 0.0, dy = 0.0, h = 0.0;//桥隧处
	x_start = StartPt.x + 10.0 + 20.0;
	y_start = StartPt.y + 5.0 + 50.0;
	tx = x_start, ty = y_start;
	wmax = 0.0;

	//NCRS=2;
	//  for(iroad=0; iroad<RoadSum; iroad++)
	//{
	for (jcross = 0; jcross < road[iroad].NCRS; jcross++)
	{
		if (road[iroad].hdmdes[jcross].DorS == 1)
		{

			Xmin = Ymin = 100000000000.0;
			Xmax = Ymax = -100000000000.0;

			Yllev = road[iroad].hdmdes[jcross].RHFL[9];//左侧路肩高程
			Yrlev = road[iroad].hdmdes[jcross].RHFR[9];//右侧路肩高程
			Ymin = Yllev < Yrlev ? Yllev : Yrlev;

			Ymlev = road[iroad].hdmdes[jcross].RHFL[1] > road[iroad].hdmdes[jcross].RHFR[1] ? road[iroad].hdmdes[jcross].RHFL[1] : road[iroad].hdmdes[jcross].RHFR[1];
			Ymax = Yllev > Ymlev ? Yllev : Ymlev;
			Ymax = Ymax < Yrlev ? Ymax : Yrlev;

			for (j = 0; j < road[iroad].hdmdmx[jcross].ZEarPtNum; j++)
			{
				YY = road[iroad].hdmdmx[jcross].ZEarPtAry[j].y + road[iroad].hdmdmx[jcross].EarH;
				Ymax = YY > Ymax ? YY : Ymax;
				Ymin = YY < Ymin ? YY : Ymin;
			}

			if (road[iroad].hdmdmx[jcross].ZEarPtNum > 0)
				Xmin = fabs(road[iroad].hdmdmx[jcross].ZEarPtAry[road[iroad].hdmdmx[jcross].ZEarPtNum - 1].x);
			for (j = 0; j < road[iroad].hdmdmx[jcross].YEarPtNum; j++)
			{
				YY = road[iroad].hdmdmx[jcross].YEarPtAry[j].y + road[iroad].hdmdmx[jcross].EarH;
				Ymax = YY > Ymax ? YY : Ymax;
				Ymin = YY < Ymin ? YY : Ymin;
			}
			if (j > 0)
				Xmax = road[iroad].hdmdmx[jcross].YEarPtAry[j - 1].x;

		}
		else if (road[iroad].hdmdes[jcross].DorS == 2)
		{
			Xmin = Ymin = 100000000000.0;
			Xmax = Ymax = -100000000000.0;

			Yllev = road[iroad].hdmdes[jcross].RHFL[9];//左侧路肩高程
			Yrlev = road[iroad].hdmdes[jcross].RHFR[9];//右侧路肩高程
			ZYmin = Yllev < Yrlev ? Yllev : Yrlev;
			Yllev = road[iroad].hdmdes[jcross].Y_RHFL[9];//左侧路肩高程
			Yrlev = road[iroad].hdmdes[jcross].Y_RHFR[9];//右侧路肩高程
			YYmin = Yllev < Yrlev ? Yllev : Yrlev;
			Ymin = ZYmin < YYmin ? ZYmin : YYmin;


			Yllev = road[iroad].hdmdes[jcross].RHFL[9];//左侧路肩高程
			Yrlev = road[iroad].hdmdes[jcross].RHFR[9];//右侧路肩高程
			Ymlev = road[iroad].hdmdes[jcross].RHFL[1] > road[iroad].hdmdes[jcross].RHFR[1] ? road[iroad].hdmdes[jcross].RHFL[1] : road[iroad].hdmdes[jcross].RHFR[1];
			ZYmax = Yllev > Ymlev ? Yllev : Ymlev;
			ZYmax = ZYmax > Yrlev ? ZYmax : Yrlev;


			Yllev = road[iroad].hdmdes[jcross].Y_RHFL[9];//左侧路肩高程
			Yrlev = road[iroad].hdmdes[jcross].Y_RHFR[9];//右侧路肩高程
			Ymlev = road[iroad].hdmdes[jcross].Y_RHFL[1] > road[iroad].hdmdes[jcross].Y_RHFR[1] ? road[iroad].hdmdes[jcross].Y_RHFL[1] : road[iroad].hdmdes[jcross].Y_RHFR[1];
			YYmax = Yllev > Ymlev ? Yllev : Ymlev;
			YYmax = YYmax > Yrlev ? YYmax : Yrlev;

			Ymax = ZYmax > YYmax ? ZYmax : YYmax;

			for (j = 0; j < road[iroad].hdmdmx[jcross].ZEarPtNum; j++)
			{
				YY = road[iroad].hdmdmx[jcross].ZEarPtAry[j].y + road[iroad].hdmdmx[jcross].EarH;
				Ymax = YY > Ymax ? YY : Ymax;
				Ymin = YY < Ymin ? YY : Ymin;
			}
			Xmin = fabs(road[iroad].hdmdmx[jcross].ZEarPtAry[road[iroad].hdmdmx[jcross].ZEarPtNum - 1].x);

			for (j = 0; j < road[iroad].hdmdmx[jcross].YEarPtNum; j++)
			{
				YY = road[iroad].hdmdmx[jcross].YEarPtAry[j].y + road[iroad].hdmdmx[jcross].EarH;
				Ymax = YY > Ymax ? YY : Ymax;
				Ymin = YY < Ymin ? YY : Ymin;
			}

			Xmax = road[iroad].hdmdmx[jcross].YEarPtAry[road[iroad].hdmdmx[jcross].YEarPtNum - 1].x;
		}
		/*-----------------------------------------------------*/

		Xo = tx, Yo = ty;
		hi = Sfactor * (Ymax - Ymin);
		wi = Sfactor * (Xmax + Xmin);

		//如果是桥隧中间断面,continue不画
		if (road[iroad].hdmdes[jcross].DorS == 1)
		{
			if ((road[iroad].hdmdes[jcross].ZDMXZ == 3 && road[iroad].hdmdes[jcross].YDMXZ == 3) ||
				(road[iroad].hdmdes[jcross].ZDMXZ == 4 && road[iroad].hdmdes[jcross].YDMXZ == 4) ||
				(road[iroad].hdmdes[jcross].Lnpt == 0 && road[iroad].hdmdes[jcross].Rnpt == 0))//桥隧处画，饶行段的过度段在一线里考滤,绕行段桥隧信息为0，点数为0。
			{
				road[iroad].hdmdes[jcross].Xo = Xo;
				road[iroad].hdmdes[jcross].Yo = Yo;
				road[iroad].hdmdes[jcross].Ymin = Ymin;
				road[iroad].hdmdes[jcross].Ymax = Ymax;
				continue;
			}

		}

		if (road[iroad].hdmdes[jcross].DorS == 2)
			if (
				(road[iroad].hdmdes[jcross].ZDMXZ == 3 &&
					road[iroad].hdmdes[jcross].YDMXZ == 3 &&
					road[iroad].hdmdes[jcross].Y_ZDMXZ == 3 &&
					road[iroad].hdmdes[jcross].Y_YDMXZ == 3) ||
					(road[iroad].hdmdes[jcross].ZDMXZ == 4 &&
						road[iroad].hdmdes[jcross].YDMXZ == 4 &&
						road[iroad].hdmdes[jcross].Y_ZDMXZ == 4 &&
						road[iroad].hdmdes[jcross].Y_YDMXZ == 4)
				)//桥隧起始里程	  
			{
				road[iroad].hdmdes[jcross].Xo = Xo;
				road[iroad].hdmdes[jcross].Yo = Yo;
				road[iroad].hdmdes[jcross].Ymin = Ymin;
				road[iroad].hdmdes[jcross].Ymax = Ymax;
				continue;
			}


		//Crs[i-1].Lnpt==0&&RXD[irxd].Crs[i-1].BTinf==0表示过度段
		//        		  else if(i>1)
		////   				&&road[iroad].hdmdes[jcross-1].Lnpt==0&&
		////				  road[iroad].hdmdes[jcross-1].ZDMXZ==0&&
		////				  (fabs(road[iroad].hdmdes[jcross-1].ZDMXZ-1.0)<0.1||
		////				  fabs(road[iroad].hdmdes[jcross].ZDMXZ-2.0)<0.1||
		////				  fabs(road[iroad].hdmdes[jcross].ZDMXZ-6.0)<0.1))//绕行段刚进入就是桥或隧道
		//			  {
		//				  road[iroad].hdmdes[jcross-1].tX0=tx-100*Sfactor;//桥隧处注释原点
		//				  road[iroad].hdmdes[jcross-1].tY0=y_start+20*Sfactor;
		//			  }

		//	  }
		//		  else if(road[iroad].hdmdes[jcross].DorS==2&&(fabs(road[iroad].hdmdes[jcross].BTinf-1.0)<0.1||fabs(road[iroad].hdmdes[jcross].BTinf-2.0)<0.1||fabs(road[iroad].hdmdes[jcross].BTinf-6.0)<0.1)
		//			  &&(fabs(road[iroad].hdmdes[jcross].Y_BTinf-1.0)<0.1||fabs(road[iroad].hdmdes[jcross].Y_BTinf-2.0)<0.1||fabs(road[iroad].hdmdes[jcross].Y_BTinf-6.0)<0.1))//双路面
		//		  {
		//			  wi=0.0;
		//			  DX=5;
		//			  if(i>1&&(fabs(Crs[i-1].BTinf+3.0)<0.1||fabs(Crs[i-1].BTinf+4.0)<0.1||fabs(Crs[i-1].BTinf+5.0)<0.1||fabs(Crs[i-1].BTinf-0.0)<0.1
		//				  ||fabs(Crs[i-1].Y_BTinf+3.0)<0.1||fabs(Crs[i-1].Y_BTinf+4.0)<0.1||fabs(Crs[i-1].Y_BTinf+5.0)<0.1||fabs(Crs[i-1].Y_BTinf-0.0)<0.1))//桥隧处不画
		//			  {
		//				  Crs[i-1].tX0=tx+0.5*wmax+12*Sfactor;
		//				  Crs[i-1].tY0=y_start+20*Sfactor;
		//			  }
		//		  }
		//	  else
		//	  DX=40;

		ty = hi + ty;
		if (ty - y_start >= WIDE)
		{
			ty = y_start;
			Yo = y_start;
			Xo = tx + wmax + DX;
			tx = Xo;
			ty = ty + hi + DY;
			wmax = wi;
		}
		else
		{
			ty = ty + DY;
			if (wi > wmax)
				wmax = wi;
		}
		road[iroad].hdmdes[jcross].Xo = Xo;
		road[iroad].hdmdes[jcross].Yo = Yo;
		road[iroad].hdmdes[jcross].Ymin = Ymin;
		road[iroad].hdmdes[jcross].Ymax = Ymax;

		if (road[iroad].hdmdes[jcross].ZDMXZ == -1 ||
			road[iroad].hdmdes[jcross].YDMXZ == -1 ||
			road[iroad].hdmdes[jcross].ZDMXZ == -2 ||
			road[iroad].hdmdes[jcross].YDMXZ == -2 ||
			road[iroad].hdmdes[jcross].Y_ZDMXZ == -1 ||
			road[iroad].hdmdes[jcross].Y_YDMXZ == -1 ||
			road[iroad].hdmdes[jcross].Y_ZDMXZ == -2 ||
			road[iroad].hdmdes[jcross].Y_YDMXZ == -2)//桥隧起始里程
		{
			road[iroad].hdmdes[jcross].tX0 = tx + 0.5*wmax + 12 * Sfactor;//桥隧处注释原点
			road[iroad].hdmdes[jcross].tY0 = y_start + 20 * Sfactor;
		}
	}
	//	}

}

//设置 Zoom的W放大形式的两个角点
void HdmDes::SetSZoomCorner(CROSS pCross, int iroad, int jcross)
{
	double xl, yl, xr, yr, yc, ZyL, ZyR;
	if (road[iroad].hdmdes[jcross].DorS == 1)
	{
		if (pCross.LeftDesignLinePart->m_DesignPointNum > 0 && pCross.RightDesignLinePart->m_DesignPointNum > 0)
		{
			xl = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].x;
			yl = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
			xr = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].x;
			yr = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y;
			yc = pCross.LeftDesignLinePart->m_DesignPoints[0].y;
			ZyL = yl; ZyR = yl;
			ZyL = yl > yr ? yl : yr;//最高点
			ZyL = ZyL > yc ? ZyL : yc;
			ZyR = yl > yr ? yr : yl;//最低点
			ZyR = ZyR > yc ? yc : ZyR;

			road[iroad].hdmdes[jcross].ZXo = xl - 4 * Sfactor; road[iroad].hdmdes[jcross].ZYo = ZyL + 6 * Sfactor;
			road[iroad].hdmdes[jcross].ZX1 = xr + 4 * Sfactor; road[iroad].hdmdes[jcross].ZY1 = ZyR - 6 * Sfactor;
			//	ads_printf(L"%lf %lf %lf %lf\n",road[iroad].hdmdes[jcross].dml,road[iroad].hdmdes[jcross].ZXo,road[iroad].hdmdes[jcross].ZYo,ZyL);
			/*
			if(fabs(road[iroad].hdmdes[jcross].cml-5455.23)<0.1)
			ads_printf(L"\n11111111xl=%lf,xr=%lf,x0=%lf,y0=%lf",xl,yr,road[iroad].hdmdes[jcross].ZXo,road[iroad].hdmdes[jcross].ZYo);*/

		}

	}
}

void HdmDes::SetSZoomCorner(CROSS pCross, RoadHdmdata &ZDroad, int jcross)
{
	double xl, yl, xr, yr, yc, ZyL, ZyR;
	if (ZDroad.hdmdes[jcross].DorS == 1)
	{
		if (pCross.LeftDesignLinePart->m_DesignPointNum > 0 && pCross.RightDesignLinePart->m_DesignPointNum > 0)
		{
			xl = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].x;
			yl = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
			xr = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].x;
			yr = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y;
			yc = pCross.LeftDesignLinePart->m_DesignPoints[0].y;
			ZyL = yl; ZyR = yl;
			ZyL = yl > yr ? yl : yr;//最高点
			ZyL = ZyL > yc ? ZyL : yc;
			ZyR = yl > yr ? yr : yl;//最低点
			ZyR = ZyR > yc ? yc : ZyR;

			ZDroad.hdmdes[jcross].ZXo = xl - 4 * Sfactor; ZDroad.hdmdes[jcross].ZYo = ZyL + 6 * Sfactor;
			ZDroad.hdmdes[jcross].ZX1 = xr + 4 * Sfactor; ZDroad.hdmdes[jcross].ZY1 = ZyR - 6 * Sfactor;
			//	ads_printf(L"%lf %lf %lf %lf\n",road[iroad].hdmdes[jcross].dml,road[iroad].hdmdes[jcross].ZXo,road[iroad].hdmdes[jcross].ZYo,ZyL);
			/*
			if(fabs(road[iroad].hdmdes[jcross].cml-5455.23)<0.1)
			ads_printf(L"\n11111111xl=%lf,xr=%lf,x0=%lf,y0=%lf",xl,yr,road[iroad].hdmdes[jcross].ZXo,road[iroad].hdmdes[jcross].ZYo);*/

		}

	}
}

void HdmDes::CalPjqPt(int zory, AcGePoint3d PJD, AcGePoint3d PrePJD, int &pjqptnum, double PjqPt[])//---wwq
{
	pjqptnum = 7;
	PjqPt[2 * 1] = PJD.x;
	PjqPt[2 * 1 + 1] = PJD.y;

	PjqPt[2 * 2] = PJD.x;
	PjqPt[2 * 2 + 1] = PJD.y - 0.5*Sfactor;

	PjqPt[2 * 3] = PjqPt[2 * 2] + zory * 0.5*Sfactor;
	PjqPt[2 * 3 + 1] = PjqPt[2 * 2 + 1];

	PjqPt[2 * 4] = PjqPt[2 * 3];
	PjqPt[2 * 4 + 1] = PjqPt[2 * 3 + 1] + 1.0*Sfactor;

	PjqPt[2 * 5] = PjqPt[2 * 4] - zory * 0.5*Sfactor;
	PjqPt[2 * 5 + 1] = PjqPt[2 * 4 + 1];
	PjqPt[2 * 0] = PjqPt[2 * 5];
	PjqPt[2 * 0 + 1] = PjqPt[2 * 5 + 1];

	AcGePoint3d spt(PjqPt[2 * 4], PjqPt[2 * 4 + 1], 0.0);
	AcGePoint3d ept;
	ept.x = spt.x - zory * 100.0*Sfactor;
	ept.y = spt.y + 100.0*Sfactor*0.04;
	ept.z = 0.0;
	double jdx, jdy;
	INTERS(&jdx, &jdy, spt.x, spt.y, ept.x, ept.y, PrePJD.x, PrePJD.y, PJD.x, PJD.y);
	PjqPt[2 * 6] = jdx;
	PjqPt[2 * 6 + 1] = jdy;
	return;

}

//计算含有浆切的水沟
void HdmDes::TGhasJQ(int zory, AcGePoint3d m_JSGouPoints[4], double TG_JQHD, double SP1, double SP2, double GS, double GDR, int &JqPtNum, AcGePoint3d JqPt[], int m_EarthPointNum, AcGePoint3d m_EarthPoints[])
{
	double gouBotPt[6], EarthPoints[200], Yd, jdx, jdy;
	int ptnum, inf;
	gouBotPt[0] = m_JSGouPoints[1].x;
	gouBotPt[1] = m_JSGouPoints[1].y;
	gouBotPt[2 * 1] = m_JSGouPoints[2].x;
	gouBotPt[2 * 1 + 1] = m_JSGouPoints[2].y;//沟底两点
	gouBotPt[2 * 2] = m_JSGouPoints[3].x;
	gouBotPt[2 * 2 + 1] = m_JSGouPoints[3].y;//沟底两点

	cal_JQpt(zory, TG_JQHD, SP1, SP2, GS, GDR, gouBotPt, JqPtNum, JqPt);//有浆切的水沟点

	for (int m = 0; m < m_EarthPointNum; m++)
	{
		EarthPoints[m * 2] = m_EarthPoints[m].x;
		EarthPoints[m * 2 + 1] = m_EarthPoints[m].y;
	}
	Gety(JqPt[4].x, m_EarthPointNum, EarthPoints, Yd, ptnum);
	SP2 = zory * SP2;
	inf = CALXY(ptnum, m_EarthPointNum, 1, SP2,
		JqPt[4].x, JqPt[4].y, 100 * Sfactor,
		&jdx, &jdy, EarthPoints);//有浆切的水沟的最外侧点与地面线的交点
	if (inf == 0)
	{
		JqPt[JqPtNum].x = jdx;
		JqPt[JqPtNum].y = jdy;
		JqPtNum++;
	}

	else
	{
		JqPt[JqPtNum].x = JqPt[4].x;
		JqPt[JqPtNum].y = JqPt[4].y;
		JqPtNum++;
	}

}
//画侧沟和线间沟的浆切
void HdmDes::CGhasJQ(int zory, AcGePoint3d m_DesignPoints[], double CG_JQHD, double SP1, double SP2, double GS, int &JqPtNum, AcGePoint3d JqPt[])
{
	// HdmDes.cpp: implementation of the HdmDes class.
	double gouBotPt[6];
	for (int m = 0; m < 3; m++)
	{
		gouBotPt[m * 2] = m_DesignPoints[m + 5].x;
		gouBotPt[m * 2 + 1] = m_DesignPoints[m + 5].y;
	}
	cal_JQpt_CG(zory, CG_JQHD, SP1, SP2, GS, gouBotPt, JqPtNum, JqPt);
}

//////////////////////////////////////////////////////////////////////////
void HdmDes::CGhasJQ(int zory, AcGePoint3d m_DesignPoints[], double CG_JQHD, double CG_GDR, int &JqPtSum, AcGePoint3d JqPtArray[])
{
	// HdmDes.cpp: implementation of the HdmDes class.
	AcGePoint3d TrueGouPtArray[14];
	int TrueGouPtSum;
	if (CG_GDR < 0.001)
	{
		for (int Index = 0; Index < 4; Index++)
		{
			TrueGouPtArray[Index] = m_DesignPoints[Index + 4];
		}
		TrueGouPtSum = 4;
	}
	else//插入沟底十个弧形点
	{
		for (int Index = 0; Index < 14; Index++)
		{
			TrueGouPtArray[Index] = m_DesignPoints[Index + 4];
		}
		TrueGouPtSum = 14;
	}

	cal_JQpt(zory, -1, TrueGouPtSum, TrueGouPtArray, CG_JQHD, JqPtSum, JqPtArray);
}
//////////////////////////////////////////////////////////////////////////

//右沟底点按标准数据推出沟的浆切点 左边zory=-1,
void HdmDes::cal_JQpt_CG(int zory, double jqhd, double SP1, double SP2, double H, double gouBotPt[6], int &JqPtNum, AcGePoint3d JqPt[])
{
	JqPt[0].x = gouBotPt[0] - zory * (H)*SP1*Sfactor;//0
	JqPt[0].y = gouBotPt[1] + (H)*Sfactor;
	JqPt[1].x = gouBotPt[0];//1
	JqPt[1].y = gouBotPt[1];
	JqPt[2].x = gouBotPt[2 * 1];//2
	JqPt[2].y = gouBotPt[2 * 1 + 1];
	JqPt[3].x = gouBotPt[2 * 1] + zory * (H)*SP2*Sfactor;//3
	JqPt[3].y = gouBotPt[2 * 1 + 1] + (H)*Sfactor;

	if (JqPt[3].y > gouBotPt[2 * 2 + 1])//按标准沟取浆切的高，如浆顶点超过地面线，则取沟高
		JqPt[3].y = gouBotPt[2 * 2 + 1];

	JqPt[4].x = JqPt[3].x + zory * jqhd*sqrt(1 + SP2 * SP2)*Sfactor;//4
	JqPt[4].y = JqPt[3].y;
	JqPt[5].x = JqPt[2].x + zory * Sfactor*(jqhd)*tan(0.5*atan(1.0 / SP2));//5
	JqPt[5].y = JqPt[2].y - Sfactor * (jqhd);

	JqPt[7].x = JqPt[0].x - zory * jqhd*sqrt(1 + SP1 * SP1)*Sfactor;//7
	JqPt[7].y = JqPt[0].y;
	JqPt[6].x = JqPt[1].x - zory * Sfactor*(jqhd)*tan(0.5*atan(1.0 / SP1));//6
	JqPt[6].y = JqPt[1].y - Sfactor * (jqhd);

	JqPt[8].x = JqPt[0].x;//8
	JqPt[8].y = JqPt[0].y;
	JqPtNum = 9;

}


//右沟底点按标准数据推出沟的浆切点 左边zory=-1,
void HdmDes::cal_JQpt(int zory, double jqhd, double SP1, double SP2, double H, double GDR, double gouBotPt[6], int &JqPtNum, AcGePoint3d JqPt[])
{
	//JqPt[0].x = gouBotPt[0] - zory * (H + jqhd) * SP1 * Sfactor;//0
	//JqPt[0].y = gouBotPt[1] + (H + jqhd) * Sfactor;
	JqPt[0].x = gouBotPt[0] - zory * H * SP1 * Sfactor;//0
	JqPt[0].y = gouBotPt[1] + H * Sfactor;
	JqPt[1].x = gouBotPt[0];//1
	JqPt[1].y = gouBotPt[1];
	JqPt[2].x = gouBotPt[2 * 1];//2
	JqPt[2].y = gouBotPt[2 * 1 + 1];
	//JqPt[3].x = gouBotPt[2 * 1] + zory * (H + jqhd) * SP2 * Sfactor;//3
	//JqPt[3].y = gouBotPt[2 * 1 + 1] + (H + jqhd) * Sfactor;
	JqPt[3].x = gouBotPt[2 * 1] + zory * H * SP2 * Sfactor;//3
	JqPt[3].y = gouBotPt[2 * 1 + 1] + H * Sfactor;

	if (JqPt[3].y > gouBotPt[2 * 2 + 1])//按标准沟取浆切的高，如浆顶点超过地面线，则取沟高
		JqPt[3].y = gouBotPt[2 * 2 + 1];

	//JqPt[4].x=JqPt[3].x-zory*jqhd*sqrt(1+SP2*SP2)*Sfactor;//4
	JqPt[4].x = JqPt[3].x + zory * jqhd * sqrt(1 + SP2 * SP2) * Sfactor;//4
	JqPt[4].y = JqPt[3].y;
	//if (fabs(SP2)<0.001)
	//	JqPt[5].x = JqPt[2].x - zory * Sfactor * (jqhd);//5
	//else
	//	JqPt[5].x = JqPt[2].x - zory * Sfactor * (jqhd)* tan(0.5 * atan(1.0 / SP2));//5
	//JqPt[5].y = JqPt[2].y + Sfactor * (jqhd);
	if (fabs(SP2) < 0.001)
		JqPt[5].x = JqPt[2].x + zory * Sfactor * (jqhd);//5
	else
		JqPt[5].x = JqPt[2].x + zory * Sfactor * (jqhd)* tan(0.5 * atan(1.0 / SP2));//5
	JqPt[5].y = JqPt[2].y - Sfactor * (jqhd);

	//JqPt[7].x=JqPt[0].x+zory*jqhd*sqrt(1+SP1*SP1)*Sfactor;//7
	JqPt[7].x = JqPt[0].x - zory * jqhd * sqrt(1 + SP1 * SP1) * Sfactor;//7
	JqPt[7].y = JqPt[0].y;

	//if (fabs(SP1) < 0.001)
	//	JqPt[6].x = JqPt[1].x + zory * Sfactor * (jqhd);//6
	//else
	//	JqPt[6].x = JqPt[1].x + zory * Sfactor * (jqhd)* tan(0.5 * atan(1.0 / SP1));//6
	//JqPt[6].y = JqPt[1].y + Sfactor * (jqhd);
	if (fabs(SP1) < 0.001)
		JqPt[6].x = JqPt[1].x - zory * Sfactor * (jqhd);//6
	else
		JqPt[6].x = JqPt[1].x - zory * Sfactor * (jqhd)* tan(0.5 * atan(1.0 / SP1));//6
	JqPt[6].y = JqPt[1].y - Sfactor * (jqhd);

	JqPt[8].x = JqPt[0].x;//8
	JqPt[8].y = JqPt[0].y;
	JqPtNum = 9;

	//////////////////////////////////////////////////////////////////////////
	//在下标为1和2的两浆砌点之间补充10个圆弧点
	if (GDR > 0.001)//如果有沟底半径，需内插水沟点
	{
		double spt[2], ept[2];
		if (zory > 0)
		{
			spt[0] = JqPt[1].x;
			spt[1] = JqPt[1].y;
			ept[0] = JqPt[2].x;
			ept[1] = JqPt[2].y;
		}
		else
		{
			spt[0] = JqPt[2].x;
			spt[1] = JqPt[2].y;
			ept[0] = JqPt[1].x;
			ept[1] = JqPt[1].y;
		}

		double pt[30];
		GetArcPt(spt, ept, GDR*Sfactor, 10, pt);
		AcGePoint2d tmpPt;
		AcDbPolyline* pLine = new AcDbPolyline(10);
		for (int j = 0; j < 10; j++)
		{
			tmpPt.x = pt[j * 2];
			tmpPt.y = pt[j * 2 + 1];
			pLine->addVertexAt(j, tmpPt);
		}

		AcDbVoidPtrArray VoidPtrArray;
		double offset = -1.0*jqhd*Sfactor;
		pLine->getOffsetCurves(offset, VoidPtrArray);
		//pLine = (AcDbPolyline*)(VoidPtrArray[0]);
		if (VoidPtrArray.length() > 0)
			pLine = (AcDbPolyline*)(VoidPtrArray[0]);

		//2修正设计点
		int npt, i;
		double despt[200];
		npt = 0;
		for (i = 0; i <= 1; i++)
		{
			despt[npt * 2] = JqPt[i].x;
			despt[npt * 2 + 1] = JqPt[i].y;
			npt++;
		}
		if (zory > 0)
		{
			for (i = 0; i < 10; i++)
			{
				//  			despt[npt*2] = pt[i*2];
				//  			despt[npt*2+1] = pt[i*2+1];	
				pLine->getPointAt(i, tmpPt);
				despt[npt * 2] = tmpPt.x;
				despt[npt * 2 + 1] = tmpPt.y;
				npt++;
			}
		}
		else
		{
			for (i = 9; i > -1; i--)
			{
				despt[npt * 2] = pt[i * 2];
				despt[npt * 2 + 1] = pt[i * 2 + 1];
				npt++;
			}
		}
		for (i = 2; i < JqPtNum; i++)
		{
			despt[npt * 2] = JqPt[i].x;
			despt[npt * 2 + 1] = JqPt[i].y;
			npt++;
		}

		JqPtNum = npt;
		for (i = 0; i < JqPtNum; i++)
		{
			JqPt[i].x = despt[i * 2];
			JqPt[i].y = despt[i * 2 + 1];
		}
	}
	//////////////////////////////////////////////////////////////////////////

}
void HdmDes::SGhasJQ(int zory, int SGptNum, AcGePoint3d m_SGouPoints[], double SG_JQHD, double SP1, double SP2, double GS, double GDR, int &JqPtNum, AcGePoint3d JqPt[])
{
	// HdmDes.cpp: implementation of the HdmDes class.
	double gouBotPt[6];
	JqPtNum = 0;


	double FactGS, FactSP1, FactSP2;//实际沟深，坡率
	FactGS = (m_SGouPoints[1].y - m_SGouPoints[2].y) / Sfactor - SG_JQHD;
	if (FactGS < GS)
		GS = FactGS;

	if (SGptNum > 5 && SGptNum < 9)
	{
		FactSP1 = fabs((m_SGouPoints[2].x - m_SGouPoints[1].x) / (m_SGouPoints[2].y - m_SGouPoints[1].y));
		FactSP2 = fabs((m_SGouPoints[4].x - m_SGouPoints[3].x) / (m_SGouPoints[4].y - m_SGouPoints[3].y));
		SP1 = FactSP1;
		SP2 = FactSP2;
		gouBotPt[0] = m_SGouPoints[2].x;//沟底两点
		gouBotPt[1] = m_SGouPoints[2].y;
		gouBotPt[2 * 1] = m_SGouPoints[3].x;//沟底两点
		gouBotPt[2 * 1 + 1] = m_SGouPoints[3].y;
		gouBotPt[2 * 2] = m_SGouPoints[4].x;
		gouBotPt[2 * 2 + 1] = m_SGouPoints[4].y;
		//SG_JQHD = -SG_JQHD;
		cal_JQpt(zory, SG_JQHD, SP1, SP2, GS, GDR, gouBotPt, JqPtNum, JqPt);//有浆切的水沟点
	}

	if (SGptNum > 15 && SGptNum < 19)
	{
		FactSP1 = fabs((m_SGouPoints[2].x - m_SGouPoints[1].x) / (m_SGouPoints[2].y - m_SGouPoints[1].y));
		FactSP2 = fabs((m_SGouPoints[14].x - m_SGouPoints[13].x) / (m_SGouPoints[14].y - m_SGouPoints[13].y));
		SP1 = FactSP1;
		SP2 = FactSP2;
		gouBotPt[0] = m_SGouPoints[2].x;//沟底两点
		gouBotPt[1] = m_SGouPoints[2].y;
		gouBotPt[2 * 1] = m_SGouPoints[13].x;//沟底两点
		gouBotPt[2 * 1 + 1] = m_SGouPoints[13].y;
		gouBotPt[2 * 2] = m_SGouPoints[14].x;
		gouBotPt[2 * 2 + 1] = m_SGouPoints[14].y;
		//SG_JQHD = -SG_JQHD;
		cal_JQpt(zory, SG_JQHD, SP1, SP2, GS, GDR, gouBotPt, JqPtNum, JqPt);//有浆切的水沟点
	}

}

//////////////////////////////////////////////////////////////////////////
void HdmDes::SGhasJQ(int zory, int GouPtSum, AcGePoint3d GouPtArray[], double JQHD, int &JqPtSum, AcGePoint3d JqPtArray[])
{
	// HdmDes.cpp: implementation of the HdmDes class.
	AcGePoint3d TrueGouPtArray[14];
	int TrueGouPtSum;
	if (GouPtSum > 5 && GouPtSum < 9)
	{
		for (int Index = 0; Index < 4; Index++)
		{
			TrueGouPtArray[Index] = GouPtArray[Index + 1];
		}
		TrueGouPtSum = 4;
	}
	if (GouPtSum > 15 && GouPtSum < 19)
	{
		for (int Index = 0; Index < 14; Index++)
		{
			TrueGouPtArray[Index] = GouPtArray[Index + 1];
		}
		TrueGouPtSum = 14;
	}
	if (GouPtSum == 6 || GouPtSum == 16)
		cal_JQpt(zory, -1, TrueGouPtSum, TrueGouPtArray, JQHD, JqPtSum, JqPtArray);
	else
		cal_JQpt(zory, 1, TrueGouPtSum, TrueGouPtArray, JQHD, JqPtSum, JqPtArray);

}
//////////////////////////////////////////////////////////////////////////
//LQGorLDG		路堤还是路堑水沟 -1-路堑 +1-路堤
//////////////////////////////////////////////////////////////////////////
void HdmDes::cal_JQpt(int zory, int LQGorLDG, int GouPtSum, AcGePoint3d GouPtArray[], double JQHD, int &JqPtSum, AcGePoint3d JqPtArray[])
{
	// HdmDes.cpp: implementation of the HdmDes class.
	JqPtSum = 0;
	if (fabs(JQHD) < 0.001)
		return;
	double SP1, SP2, GS;
	double TopJQPt1[2], TopJQPt2[2];
	GS = (GouPtArray[0].y - GouPtArray[1].y) / Sfactor - JQHD;
	if (fabs(GS) < 0.001)
	{
		AfxMessageBox(L"水沟截面数据设置有误！！！请核查！");
		return;
	}

	if (GouPtSum == 4)
	{
		if (fabs(GouPtArray[1].y - GouPtArray[0].y) < 0.001)
			SP1 = 0.0;
		else
			SP1 = fabs((GouPtArray[1].x - GouPtArray[0].x) / (GouPtArray[1].y - GouPtArray[0].y));
		if (fabs(GouPtArray[3].y - GouPtArray[2].y) < 0.001)
			SP2 = 0.0;
		else
			SP2 = fabs((GouPtArray[3].x - GouPtArray[2].x) / (GouPtArray[3].y - GouPtArray[2].y));

		//计算沟顶的两个浆砌点
		TopJQPt1[0] = GouPtArray[3].x - zory * LQGorLDG*JQHD*sqrt(1 + SP2 * SP2)*Sfactor;
		TopJQPt1[1] = GouPtArray[3].y;
		TopJQPt2[0] = GouPtArray[0].x + zory * LQGorLDG*JQHD*sqrt(1 + SP1 * SP1)*Sfactor;
		TopJQPt2[1] = GouPtArray[0].y;
		if (fabs(TopJQPt1[0] - TopJQPt2[0]) < 0.001)
		{
			AfxMessageBox(L"水沟截面数据设置有误！！！请核查！");
			return;
		}

		//将水沟设计点偏移一个浆砌厚度
		AcGePoint2d tmpPt;
		AcDbPolyline* pGouPline = new AcDbPolyline();//水沟点多段线
		AcDbPolyline* pJQPline = new AcDbPolyline();//浆砌点多段线
		int Index;
		for (Index = 0; Index < 4; Index++)
		{
			tmpPt.x = GouPtArray[Index].x;
			tmpPt.y = GouPtArray[Index].y;
			pGouPline->addVertexAt(Index, tmpPt);
		}
		AcDbVoidPtrArray offsetCurves;
		double offset = -1.0*zory*LQGorLDG*JQHD*Sfactor;
		int rc = pGouPline->getOffsetCurves(offset, offsetCurves);
		//pJQPline = (AcDbPolyline*)(offsetCurves[0]);
		if (offsetCurves.length() > 0)
			pJQPline = (AcDbPolyline*)(offsetCurves[0]);

		for (Index = 0; Index < 4; Index++)
		{
			JqPtArray[Index] = GouPtArray[Index];
		}

		for (Index = 4; Index < 8; Index++)
		{
			pJQPline->getPointAt(7 - Index, JqPtArray[Index]);
		}
		JqPtArray[4].x = TopJQPt1[0];
		JqPtArray[4].y = TopJQPt1[1];
		JqPtArray[7].x = TopJQPt2[0];
		JqPtArray[7].y = TopJQPt2[1];
		JqPtArray[8] = JqPtArray[0];
		JqPtSum = 9;
	}

	if (GouPtSum == 14)
	{
		if (fabs(GouPtArray[1].y - GouPtArray[0].y) < 0.001)
			SP1 = 0.0;
		else
			SP1 = fabs((GouPtArray[1].x - GouPtArray[0].x) / (GouPtArray[1].y - GouPtArray[0].y));
		if (fabs(GouPtArray[13].y - GouPtArray[12].y) < 0.001)
			SP2 = 0.0;
		else
			SP2 = fabs((GouPtArray[13].x - GouPtArray[12].x) / (GouPtArray[13].y - GouPtArray[12].y));

		//计算沟顶的两个浆砌点
		TopJQPt1[0] = GouPtArray[13].x - zory * LQGorLDG*JQHD*sqrt(1 + SP2 * SP2)*Sfactor;
		TopJQPt1[1] = GouPtArray[13].y;
		TopJQPt2[0] = GouPtArray[0].x + zory * LQGorLDG*JQHD*sqrt(1 + SP1 * SP1)*Sfactor;
		TopJQPt2[1] = GouPtArray[0].y;
		if (fabs(TopJQPt1[0] - TopJQPt2[0]) < 0.001)
		{
			AfxMessageBox(L"水沟截面数据设置有误！！！请核查！");
			return;
		}
		//将水沟设计点偏移一个浆砌厚度
		AcGePoint2d tmpPt;
		AcDbPolyline* pGouPline = new AcDbPolyline();//水沟点多段线
		AcDbPolyline* pJQPline = new AcDbPolyline();//浆砌点多段线
		int Index;
		for (Index = 0; Index < 14; Index++)
		{
			tmpPt.x = GouPtArray[Index].x;
			tmpPt.y = GouPtArray[Index].y;
			pGouPline->addVertexAt(Index, tmpPt);
		}

		AcDbVoidPtrArray offsetCurves;
		double offset = -1.0*zory*LQGorLDG*JQHD*Sfactor;
		pGouPline->getOffsetCurves(offset, offsetCurves);
		//pJQPline = (AcDbPolyline*)(offsetCurves[0]);
		if (offsetCurves.length() > 0)
			pJQPline = (AcDbPolyline*)(offsetCurves[0]);
		int NumVectors = pJQPline->numVerts();

		for (Index = 0; Index < 14; Index++)
		{
			JqPtArray[Index] = GouPtArray[Index];
		}

		for (Index = 14; Index < 14 + NumVectors; Index++)
		{
			pJQPline->getPointAt(13 + NumVectors - Index, JqPtArray[Index]);
		}
		JqPtArray[14].x = TopJQPt1[0];
		JqPtArray[14].y = TopJQPt1[1];
		JqPtArray[27].x = TopJQPt2[0];
		JqPtArray[27].y = TopJQPt2[1];
		for (Index = 13 + NumVectors; Index < 27; Index++)
		{
			JqPtArray[Index] = JqPtArray[27];
		}
		JqPtArray[28] = JqPtArray[0];
		JqPtSum = 29;
	}

}
//////////////////////////////////////////////////////////////////////////


void HdmDes::SetDZoomCorner(CROSS pCross, int iroad, int jcross)
{
	double xl, yl, xr, yr, yc, ZyL, ZyR;
	if (road[iroad].hdmdes[jcross].DorS == 2)
	{
		if (pCross.LeftDesignLinePart && pCross.LeftDesignLinePart->m_DesignPointNum > 0 && pCross.Y_RightDesignLinePart&& pCross.Y_RightDesignLinePart->m_DesignPointNum > 0)
		{
			xl = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].x;
			yl = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
			xr = pCross.Y_RightDesignLinePart->m_DesignPoints[pCross.Y_RightDesignLinePart->m_DesignPointNum - 1].x;
			yr = pCross.Y_RightDesignLinePart->m_DesignPoints[pCross.Y_RightDesignLinePart->m_DesignPointNum - 1].y;
			yc = pCross.LeftDesignLinePart->m_DesignPoints[0].y;
		}
		else if (pCross.LeftDesignLinePart && pCross.LeftDesignLinePart->m_DesignPointNum > 0)
		{
			xl = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].x;
			yl = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
			xr = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].x;
			yr = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y;
			yc = pCross.LeftDesignLinePart->m_DesignPoints[0].y;
		}
		else if (pCross.Y_RightDesignLinePart && pCross.Y_RightDesignLinePart->m_DesignPointNum > 0)
		{
			xl = pCross.Y_LeftDesignLinePart->m_DesignPoints[pCross.Y_LeftDesignLinePart->m_DesignPointNum - 1].x;
			yl = pCross.Y_LeftDesignLinePart->m_DesignPoints[pCross.Y_LeftDesignLinePart->m_DesignPointNum - 1].y;
			xr = pCross.Y_RightDesignLinePart->m_DesignPoints[pCross.Y_RightDesignLinePart->m_DesignPointNum - 1].x;
			yr = pCross.Y_RightDesignLinePart->m_DesignPoints[pCross.Y_RightDesignLinePart->m_DesignPointNum - 1].y;
			yc = pCross.Y_LeftDesignLinePart->m_DesignPoints[0].y;
		}

		if (pCross.LeftDesignLinePart && pCross.LeftDesignLinePart->m_DesignPointNum > 0 || pCross.Y_RightDesignLinePart && pCross.Y_RightDesignLinePart->m_DesignPointNum > 0)
		{
			ZyL = yl; ZyR = yl;
			ZyL = yl > yr ? yl : yr;
			ZyL = ZyL > yc ? ZyL : yc;
			ZyR = yl > yr ? yr : yl;
			ZyR = ZyR > yc ? yc : ZyR;
			road[iroad].hdmdes[jcross].ZXo = xl - 4 * Sfactor; road[iroad].hdmdes[jcross].ZYo = ZyL + 6 * Sfactor;
			road[iroad].hdmdes[jcross].ZX1 = xr + 4 * Sfactor; road[iroad].hdmdes[jcross].ZY1 = ZyR - 6 * Sfactor;

		}

	}

}
int HdmDes::INTERS(double *x, double *y, double X1, double Y1, double X2, double Y2, double X3, double Y3, double X4, double Y4)
{
	double A11, A12, A21, A22, B1, B2, D, D1, D2;
	int INF;
	double X1min, Y1min, X2min, Y2min, X1max, Y1max, X2max, Y2max;
	double Len1, Len2;
	Len1 = sqrt((X1 - X2)*(X1 - X2) + (Y1 - Y2)*(Y1 - Y2));
	Len2 = sqrt((X3 - X4)*(X3 - X4) + (Y3 - Y4)*(Y3 - Y4));
	if (Len1 < 0.001 || Len2 < 0.001)
		return -1;

	A11 = Y2 - Y1;
	A12 = X1 - X2;
	A21 = Y4 - Y3;
	A22 = X3 - X4;
	B1 = X1 * Y2 - X2 * Y1;
	B2 = X3 * Y4 - X4 * Y3;
	D = A11 * A22 - A21 * A12;
	if (fabs(D) < 1.0E-5)
		INF = -1;
	else
	{
		D1 = B1 * A22 - B2 * A12;
		D2 = B2 * A11 - B1 * A21;
		*x = D1 / D;
		*y = D2 / D;

		X1min = min(X1, X2) - 0.001;
		X1max = max(X1, X2) + 0.001;
		Y1min = min(Y1, Y2) - 0.001;
		Y1max = max(Y1, Y2) + 0.001;
		X2min = min(X3, X4) - 0.001;
		X2max = max(X3, X4) + 0.001;
		Y2min = min(Y3, Y4) - 0.001;
		Y2max = max(Y3, Y4) + 0.001;

		if (X1min <= *x && *x <= X1max && Y1min <= *y && *y <= Y1max
			&& X2min <= *x && *x <= X2max
			&& Y2min <= *y && *y <= Y2max)
			INF = 0;
		else
			INF = 1;
	}
	return INF;
}


double  HdmDes::SearchLJFLml(int iroad, double startml, double endml, int &j, bool FrontORBack, int zory, double& sml1, double &zsml1)//true:向前,false:向后
{
	sml1 = startml;//路肩分离处里程
	double XJJ, LJFLK, zxlmbk, flxlmbk, CmlOnFLD;
	xlpoint PZ;
	int i = 0;
	double half_fgdk, lydk, cxdk, yljk, tljk, tljhp;
	int bkmode, sjbgmode;


	while (i < road[0].NCRS && road[0].hdmdes[i].cml < startml - 0.001)
		i++;

	if (i >= road[0].NCRS)
		return sml1;


	if (FrontORBack)//向前里程增加方向搜索
	{
		while (i < road[0].NCRS && road[0].hdmdes[i].cml < endml)
		{
			// 计算路肩分离宽
			PZ.lc = road[0].hdmdes[i].cml;
			road[0].pm->xlpoint_pz(&PZ);
			CmlOnFLD = road[iroad].pm->PROJ_ML(PZ.x, PZ.y);
			XJJ = road[0].hdmdes[i].xjj;
			if (XJJ < 0.00001)//左线分离
			{
				//取主线的左侧半宽+分离线的右侧半宽
				zxlmbk = fabs(road[0].hdmdes[i].RHFL[8]);
				//计算在分离段上的投影里程
				PZ.lc = road[0].hdmdes[i].cml;
				road[0].pm->xlpoint_pz(&PZ);
				CmlOnFLD = road[iroad].pm->PROJ_ML(PZ.x, PZ.y);

				CalLMK_JK(CmlOnFLD, road[iroad].NYLMK, road[iroad].YLMK,
					road[iroad].YcgNm, road[iroad].Ycg,
					road[iroad].YjkNm, road[iroad].Yjk,
					half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
				CalLMKbyFile(CmlOnFLD, 1, road[iroad].pm, road[iroad].pBXArr, road[iroad].BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
				flxlmbk = half_fgdk + lydk + cxdk + yljk + tljk;
			}
			else//右线分离
			{
				//取主线的右侧半宽+分离线的左侧半宽
				zxlmbk = fabs(road[0].hdmdes[i].RHFR[8]);
				//计算在分离段上的投影里程

				CalLMK_JK(CmlOnFLD, road[iroad].NZLMK, road[iroad].ZLMK,
					road[iroad].ZcgNm, road[iroad].Zcg,
					road[iroad].ZjkNm, road[iroad].Zjk,
					half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
				CalLMKbyFile(CmlOnFLD, -1, road[iroad].pm, road[iroad].pBXArr, road[iroad].BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
				flxlmbk = half_fgdk + lydk + cxdk + yljk + tljk;
			}
			LJFLK = zxlmbk + flxlmbk;

			if (XJJ < LJFLK)
				i++;
			else
				break;
		}
	}
	else
	{
		while (i >= 0 && road[0].hdmdes[i].cml > endml)
		{
			// 计算路肩分离宽 
			PZ.lc = road[0].hdmdes[i].cml;
			road[0].pm->xlpoint_pz(&PZ);
			CmlOnFLD = road[iroad].pm->PROJ_ML(PZ.x, PZ.y);
			if (XJJ < 0.00001)//左线分离
			{
				//取主线的左侧半宽+分离线的右侧半宽
				zxlmbk = fabs(road[0].hdmdes[i].RHFL[8]);
				//计算在分离段上的投影里程
				PZ.lc = road[0].hdmdes[i].cml;
				road[0].pm->xlpoint_pz(&PZ);
				CmlOnFLD = road[iroad].pm->PROJ_ML(PZ.x, PZ.y);

				CalLMK_JK(CmlOnFLD, road[iroad].NYLMK, road[iroad].YLMK,
					road[iroad].YcgNm, road[iroad].Ycg,
					road[iroad].YjkNm, road[iroad].Yjk,
					half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
				CalLMKbyFile(CmlOnFLD, 1, road[iroad].pm, road[iroad].pBXArr, road[iroad].BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
				flxlmbk = half_fgdk + lydk + cxdk + yljk + tljk;
			}
			else//右线分离
			{
				//取主线的右侧半宽+分离线的左侧半宽
				zxlmbk = fabs(road[0].hdmdes[i].RHFR[8]);
				//计算在分离段上的投影里程

				CalLMK_JK(CmlOnFLD, road[iroad].NZLMK, road[iroad].ZLMK,
					road[iroad].ZcgNm, road[iroad].Zcg,
					road[iroad].ZjkNm, road[iroad].Zjk,
					half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
				CalLMKbyFile(CmlOnFLD, -1, road[iroad].pm, road[iroad].pBXArr, road[iroad].BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
				flxlmbk = half_fgdk + lydk + cxdk + yljk + tljk;
			}
			LJFLK = zxlmbk + flxlmbk;
			XJJ = road[0].hdmdes[i].xjj;

			if (XJJ < LJFLK)
				i--;
			else
				break;
		}
	}
	sml1 = road[0].hdmdes[i].cml;
	zsml1 = sml1;
	j = i;

	PZ.lc = road[0].hdmdes[i].cml;
	road[0].pm->xlpoint_pz(&PZ);
	zsml1 = road[iroad].pm->PROJ_ML(PZ.x, PZ.y);

	return sml1;
}


void  HdmDes::SearchBPFLml(RoadHdmdata &ZXroad, RoadHdmdata &ZDroad, double startml, double endml, int &j, bool FrontORBack, int zory, double& sml1, double &zsml1)//true:向前,false:向后
{

	sml1 = startml;
	zsml1 = sml1;//初始值
	double XJJ, CmlOnFLD;
	xlpoint PZ;
	int i = 0;
	double ZX_BPLen, FLX_BPLen;
	int ZX_dmxz, FLX_dmxz;
	double NewYd, NewLearpt[400], NewRearpt[400], Yd, Learpt[400], Rearpt[400];
	int newNumL, newNumR, NumL, NumR;
	double ZXtwinf, FLXtwinf;
	double tmp[20];
	double ZX_DesPoint[500], FLX_DesPoint[500], goutmp[36], jsg[36];
	int ZX_DesPtSum, FLX_DesPtSum;
	double FLX_desh, FLX_RHF[10], lmhd[3], BPFLK;
	int itmp[10];
	double Z_YBTZDK, Y_ZBTZDK;
	double projml, resPt[2];

	if (FrontORBack)//向前里程增加方向搜索
	{
		while (i < ZXroad.NCRS && ZXroad.hdmdes[i].cml < startml - 0.001)
		{
			i++;
		}

		if (i >= ZXroad.NCRS)
			return;

		while (i < ZXroad.NCRS && ZXroad.hdmdes[i].cml < endml)
		{
			//PZ.lc = ZXroad.hdmdes[i].cml;
			//ZXroad.pm->xlpoint_pz(&PZ);
			PZ.lc = ZXroad.hdmdes[i].cml;
			ZXroad.pm->xlpoint_pz(&PZ);
			CmlOnFLD = ZDroad.pm->PROJ_ML(PZ.x, PZ.y);
			int inf;
			inf = BAS_DRAW_FUN::CalXjj(ZXroad.hdmdes[i].cml, ZXroad.pm->XYArray,
				ZXroad.pm->XYNum, ZDroad.pm->XYArray, ZDroad.pm->XYNum,
				XJJ, projml, resPt);
			if (inf == 0)//找不到投影里程
				break;//将该点作为分离点

			if (zory < -0.00001)//左侧有关联
			{

				//计算出主线的断面性质
				ZX_dmxz = ZXroad.hdmdes[i].ZDMXZ;

				//计算出分离线右侧的断面性质
				FLX_dmxz = SetDmProperty(CmlOnFLD, ZDroad.pm, ZDroad.NYBri, ZDroad.YBri,
					ZDroad.NAllBri, ZDroad.AllBri,
					ZDroad.NYTun, ZDroad.YTun,
					ZDroad.NAllTun, ZDroad.AllTun, 1, Z_YBTZDK);

				if (ZX_dmxz == 4 || FLX_dmxz == 4)//两线至少有一条路位于桥隧上，则搜索停止
					break;
				if (ZX_dmxz == 3 || FLX_dmxz == 3)//两线至少有一条路位于桥隧上，则跳过继续搜索
				{
					i++;
					continue;
				}
				//计算出主线的左侧边坡长
				NewYd = ZXroad.hdmdmx[i].EarH;
				newNumL = ZXroad.hdmdmx[i].ZEarPtNum;
				int k;
				for (k = 0; k < newNumL; k++)
				{
					NewLearpt[k * 2] = ZXroad.hdmdmx[i].ZEarPtAry[k].x;
					NewLearpt[k * 2 + 1] = ZXroad.hdmdmx[i].ZEarPtAry[k].y;
				}

				CrosNew(0, -1, i, NewYd, newNumL, NewLearpt,
					ZXroad.hdmdes[i].RHFL, ZXroad.hdmdes[i].zlmhd, ZXroad.hdmdes[i].ZZJ, ZXroad.hdmdes[i].ZPJPT,
					tmp[0], ZXtwinf, tmp[1], ZX_DesPtSum, ZX_DesPoint,
					tmp[2], tmp[3], tmp[4], tmp[5],
					tmp[6],
					itmp[0], tmp[7], itmp[1], itmp[2], goutmp, tmp[8], tmp[9], tmp[10], tmp[11],
					itmp[3], jsg,
					tmp[12], tmp[13], tmp[14], tmp[15]);
				ZX_BPLen = fabs(ZX_DesPoint[(ZX_DesPtSum - 1) * 2]);

				//计算出分离线的右侧边坡长
				//1.求设计标高
				FLX_desh = CalDesH(CmlOnFLD, ZDroad.YZM, ZDroad.AllZM);

				CalLMPT(CmlOnFLD, FLX_desh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm,
					ZDroad.Yjk, ZDroad.NYLMK, ZDroad.YLMK, FLX_RHF, 1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

				Yd = ZXroad.hdmdmx[i].EarH;
				NumL = ZXroad.hdmdmx[i].ZEarPtNum;
				for (k = 0; k < NumL; k++)
				{
					Learpt[k * 2] = ZXroad.hdmdmx[i].ZEarPtAry[k].x;
					Learpt[k * 2 + 1] = ZXroad.hdmdmx[i].ZEarPtAry[k].y;
				}

				NumR = ZXroad.hdmdmx[i].YEarPtNum;
				for (k = 0; k < NumR; k++)
				{
					Rearpt[k * 2] = ZXroad.hdmdmx[i].YEarPtAry[k].x;
					Rearpt[k * 2 + 1] = ZXroad.hdmdmx[i].YEarPtAry[k].y;
				}
				//移动坐标轴,生成新的地面线
				CalNewZB(XJJ, Yd, Learpt, NumL, Rearpt, NumR, NewYd, NewLearpt, newNumL, NewRearpt, newNumR);
				CrosNew1(ZDroad, 1, CmlOnFLD, NewYd, newNumR, NewRearpt, FLX_RHF, lmhd, 1000, ZXroad.hdmdes[0].ZPJPT,
					tmp[0], FLXtwinf, tmp[1], FLX_DesPtSum, FLX_DesPoint,
					tmp[2], tmp[3], tmp[4], tmp[5],
					tmp[6],
					itmp[0], tmp[7], itmp[1], itmp[2], goutmp, tmp[8], tmp[9], tmp[10], tmp[11],
					itmp[3], jsg,
					tmp[12], tmp[13], tmp[14]);
				FLX_BPLen = fabs(FLX_DesPoint[(FLX_DesPtSum - 1) * 2]);

			}
			else//右线分离
			{
				//计算出主线的断面性质
				ZX_dmxz = ZXroad.hdmdes[i].YDMXZ;
				//计算出分离线右侧的断面性质
				FLX_dmxz = SetDmProperty(CmlOnFLD, ZDroad.pm, ZDroad.NZBri, ZDroad.ZBri,
					ZDroad.NAllBri, ZDroad.AllBri,
					ZDroad.NZTun, ZDroad.ZTun,
					ZDroad.NAllTun, ZDroad.AllTun, -1, Y_ZBTZDK);
				if (ZX_dmxz == 4 || FLX_dmxz == 4)//两线至少有一条路位于隧上，则搜索停止
					break;
				if (ZX_dmxz == 3 || FLX_dmxz == 3)//两线至少有一条路位于桥上，则跳过继续搜索
				{
					i++;
					continue;
				}
				//计算出主线的左侧边坡长
				NewYd = ZXroad.hdmdmx[i].EarH;
				newNumR = ZXroad.hdmdmx[i].YEarPtNum;
				int k;
				for (k = 0; k < newNumR; k++)
				{
					NewRearpt[k * 2] = ZXroad.hdmdmx[i].YEarPtAry[k].x;
					NewRearpt[k * 2 + 1] = ZXroad.hdmdmx[i].YEarPtAry[k].y;
				}
				CrosNew(0, 1, i, NewYd, newNumR, NewRearpt, ZXroad.hdmdes[i].RHFR, ZXroad.hdmdes[i].ylmhd,
					ZXroad.hdmdes[i].YZJ, ZXroad.hdmdes[i].ZPJPT, tmp[0], ZXtwinf, tmp[1], ZX_DesPtSum, ZX_DesPoint,
					tmp[2], tmp[3], tmp[4], tmp[5],
					tmp[6],
					itmp[0], tmp[7], itmp[1], itmp[2], goutmp, tmp[8], tmp[9], tmp[10], tmp[11],
					itmp[3], jsg,
					tmp[12], tmp[13], tmp[14], tmp[15]);
				ZX_BPLen = fabs(ZX_DesPoint[(ZX_DesPtSum - 1) * 2]);
				//计算出分离线的右侧边坡长
				//1.求设计标高
				FLX_desh = CalDesH(CmlOnFLD, ZDroad.ZZM, ZDroad.AllZM);
				CalLMPT(CmlOnFLD, FLX_desh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm,
					ZDroad.Zjk, ZDroad.NZLMK, ZDroad.ZLMK, FLX_RHF, -1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

				Yd = ZXroad.hdmdmx[i].EarH;
				NumL = ZXroad.hdmdmx[i].ZEarPtNum;
				for (k = 0; k < NumL; k++)
				{
					Learpt[k * 2] = ZXroad.hdmdmx[i].ZEarPtAry[k].x;
					Learpt[k * 2 + 1] = ZXroad.hdmdmx[i].ZEarPtAry[k].y;
				}
				NumR = ZXroad.hdmdmx[i].YEarPtNum;
				for (k = 0; k < NumR; k++)
				{
					Rearpt[k * 2] = ZXroad.hdmdmx[i].YEarPtAry[k].x;
					Rearpt[k * 2 + 1] = ZXroad.hdmdmx[i].YEarPtAry[k].y;
				}
				//移动坐标轴,生成新的地面线
				CalNewZB(XJJ, Yd, Learpt, NumL, Rearpt, NumR, NewYd, NewLearpt, newNumL, NewRearpt, newNumR);
				CrosNew1(ZDroad, -1, CmlOnFLD, NewYd, newNumL, NewLearpt, FLX_RHF, lmhd, 1000, ZXroad.hdmdes[0].ZPJPT,
					tmp[0], FLXtwinf, tmp[1], FLX_DesPtSum, FLX_DesPoint,
					tmp[2], tmp[3], tmp[4], tmp[5],
					tmp[6],
					itmp[0], tmp[7], itmp[1], itmp[2], goutmp, tmp[8], tmp[9], tmp[10], tmp[11],
					itmp[3], jsg,
					tmp[12], tmp[13], tmp[14]);
				FLX_BPLen = fabs(FLX_DesPoint[(FLX_DesPtSum - 1) * 2]);
			}

			BPFLK = ZX_BPLen + FLX_BPLen;
			if (fabs(XJJ) < BPFLK)
				i++;
			else
				break;

		}

	}
	else
	{
		i = ZXroad.NCRS - 1;
		while (i >= 0 && ZXroad.hdmdes[i].cml > startml + 0.001)
			i--;

		if (i < 0)
			return;

		while (i >= 0 && ZXroad.hdmdes[i].cml > endml)
		{
			// 计算路肩分离宽 
			//PZ.lc = ZXroad.hdmdes[i].cml;
			//ZXroad.pm->xlpoint_pz(&PZ);
			//ZDroad.pm->PROJ_ML(PZ.x,PZ.y);
			CmlOnFLD = ZXroad.hdmdes[i].FLDcml;
			XJJ = ZXroad.hdmdes[i].xjj;
			if (XJJ < -0.00001)//左线分离
			{
				//计算出主线的断面性质
				ZX_dmxz = ZXroad.hdmdes[i].ZDMXZ;
				//计算出分离线右侧的断面性质
				FLX_dmxz = SetDmProperty(CmlOnFLD, ZDroad.pm, ZDroad.NYBri, ZDroad.YBri,
					ZDroad.NAllBri, ZDroad.AllBri,
					ZDroad.NYTun, ZDroad.YTun,
					ZDroad.NAllTun, ZDroad.AllTun, 1, Z_YBTZDK);
				if (ZX_dmxz == 4 || FLX_dmxz == 4)//两线至少有一条路位于桥隧上，则搜索停止
					break;
				if (ZX_dmxz == 3 || FLX_dmxz == 3)//两线至少有一条路位于桥隧上，则跳过继续搜索
				{
					i--;
					continue;
				}
				//计算出主线的左侧边坡长
				NewYd = ZXroad.hdmdmx[i].EarH;
				newNumL = ZXroad.hdmdmx[i].ZEarPtNum;
				int k;
				for (k = 0; k < newNumL; k++)
				{
					NewLearpt[k * 2] = ZXroad.hdmdmx[i].ZEarPtAry[k].x;
					NewLearpt[k * 2 + 1] = ZXroad.hdmdmx[i].ZEarPtAry[k].y;
				}
				CrosNew(0, -1, i, NewYd, newNumL, NewLearpt, ZXroad.hdmdes[i].RHFL, ZXroad.hdmdes[i].zlmhd, ZXroad.hdmdes[i].ZZJ, ZXroad.hdmdes[i].ZPJPT,
					tmp[0], ZXtwinf, tmp[1], ZX_DesPtSum, ZX_DesPoint,
					tmp[2], tmp[3], tmp[4], tmp[5],
					tmp[6],
					itmp[0], tmp[7], itmp[1], itmp[2], goutmp, tmp[8], tmp[9], tmp[10], tmp[11],
					itmp[3], jsg,
					tmp[12], tmp[13], tmp[14], tmp[15]);
				ZX_BPLen = fabs(ZX_DesPoint[(ZX_DesPtSum - 1) * 2]);
				//计算出分离线的右侧边坡长
				//1.求设计标高
				FLX_desh = CalDesH(CmlOnFLD, ZDroad.YZM, ZDroad.AllZM);
				CalLMPT(CmlOnFLD, FLX_desh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm,
					ZDroad.Yjk, ZDroad.NYLMK, ZDroad.YLMK, FLX_RHF, 1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

				Yd = ZXroad.hdmdmx[i].EarH;
				NumL = ZXroad.hdmdmx[i].ZEarPtNum;
				for (k = 0; k < NumL; k++)
				{
					Learpt[k * 2] = ZXroad.hdmdmx[i].ZEarPtAry[k].x;
					Learpt[k * 2 + 1] = ZXroad.hdmdmx[i].ZEarPtAry[k].y;
				}
				NumR = ZXroad.hdmdmx[i].YEarPtNum;
				for (k = 0; k < NumR; k++)
				{
					Rearpt[k * 2] = ZXroad.hdmdmx[i].YEarPtAry[k].x;
					Rearpt[k * 2 + 1] = ZXroad.hdmdmx[i].YEarPtAry[k].y;
				}
				//移动坐标轴,生成新的地面线
				CalNewZB(XJJ, Yd, Learpt, NumL, Rearpt, NumR, NewYd, NewLearpt, newNumL, NewRearpt, newNumR);
				CrosNew1(ZDroad, 1, CmlOnFLD, NewYd, newNumR, NewRearpt, FLX_RHF, lmhd, 1000, ZXroad.hdmdes[0].ZPJPT,
					tmp[0], FLXtwinf, tmp[1], FLX_DesPtSum, FLX_DesPoint,
					tmp[2], tmp[3], tmp[4], tmp[5],
					tmp[6],
					itmp[0], tmp[7], itmp[1], itmp[2], goutmp, tmp[8], tmp[9], tmp[10], tmp[11],
					itmp[3], jsg,
					tmp[12], tmp[13], tmp[14]);
				FLX_BPLen = fabs(FLX_DesPoint[(FLX_DesPtSum - 1) * 2]);
			}
			else//右线分离
			{
				//计算出主线的断面性质
				ZX_dmxz = ZXroad.hdmdes[i].YDMXZ;
				//计算出分离线右侧的断面性质
				FLX_dmxz = SetDmProperty(CmlOnFLD, ZDroad.pm, ZDroad.NZBri, ZDroad.ZBri,
					ZDroad.NAllBri, ZDroad.AllBri,
					ZDroad.NZTun, ZDroad.ZTun,
					ZDroad.NAllTun, ZDroad.AllTun, -1, Y_ZBTZDK);
				if (ZX_dmxz == 4 || FLX_dmxz == 4)//两线至少有一条路位于桥隧上，则搜索停止
					break;
				if (ZX_dmxz == 3 || FLX_dmxz == 3)//两线至少有一条路位于桥隧上，则跳过继续搜索
				{
					i--;
					continue;
				}
				//计算出主线的左侧边坡长
				NewYd = ZXroad.hdmdmx[i].EarH;
				newNumR = ZXroad.hdmdmx[i].YEarPtNum;
				int k;
				for (k = 0; k < newNumR; k++)
				{
					NewRearpt[k * 2] = ZXroad.hdmdmx[i].YEarPtAry[k].x;
					NewRearpt[k * 2 + 1] = ZXroad.hdmdmx[i].YEarPtAry[k].y;
				}
				CrosNew(0, 1, i, NewYd, newNumR, NewRearpt, ZXroad.hdmdes[i].RHFR, ZXroad.hdmdes[i].ylmhd, ZXroad.hdmdes[i].YZJ, ZXroad.hdmdes[i].ZPJPT,
					tmp[0], ZXtwinf, tmp[1], ZX_DesPtSum, ZX_DesPoint,
					tmp[2], tmp[3], tmp[4], tmp[5],
					tmp[6],
					itmp[0], tmp[7], itmp[1], itmp[2], goutmp, tmp[8], tmp[9], tmp[10], tmp[11],
					itmp[3], jsg,
					tmp[12], tmp[13], tmp[14], tmp[15]);
				ZX_BPLen = fabs(ZX_DesPoint[(ZX_DesPtSum - 1) * 2]);
				//计算出分离线的右侧边坡长
				//1.求设计标高
				FLX_desh = CalDesH(CmlOnFLD, ZDroad.ZZM, ZDroad.AllZM);
				CalLMPT(CmlOnFLD, FLX_desh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm,
					ZDroad.Zjk, ZDroad.NZLMK, ZDroad.ZLMK, FLX_RHF, -1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

				Yd = ZXroad.hdmdmx[i].EarH;
				NumL = ZXroad.hdmdmx[i].ZEarPtNum;
				for (k = 0; k < NumL; k++)
				{
					Learpt[k * 2] = ZXroad.hdmdmx[i].ZEarPtAry[k].x;
					Learpt[k * 2 + 1] = ZXroad.hdmdmx[i].ZEarPtAry[k].y;
				}
				NumR = ZXroad.hdmdmx[i].YEarPtNum;
				for (k = 0; k < NumR; k++)
				{
					Rearpt[k * 2] = ZXroad.hdmdmx[i].YEarPtAry[k].x;
					Rearpt[k * 2 + 1] = ZXroad.hdmdmx[i].YEarPtAry[k].y;
				}
				//移动坐标轴,生成新的地面线
				CalNewZB(XJJ, Yd, Learpt, NumL, Rearpt, NumR, NewYd, NewLearpt, newNumL, NewRearpt, newNumR);
				CrosNew1(ZDroad, -1, CmlOnFLD, NewYd, newNumL, NewLearpt, FLX_RHF, lmhd, 1000, ZXroad.hdmdes[0].ZPJPT,
					tmp[0], FLXtwinf, tmp[1], FLX_DesPtSum, FLX_DesPoint,
					tmp[2], tmp[3], tmp[4], tmp[5],
					tmp[6],
					itmp[0], tmp[7], itmp[1], itmp[2], goutmp, tmp[8], tmp[9], tmp[10], tmp[11],
					itmp[3], jsg,
					tmp[12], tmp[13], tmp[14]);
				FLX_BPLen = fabs(FLX_DesPoint[(FLX_DesPtSum - 1) * 2]);
			}
			BPFLK = ZX_BPLen + FLX_BPLen;
			if (XJJ < BPFLK)
				i--;
			else
				break;
		}
	}

	if (i >= ZXroad.NCRS)
		i--;
	if (i >= 0 && i < ZXroad.NCRS)
	{
		zsml1 = ZXroad.hdmdes[i].cml;//主线里程
		j = i;
		PZ.lc = ZXroad.hdmdes[i].cml;
		ZXroad.pm->xlpoint_pz(&PZ);
		sml1 = ZDroad.pm->PROJ_ML(PZ.x, PZ.y);//分离段里程
	}

	return;
}


//从startml开始(路肩分离)，搜索边坡分离断面,返回分离断面序号
//double  HdmDes::SearchBPFLml(double startml,double endml,int &k, bool FrontORBack,int zory,int irxd,double &sml1,double &zsml1)//true:向前,false:向后
//{
//    sml1 = startml;//边坡分离处里程
//	double XJJ;
//	int i=0;
//	double StartDesPt[2],BPpt[50];
//	double TM[30],TH[30],TPTW[30],TPTI[30],ZJ;
//	int TorW;
//	double GK,GS,GP1,GP2,CG_JQHD;
//	while(i<NCRS && Crs[i].cml<startml-0.001)//找起始断面
//		i++;
//	
//	if(i==NCRS)
//		return sml1;
//	double cml;
//	xlpoint PZ;
//	double DesBG,ZDesBG,YDesBG;
//	double Y_RHFL[8],Y_RHFR[8],Z_RHFL[8],Z_RHFR[8];
//	double ZX_TW[2],YX_TW[2];
//	double NewYd,NewLearpt[400],NewRearpt[400];
//	int newLnpt, newRnpt,nLTBPJS,desinf,BPptSum;
//	double ZBPlen,YBPlen,D,ZoffsetX,YoffsetX;
//	double Ldeltah,Rdeltah;
//	int nLZBPJS;
//	int Z_BTinf,Y_BTinf;
//	double Zprojml,Yprojml;
//	
//    //求左线右侧边坡点
//    while(i<NCRS)
//		{
//		PZ.lc = Crs[i].cml;
//		xlpoint_pz(pzLinep->array,pzLinep->tarray,&PZ);
//		if(zory==-1)//左线为绕行
//		{
//			Zprojml = PROJ_ML(pzLinepZ->array,pzLinepZ->tarray,PZ.x,PZ.y,PZ.x,PZ.y);      
//			Z_BTinf = ZRXD[irxd].CheckIfInBriOrTun(Zprojml);//从左线绕行段中查找,返回断面
//		    Y_BTinf = CheckIfInBriOrTun(Crs[i].cml);//从一线查找,返回断面性质性质			
//		}
//		else 
//		{
//			Yprojml = PROJ_ML(pzLinepY->array,pzLinepY->tarray,PZ.x,PZ.y,PZ.x,PZ.y);      
//			Y_BTinf = YRXD[irxd].CheckIfInBriOrTun(Yprojml);//从右线绕行段中查找,返回断面
//			Z_BTinf = CheckIfInBriOrTun(Crs[i].cml);//从一线查找,返回断面性质性质		
//		}//判别左线和右线桥隧
//		
//		  if(fabs(Z_BTinf-1.0)<0.1||fabs(Z_BTinf-2.0)<0.1||fabs(Z_BTinf-6.0)<0.1
//			  ||fabs(Y_BTinf-1.0)<0.1||fabs(Y_BTinf-2.0)<0.1||fabs(Y_BTinf-6.0)<0.1)
//			  break;
//		
//			CalDesBG(false,Crs[i].cml,DesBG,ZDesBG,YDesBG);//求左右线设计标高
//			//求左右线路面点
//			CalRX_LMPT(Crs[i].cml,Crs[i].EarH,Crs[i].Zxjj,Crs[i].Yxjj,Crs[i].qxjk,Crs[i].Yqxjk,
//				Crs[i].Learpt,Crs[i].NumL,Crs[i].Rearpt,Crs[i].NumR,
//				ZDesBG,YDesBG,ZoffsetX,YoffsetX,Z_RHFL,Z_RHFR,Y_RHFL,Y_RHFR,ZX_TW,YX_TW,Ldeltah,Rdeltah);		
//			//移动到左线局部坐标系
//			//将坐标轴从一线移到左线或右线的位置后，形成新的地面线坐标			
//			CalNewZB(Crs[i].Zxjj,Crs[i].EarH,Crs[i].Learpt,Crs[i].NumL,Crs[i].Rearpt,Crs[i].NumR,
//				NewYd,NewLearpt,newLnpt,NewRearpt,newRnpt);
//			XJJ = fabs(ZoffsetX) + fabs(YoffsetX);
//			//计算左线右侧边坡
//			if(ZX_TW[1]<0.1)//填方取路肩处
//			{
//				StartDesPt[0]=Z_RHFR[3*2];//以左线为Y轴
//				StartDesPt[1]=Z_RHFR[3*2+1]-NewYd;//地面标高为原点				
//				nLTBPJS=FindWichBP(cml,RightHdmData.NLDBP,RightHdmData.LDBP,TM,TH,TPTW,TPTI);//左路堤边坡
//				TorW = -1;
//			}
//			else//挖方取路肩处+水沟宽+平台宽
//			{
//				Cal_D(cml,LeftHdmData.NLQSG,LeftHdmData.LQSG,&D,&GK,&GS,&GP1,&GP2,&CG_JQHD);//路堑边沟宽度
//				nLTBPJS=FindWichBP(cml,RightHdmData.NLQBP,RightHdmData.LQBP,TM,TH,TPTW,TPTI);//左路堑边坡
//				
//			/*
//				nLTBPJS = 3;
//			                TM[0]=1.0,TM[1]=1.5,TM[2]=1.75;
//							TH[0]=8,TH[1]=10,TH[2]=100.0;
//							TPTW[0]=1,TPTW[1]=1,TPTW[2]=1;
//							TPTI[0]=0,TPTI[1]=0,TPTI[2]=0;*/
//			
//				
//				StartDesPt[0]=Z_RHFR[3*2]+D+TPTW[0];//
//				StartDesPt[1]=Z_RHFR[3*2+1]-NewYd;//以一线中线为Y轴，地面标高为原点				
//				TorW = 1;
//			}
//	        ZJ=100.0;
//			desinf=DesBPnew(TorW,StartDesPt,TM,TH,TPTW,TPTI,0,
//				newRnpt,NewRearpt,100.0,BPpt,BPptSum,ZJ,nLTBPJS);//路堤
//			ZBPlen = fabs(BPpt[(BPptSum-1)*2]);
//			
//			
//		//计算右线左侧边坡
//			//移动到右线局部坐标系
//			//将坐标轴从一线移到左线或右线的位置后，形成新的地面线坐标			
//			CalNewZB(Crs[i].Yxjj,Crs[i].EarH,Crs[i].Learpt,Crs[i].NumL,
//				Crs[i].Rearpt,Crs[i].NumR,NewYd,NewLearpt,newLnpt,
//				NewRearpt,newRnpt);
//			
//			//计算左线右侧边坡
//			double StartDesPt[2];
//			if(YX_TW[0]<0.1)//填方取路肩处
//			{
//				StartDesPt[0]=Y_RHFL[3*2];//以左线为Y轴
//				StartDesPt[1]=Y_RHFL[3*2+1]-NewYd;//地面标高为原点				
//				nLTBPJS=FindWichBP(cml,LeftHdmData.NLDBP,LeftHdmData.LDBP,TM,TH,TPTW,TPTI);//左路堤边坡	
//				TorW = -1;
//			}
//			else//挖方取路肩处+水沟宽+平台宽
//			{
//				Cal_D(cml,LeftHdmData.NLQSG,LeftHdmData.LQSG,&D,&GK,&GS,&GP1,&GP2,&CG_JQHD);//路堑边沟宽度
//				//D = 1.6;
//				nLTBPJS=FindWichBP(cml,LeftHdmData.NLQBP,LeftHdmData.LQBP,TM,TH,TPTW,TPTI);//左路堑边坡
//					
//				/*
//				nLTBPJS = 3;
//				                TM[0]=1.0,TM[1]=1.5,TM[2]=1.75;
//								TH[0]=8,TH[1]=10,TH[2]=100.0;
//								TPTW[0]=1,TPTW[1]=1,TPTW[2]=1;
//								TPTI[0]=0,TPTI[1]=0,TPTI[2]=0;*/
//				
//				
//				StartDesPt[0]=Y_RHFL[3*2]+D+TPTW[0];
//				StartDesPt[1]=Y_RHFL[3*2+1]-NewYd;//以一线中线为Y轴，地面标高为原点				
//				TorW = 1;
//			}
//			desinf=DesBPnew(TorW,StartDesPt,TM,TH,TPTW,TPTI,0,
//				newLnpt,NewLearpt,100.0,BPpt,BPptSum,ZJ,nLTBPJS);//路堤
//		
//			
//       	   YBPlen = BPpt[(BPptSum-1)*2];
//    /*
//    
//            if(Crs[i].cml>4200 &&Crs[i].cml<4800)
//        	{
//                 ads_printf(L"%lf zBPlen=%lf yBPlen=%lf XJJ=%lf\n",Crs[i].cml,ZBPlen,YBPlen,XJJ);
//    / *
//        		 ads_printf(L"左线: %lf %lf\n",Z_RHFR[3*2],Z_RHFR[3*2+1]);
//        		 ads_printf(L"%d \n",nLTBPJS);
//        		 for(j=0; j<nLTBPJS; j++)
//        			 ads_printf(L"%lf %lf %lf \n",TM[j],TH[j],TPTW[j]);* /        
//        	}
//        */
//    
//		if(ZBPlen+YBPlen > XJJ)//两侧边坡相交
//		{
//			if(FrontORBack)//向前里程增加方向搜索
//			{
//				i++;			   
//				if(i<NCRS && Crs[i].cml > endml)
//					break;				
//			}
//			else
//			{
//			     i--;
//				 if(i>=0 && Crs[i].cml < endml)
//					 break;				 
//			}
//		}
//		else////两侧边坡不相交，退出
//			break; 
//	}
//	sml1 = Crs[i].cml;	
//    zsml1=sml1;
//	PZ.lc = Crs[i].cml;
//	xlpoint_pz(pzLinep->array,pzLinep->tarray,&PZ);
//	if(zory==-1&&pzLinepZ)
//		zsml1 = PROJ_ML(pzLinepZ->array,pzLinepZ->tarray,PZ.x,PZ.y,PZ.x,PZ.y);
//    if(zory==1&&pzLinepY)
//		zsml1 = PROJ_ML(pzLinepY->array,pzLinepY->tarray,PZ.x,PZ.y,PZ.x,PZ.y);//
//	k=i;
//	return sml1;
//}
void  HdmDes::SetZxXJJ()//设置主线线间距和各道路起终点在主线上的投影
{
	double spt[2], ept[2];
	double resPt[2], projml;
	int j;
	for (j = 0; j < road[0].NCRS; j++)
	{
		road[0].hdmdes[j].xjj = 0.0;
	}

	for (int i = 1; i < RoadSum; i++)
	{
		//计算分离段起终点在主线上的投影里程
		spt[0] = road[i].pm->XYArray[1][8];
		spt[1] = road[i].pm->XYArray[1][9];
		road[i].SmlOnZx = road[0].pm->PROJ_ML(spt[0], spt[1]);

		ept[0] = road[i].pm->XYArray[road[i].pm->XYNum][8];
		ept[1] = road[i].pm->XYArray[road[i].pm->XYNum][9];
		road[i].EmlOnZx = road[0].pm->PROJ_ML(ept[0], ept[1]);
		//ads_printf(L"i=%d %s %s\n",i,road[0].pm->XLC(road[i].SmlOnZx),road[0].pm->XLC(road[i].EmlOnZx));
		for (j = 0; j < road[0].NCRS; j++)
		{
			if (road[0].hdmdes[j].cml > road[i].SmlOnZx - 0.1 &&  road[0].hdmdes[j].cml < road[i].EmlOnZx + 0.1)
			{
				//计算线间距
				double xjj;
				BAS_DRAW_FUN::CalXjj(road[0].hdmdes[j].cml, road[0].pm->XYArray,
					road[0].pm->XYNum, road[i].pm->XYArray, road[i].pm->XYNum,
					xjj, projml, resPt);
				xlpoint pZ;
				pZ.lc = road[0].hdmdes[j].cml;
				road[0].pm->xlpoint_pz(&pZ);
				double spt[2], fwj, PtOnFld[2];
				spt[0] = pZ.x, spt[1] = pZ.y;
				fwj = pZ.a;

				//				if(road[i].ZxOrYx<0 && xjj>0.0 || road[i].ZxOrYx>0 && xjj<0.0 )//如果是左线，线间距>0 转换为0
				//				{
				//				//	ads_printf(L"QQQQQQ i=%d %lf %lf %lf\n",i,road[0].hdmdes[j].cml,xjj,projml);
				//					xjj = 0.0;
				//				}

				//if(xjj>0.001)
				//{
				//	road[i].pm->CalJD_ZX_XL(spt,fwj+0.5*pi,PtOnFld,road[0].hdmdes[j].FLDcml);	
				//	road[0].hdmdes[j].xjj = sqrt((spt[0]-PtOnFld[0])*(spt[0]-PtOnFld[0])+(spt[1]-PtOnFld[1])*(spt[1]-PtOnFld[1]));//相关道路上的投影里程			   
				//}
				//else if(xjj<-0.001)
				//{
				//	road[i].pm->CalJD_ZX_XL(spt,fwj-0.5*pi,PtOnFld,road[0].hdmdes[j].FLDcml);	
				//	road[0].hdmdes[j].xjj = -sqrt((spt[0]-PtOnFld[0])*(spt[0]-PtOnFld[0])+(spt[1]-PtOnFld[1])*(spt[1]-PtOnFld[1]));//相关道路上的投影里程			   
				//	//	   ads_printf(L"%lf %lf\n",road[0].hdmdes[j].cml,road[0].hdmdes[j].xjj);
				//}				   
				//else
				//{
				//	road[0].hdmdes[j].xjj = 0.0;
				//	//					if(j>0)
				//	//					    road[0].hdmdes[j].xjj = road[0].hdmdes[j-1].xjj;
				//	//					else
				//	//                        road[0].hdmdes[j].xjj = 0.0;
				//	road[0].hdmdes[j].FLDcml = projml;
				//}
				if (abs(xjj) < 0.001)
				{
					road[0].hdmdes[j].xjj = 0.0;
					road[0].hdmdes[j].FLDcml = projml;
				}

				road[0].hdmdes[j].FLDname = road[i].roadname;//相关道路名		   			   

			}
		}

	}
}

void  HdmDes::SetFLDXJJ()//设置主线线间距和各道路起终点在主线上的投影
{
	double resPt[2], projml;

	for (int i = 1; i < RoadSum; i++)
	{
		int j;
		for (j = 0; j < road[i].NCRS; j++)
		{
			road[i].hdmdes[j].xjj = 0.0;
		}
		for (j = 0; j < road[i].NCRS; j++)
		{
			//计算线间距
			double xjj;
			BAS_DRAW_FUN::CalXjj(road[i].hdmdes[j].cml, road[i].pm->XYArray,
				road[i].pm->XYNum, road[0].pm->XYArray, road[0].pm->XYNum,
				xjj, projml, resPt);

			//   if(road[i].ZxOrYx<0 && xjj<0.0 || road[i].ZxOrYx>0 && xjj>0.0 )//如果是左线，线间距>0 转换为0
			//		xjj = 0.0;



			if (fabs(xjj) > 0.0001)
				road[i].hdmdes[j].xjj = xjj;//相关道路名		   			            
			else
			{
				//  if(j>0)
				//   road[i].hdmdes[j].xjj =  road[i].hdmdes[j-1].xjj;//相关道路名		   			            
				// else
				road[i].hdmdes[j].xjj = 0.0;
			}


			road[i].hdmdes[j].FLDname = road[0].roadname;//相关道路名
			//			   if(fabs(road[i].hdmdes[j].dml-200200)<0.1)
			//			      ads_printf(L"fldxjj=%lf\n",road[i].hdmdes[j].xjj);
		}
	}
}

bool HdmDes::ReadBDFile()
{
	FILE *fpr = NULL;
	CString fname;
	fname = Cworkdir + "\\DATA\\";
	fname = fname + "BDDATA";
	fpr = _wfopen(fname, L"r");
	ACHAR xl1[256], xl2[256];
	int i;
	NBIDUAN = 0;
	if (fpr != NULL)
	{
		fwscanf(fpr, L"%d", &NBIDUAN);
		for (i = 0; i < NBIDUAN; i++)
		{
			fwscanf(fpr, L"%s%s%d%d%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf", xl1, xl2, &BDArr[i].ZDStOrEd, &BDArr[i].Lmhp,
				&BDArr[i].C1, &BDArr[i].C2, &BDArr[i].Z1, &BDArr[i].Z2,
				&BDArr[i].YljRNose, &BDArr[i].TljRNose, &BDArr[i].Yljdml1,
				&BDArr[i].Yljdml2, &BDArr[i].Tljdml1, &BDArr[i].Tljdml2, &BDArr[i].FldDml1, &BDArr[i].FldDml2);
			BDArr[i].XL1 = xl1;
			BDArr[i].XL1.MakeUpper();
			//			int ichar=BDArr[i].XL1.Find(L","); 
			//			int j = BDArr[i].XL1.GetLength();
			//			BDArr[i].XL1=BDArr[i].XL1.Right(j-ichar-1);
			BDArr[i].XL2 = xl2;
			BDArr[i].XL2.MakeUpper();
			//			ichar=BDArr[i].XL2.Find(L","); 
			//			j = BDArr[i].XL2.GetLength();
			//			BDArr[i].XL2=BDArr[i].XL2.Right(j-ichar-1);			
			fwscanf(fpr, L"%lf%lf%lf%lf%lf%lf", &BDArr[i].YCSpt[0], &BDArr[i].YCSpt[1],
				&BDArr[i].YCEpt[0], &BDArr[i].YCEpt[1], &BDArr[i].YNosePt[0], &BDArr[i].YNosePt[1]);
			fwscanf(fpr, L"%lf%lf%lf%lf%lf%lf", &BDArr[i].TCSpt[0], &BDArr[i].TCSpt[1],
				&BDArr[i].TCEpt[0], &BDArr[i].TCEpt[1], &BDArr[i].TNosePt[0], &BDArr[i].TNosePt[1]);
			fwscanf(fpr, L"%lf%lf%lf%lf", &BDArr[i].YLjPt1[0], &BDArr[i].YLjPt1[1], &BDArr[i].YLjPt2[0], &BDArr[i].YLjPt2[1]);
		}
		fclose(fpr);
	}

	double NosePt[2], cml1, cml2, cml;
	int pos, len, LorR;
	CString DBS1, DBS2, Name1, Name2;
	XLDataBase DBS;
	JD_CENTER *pm1 = NULL, *pm2 = NULL;


	for (i = 0; i < NBIDUAN; i++)
	{
		if (BDArr[i].XL1 == "" || BDArr[i].XL2 == "")
			continue;
		pos = BDArr[i].XL1.FindOneOf(L",");
		DBS1 = BDArr[i].XL1.Left(pos);
		len = BDArr[i].XL1.GetLength();
		Name1 = BDArr[i].XL1.Right(len - pos - 1);
		if (DBS1 == "" || Name1 == "")
			continue;
		else
		{
			DBS.Read_XLDbs(DBS1, L"线元表", Name1);
			DBS.Read_XLDbs(DBS1, L"断链表", Name1);
			if (DBS.XYNum > 0)
			{
				if (pm1)
					delete pm1;
				pm1 = new JD_CENTER(DBS.XYArray, DBS.XYNum);//主线对象
				if (DBS.NDL > 0)
					pm1->setDLB(DBS.DLArray, DBS.NDL);
			}
			_tcscpy(pm1->mdbname, DBS1);
			_tcscpy(pm1->RoadName, Name1);

		}
		pos = BDArr[i].XL2.FindOneOf(L",");
		DBS2 = BDArr[i].XL2.Left(pos);
		len = BDArr[i].XL2.GetLength();
		Name2 = BDArr[i].XL2.Right(len - pos - 1);

		if (DBS2 == "" || Name2 == "")
			continue;
		else
		{
			DBS.Read_XLDbs(DBS2, L"线元表", Name2);
			DBS.Read_XLDbs(DBS2, L"断链表", Name2);
			if (DBS.XYNum > 0)
			{
				if (pm2)
					delete pm2;
				pm2 = new JD_CENTER(DBS.XYArray, DBS.XYNum);//主线对象
				if (DBS.NDL > 0)
					pm2->setDLB(DBS.DLArray, DBS.NDL);
			}
			_tcscpy(pm2->mdbname, DBS2);
			_tcscpy(pm2->RoadName, Name2);
		}

		if (pm1 == NULL || pm2 == NULL)
			continue;

		if (BDArr[i].ZDStOrEd == 0)
			BDArr[i].InOrOut = pm1->GetInOrOut(BDArr[i].ZDStOrEd, pm2);
		else
			BDArr[i].InOrOut = pm1->GetInOrOut(BDArr[i].ZDStOrEd, pm2);
	}
	return true;
}

bool HdmDes::FindWichBDDml(CString xl1, CString xl2, int qorh, double &xl1dml, double &xl2dml)
{
	int i;
	xl1.MakeUpper();
	xl2.MakeUpper();
	xl1dml = xl2dml = 0;
	for (i = 0; i < NBIDUAN; i++)
	{
		if (xl1 == BDArr[i].XL1&&xl2 == BDArr[i].XL2&&qorh == BDArr[i].InOrOut)
		{
			xl1dml = BDArr[i].Yljdml1;
			xl2dml = BDArr[i].Yljdml2;
			return true;
		}
	}
	return false;
}

bool HdmDes::FindWichNose(CString xl1, CString xl2, int qorh, double &YljNose)
{
	int i;
	double xl1dml, xl2dml;
	xl1.MakeUpper();
	xl2.MakeUpper();
	xl1dml = xl2dml = 0;
	YljNose = 0;
	for (i = 0; i < NBIDUAN; i++)
	{
		if (xl1 == BDArr[i].XL1&&xl2 == BDArr[i].XL2&&qorh == BDArr[i].InOrOut)
		{
			YljNose = BDArr[i].YljRNose;
			return true;
		}
	}
	return false;
}

bool HdmDes::FindWichNoseAndProperty(CString xl1, CString xl2, double cmlonzd, JD_CENTER *zdpm, int &qorh, double &YljNose, int &TorF, double &FldDmlOnZD, double &BDDmlOnZD)
{
	int i;
	double xl1dml, xl2dml, cml1;
	xl1dml = xl2dml = 0;
	YljNose = 0;
	xl1.MakeUpper();
	xl2.MakeUpper();

	for (i = 0; i < NBIDUAN; i++)
	{

		cml1 = zdpm->TYLC(BDArr[i].Yljdml2);
		if (BDArr[i].ZDStOrEd == 0)
		{
			if (xl1 == BDArr[i].XL1&&xl2 == BDArr[i].XL2 && cmlonzd < cml1 + 1)
			{
				YljNose = BDArr[i].YljRNose;
				qorh = BDArr[i].InOrOut;
				TorF = BDArr[i].Lmhp;
				BDDmlOnZD = BDArr[i].Yljdml2;
				FldDmlOnZD = BDArr[i].FldDml2;
				return true;
			}
		}
		else
		{
			if (xl1 == BDArr[i].XL1&&xl2 == BDArr[i].XL2 && cmlonzd > cml1 - 1)
			{
				YljNose = BDArr[i].YljRNose;
				qorh = BDArr[i].InOrOut;
				TorF = BDArr[i].Lmhp;
				BDDmlOnZD = BDArr[i].Yljdml2;
				FldDmlOnZD = BDArr[i].FldDml2;
				return true;
			}
		}
	}
	return false;
}

//lmhp 1:同坡,-1:反坡
bool HdmDes::FindWichHP(CString xl1, CString xl2, int qorh, int &lmhp)
{
	int i;
	double xl1dml, xl2dml;
	xl1.MakeUpper();
	xl2.MakeUpper();
	xl1dml = xl2dml = 0;
	lmhp = 1;
	for (i = 0; i < NBIDUAN; i++)
	{
		if (xl1 == BDArr[i].XL1&&xl2 == BDArr[i].XL2&&qorh == BDArr[i].InOrOut)
		{
			lmhp = BDArr[i].Lmhp;
			return true;
		}
	}
	return false;
}
//lmhp 1:同坡,-1:反坡
bool HdmDes::FindWichLinkRoad(CString xl2, int qorh, int &lmhp, CString &mdbname1, CString &roadname1, double &dml1, double &dml2, double &flddml1, double &flddml2)
{
	int i, pos, len;
	double xl1dml, xl2dml;
	CString xl1;
	xl1dml = xl2dml = 0;
	lmhp = 1;
	xl2.MakeUpper();
	for (i = 0; i < NBIDUAN; i++)
	{
		if (xl2 == BDArr[i].XL2&&qorh == BDArr[i].InOrOut)
		{
			lmhp = BDArr[i].Lmhp;
			xl1 = BDArr[i].XL1;
			pos = BDArr[i].XL1.FindOneOf(L",");
			mdbname1 = BDArr[i].XL1.Left(pos);
			len = BDArr[i].XL1.GetLength();
			roadname1 = BDArr[i].XL1.Right(len - pos - 1);

			dml1 = BDArr[i].Yljdml1;
			dml2 = BDArr[i].Yljdml2;
			flddml1 = BDArr[i].FldDml1;
			flddml2 = BDArr[i].FldDml2;
			return true;
		}
	}
	return false;
}
//计算绕行分段里程
//每个绕行段：起始：RXDsml-起始里程=RXDsml1-路肩分离里程=RXDsml2-路基分离里程
//终止: RXDeml-终止里程=RXDeml1-路肩分离里程=RXDeml2-路基分离里程
void HdmDes::Cal_FLD_Fendml()
{
	//先计算左侧
	CString GH;

	for (int i = 1; i < RoadSum; i++)
	{
		//计算路面分离时的里程
		//计算出左右路面宽
		/*
		CalNoseCen(road[0].pm,road[i].pm,road[i].SmlOnZx,1,0,i,0.6,
		road[i].LJFLSmlOnZx,road[i].LJFLSmlOnFLD,nosept);
		CalNoseCen(road[0].pm,road[i].pm,road[i].EmlOnZx,-1,0,i,0.6,
		road[i].LJFLEmlOnZx,road[i].LJFLEmlOnFLD,nosept);	*/

		CString xl1, xl2;
		//		xl1.Format(L"%s,%s",road[0].pm->mdbname,road[0].roadname);
		//		xl2.Format(L"%s,%s",road[i].pm->mdbname,road[i].roadname);


		//		FindWichBDDml(xl1,xl2,0,dml1,dml2);

		road[i].LJFLSmlOnZx = road[i].SmlOnZx;
		road[i].LJFLSmlOnFLD = road[i].pm->TYLC(road[i].pm->DLArray[0].ELC);
		//		FindWichBDDml(xl1,xl2,1,dml1,dml2);
		road[i].LJFLEmlOnZx = road[i].EmlOnZx;
		road[i].LJFLEmlOnFLD = road[i].pm->TYLC(road[i].pm->DLArray[road[i].pm->DLNum - 1].BLC);




		//  SearchBPFLml(i,road[i].LJFLSmlOnZx,road[i].EmlOnZx,J1,true,-1,road[i].BPFLSmlOnFLD,road[i].BPFLSmlOnZx);//从sml开始,在Crs[i]中向前搜索
		//  SearchBPFLml(i,road[i].EmlOnZx,road[i].BPFLSmlOnZx,J2,false,-1,road[i].BPFLEmlOnFLD,road[i].BPFLEmlOnZx);//从eml开始,在Crs[i]中向后搜索
		//  ads_printf(L"i=%d zx_ljflsml=%lf zx_bpflsml=%lf  zx_ljfleml=%lf zx_bpfleml=%lf\n",
		//   i,road[0].pm->XLC(road[i].LJFLSmlOnZx,GH),road[i].pm->XLC(road[i].BPFLSmlOnZx,GH),road[i].pm->XLC(road[i].LJFLEmlOnZx,GH),road[i].pm->XLC(road[i].BPFLEmlOnZx,GH));
	}

}

//输入主线里程，计算断面属性
//DorS: 0:只有一个中线的整体式路基 
//      1: 绕行过渡段有两个中线的整体式路基(有两个路面，没有关联边坡) ml<LJFLSmlOnZx ml>EmlOnZx 
//      2：绕行过渡段有两个中线的整体式路基(有两个路面，有关联边坡)
//		duanluo=3关联断面
void HdmDes::Cal_HdmProperty(double cml, int &duanluo, int &DorS, int &iroad, int &ZxOrYx)
{
	DorS = 1;//通常为只有一个中线的整体式路基 
	iroad = 0;
	duanluo = 1;

	for (int i = 1; i < RoadSum; i++)//对左侧绕行段循环
	{
		ZxOrYx = road[i].ZxOrYx;
		//			if((cml>road[i].SmlOnZx-0.01 && cml<road[i].LJFLSmlOnZx+0.01)||
		//				(cml>road[i].LJFLEmlOnZx-0.01 && cml<road[i].EmlOnZx+0.01))//绕行过渡段双路面路基
		//			{
		//				DorS = 1;//绕行过渡段有两个中线的关联式路基(有两个路面，没有关联边坡) 
		//				iroad = i;
		//				duanluo = 2;
		//				return;
		//			}
		//	else 
		if (cml > road[i].LJFLSmlOnZx - 0.001 && cml < road[i].LJFLEmlOnZx + 0.001)
			duanluo = 3;
		//				    || cml>road[i].BPFLEmlOnZx-0.01 && cml<road[i].LJFLEmlOnZx+0.01)//绕行段路基完全分离
		//			{
		//				DorS = 2;//按
		//				iroad = i;
		//				return;
		//			}			
	}
}

void HdmDes::Design_ZX_Hdm()
{
	ACHAR pszLabel[256];
	int i, NCRS, iroad;
	double cml;
	int DorS;
	i = 0;

	_stprintf(pszLabel, L"%s横断面自动设计", road[i].roadname);
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);

	NCRS = road[i].NCRS;
	for (int j = 0; j < NCRS; j++)
	{
		//计算左幅
		cml = road[i].hdmdes[j].cml;
		int ZxOrYx;//各分离段在主线的左右侧
		Cal_HdmProperty(cml, road[i].hdmdes[j].DuanLuoInf, DorS, iroad, ZxOrYx);


		Cal_HdmDQinf(i, j);

		xlpoint PZ;
		PZ.lc = cml;
		road[i].pm->xlpoint_pz(&PZ);

		//			road[i].hdmdes[j].fwj = PZ.a;//记录断面中心切线方位角
		//	if(road[i].hdmdes[j].dml<85000 && road[i].hdmdes[j].dml>84000)
		//if(road[i].hdmdes[j].DuanLuoInf>1)
		//	ads_printf(L"############## %lf  %d %d %d %lf\n",road[i].hdmdes[j].dml,road[i].hdmdes[j].DuanLuoInf,ZxOrYx,road[i].hdmdes[j].IfFldSEHdm,road[i].hdmdes[j].xjj);
		//计算断面性质和相关道路
		if (road[i].hdmdes[j].DuanLuoInf == 3 && !road[i].hdmdes[j].IfFldSEHdm)//需要进行关联判别
		{
			//关联式路基
			//////////////////////////////////////////////////////////////////////////
			//路基中线和线路中线不一致：不能将将路面宽设为0，因为关联部分也有路面（删除）
			// 				if(ZxOrYx<0 && fabs(road[i].hdmdes[j].xjj)<1.0)//左线分离且线间距<1m 主线左幅宽设0
			// 				{
			// 					double desh;
			// 					desh =  road[i].hdmdes[j].RHFL[1];
			// 					for(int k=0; k<5; k++)
			// 					{
			//                         road[i].hdmdes[j].RHFL[k*2]=0.0;
			// 						road[i].hdmdes[j].RHFL[k*2+1]=desh;
			// 					}
			// 				}
			// 				
			// 				if(ZxOrYx>0 && fabs(road[i].hdmdes[j].xjj)<1.0)//右线分离且线间距<1m 主线左幅宽设0
			// 				{
			// 					double desh;
			// 					desh =  road[i].hdmdes[j].RHFR[1];
			// 					for(int k=0; k<5; k++)
			// 					{
			//                         road[i].hdmdes[j].RHFR[k*2]=0.0;
			// 						road[i].hdmdes[j].RHFR[k*2+1]=desh;
			// 					}
			// 				}
			//////////////////////////////////////////////////////////////////////////
			DesLinkCross(i, j, ZxOrYx);
			//解算边坡交点,若有则为关联路基,若没有则为单线整体路基
			//求出支距				
		}
		else
		{

			//		if(DorS==0)//单线整体式路基
			DesACrossOnSingleLine(i, j);
			//		else //过渡段鼻端之前双路面整体式路基
			//		{
			//		    DesACrossOnDoubleLineFLD(j,iroad);	

			//		}
		}

		//			if(j>0&&((road[i].hdmdes[j].DuanLuoInf==0&&road[i].hdmdes[j-1].DuanLuoInf==2)||
		//			(road[i].hdmdes[j].DuanLuoInf==2&&road[i].hdmdes[j-1].DuanLuoInf==0)))
		//			{//双路基到单路基的临界断面
		//				//1、CRS数组针加一个成员
		//				//ads_printf(L"\ncml=%lf,%d,%d",road[i].hdmdes[j].cml,Crs[i-1].DuanLuoInf,road[i].hdmdes[j].DuanLuoInf);
		//				NCRS++;
		//				int j;
		//				for(int k=NCRS-1;k>j;k--)
		//					road[i].hdmdes[k]=road[i].hdmdes[k-1];
		//				if(road[i].hdmdes[j].DuanLuoInf==2)
		//				{
		//					road[i].hdmdes[j]=road[i].hdmdes[j-1];
		//					road[i].hdmdes[j].DuanLuoInf=2;
		//				}
		//		//		DorS=2;//3、按双路面处理
		//			}

		//分情况设计
		//还需考虑桥隧相连的情况
		int Pos = (int)(j*100.0 / road[i].NCRS);
		acedSetStatusBarProgressMeterPos(Pos);
	}
	//
	road[i].NCRS = NCRS;
	//用于计算水沟填挖与断面整体填挖,边坡绿化面积，水沟长度，路面面积
	CalTorWforPSandDM(i);
	acedSetStatusBarProgressMeterPos(100);
	acedRestoreStatusBar();
}

/************************************************************************/
//设计road[i].hdmdes[j]的单线整体式路基横断面
//zory=-1时设计左侧，zory=1时设计右侧，zory=0时设计左右侧
/************************************************************************/
void HdmDes::DesACrossOnSingleLine(int i, int j, int zory)//只有一个中线的整体式路面
{
	int ZIfBTinf, YIfBTinf;
	double LDesPoint[500], RDesPoint[500], LFillArea, LCutArea, RFillArea, RCutArea, FillArea, CutArea;
	double LGouH, LGouX, RGouH, RGouX;
	double LFillBetterSoilArea, LFillSSTArea, LQBTArea, LGouTarea, LGouWarea, LHJarea, LSGJQarea, LDQlength, LGrasslength;
	double RFillBetterSoilArea, RFillSSTArea, RQBTArea, RGouTarea, RGouWarea, RHJarea, RSGJQarea, RDQlength, RGrasslength;
	int Lnpt, Rnpt;
	//double LgouTarea,LgouWarea,Rg/ouTarea,RgouWarea;
	double cml;
	double NewYd, NewLearpt[800], NewRearpt[800];
	int newNumL, newNumR;
	//将地面点从路基中线平移到线路中线后的地面点数据
	double NewYdOffset, NewLearptOffset[800], NewRearptOffset[800];
	int newNumLOffset, newNumROffset;
	//	double OffsetByXLZX = 0.0;//路基中线相对于线路中线的偏移量
	double RHF[10];
	int k;

	ZIfBTinf = 0;
	YIfBTinf = 0;
	LFillBetterSoilArea = LFillSSTArea = LQBTArea = LGouTarea = LGouWarea = LHJarea = LSGJQarea = LDQlength = LGrasslength = 0.0;
	RFillBetterSoilArea = RFillSSTArea = RQBTArea = RGouTarea = RGouWarea = RHJarea = RSGJQarea = RDQlength = RGrasslength = 0.0;
	Lnpt = Rnpt = 0;
	LFillArea = RFillArea = FillArea = LCutArea = RCutArea = CutArea = 0.0;

	cml = road[i].hdmdes[j].cml;
	road[i].hdmdes[j].DorS = 1;
	//	road[i].hdmdes[j].xjj = 0.0;
	road[i].hdmdes[j].newLYd = road[i].hdmdes[j].newRYd = road[i].hdmdmx[j].EarH;
	NewYd = road[i].hdmdmx[j].EarH;

	//ads_printf(L"@@@@@@@@@@@@@@ %d %d\n",road[i].ZjkNm,road[i].YjkNm);
	if (zory <= 0)
	{
		for (k = 0; k < 10; k++)
			RHF[k] = road[i].hdmdes[j].RHFL[k];

		if (road[i].hdmdes[j].ZDMXZ == 3)//桥中
		{
			road[i].hdmdes[j].LZDK = road[i].hdmdes[j].RHFL[8] + road[i].hdmdes[j].BriZZDK;//桥梁用地
			if (road[i].NCRS == 1)
				ads_alert(L"指定里程位于桥梁范围内!");

			if (road[i].hdmdes[j].YDMXZ == 3 || road[i].hdmdes[j].YDMXZ == 4)//断面位于整幅桥或整幅隧
				ZIfBTinf = 1;
			else////半桥
			{
				for (int k = 0; k < 10; k = k + 2)
				{
					RHF[k] = 0.0;
					RHF[k + 1] = road[i].hdmdes[j].RHFR[1];
				}
			}

		}

		if (road[i].hdmdes[j].ZDMXZ == 4)//隧中
		{
			//road[i].hdmdes[j].LZDK=road[i].hdmdes[j].RHFL[8]+road[i].hdmdes[j].TunZZDK;//桥梁用地
			road[i].hdmdes[j].LZDK = 0.0;
			if (road[i].NCRS == 1)
				ads_alert(L"指定里程位于隧道范围内!");
			if (road[i].hdmdes[j].YDMXZ == 3 || road[i].hdmdes[j].YDMXZ == 4)//断面位于整幅桥或整幅隧
				ZIfBTinf = 1;
			else////半隧
			{
				for (int k = 0; k < 10; k = k + 2)
				{
					RHF[k] = 0.0;
					RHF[k + 1] = road[i].hdmdes[j].RHFR[1];
				}
			}

		}


		if (!ZIfBTinf)
		{
			//////////////////////////////////////////////////////////////////////////
			//考虑路基中线与线路中线不重合：地面线要进行移动（修改）
			newNumL = road[i].hdmdmx[j].ZEarPtNum;
			for (int k = 0; k < newNumL; k++)
			{
				NewLearpt[k * 2] = road[i].hdmdmx[j].ZEarPtAry[k].x;
				NewLearpt[k * 2 + 1] = road[i].hdmdmx[j].ZEarPtAry[k].y;
			}
			newNumR = road[i].hdmdmx[j].YEarPtNum;
			for (k = 0; k < newNumR; k++)
			{
				NewRearpt[k * 2] = road[i].hdmdmx[j].YEarPtAry[k].x;
				NewRearpt[k * 2 + 1] = road[i].hdmdmx[j].YEarPtAry[k].y;
			}
			//			CalOffsetByXLZX(cml,road[i].NZLMK,road[i].ZLMK,OffsetByXLZX);
			CalNewZB(road[i].hdmdes[j].OffsetByXLZX, NewYd, NewLearpt, newNumL, NewRearpt, newNumR,
				NewYdOffset, NewLearptOffset, newNumLOffset, NewRearptOffset, newNumROffset);

			CrosNew(i, -1, j, NewYdOffset, newNumLOffset, NewLearptOffset,/*road[i].hdmdes[j].RHFL*/RHF, road[i].hdmdes[j].zlmhd, road[i].hdmdes[j].ZZJ, road[i].hdmdes[j].ZPJPT,
				road[i].hdmdes[j].Ldeltah, road[i].hdmdes[j].Zt, road[i].hdmdes[j].ZHc, Lnpt, LDesPoint,
				LFillArea, LFillBetterSoilArea, LQBTArea, LCutArea,
				road[i].hdmdes[j].LZDK,
				road[i].hdmdes[j].LIfSetGouH, road[i].hdmdes[j].LGouH, road[i].hdmdes[j].LGouProperty, road[i].hdmdes[j].LGouPtNum, road[i].hdmdes[j].Lgou, road[i].hdmdes[j].LGouH, LGouX, LGouTarea, LGouWarea,
				road[i].hdmdes[j].LJSGouPtNum, road[i].hdmdes[j].LJSgou,
				LSGJQarea, LDQlength, LGrasslength, road[i].hdmdes[j].ZCG_GDR);
			//////////////////////////////////////////////////////////////////////////
		}


		road[i].hdmdes[j].Lnpt = Lnpt;
		if (road[i].hdmdes[j].RPTL.length() > 0)
			road[i].hdmdes[j].RPTL.removeSubArray(0, road[i].hdmdes[j].RPTL.length() - 1);
		AcGePoint3d pt;

		//////////////////////////////////////////////////////////////////////////
		for (int k = 0; k < Lnpt; k++)
		{
			pt.x = -1.0*LDesPoint[k * 2];
			pt.y = LDesPoint[k * 2 + 1];
			road[i].hdmdes[j].RPTL.append(pt);
		}
		//////////////////////////////////////////////////////////////////////////
		if (road[i].hdmdes[j].Lnpt > 0)
			road[i].hdmdes[j].Ljdnum = road[i].hdmdes[j].Lnpt - 1;
		//////////////////////////////////////////////////////////////////////////
		for (k = 0; k < road[i].hdmdes[j].LJSGouPtNum; k++)
			road[i].hdmdes[j].LJSgou[k * 2] = -1 * road[i].hdmdes[j].LJSgou[k * 2];
		for (int kk = 0; kk < road[i].hdmdes[j].LGouPtNum; kk++)
			road[i].hdmdes[j].Lgou[kk * 2] = -1 * road[i].hdmdes[j].Lgou[kk * 2];
		//////////////////////////////////////////////////////////////////////////

		road[i].hdmdes[j].Z_LFillSSTArea = LFillSSTArea;
		road[i].hdmdes[j].Z_LFillArea = LFillArea;
		road[i].hdmdes[j].Z_LCutArea = LCutArea;
		road[i].hdmdes[j].Z_LQBTArea = LQBTArea;
		road[i].hdmdes[j].Z_LHJarea = LHJarea;
		road[i].hdmdes[j].Z_LFillBetterSoilArea = LFillBetterSoilArea;
		road[i].hdmdes[j].Z_LSGJQarea = LSGJQarea;
		road[i].hdmdes[j].Z_LDQlength = LDQlength;
		road[i].hdmdes[j].Z_LGrasslength = LGrasslength;
		road[i].hdmdes[j].Z_LGouTarea = LGouTarea;
		road[i].hdmdes[j].Z_LGouWarea = LGouWarea;

	}

	if (zory >= 0)
	{
		for (int k = 0; k < 10; k++)
			RHF[k] = road[i].hdmdes[j].RHFR[k];
		if (road[i].hdmdes[j].YDMXZ == 3)//桥中
		{
			road[i].hdmdes[j].RZDK = road[i].hdmdes[j].RHFR[8] + road[i].hdmdes[j].BriYZDK;//桥梁用地
			if (road[i].NCRS == 1)
				ads_alert(L"指定里程位于桥梁范围内!");
			if (road[i].hdmdes[j].ZDMXZ == 3 || road[i].hdmdes[j].ZDMXZ == 4)//断面位于整幅桥或整幅隧
				YIfBTinf = 1;
			else////半桥
			{
				for (k = 0; k < 10; k = k + 2)
				{
					RHF[k] = 0.0;
					RHF[k + 1] = road[i].hdmdes[j].RHFL[1];
				}
			}
		}

		if (road[i].hdmdes[j].YDMXZ == 4)//隧中
		{
			//	road[i].hdmdes[j].RZDK=road[i].hdmdes[j].RHFR[8]+road[i].hdmdes[j].TunYZDK;//桥梁用地
			road[i].hdmdes[j].RZDK = 0.0;
			if (road[i].NCRS == 1)
				ads_alert(L"指定里程位于隧道范围内!");
			if (road[i].hdmdes[j].ZDMXZ == 3 || road[i].hdmdes[j].ZDMXZ == 4)//断面位于整幅桥或整幅隧
				YIfBTinf = 1;
			else////半隧
			{
				for (k = 0; k < 10; k = k + 2)
				{
					RHF[k] = 0.0;
					RHF[k + 1] = road[i].hdmdes[j].RHFL[1];
				}
			}
		}
		if (!YIfBTinf)
		{
			//////////////////////////////////////////////////////////////////////////
			//考虑路基中线与线路中线不重合，需要将路面点平移至路基中线（修改）
			newNumL = road[i].hdmdmx[j].ZEarPtNum;
			for (int k = 0; k < newNumL; k++)
			{
				NewLearpt[k * 2] = road[i].hdmdmx[j].ZEarPtAry[k].x;
				NewLearpt[k * 2 + 1] = road[i].hdmdmx[j].ZEarPtAry[k].y;
			}
			newNumR = road[i].hdmdmx[j].YEarPtNum;
			for (k = 0; k < newNumR; k++)
			{
				NewRearpt[k * 2] = road[i].hdmdmx[j].YEarPtAry[k].x;
				NewRearpt[k * 2 + 1] = road[i].hdmdmx[j].YEarPtAry[k].y;
			}
			//			CalOffsetByXLZX(cml,road[i].NYLMK,road[i].YLMK,OffsetByXLZX);
			CalNewZB(road[i].hdmdes[j].OffsetByXLZX, NewYd, NewLearpt, newNumL, NewRearpt, newNumR,
				NewYdOffset, NewLearptOffset, newNumLOffset, NewRearptOffset, newNumROffset);

			//////////////////////////////////////////////////////////////////////////
			CrosNew(i, 1, j, NewYdOffset, newNumROffset, NewRearptOffset, RHF, road[i].hdmdes[j].ylmhd, road[i].hdmdes[j].YZJ, road[i].hdmdes[j].YPJPT,
				road[i].hdmdes[j].Rdeltah, road[i].hdmdes[j].Yt, road[i].hdmdes[j].YHc, Rnpt, RDesPoint,
				RFillArea, RFillBetterSoilArea, RQBTArea, RCutArea,
				road[i].hdmdes[j].RZDK,
				road[i].hdmdes[j].RIfSetGouH, road[i].hdmdes[j].RGouH, road[i].hdmdes[j].RGouProperty, road[i].hdmdes[j].RGouPtNum, road[i].hdmdes[j].Rgou, road[i].hdmdes[j].RGouH, RGouX, RGouTarea, RGouWarea,
				road[i].hdmdes[j].RJSGouPtNum, road[i].hdmdes[j].RJSgou,
				RSGJQarea, RDQlength, RGrasslength, road[i].hdmdes[j].YCG_GDR);

		}
		road[i].hdmdes[j].Rnpt = Rnpt;
		if (road[i].hdmdes[j].RPTR.length() > 0)
			road[i].hdmdes[j].RPTR.removeSubArray(0, road[i].hdmdes[j].RPTR.length() - 1);
		//////////////////////////////////////////////////////////////////////////
		AcGePoint3d pt;
		for (k = 0; k < Rnpt; k++)
		{
			pt.x = RDesPoint[k * 2];
			pt.y = RDesPoint[k * 2 + 1];
			road[i].hdmdes[j].RPTR.append(pt);
		}
		if (road[i].hdmdes[j].Rnpt > 0)
			road[i].hdmdes[j].Rjdnum = road[i].hdmdes[j].Rnpt - 1;

		//////////////////////////////////////////////////////////////////////////

		road[i].hdmdes[j].Y_RFillArea = RFillArea;
		road[i].hdmdes[j].Y_RCutArea = RCutArea;
		road[i].hdmdes[j].Y_RFillSSTArea = RFillSSTArea;
		road[i].hdmdes[j].Y_RQBTArea = RQBTArea;
		road[i].hdmdes[j].Y_RHJarea = RHJarea;
		road[i].hdmdes[j].Y_RFillBetterSoilArea = RFillBetterSoilArea;
		road[i].hdmdes[j].Y_RSGJQarea = RSGJQarea;
		road[i].hdmdes[j].Y_RDQlength = RDQlength;//挡墙坡长
		road[i].hdmdes[j].Y_RGrasslength = RGrasslength;//铺草坡长
		road[i].hdmdes[j].Y_RGouTarea = RGouTarea;
		road[i].hdmdes[j].Y_RGouWarea = RGouWarea;


	}

	double LCutBenchArea = 0.0;
	double RCutBenchArea = 0.0;
	//左右两侧至少有一侧是填方，且两侧坡脚点一个在路基中线地面线以上，一个在以下才考虑做台阶
	if ((fabs(road[i].hdmdes[j].Zt) < 0.1 || fabs(road[i].hdmdes[j].Yt) < 0.1)
		&& LDesPoint[2 * Lnpt - 1] * RDesPoint[2 * Rnpt - 1] < 0.0)
	{
		CreateBenchPtArray(Lnpt, LDesPoint, newNumLOffset, NewLearptOffset, road[i].hdmBench[j].ZEarPtAry, LCutBenchArea);
		road[i].hdmBench[j].ZEarPtNum = road[i].hdmBench[j].ZEarPtAry.GetSize();
		CreateBenchPtArray(Rnpt, RDesPoint, newNumROffset, NewRearptOffset, road[i].hdmBench[j].YEarPtAry, RCutBenchArea);
		road[i].hdmBench[j].YEarPtNum = road[i].hdmBench[j].YEarPtAry.GetSize();
	}


	//判别本断面清表土和挖淤泥面积数量
	FindWichHTHD(road[i].hdmdes[j].cml, road[i].pm, road[i].hdmbz.NZHTHD, road[i].hdmbz.ZHTHD, road[i].hdmdes[j].ZHTHD, road[i].hdmdes[j].ZHTXZ);
	if (road[i].hdmdes[j].ZHTXZ == 0)//清表土
		road[i].hdmdes[j].QBTArea = LQBTArea;
	else
		road[i].hdmdes[j].WYNArea = LQBTArea;
	FindWichHTHD(road[i].hdmdes[j].cml, road[i].pm, road[i].hdmbz.NYHTHD, road[i].hdmbz.YHTHD, road[i].hdmdes[j].YHTHD, road[i].hdmdes[j].YHTXZ);
	if (road[i].hdmdes[j].YHTXZ == 0)//清表土
		road[i].hdmdes[j].QBTArea += RQBTArea;
	else
		road[i].hdmdes[j].WYNArea += LQBTArea;


	road[i].hdmdes[j].GouTarea = LGouTarea + RGouTarea;//水沟填面积
	road[i].hdmdes[j].GouWarea = LGouWarea + RGouWarea;//水沟挖面积
	//road[i].hdmdes[j].FillArea = LFillArea + RFillArea + road[i].hdmdes[j].GouTarea;//填面积
	road[i].hdmdes[j].FillArea = LFillArea + RFillArea;//填面积,不包括水沟填面积
	//	if(road[i].hdmdes[j].cml<21000)
	//ads_printf(L"cml=%lf fill=%lf lqbt=%lf rqbt=%lf gout=%lf\n",road[i].hdmdes[j].cml,road[i].hdmdes[j].FillArea,LQBTArea,RQBTArea,road[i].hdmdes[j].GouTarea);
	//road[i].hdmdes[j].CutArea = LCutArea + RCutArea + road[i].hdmdes[j].GouWarea; //挖面积
	road[i].hdmdes[j].CutArea = LCutArea + RCutArea; //挖面积,不包括水沟挖面积
	road[i].hdmdes[j].aw = road[i].hdmdes[j].CutArea;
	road[i].hdmdes[j].at = road[i].hdmdes[j].FillArea;
	road[i].hdmdes[j].FillBetterSoilArea = LFillBetterSoilArea + RFillBetterSoilArea;//填改良土面积
	road[i].hdmdes[j].HJarea = LHJarea + RHJarea;//护肩面积
	road[i].hdmdes[j].SGJQarea = LSGJQarea + RSGJQarea;//浆砌面积
	road[i].hdmdes[j].Z_LSGJQarea = LSGJQarea;//左浆砌面积
	road[i].hdmdes[j].Y_RSGJQarea = RSGJQarea;//右浆砌面积
	road[i].hdmdes[j].DQlength = LDQlength + RDQlength;//挡墙坡长
	road[i].hdmdes[j].Grasslength = LGrasslength + RGrasslength;//铺草坡长

	//////////////////////////////////////////////////////////////////////////
	//台阶面积
	// 	road[i].hdmdes[j].FillArea += LCutBenchArea + RCutBenchArea;
	// 	road[i].hdmdes[j].CutArea += LCutBenchArea + RCutBenchArea;

	//用于交互设计
	road[i].hdmdes[j].MidFillArea = 0.0;
	road[i].hdmdes[j].MidCutArea = 0.0;
	road[i].hdmdes[j].MidFillSSTArea = 0.0;//填渗水土面积
	road[i].hdmdes[j].MidQBTArea = 0.0;
	road[i].hdmdes[j].MidFillGLTArea = 0.0;
	road[i].hdmdes[j].MidHJarea = 0.0;
	road[i].hdmdes[j].Y_RFillBetterSoilArea = RFillBetterSoilArea; road[i].hdmdes[j].MidGouJQarea = 0.0;
	road[i].hdmdes[j].MidDQlength = 0.0;
	road[i].hdmdes[j].MidGrasslength = 0.0;

	//	ads_printf(L"######## %lf %lf\n",road[i].hdmdes[j].LGouH,road[i].hdmdes[j].RGouH);

}

void HdmDes::DesACrossOnSingleLine(RoadHdmdata &ZDroad, int j, int zory)//只有一个中线的整体式路面
{
	int ZIfBTinf, YIfBTinf;
	double LDesPoint[500], RDesPoint[500], LFillArea, LCutArea, RFillArea, RCutArea, FillArea, CutArea;
	double LGouH, LGouX, RGouH, RGouX;
	double LFillBetterSoilArea, LFillSSTArea, LQBTArea, LGouTarea, LGouWarea, LHJarea, LSGJQarea, LDQlength, LGrasslength;
	double RFillBetterSoilArea, RFillSSTArea, RQBTArea, RGouTarea, RGouWarea, RHJarea, RSGJQarea, RDQlength, RGrasslength;
	int Lnpt, Rnpt;
	//double LgouTarea,LgouWarea,RgouTarea,RgouWarea;
	double cml;
	double NewYd, NewLearpt[400], NewRearpt[400];
	int newNumL, newNumR;

	ZIfBTinf = 0;
	YIfBTinf = 0;
	LFillBetterSoilArea = LFillSSTArea = LQBTArea = LGouTarea = LGouWarea = LHJarea = LSGJQarea = LDQlength = LGrasslength = 0.0;
	RFillBetterSoilArea = RFillSSTArea = RQBTArea = RGouTarea = RGouWarea = RHJarea = RSGJQarea = RDQlength = RGrasslength = 0.0;
	Lnpt = Rnpt = 0;
	LFillArea = RFillArea = FillArea = LCutArea = RCutArea = CutArea = 0.0;

	if (zory <= 0)
	{
		cml = ZDroad.hdmdes[j].cml;
		ZDroad.hdmdes[j].DorS = 1;
		//	ZDroad.hdmdes[j].xjj = 0.0;
		ZDroad.hdmdes[j].newLYd = ZDroad.hdmdes[j].newRYd = ZDroad.hdmdmx[j].EarH;
		if (ZDroad.hdmdes[j].ZDMXZ == 3)//桥中
		{
			ZDroad.hdmdes[j].LZDK = ZDroad.hdmdes[j].RHFL[8] + ZDroad.hdmdes[j].BriZZDK;//桥梁用地
			if (ZDroad.NCRS == 1)
				ads_alert(L"指定里程位于桥梁范围内!");
			ZIfBTinf = 1;
		}

		if (ZDroad.hdmdes[j].ZDMXZ == 4)//隧中
		{
			//	ZDroad.hdmdes[j].LZDK=ZDroad.hdmdes[j].RHFL[8]+ZDroad.hdmdes[j].TunZZDK;//桥梁用地
			ZDroad.hdmdes[j].LZDK = 0.0;//桥梁用地
			if (ZDroad.NCRS == 1)
				ads_alert(L"指定里程位于隧道范围内!");
			ZIfBTinf = 1;
		}

		if (!ZIfBTinf)
		{
			NewYd = ZDroad.hdmdmx[j].EarH;
			newNumL = ZDroad.hdmdmx[j].ZEarPtNum;
			for (int k = 0; k < newNumL; k++)
			{
				NewLearpt[k * 2] = ZDroad.hdmdmx[j].ZEarPtAry[k].x;
				NewLearpt[k * 2 + 1] = ZDroad.hdmdmx[j].ZEarPtAry[k].y;
			}

			CrosNew1(ZDroad, -1, cml, NewYd, newNumL, NewLearpt, ZDroad.hdmdes[j].RHFL, ZDroad.hdmdes[j].zlmhd, ZDroad.hdmdes[j].ZZJ, ZDroad.hdmdes[j].ZPJPT,
				ZDroad.hdmdes[j].Ldeltah, ZDroad.hdmdes[j].Zt, ZDroad.hdmdes[j].ZHc, Lnpt, LDesPoint,
				LFillArea, LFillBetterSoilArea, LQBTArea, LCutArea,
				ZDroad.hdmdes[j].LZDK,
				ZDroad.hdmdes[j].LIfSetGouH, ZDroad.hdmdes[j].LGouH, ZDroad.hdmdes[j].LGouProperty, ZDroad.hdmdes[j].LGouPtNum, ZDroad.hdmdes[j].Lgou, ZDroad.hdmdes[j].LGouH, LGouX, LGouTarea, LGouWarea,
				ZDroad.hdmdes[j].LJSGouPtNum, ZDroad.hdmdes[j].LJSgou,
				LSGJQarea, LDQlength, LGrasslength);
		}

		ZDroad.hdmdes[j].Lnpt = Lnpt;
		if (ZDroad.hdmdes[j].RPTL.length() > 0)
			ZDroad.hdmdes[j].RPTL.removeSubArray(0, ZDroad.hdmdes[j].RPTL.length() - 1);
		AcGePoint3d pt;
		int k;
		for (k = 0; k < Lnpt; k++)
		{
			pt.x = -1.0*LDesPoint[k * 2];
			pt.y = LDesPoint[k * 2 + 1];
			ZDroad.hdmdes[j].RPTL.append(pt);

		}

		if (ZDroad.hdmdes[j].Lnpt > 0)
			ZDroad.hdmdes[j].Ljdnum = ZDroad.hdmdes[j].Lnpt - 1;

		for (k = 0; k < ZDroad.hdmdes[j].LJSGouPtNum; k++)
			ZDroad.hdmdes[j].LJSgou[k * 2] = -1 * ZDroad.hdmdes[j].LJSgou[k * 2];
		for (int kk = 0; kk < ZDroad.hdmdes[j].LGouPtNum; kk++)
			ZDroad.hdmdes[j].Lgou[kk * 2] = -1 * ZDroad.hdmdes[j].Lgou[kk * 2];

		ZDroad.hdmdes[j].Z_LFillSSTArea = LFillSSTArea;
		ZDroad.hdmdes[j].Z_LFillArea = LFillArea;
		ZDroad.hdmdes[j].Z_LCutArea = LCutArea;
		ZDroad.hdmdes[j].Z_LQBTArea = LQBTArea;
		ZDroad.hdmdes[j].Z_LHJarea = LHJarea;
		ZDroad.hdmdes[j].Z_LFillBetterSoilArea = LFillBetterSoilArea;
		ZDroad.hdmdes[j].Z_LSGJQarea = LSGJQarea;
		ZDroad.hdmdes[j].Z_LDQlength = LDQlength;
		ZDroad.hdmdes[j].Z_LGrasslength = LGrasslength;
		ZDroad.hdmdes[j].Z_LGouTarea = LGouTarea;
		ZDroad.hdmdes[j].Z_LGouWarea = LGouWarea;


	}

	if (zory >= 0)
	{
		if (ZDroad.hdmdes[j].YDMXZ == 3)//桥中
		{
			ZDroad.hdmdes[j].RZDK = ZDroad.hdmdes[j].RHFR[8] + ZDroad.hdmdes[j].BriYZDK;//桥梁用地
			if (ZDroad.NCRS == 1)
				ads_alert(L"指定里程位于桥梁范围内!");
			YIfBTinf = 1;
		}

		if (ZDroad.hdmdes[j].YDMXZ == 4)//隧中
		{
			//	ZDroad.hdmdes[j].RZDK=ZDroad.hdmdes[j].RHFR[8]+ZDroad.hdmdes[j].TunYZDK;//桥梁用地
			ZDroad.hdmdes[j].RZDK = 0.0;//桥梁用地
			if (ZDroad.NCRS == 1)
				ads_alert(L"指定里程位于隧道范围内!");
			YIfBTinf = 1;
		}
		if (!YIfBTinf)
		{
			newNumR = ZDroad.hdmdmx[j].YEarPtNum;
			for (int k = 0; k < newNumR; k++)
			{
				NewRearpt[k * 2] = ZDroad.hdmdmx[j].YEarPtAry[k].x;
				NewRearpt[k * 2 + 1] = ZDroad.hdmdmx[j].YEarPtAry[k].y;
			}
			CrosNew1(ZDroad, 1, cml, NewYd, newNumR, NewRearpt, ZDroad.hdmdes[j].RHFR, ZDroad.hdmdes[j].ylmhd, ZDroad.hdmdes[j].YZJ, ZDroad.hdmdes[j].YPJPT,
				ZDroad.hdmdes[j].Rdeltah, ZDroad.hdmdes[j].Yt, ZDroad.hdmdes[j].YHc, Rnpt, RDesPoint,
				RFillArea, RFillBetterSoilArea, RQBTArea, RCutArea,
				ZDroad.hdmdes[j].RZDK,
				ZDroad.hdmdes[j].RIfSetGouH, ZDroad.hdmdes[j].RGouH, ZDroad.hdmdes[j].RGouProperty, ZDroad.hdmdes[j].RGouPtNum, ZDroad.hdmdes[j].Rgou, ZDroad.hdmdes[j].RGouH, RGouX, RGouTarea, RGouWarea,
				ZDroad.hdmdes[j].RJSGouPtNum, ZDroad.hdmdes[j].RJSgou,
				RSGJQarea, RDQlength, RGrasslength);
		}

		ZDroad.hdmdes[j].Rnpt = Rnpt;
		if (ZDroad.hdmdes[j].RPTR.length() > 0)
			ZDroad.hdmdes[j].RPTR.removeSubArray(0, ZDroad.hdmdes[j].RPTR.length() - 1);
		AcGePoint3d pt;
		for (int k = 0; k < Rnpt; k++)
		{
			pt.x = RDesPoint[k * 2];
			pt.y = RDesPoint[k * 2 + 1];
			ZDroad.hdmdes[j].RPTR.append(pt);
		}
		if (ZDroad.hdmdes[j].Rnpt > 0)
			ZDroad.hdmdes[j].Rjdnum = ZDroad.hdmdes[j].Rnpt - 1;

		ZDroad.hdmdes[j].Y_RFillArea = RFillArea;
		ZDroad.hdmdes[j].Y_RCutArea = RCutArea;
		ZDroad.hdmdes[j].Y_RFillSSTArea = RFillSSTArea;
		ZDroad.hdmdes[j].Y_RQBTArea = RQBTArea;
		ZDroad.hdmdes[j].Y_RHJarea = RHJarea;
		ZDroad.hdmdes[j].Y_RFillBetterSoilArea = RFillBetterSoilArea;
		ZDroad.hdmdes[j].Y_RSGJQarea = RSGJQarea;
		ZDroad.hdmdes[j].Y_RDQlength = RDQlength;//挡墙坡长
		ZDroad.hdmdes[j].Y_RGrasslength = RGrasslength;//铺草坡长
		ZDroad.hdmdes[j].Y_RGouTarea = RGouTarea;
		ZDroad.hdmdes[j].Y_RGouWarea = RGouWarea;
	}


	//计算左右两侧面积	
	//判别本断面清表土和挖淤泥面积数量
	FindWichHTHD(ZDroad.hdmdes[j].cml, ZDroad.pm, ZDroad.hdmbz.NZHTHD, ZDroad.hdmbz.ZHTHD, ZDroad.hdmdes[j].ZHTHD, ZDroad.hdmdes[j].ZHTXZ);
	if (ZDroad.hdmdes[j].ZHTXZ == 0)//清表土
		ZDroad.hdmdes[j].QBTArea = LQBTArea;
	else
		ZDroad.hdmdes[j].WYNArea = LQBTArea;
	FindWichHTHD(ZDroad.hdmdes[j].cml, ZDroad.pm, ZDroad.hdmbz.NYHTHD, ZDroad.hdmbz.YHTHD, ZDroad.hdmdes[j].YHTHD, ZDroad.hdmdes[j].YHTXZ);
	if (ZDroad.hdmdes[j].YHTXZ == 0)//清表土
		ZDroad.hdmdes[j].QBTArea += RQBTArea;
	else
		ZDroad.hdmdes[j].WYNArea += LQBTArea;
	// 	ZDroad.hdmdes[j].QBTArea = LQBTArea + RQBTArea;//清表土面积
	ZDroad.hdmdes[j].GouTarea = LGouTarea + RGouTarea;//水沟填面积
	ZDroad.hdmdes[j].GouWarea = LGouWarea + RGouWarea;//水沟挖面积
	ZDroad.hdmdes[j].FillArea = LFillArea + RFillArea + ZDroad.hdmdes[j].GouTarea;//填面积
	ZDroad.hdmdes[j].CutArea = LCutArea + RCutArea + ZDroad.hdmdes[j].GouWarea; //挖面积
	ZDroad.hdmdes[j].aw = ZDroad.hdmdes[j].CutArea;
	ZDroad.hdmdes[j].at = ZDroad.hdmdes[j].FillArea;
	ZDroad.hdmdes[j].FillBetterSoilArea = LFillBetterSoilArea + RFillBetterSoilArea;//填改良土面积
	ZDroad.hdmdes[j].HJarea = LHJarea + RHJarea;//护肩面积
	ZDroad.hdmdes[j].SGJQarea = LSGJQarea + RSGJQarea;//浆砌面积
	ZDroad.hdmdes[j].Z_LSGJQarea = LSGJQarea;//左浆砌面积
	ZDroad.hdmdes[j].Y_RSGJQarea = RSGJQarea;//右浆砌面积
	ZDroad.hdmdes[j].DQlength = LDQlength + RDQlength;//挡墙坡长
	ZDroad.hdmdes[j].Grasslength = LGrasslength + RGrasslength;//铺草坡长
	//用于交互设计
	ZDroad.hdmdes[j].MidFillArea = 0.0;
	ZDroad.hdmdes[j].MidCutArea = 0.0;
	ZDroad.hdmdes[j].MidFillSSTArea = 0.0;//填渗水土面积
	ZDroad.hdmdes[j].MidQBTArea = 0.0;
	ZDroad.hdmdes[j].MidFillGLTArea = 0.0;
	ZDroad.hdmdes[j].MidHJarea = 0.0;
	ZDroad.hdmdes[j].MidGouJQarea = 0.0;
	ZDroad.hdmdes[j].MidDQlength = 0.0;//挡墙坡长
	ZDroad.hdmdes[j].MidGrasslength = 0.0;//铺草坡长
}
//传入当前主线道路断面号及相关道路号，左右侧断面信息，计算有两个中线的整体式
void HdmDes::DesZXCrossOnDoubleLM(int j, RoadHdmdata &ZDroad, int zory)
{
	int Z_ZIfBTinf, Z_YIfBTinf, Y_ZIfBTinf, Y_YIfBTinf;
	double FLD_Zdesh, FLD_Ydesh, CmlOnFLD;
	double Z_LFillArea, Z_LCutArea, Y_RFillArea, Y_RCutArea, MidFillArea, MidCutArea;
	double Z_LFillBetterSoilArea, Z_LFillSSTArea, Z_LQBTArea, Z_LGouTarea, Z_LGouWarea, Z_LJSgou[36], Z_RJSgou[36], Z_LHJarea, Z_LSGJQarea, Z_LDQlength, Z_LGrasslength;
	double Y_RFillBetterSoilArea, Y_RFillSSTArea, Y_RQBTArea, Y_RGouTarea, Y_RGouWarea, Y_LJSgou[36], Y_RJSgou[36], Y_RHJarea, Y_RSGJQarea, Y_RDQlength, Y_RGrasslength;
	double MidFillGLTArea, MidQBTArea, MidHJarea, MidDQlength, MidGrasslength, MidGouJQarea;

	double Z_LGouH, Z_LGouX, Y_RGouH, Y_RGouX;
	double Z_TWH, Y_TWH;
	int Z_LGouProperty, Z_LGouPtNum, Z_LJSGouPtNum;
	int Y_RGouProperty, Y_RGouPtNum, Y_RJSGouPtNum;

	double Z_RGouH, Z_RGouX, Y_LGouH, Y_LGouX;
	int Z_RGouProperty, Z_RGouPtNum, Z_RJSGouPtNum;
	int Y_LGouProperty, Y_LGouPtNum, Y_LJSGouPtNum;

	double Z_Lgou[36], Z_Rgou[36], Y_Lgou[36], Y_Rgou[36];

	//填挖信息
	double ZX_TW[2], YX_TW[2];
	//桥隧信息
	double Z_BTinf, Y_BTinf;
	double Z_LZDK, Y_RZDK;

	AcGePoint3d pt;
	double ZJ;
	int Z_Lnpt, Z_Rnpt, Y_Lnpt, Y_Rnpt;
	double Z_RHFL[10], Z_RHFR[10], Y_RHFL[10], Y_RHFR[10];
	double Z_LDesPoint[500], Z_RDesPoint[500], Y_RDesPoint[500], Y_LDesPoint[500];
	double Z_YTWinf, Y_ZTWinf;
	double Z_Ydeltah, Z_Zdeltah, Y_Zdeltah, Y_Ydeltah;
	double Z_Ylmhd[3], Y_Zlmhd[3];

	double ZX_Yd, ZX_Learpt[400], ZX_Rearpt[400];
	int ZX_NumL, ZX_NumR;
	double YX_Yd, YX_Learpt[400], YX_Rearpt[400];
	int YX_NumL, YX_NumR;
	int Z_ZDMXZ, Z_YDMXZ, Y_ZDMXZ, Y_YDMXZ;
	double Z_ZBriZDK, Z_YBriZDK, Y_ZBriZDK, Y_YBriZDK;
	double Z_ZTunZDK, Z_YTunZDK, Y_ZTunZDK, Y_YTunZDK;
	double XJJ;
	double ZZlmhd[3], ZYlmhd[3], YZlmhd[3], YYlmhd[3];
	double ZZt, ZYt, YZt, YYt;
	double ZZtwh, ZYtwh, YZtwh, YYtwh;
	double ZZzdk, ZYzdk, YZzdk, YYzdk;
	bool IfXJGou;
	double cml;
	double dtmp[10];
	int Z_LIfSetGouH, Z_RIfSetGouH, Y_LIfSetGouH, Y_RIfSetGouH;
	double ZPJPT[2], YPJPT[2];

	//	double Z_LGouH,Z_RGouH,Y_LGouH,Y_RGouH;
	ZPJPT[0] = ZPJPT[1] = YPJPT[0] = YPJPT[1] = -1;
	//战时
	Z_ZBriZDK = Z_YBriZDK = Y_ZBriZDK = Y_YBriZDK = 1;
	Z_ZTunZDK = Z_YTunZDK = Y_ZTunZDK = Y_YTunZDK = 1;
	Z_Ydeltah = Z_Zdeltah = Y_Zdeltah = Y_Ydeltah = 0.0;
	IfXJGou = false;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	Z_ZIfBTinf = Z_YIfBTinf = Y_ZIfBTinf = Y_YIfBTinf = 0;
	FLD_Zdesh = FLD_Ydesh = CmlOnFLD = 0.0;
	Z_LFillArea = Z_LCutArea = Y_RFillArea = Y_RCutArea = MidFillArea = MidCutArea = 0.0;
	Z_LFillBetterSoilArea = Z_LFillSSTArea = Z_LQBTArea = Z_LGouTarea = Z_LGouWarea = 0.0;
	Z_LHJarea = Z_LSGJQarea = Z_LDQlength = Z_LGrasslength = 0.0;
	Y_RFillBetterSoilArea = Y_RFillSSTArea = Y_RQBTArea = Y_RGouTarea = Y_RGouWarea = 0.0;
	Y_RHJarea = Y_RSGJQarea = Y_RDQlength = Y_RGrasslength = 0.0;
	int k;
	for (k = 0; k < 20; k++)
		Y_LJSgou[k] = Y_RJSgou[k] = Z_LJSgou[k] = Z_RJSgou[k] = 0.0;
	MidFillGLTArea = MidQBTArea = MidHJarea = MidDQlength = MidGrasslength = MidGouJQarea = 0.0;

	Z_LGouH = Z_LGouX = Y_RGouH = Y_RGouX = Z_TWH = Y_TWH = 0.0;
	Z_LGouProperty = Z_LGouPtNum = Z_LJSGouPtNum = 0;
	Y_RGouProperty = Y_RGouPtNum = Y_RJSGouPtNum = 0;
	Z_RGouH = Z_RGouX = Y_LGouH = Y_LGouX = 0.0;
	Z_RGouProperty = Z_RGouPtNum = Z_RJSGouPtNum = 0;
	Y_LGouProperty = Y_LGouPtNum = Y_LJSGouPtNum = 0;
	for (k = 0; k < 14; k++)
		Z_Lgou[k] = Z_Rgou[k] = Y_Lgou[k] = Y_Rgou[k] = 0.0;

	//填挖信息
	for (k = 0; k < 2; k++)
		ZX_TW[k] = YX_TW[k] = 0.0;
	//桥隧信息
	Z_BTinf = Y_BTinf = Z_LZDK = Y_RZDK = 0.0;
	ZJ = 1000;
	Z_Lnpt = Z_Rnpt = Y_Lnpt = Y_Rnpt = 0;
	for (k = 0; k < 10; k++)
		Z_RHFL[k] = Z_RHFR[k] = Y_RHFL[k] = Y_RHFR[k] = 0.0;
	for (k = 0; k < 50; k++)
		Z_LDesPoint[k] = Z_RDesPoint[k] = Y_RDesPoint[k] = Y_LDesPoint[k] = 0.0;
	Z_YTWinf = Y_ZTWinf = 0.0;
	Z_Ydeltah = Y_Zdeltah = 0.0;
	for (k = 0; k < 3; k++)
		Z_Ylmhd[k] = Y_Zlmhd[k] = 0.0;

	ZX_Yd = 0.0;
	for (k = 0; k < 400; k++)
	{
		ZX_Learpt[k] = ZX_Rearpt[k] = 0.0;
		YX_Learpt[k] = YX_Rearpt[k] = 0.0;
	}
	ZX_NumL = ZX_NumR = 0;
	YX_Yd = 0.0;

	YX_NumL = YX_NumR = 0;
	Z_ZDMXZ = Z_YDMXZ = Y_ZDMXZ = Y_YDMXZ = 0;
	Z_ZBriZDK = Z_YBriZDK = Y_ZBriZDK = Y_YBriZDK = 1;
	Z_ZTunZDK = Z_YTunZDK = Y_ZTunZDK = Y_YTunZDK = 1;
	XJJ = 0.0;
	for (k = 0; k < 3; k++)
		ZZlmhd[k] = ZYlmhd[k] = YZlmhd[k] = YYlmhd[k] = 0.0;
	ZZt = ZYt = YZt = YYt = 0.0;
	ZZtwh = ZYtwh = YZtwh = YYtwh = 0.0;
	ZZzdk = ZYzdk = YZzdk = YYzdk = 0.0;
	IfXJGou = false;
	Z_LIfSetGouH = Z_RIfSetGouH = Y_LIfSetGouH = Y_RIfSetGouH = false;


	//ads_printf(L"cmlonfld=%lf\n",CmlOnFLD);
	//计算路面点
	CalZXxjj(road[0].hdmdes[j].cml, road[0].pm, ZDroad.pm, XJJ, CmlOnFLD);
	road[0].hdmdes[j].xjj = XJJ;
	road[0].hdmdes[j].FLDcml = CmlOnFLD;
	road[0].hdmdes[j].FLDname = ZDroad.pm->mdbname;

	//1。依据同坡和反坡信息计算出主线路面标高
	double ZD_RHFL[10], ZD_RHFR[10], LinkPt[2];
	CalBDZDDesH(road[0], road[0].hdmdes[j].cml, CmlOnFLD, XJJ, ZDroad, ZD_RHFL, ZD_RHFR, road[0].hdmdes[j].RHFL, road[0].hdmdes[j].RHFR);
	//需修正主线路面宽
	if (zory < -0.00001)//左侧关联
	{
		//左线(分离线)路面点
		Z_ZDMXZ = SetDmProperty(CmlOnFLD, ZDroad.pm,
			ZDroad.NZBri, ZDroad.ZBri, ZDroad.NAllBri,
			ZDroad.AllBri, ZDroad.NZTun, ZDroad.ZTun,
			ZDroad.NAllTun, ZDroad.AllTun, -1, Z_ZBriZDK);
		int i;
		for (i = 0; i < 10; i++)
		{
			Z_RHFL[i] = ZD_RHFL[i];
			Z_RHFR[i] = ZD_RHFR[i];
		}
		Z_YDMXZ = SetDmProperty(CmlOnFLD, ZDroad.pm,
			ZDroad.NYBri, ZDroad.YBri, ZDroad.NAllBri, ZDroad.AllBri,
			ZDroad.NYTun, ZDroad.YTun, ZDroad.NAllTun, ZDroad.AllTun, 1, Z_YBriZDK);
		Y_ZDMXZ = road[0].hdmdes[j].ZDMXZ;
		for (i = 0; i < 10; i++)
			Y_RHFL[i] = road[0].hdmdes[j].RHFL[i];
		YX_Yd = road[0].hdmdmx[j].EarH;
		YX_NumL = road[0].hdmdmx[j].ZEarPtNum;
		for (int k = 0; k < YX_NumL; k++)
		{
			YX_Learpt[k * 2] = road[0].hdmdmx[j].ZEarPtAry[k].x;
			YX_Learpt[k * 2 + 1] = road[0].hdmdmx[j].ZEarPtAry[k].y;
		}

		//移轴
		CalNewZB(road[0].hdmdes[j].xjj, YX_Yd, YX_Learpt, YX_NumL, YX_Rearpt, YX_NumR,
			ZX_Yd, ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR);


		//设计左线左侧
		if (Z_ZDMXZ == 3)//桥中
		{
			Z_LZDK = Z_RHFL[8] + Z_ZBriZDK;//桥梁用地
			Z_ZIfBTinf = 1;
			if (road[0].NCRS == 1)
				ads_alert(L"指定里程位于桥梁范围内!");
		}

		if (Z_ZDMXZ == 4)//隧道中
		{
			//  Z_LZDK = Z_RHFL[8] + Z_ZTunZDK;//隧道用地
			Z_LZDK = 0.0;//隧道用地
			Z_ZIfBTinf = 1;
			if (road[0].NCRS == 1)
				ads_alert(L"指定里程位于隧道范围内!");
		}

		if (!Z_ZIfBTinf)
		{
			CrosNew1(ZDroad, -1, CmlOnFLD, ZX_Yd, ZX_NumL, ZX_Learpt,
				Z_RHFL, ZZlmhd, 1000, ZPJPT,
				Z_Zdeltah, ZZt, ZZtwh, Z_Lnpt, Z_LDesPoint,
				Z_LFillArea, Z_LFillBetterSoilArea, Z_LQBTArea, Z_LCutArea,
				Z_LZDK,
				Z_LIfSetGouH, Z_LGouH, Z_LGouProperty, Z_LGouPtNum, Z_Lgou,
				Z_LGouH, Z_LGouX, Z_LGouTarea, Z_LGouWarea,
				Z_LJSGouPtNum, Z_LJSgou,
				Z_LSGJQarea, Z_LDQlength, Z_LGrasslength);
		}
	}
	else
	{
		//右线(分离线)路面点
		Y_ZDMXZ = SetDmProperty(CmlOnFLD, ZDroad.pm,
			ZDroad.NZBri, ZDroad.ZBri, ZDroad.NAllBri,
			ZDroad.AllBri, ZDroad.NZTun, ZDroad.ZTun,
			ZDroad.NAllTun, ZDroad.AllTun, -1, Y_ZBriZDK);
		int i;
		for (i = 0; i < 10; i++)
		{
			Y_RHFL[i] = ZD_RHFL[i];
			Y_RHFR[i] = ZD_RHFR[i];
		}
		Y_YDMXZ = SetDmProperty(CmlOnFLD, ZDroad.pm,
			ZDroad.NYBri, ZDroad.YBri, ZDroad.NAllBri, ZDroad.AllBri,
			ZDroad.NYTun, ZDroad.YTun, ZDroad.NAllTun, ZDroad.AllTun, 1, Y_YBriZDK);
		Z_YDMXZ = road[0].hdmdes[j].YDMXZ;
		for (i = 0; i < 10; i++)
			Z_RHFR[i] = road[0].hdmdes[j].RHFR[i];
		ZX_Yd = road[0].hdmdmx[j].EarH;
		ZX_NumR = road[0].hdmdmx[j].YEarPtNum;
		for (k = 0; k < ZX_NumR; k++)
		{
			ZX_Rearpt[k * 2] = road[0].hdmdmx[j].YEarPtAry[k].x;
			ZX_Rearpt[k * 2 + 1] = road[0].hdmdmx[j].YEarPtAry[k].y;
		}
		//移轴
		CalNewZB(road[0].hdmdes[j].xjj, ZX_Yd, ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR,
			YX_Yd, YX_Learpt, YX_NumL, YX_Rearpt, YX_NumR);

		//4.右线右侧
		if (Y_YDMXZ == 3)//桥中
		{
			Y_RZDK = Y_RHFR[8] + Y_YBriZDK;//桥梁用地
			Y_YIfBTinf = 1;
			if (road[0].NCRS == 1)
			{
				ads_alert(L"指定里程位于桥梁范围内!");
			}
		}

		if (Y_YDMXZ == 4)//隧道中
		{
			// Y_RZDK=Y_RHFR[8]+Y_YTunZDK;//桥梁用地
			Y_RZDK = 0.0;//桥梁用地
			Y_YIfBTinf = 1;
			if (road[0].NCRS == 1)
			{
				ads_alert(L"指定里程位于隧道范围内!");

			}
		}

		if (!Y_YIfBTinf)
		{
			CrosNew1(ZDroad, 1, CmlOnFLD, YX_Yd, YX_NumR, YX_Rearpt,
				Y_RHFR, YYlmhd, 1000, YPJPT,
				Y_Ydeltah, YYt, YYtwh, Y_Rnpt, Y_RDesPoint,
				Y_RFillArea, Y_RFillBetterSoilArea, Y_RQBTArea, Y_RCutArea,
				Y_RZDK,
				Y_RIfSetGouH, Y_RGouH, Y_RGouProperty, Y_RGouPtNum, Y_Rgou,
				Y_RGouH, Y_RGouX, Y_RGouTarea, Y_RGouWarea,
				Y_RJSGouPtNum, Y_RJSgou,
				Y_RSGJQarea, Y_RDQlength, Y_RGrasslength);
			//右线右侧设计完!
		}
	}

	//4.计算两线中间断面	
	//4.1 计算左线(分离线)右侧断面性质
	if (Z_YDMXZ == 3 || Z_YDMXZ == 4)//桥中
		Z_YIfBTinf = 1;
	//4.2 计算左线右侧断面填挖信息
	//4.3 计算右线左侧断面性质
	if (Y_ZDMXZ == 3 || Y_ZDMXZ == 4)//桥中
		Y_ZIfBTinf = 1;
	//4.2 计算左线右侧断面填挖信息
	//4.4 依据填挖信息拼合断面
	//设计两线中间
	if (!Z_YIfBTinf && !Y_ZIfBTinf)//两线中间均非桥隧
	{
		DesZXHdm_ON_doubleLM(XJJ, ZDroad,
			cml, CmlOnFLD,
			Z_RHFR, Y_RHFL,
			ZX_Yd, ZX_NumR, ZX_Rearpt,
			YX_Yd, YX_NumL, YX_Learpt,
			ZYt, YZt,
			ZYlmhd, YZlmhd,
			Z_Rnpt, Z_RDesPoint, Y_Lnpt, Y_LDesPoint,
			MidFillArea, MidCutArea,
			MidQBTArea, MidFillGLTArea, MidHJarea, MidGouJQarea,
			MidDQlength, MidGrasslength, IfXJGou
		);//设计左填至右填
	}
	else if (Z_YIfBTinf && !Y_ZIfBTinf)//左线为桥,右线非桥
	{//不考虑水沟
		//设计右线左侧
		if (XJJ < 0.00001)
			CrosNew(0, -1, j, YX_Yd, YX_NumL, YX_Learpt,
				Y_RHFL, YZlmhd, Y_RHFL[8], YPJPT,
				Y_Zdeltah, YZt, YZtwh, Y_Lnpt, Y_LDesPoint,
				MidFillArea, MidFillGLTArea, MidQBTArea, MidCutArea,
				YZzdk,
				Y_LIfSetGouH, Y_LGouH, Y_LGouProperty, Y_LGouPtNum, Y_Lgou,
				Y_LGouH, Y_LGouX, dtmp[0], dtmp[1],
				Y_LJSGouPtNum, Y_LJSgou,
				MidGouJQarea, MidDQlength, MidGrasslength, dtmp[2]);
		else
			CrosNew1(ZDroad, -1, CmlOnFLD, YX_Yd, YX_NumL, YX_Learpt,
				Y_RHFL, YZlmhd, Y_RHFL[8], YPJPT,
				Y_Zdeltah, YZt, YZtwh, Y_Lnpt, Y_LDesPoint,
				MidFillArea, MidFillGLTArea, MidQBTArea, MidCutArea,
				YZzdk,
				Y_LIfSetGouH, Y_LGouH, Y_LGouProperty, Y_LGouPtNum, Y_Lgou,
				Y_LGouH, Y_LGouX, dtmp[0], dtmp[1],
				Y_LJSGouPtNum, Y_LJSgou,
				MidGouJQarea, MidDQlength, MidGrasslength);
	}
	else if (!Z_YIfBTinf && Y_ZIfBTinf)//右线为桥,左线非桥
	{
		//设计左线右侧
		if (XJJ < 0.00001)
			CrosNew1(ZDroad, 1, CmlOnFLD, ZX_Yd, ZX_NumR, ZX_Rearpt,
				Z_RHFR, ZYlmhd, Z_RHFR[8], ZPJPT,
				Z_Ydeltah, ZYt, ZYtwh, Z_Rnpt, Z_RDesPoint,
				MidFillArea, MidFillGLTArea, MidQBTArea, MidCutArea,
				ZYzdk,
				Z_RIfSetGouH, Z_RGouH, Z_RGouProperty, Z_RGouPtNum, Z_Rgou,
				Z_RGouH, Z_RGouX, dtmp[0], dtmp[1],
				Z_RJSGouPtNum, Z_RJSgou,
				MidGouJQarea, MidDQlength, MidGrasslength);
		else
			CrosNew(0, 1, j, ZX_Yd, ZX_NumR, ZX_Rearpt,
				Z_RHFR, ZYlmhd, Z_RHFR[8], ZPJPT,
				Z_Ydeltah, ZYt, ZYtwh, Z_Rnpt, Z_RDesPoint,
				MidFillArea, MidFillGLTArea, MidQBTArea, MidCutArea,
				ZYzdk,
				Z_RIfSetGouH, Z_RGouH, Z_RGouProperty, Z_RGouPtNum, Z_Rgou,
				Z_RGouH, Z_RGouX, dtmp[0], dtmp[1],
				Z_RJSGouPtNum, Z_RJSgou,
				MidGouJQarea, MidDQlength, MidGrasslength, dtmp[2]);
	}
	else//两线中间均为桥隧
	{
	}
	//设计完成，给节点付值

	if (zory < 0)//当前为右线，左侧有关联匝道
	{
		road[0].hdmdes[j].IfHasZlink = 1;
		//左线关联
		road[0].hdmdes[j].zlink = new CRSDAT;
		InitHdmData(*road[0].hdmdes[j].zlink);
		road[0].hdmdes[j].zlink->cml = CmlOnFLD;
		road[0].hdmdes[j].zlink->glRoadName = ZDroad.roadname;
		road[0].hdmdes[j].zlink->Zt = ZZt;
		road[0].hdmdes[j].zlink->ZDMXZ = Z_ZDMXZ;
		road[0].hdmdes[j].zlink->Lnpt = Z_Lnpt;
		road[0].hdmdes[j].zlink->newLYd = road[0].hdmdes[j].zlink->newRYd = ZX_Yd;
		for (k = 0; k < Z_Lnpt; k++)
		{
			pt.x = -1.0*Z_LDesPoint[k * 2];
			pt.y = Z_LDesPoint[k * 2 + 1];
			road[0].hdmdes[j].zlink->RPTL.append(pt);
		}
		if (Z_Lnpt > 0)
			road[0].hdmdes[j].zlink->Ljdnum = Z_Lnpt - 1;

		road[0].hdmdes[j].zlink->LIfSetGouH = Z_LIfSetGouH;
		road[0].hdmdes[j].zlink->LGouH = Z_LGouH;
		road[0].hdmdes[j].zlink->LGouProperty = Z_LGouProperty;
		road[0].hdmdes[j].zlink->LGouPtNum = Z_LGouPtNum;
		for (int kk = 0; kk < road[0].hdmdes[j].zlink->LGouPtNum; kk++)
		{
			road[0].hdmdes[j].zlink->Lgou[kk * 2] = -1 * Z_Lgou[kk * 2];
			road[0].hdmdes[j].zlink->Lgou[kk * 2 + 1] = Z_Lgou[kk * 2 + 1];
		}
		road[0].hdmdes[j].zlink->LJSGouPtNum = Z_LJSGouPtNum;
		for (k = 0; k < Z_LJSGouPtNum; k++)
		{
			road[0].hdmdes[j].zlink->LJSgou[k * 2] = -1 * Z_LJSgou[k * 2];
			road[0].hdmdes[j].zlink->LJSgou[k * 2 + 1] = Z_LJSgou[k * 2 + 1];
		}
		road[0].hdmdes[j].LZDK = Z_LZDK;

		//左线右侧
		road[0].hdmdes[j].zlink->Yt = ZYt;
		road[0].hdmdes[j].zlink->YDMXZ = Z_YDMXZ;
		road[0].hdmdes[j].zlink->Rnpt = Z_Rnpt;
		for (k = 0; k < Z_Rnpt; k++)
		{
			pt.x = Z_RDesPoint[k * 2];
			pt.y = Z_RDesPoint[k * 2 + 1];
			road[0].hdmdes[j].zlink->RPTR.append(pt);
		}
		if (Z_Rnpt > 0)
			road[0].hdmdes[j].zlink->Rjdnum = Z_Rnpt - 1;
		road[0].hdmdes[j].zlink->Ldeltah = Z_Zdeltah;
		road[0].hdmdes[j].ZDorS = 2.0;//双线路面
		for (k = 0; k < 3; k++)
		{
			road[0].hdmdes[j].zlink->zlmhd[k] = ZZlmhd[k];
			road[0].hdmdes[j].zlink->ylmhd[k] = ZYlmhd[k];
			road[0].hdmdes[j].zlmhd[k] = YZlmhd[k];
		}


		//右线左侧 		   		   
		road[0].hdmdes[j].Zt = YZt;
		road[0].hdmdes[j].ZDMXZ = Y_ZDMXZ;
		road[0].hdmdes[j].Lnpt = Y_Lnpt;

		for (k = 0; k < Y_Lnpt; k++)
		{
			pt.x = -1 * Y_LDesPoint[k * 2];
			pt.y = Y_LDesPoint[k * 2 + 1];
			road[0].hdmdes[j].RPTL.append(pt);
		}

		if (Y_Lnpt > 0)
			road[0].hdmdes[j].Ljdnum = road[0].hdmdes[j].Lnpt - 1;

		road[0].hdmdes[j].ZHc = YZtwh;

		for (k = 0; k < 5; k++)
		{
			road[0].hdmdes[j].zlink->RHFL[2 * k] = Z_RHFL[k * 2];
			road[0].hdmdes[j].zlink->RHFL[2 * k + 1] = Z_RHFL[k * 2 + 1];

			road[0].hdmdes[j].zlink->RHFR[2 * k] = Z_RHFR[k * 2];
			road[0].hdmdes[j].zlink->RHFR[2 * k + 1] = Z_RHFR[k * 2 + 1];

			road[0].hdmdes[j].RHFL[2 * k] = Y_RHFL[k * 2];
			road[0].hdmdes[j].RHFL[2 * k + 1] = Y_RHFL[k * 2 + 1];
		}

		road[0].hdmdes[j].Z_LFillArea = Z_LFillArea + Z_LGouTarea + MidFillArea;
		road[0].hdmdes[j].Z_LCutArea = Z_LCutArea + Z_LGouWarea + MidCutArea;
		road[0].hdmdes[j].Z_LSGJQarea = Z_LSGJQarea;
		road[0].hdmdes[j].Z_LDQlength = Z_LDQlength;
		road[0].hdmdes[j].Z_LGrasslength = Z_LGrasslength;
	}
	else
	{
		road[0].hdmdes[j].IfHasYlink = 1;
		//右线关联
		road[0].hdmdes[j].ylink = new CRSDAT;
		InitHdmData(*road[0].hdmdes[j].ylink);
		road[0].hdmdes[j].ylink->cml = CmlOnFLD;
		road[0].hdmdes[j].ylink->glRoadName = ZDroad.roadname;
		road[0].hdmdes[j].ylink->Zt = YZt;
		road[0].hdmdes[j].ylink->ZDMXZ = Y_ZDMXZ;
		road[0].hdmdes[j].ylink->Lnpt = Y_Lnpt;
		road[0].hdmdes[j].ylink->newLYd = road[0].hdmdes[j].ylink->newRYd = YX_Yd;
		road[0].hdmdes[j].YDorS = 2.0;//双线路面
		for (k = 0; k < Y_Lnpt; k++)
		{
			pt.x = -1.0*Y_LDesPoint[k * 2];
			pt.y = Y_LDesPoint[k * 2 + 1];
			road[0].hdmdes[j].ylink->RPTL.append(pt);
		}
		if (Y_Lnpt > 0)
			road[0].hdmdes[j].ylink->Ljdnum = Y_Lnpt - 1;

		road[0].hdmdes[j].ylink->RIfSetGouH = Y_RIfSetGouH;
		road[0].hdmdes[j].ylink->RGouH = Y_RGouH;
		road[0].hdmdes[j].ylink->RGouProperty = Y_RGouProperty;
		road[0].hdmdes[j].ylink->RGouPtNum = Y_RGouPtNum;
		for (int kk = 0; kk < road[0].hdmdes[j].ylink->RGouPtNum; kk++)
		{
			road[0].hdmdes[j].ylink->Rgou[kk * 2] = Y_Rgou[kk * 2];
			road[0].hdmdes[j].ylink->Rgou[kk * 2 + 1] = Y_Rgou[kk * 2 + 1];
		}
		road[0].hdmdes[j].ylink->RJSGouPtNum = Y_RJSGouPtNum;
		for (k = 0; k < Y_RJSGouPtNum; k++)
		{
			road[0].hdmdes[j].ylink->RJSgou[k * 2] = Y_RJSgou[k * 2];
			road[0].hdmdes[j].ylink->RJSgou[k * 2 + 1] = Y_RJSgou[k * 2 + 1];
		}
		road[0].hdmdes[j].RZDK = Y_RZDK;

		road[0].hdmdes[j].ylink->Yt = YYt;
		road[0].hdmdes[j].ylink->YDMXZ = Y_YDMXZ;
		road[0].hdmdes[j].ylink->Rnpt = Y_Rnpt;
		for (k = 0; k < Y_Rnpt; k++)
		{
			pt.x = Y_RDesPoint[k * 2];
			pt.y = Y_RDesPoint[k * 2 + 1];
			road[0].hdmdes[j].ylink->RPTR.append(pt);
		}
		if (Y_Rnpt > 0)
			road[0].hdmdes[j].ylink->Rjdnum = Y_Rnpt - 1;

		road[0].hdmdes[j].Yt = ZYt;
		road[0].hdmdes[j].YDMXZ = Z_YDMXZ;
		road[0].hdmdes[j].Rnpt = Z_Rnpt;
		for (k = 0; k < Z_Rnpt; k++)
		{
			pt.x = Z_RDesPoint[k * 2];
			pt.y = Z_RDesPoint[k * 2 + 1];
			road[0].hdmdes[j].RPTR.append(pt);
		}

		if (Z_Rnpt > 0)
			road[0].hdmdes[j].Rjdnum = road[0].hdmdes[j].Rnpt - 1;

		road[0].hdmdes[j].YHc = ZYtwh;
		//road[0].hdmdes[j].YDorS = 2;//双线路面

		for (k = 0; k < 3; k++)
		{
			road[0].hdmdes[j].ylink->zlmhd[k] = YZlmhd[k];
			road[0].hdmdes[j].ylink->ylmhd[k] = YYlmhd[k];
			road[0].hdmdes[j].ylmhd[k] = ZYlmhd[k];
		}
		////////////////////////////////////////////////////////////////////////	  
		road[0].hdmdes[j].Y_RFillArea = Y_RFillArea + Y_RGouTarea + MidFillArea;
		road[0].hdmdes[j].Y_RCutArea = Y_RCutArea + Y_RGouWarea + MidCutArea;
		road[0].hdmdes[j].Y_RSGJQarea = Y_RSGJQarea;
		road[0].hdmdes[j].Y_RDQlength = Y_RDQlength;
		road[0].hdmdes[j].Y_RGrasslength = Y_RGrasslength;

		for (k = 0; k < 5; k++)
		{
			road[0].hdmdes[j].ylink->RHFL[2 * k] = Y_RHFL[k * 2];
			road[0].hdmdes[j].ylink->RHFL[2 * k + 1] = Y_RHFL[k * 2 + 1];

			road[0].hdmdes[j].ylink->RHFR[2 * k] = Y_RHFR[k * 2];
			road[0].hdmdes[j].ylink->RHFR[2 * k + 1] = Y_RHFR[k * 2 + 1];

			road[0].hdmdes[j].RHFR[2 * k] = Z_RHFR[k * 2];
			road[0].hdmdes[j].RHFR[2 * k + 1] = Z_RHFR[k * 2 + 1];
		}
		road[0].hdmdes[j].ylink->Rdeltah = Y_Ydeltah;
	}

	/*
	if(ZZtwh==-10000)
	ZZtwh = ZYtwh;
	if(ZYtwh==-10000)
	ZYtwh = ZZtwh;
	if(YZtwh==-10000)
	YZtwh = YYtwh;
	if(YYtwh==-10000)
	YYtwh = YZtwh;


	road[0].hdmdes[j].Z_LFillArea=Z_LFillArea+ Z_LGouTarea + Z_LQBTArea;
	road[0].hdmdes[j].MidFillArea=MidFillArea + MidQBTArea;
	road[0].hdmdes[j].Y_RFillArea=Y_RFillArea +  Y_RGouTarea + Y_RQBTArea;

	road[0].hdmdes[j].Z_LCutArea=Z_LCutArea + Z_LGouWarea ;
	road[0].hdmdes[j].MidCutArea=MidCutArea ;
	road[0].hdmdes[j].Y_RCutArea=Y_RCutArea + Y_RGouWarea;
	road[0].hdmdes[j].Z_LFillSSTArea = Z_LFillSSTArea ;
	road[0].hdmdes[j].Y_RFillSSTArea=Y_RFillSSTArea;//填渗水土面积
	road[0].hdmdes[j].Z_LQBTArea=Z_LQBTArea ;
	road[0].hdmdes[j].MidQBTArea=MidQBTArea;
	road[0].hdmdes[j].Y_RQBTArea=Y_RQBTArea;
	road[0].hdmdes[j].Z_LFillBetterSoilArea=Z_LFillBetterSoilArea ; road[0].hdmdes[j].MidFillGLTArea=MidFillGLTArea ;road[0].hdmdes[j].Y_RFillBetterSoilArea=Y_RFillBetterSoilArea;
	road[0].hdmdes[j].Z_LHJarea=Z_LHJarea ;road[0].hdmdes[j].MidHJarea=MidHJarea ;road[0].hdmdes[j].Y_RHJarea=Y_RHJarea;
	road[0].hdmdes[j].Z_LSGJQarea=Z_LSGJQarea ;road[0].hdmdes[j].MidGouJQarea=MidGouJQarea ;road[0].hdmdes[j].Y_RSGJQarea=Y_RSGJQarea;
	road[0].hdmdes[j].Z_LDQlength=Z_LDQlength ;road[0].hdmdes[j].MidDQlength=MidDQlength ;road[0].hdmdes[j].Y_RDQlength=Y_RDQlength;//挡墙坡长

	road[0].hdmdes[j].Z_LGrasslength=Z_LGrasslength ;road[0].hdmdes[j].MidGrasslength=MidGrasslength;road[0].hdmdes[j].Y_RGrasslength=Y_RGrasslength;//铺草坡长
	road[0].hdmdes[j].Z_LGouTarea=Z_LGouTarea ; road[0].hdmdes[j].Y_RGouTarea=Y_RGouTarea;
	road[0].hdmdes[j].Z_LGouWarea=Z_LGouWarea ;road[0].hdmdes[j].Y_RGouWarea=Y_RGouWarea;

	if(road[0].hdmdes[j].Y_Lnpt>0)

	if(road[0].hdmdes[j].Y_Rnpt>0)
	road[0].hdmdes[j].Y_Rjdnum = road[0].hdmdes[j].Y_Rnpt-1;*/




}

//输入地面线及路肩标高，计算填挖信息
void HdmDes::CalTWinf(double Earh, double earpt[], int npt, double w, double BG, double &TWinf, double &deltah)
{
	deltah = 0.0;
	TWinf = 0.0;
	deltah = Cal_deltah(earpt, npt, fabs(w), BG, Earh);
	if (deltah < 0.6)//路堑//由路肩填挖高决定路面宽，是路堤还是路签
		TWinf = 1.0;
	else
		TWinf = 0.0;
}

void HdmDes::DesFLdHdm_ZTtoYT(double XJJ, int iroad,
	double cml, double projml,
	double Z_RHFR[], double Y_RHFL[],
	double LNewYd, int Z_NewNumR, double Z_NewRearpt[],
	double RNewYd, int Y_NewNumL, double Y_NewLearpt[],
	double &Z_RTW, double &Y_LTW,
	double Z_Rlmhd[3], double Y_Llmhd[3],
	int &Z_Rnpt, double Z_RDesPoint[],
	int &Y_Lnpt, double Y_LDesPoint[],
	double &MidFillArea, double &MidCutArea,
	double &MidQBTArea, double &MidFillGLTArea, double &MidHJarea,
	double &MidGouJQarea,
	double &MidDQLength, double &MidCrassLength, bool &IfXJGou
)//设计左填至右填
{
	//左线右侧单独设计,得左线边坡点
	double Z_RStartDesPt[2], Y_LStartDesPt[2];
	double Z_RTM[30], Z_RTH[30], Z_RTPTW[30], Z_RTPTI[30];
	double Y_LTM[30], Y_LTH[30], Y_LTPTW[30], Y_LTPTI[30];
	int Z_RLTBPJS, Y_LLTBPJS;
	double Z_RZJ, Y_LZJ, XJGK;
	int Z_RBPptSum, Y_LBPptSum;
	double Z_RBPpt[50], Y_LBPpt[50];
	double BPJD[2];
	double Z_RDQLength, Z_RGrassLength, Y_LDQLength, Y_LGrassLength;
	double zssthd, zglthd, zhjwid, zhthd;
	double yssthd, yglthd, yhjwid, yhthd;
	double Z_RFillArea, Z_RCutArea, Y_LFillArea, Y_LCutArea;
	double Z_RQBTArea, Z_RFillGLTArea, Z_RHJarea;
	double Y_LQBTArea, Y_LFillGLTArea, Y_LHJarea;
	double Z_Rhthd, Y_Lhthd;
	double dtmp, desinf, PTK;
	double ljdis, deltax;

	int j;
	for (j = 0; j < 2; j++)
		Z_RStartDesPt[j] = Y_LStartDesPt[j] = 0.0;
	for (j = 0; j < 30; j++)
	{
		Z_RTM[j] = Z_RTH[j] = Z_RTPTW[j] = Z_RTPTI[j] = 0.0;
		Y_LTM[j] = Y_LTH[j] = Y_LTPTW[j] = Y_LTPTI[j] = 0.0;
	}
	Z_RLTBPJS = Y_LLTBPJS = 0;
	Z_RZJ = Y_LZJ = XJGK = 1000.0;
	Z_RBPptSum = Y_LBPptSum = 0;
	Z_RDQLength = Z_RGrassLength = Y_LDQLength = Y_LGrassLength = 0;
	zssthd = zglthd = zhjwid = zhthd = 0;
	yssthd = yglthd = yhjwid = yhthd = 0;
	Z_RFillArea = Z_RCutArea = Y_LFillArea = Y_LCutArea = 0;
	Z_RQBTArea = Z_RFillGLTArea = Z_RHJarea = 0;
	Y_LQBTArea = Y_LFillGLTArea = Y_LHJarea = 0;
	Z_Rhthd = Y_Lhthd = 0;


	Z_RStartDesPt[0] = Z_RHFR[3 * 2];//以左线为Y轴
	Z_RStartDesPt[1] = Z_RHFR[3 * 2 + 1] - LNewYd;//地面标高为原点	
	if (XJJ < 0.0001)//左线为绕行，一线为右线
	{
		//取出左线右侧参数
		Z_RLTBPJS = FindWichBP(projml, road[iroad].pm, road[iroad].hdmbz.NYLDBP, road[iroad].hdmbz.YLDBP, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI);//左路堤边坡
		//清表土厚度
		Z_Rhthd = FindWichHTHD(projml, road[iroad].pm, road[iroad].hdmbz.NYHTHD, road[iroad].hdmbz.YHTHD);
		Z_RZJ = FindWichDQ(projml, road[iroad].pm, road[iroad].hdmbz.NYDQ, road[iroad].hdmbz.YDQ);
		//路面厚
		FindWichHD(projml, road[iroad].pm, road[iroad].hdmbz.NYLMHD, road[iroad].hdmbz.YLMHD, Z_Rlmhd);

		Y_LLTBPJS = FindWichBP(cml, road[0].pm, road[0].hdmbz.NZLDBP, road[0].hdmbz.ZLDBP, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI);//左路堤边坡
		//清表土厚度
		Y_Lhthd = FindWichHTHD(cml, road[0].pm, road[0].hdmbz.NZHTHD, road[0].hdmbz.ZHTHD);
		Y_LZJ = FindWichDQ(cml, road[0].pm, road[0].hdmbz.NZDQ, road[0].hdmbz.ZDQ);
		//路面厚
		FindWichHD(cml, road[0].pm, road[0].hdmbz.NZLMHD, road[0].hdmbz.ZLMHD, Y_Llmhd);
	}
	else
	{
		//取出左线(主线)右侧参数
		Z_RLTBPJS = FindWichBP(cml, road[0].pm, road[0].hdmbz.NYLDBP, road[0].hdmbz.YLDBP, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI);//左路堤边坡
		//清表土厚度
		Z_Rhthd = FindWichHTHD(cml, road[0].pm, road[0].hdmbz.NYHTHD, road[0].hdmbz.YHTHD);
		Z_RZJ = FindWichDQ(cml, road[0].pm, road[0].hdmbz.NYDQ, road[0].hdmbz.YDQ);
		//路面厚
		FindWichHD(cml, road[0].pm, road[0].hdmbz.NYLMHD, road[0].hdmbz.YLMHD, Z_Rlmhd);

		Y_LLTBPJS = FindWichBP(projml, road[iroad].pm, road[iroad].hdmbz.NZLDBP, road[iroad].hdmbz.ZLDBP, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI);//左路堤边坡
		//清表土厚度
		Y_Lhthd = FindWichHTHD(projml, road[iroad].pm, road[iroad].hdmbz.NZHTHD, road[iroad].hdmbz.ZHTHD);
		Y_LZJ = FindWichDQ(projml, road[iroad].pm, road[iroad].hdmbz.NZDQ, road[iroad].hdmbz.ZDQ);
		//路面厚
		FindWichHD(projml, road[iroad].pm, road[iroad].hdmbz.NZLMHD, road[iroad].hdmbz.ZLMHD, Y_Llmhd);
	}


	Z_Rnpt = 5;
	Z_RDesPoint[0] = 0.0;
	Z_RDesPoint[1] = Z_RHFR[1] - LNewYd;
	for (j = 0; j < 5; j++)
	{
		Z_RDesPoint[j * 2] = Z_RHFR[j * 2];
		Z_RDesPoint[j * 2 + 1] = Z_RHFR[j * 2 + 1] - LNewYd;
	}

	Y_Lnpt = 5;
	Y_LDesPoint[0] = 0.0;
	Y_LDesPoint[1] = Y_RHFL[1] - RNewYd;

	for (j = 0; j < 5; j++)
	{
		Y_LDesPoint[j * 2] = Y_RHFL[j * 2];
		Y_LDesPoint[j * 2 + 1] = Y_RHFL[j * 2 + 1] - RNewYd;
	}

	//-------------------------------------------------------------------------------------------------------------	
	XJGK = 2.4;//2.4
	ljdis = fabs(XJJ) - Z_RHFR[8] - Y_RHFL[8];//路肩距离
	if (ljdis > XJGK)//做边坡并做线间沟
	{
		Z_RStartDesPt[0] = Z_RHFR[4 * 2];//以左线为Y轴
		Z_RStartDesPt[1] = Z_RHFR[4 * 2 + 1] - LNewYd;//地面标高为原点	
		desinf = DesBPnew(-1, Z_RStartDesPt, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI, 0, Z_NewNumR, Z_NewRearpt, 100.0,
			Z_RBPpt, Z_RBPptSum, Z_RZJ, Z_RLTBPJS);//路堤
		//右线左侧单独设计,得右线边坡点
		Y_LStartDesPt[0] = Y_RHFL[4 * 2];//以左线为Y轴
		Y_LStartDesPt[1] = Y_RHFL[4 * 2 + 1] - RNewYd;//地面标高为原点				
		desinf = DesBPnew(-1, Y_LStartDesPt, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI, 0, Y_NewNumL, Y_NewLearpt, 100.0,
			Y_LBPpt, Y_LBPptSum, Y_LZJ, Y_LLTBPJS);//路堤

		int Binf = CalBPJD(0.0, fabs(XJJ), Z_RStartDesPt, Z_RBPpt, Z_RBPptSum,
			Y_LStartDesPt, Y_LBPpt, Y_LBPptSum, LNewYd, RNewYd, BPJD);


		if (Binf)//两侧边坡相交
		{

			//建立统一坐标系,求出两侧边坡交点,得支距
			int inf = CalBPJD(XJGK, fabs(XJJ), Z_RStartDesPt, Z_RBPpt, Z_RBPptSum,
				Y_LStartDesPt, Y_LBPpt, Y_LBPptSum, LNewYd, RNewYd, BPJD);
			if (inf && BPJD[1] < Z_RHFR[9] - LNewYd && BPJD[1] < Y_RHFL[9] - LNewYd)//找到交点,且交点标高小于路肩标高-ssthd
			{
				Z_RZJ = BPJD[0];
				PTK = 1.0;
			}
			else
			{
				inf = CalBPJD(XJGK - 1.0, fabs(XJJ), Z_RStartDesPt, Z_RBPpt, Z_RBPptSum,
					Y_LStartDesPt, Y_LBPpt, Y_LBPptSum, LNewYd, RNewYd, BPJD);//缩小线间沟再计算,找到交点
				if (inf && BPJD[1] < Z_RHFR[9] - LNewYd && BPJD[1] < Y_RHFL[9] - LNewYd)//找到交点,且交点标高小于路肩标高-ssthd
				{
					Z_RZJ = BPJD[0];
					PTK = 0.5;
				}
				else
					IfXJGou = true;//无法做边坡+线间沟
			}
		}
		//按照支距重新设计左线右侧
		desinf = DesBPnew(-1, Z_RStartDesPt, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI, 0, Z_NewNumR, Z_NewRearpt, 100.0,
			Z_RBPpt, Z_RBPptSum, Z_RZJ, Z_RLTBPJS);//路堤


		Z_Rnpt = 5;
		int j;
		for (j = 0; j < 5; j++)
		{
			Z_RDesPoint[j * 2] = Z_RHFR[j * 2];
			Z_RDesPoint[j * 2 + 1] = Z_RHFR[j * 2 + 1] - LNewYd;

		}
		Z_RDesPoint[0] = 0;
		Z_RDesPoint[1] = Z_RDesPoint[3];

		Y_Lnpt = 5;
		for (j = 0; j < 5; j++)
		{
			Y_LDesPoint[j * 2] = Y_RHFL[j * 2];
			Y_LDesPoint[j * 2 + 1] = Y_RHFL[j * 2 + 1] - RNewYd;
		}
		Y_LDesPoint[0] = 0;
		Y_LDesPoint[1] = Y_LDesPoint[3];
		BPptToDESpt(Z_RBPptSum, Z_RBPpt, Z_Rnpt, Z_RDesPoint, dtmp, dtmp, dtmp, dtmp, Z_RDQLength, Z_RGrassLength);

		//补充线间沟	
		if (Binf)
		{
			Z_RDesPoint[Z_Rnpt * 2] = Z_RDesPoint[(Z_Rnpt - 1) * 2] + PTK;
			Z_RDesPoint[Z_Rnpt * 2 + 1] = Z_RDesPoint[(Z_Rnpt - 1) * 2 + 1];//沟底标高
			Z_Rnpt++;

			Z_RDesPoint[Z_Rnpt * 2] = Z_RDesPoint[(Z_Rnpt - 1) * 2];
			Z_RDesPoint[Z_Rnpt * 2 + 1] = Z_RDesPoint[(Z_Rnpt - 1) * 2 + 1] - 0.6;//沟底标高
			Z_Rnpt++;

			Z_RDesPoint[Z_Rnpt * 2] = Z_RDesPoint[(Z_Rnpt - 1) * 2] + 0.2;
			Z_RDesPoint[Z_Rnpt * 2 + 1] = Z_RDesPoint[(Z_Rnpt - 1) * 2 + 1];//沟底标高
			Z_Rnpt++;
		}

		//------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------
		//右侧点
		if (Binf)
			Y_LZJ = fabs(XJJ) - Z_RZJ - (2 * PTK + 0.4);
		else
			Y_LZJ = 100.0;
		desinf = DesBPnew(-1, Y_LStartDesPt, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI, 0, Y_NewNumL, Y_NewLearpt, 100.0,
			Y_LBPpt, Y_LBPptSum, Y_LZJ, Y_LLTBPJS);//路堤
		BPptToDESpt(Y_LBPptSum, Y_LBPpt, Y_Lnpt, Y_LDesPoint, dtmp, dtmp, dtmp, dtmp, Y_LDQLength, Y_LGrassLength);
		//补充线间沟	   
		if (Binf)
		{
			Y_LDesPoint[Y_Lnpt * 2] = Y_LDesPoint[(Y_Lnpt - 1) * 2] + PTK;
			Y_LDesPoint[Y_Lnpt * 2 + 1] = Y_LDesPoint[(Y_Lnpt - 1) * 2 + 1];//沟底标高
			Y_Lnpt++;

			Y_LDesPoint[Y_Lnpt * 2] = Y_LDesPoint[(Y_Lnpt - 1) * 2];
			Y_LDesPoint[Y_Lnpt * 2 + 1] = Y_LDesPoint[(Y_Lnpt - 1) * 2 + 1] - 0.6;//沟底标高
			Y_Lnpt++;

			Y_LDesPoint[Y_Lnpt * 2] = Y_LDesPoint[(Y_Lnpt - 1) * 2] + 0.2;
			Y_LDesPoint[Y_Lnpt * 2 + 1] = Y_LDesPoint[(Y_Lnpt - 1) * 2 + 1];//沟底标高
			Y_Lnpt++;
		}
	}
	else if (ljdis > 0.5)//不做边坡，只做线间沟
		IfXJGou = true;//无法做边坡+线间沟
	else//左线右侧直接与右线左侧路肩点连接
	{
		Z_RDesPoint[Z_Rnpt * 2] = Z_RHFR[4 * 2] + ljdis;
		Z_RDesPoint[Z_Rnpt * 2 + 1] = Y_RHFL[4 * 2 + 1] - LNewYd;
		Z_Rnpt++;
	}

	if (IfXJGou)
	{
		double goudBG;
		deltax = 0.5*ljdis;//

		Z_RDesPoint[5 * 2] = Z_RHFR[8] + deltax - 0.2;
		Z_RDesPoint[5 * 2 + 1] = Z_RHFR[9] - 0.04*(deltax - 0.2) - LNewYd;
		Y_LDesPoint[5 * 2] = Y_RHFL[8] + deltax - 0.2;
		Y_LDesPoint[5 * 2 + 1] = Y_RHFL[9] - 0.04*(deltax - 0.2) - RNewYd;

		if (Y_LDesPoint[5 * 2 + 1] > Z_RDesPoint[5 * 2 + 1])
			goudBG = Z_RDesPoint[5 * 2 + 1] - 0.6 + LNewYd;
		else
			goudBG = Y_LDesPoint[5 * 2 + 1] - 0.6 + RNewYd;


		Z_RDesPoint[6 * 2] = Z_RDesPoint[5 * 2];
		Z_RDesPoint[6 * 2 + 1] = goudBG - LNewYd;//沟底标高
		Z_RDesPoint[7 * 2] = Z_RDesPoint[5 * 2] + 0.2;
		Z_RDesPoint[7 * 2 + 1] = goudBG - LNewYd;//沟底标高

		Y_LDesPoint[6 * 2] = Y_LDesPoint[5 * 2];
		Y_LDesPoint[6 * 2 + 1] = goudBG - RNewYd;//沟底标高
		Y_LDesPoint[7 * 2] = Y_LDesPoint[5 * 2] + 0.2;
		Y_LDesPoint[7 * 2 + 1] = goudBG - RNewYd;//沟底标高


		Z_Rnpt = 8;//左线右侧设计完成			   
		Z_RZJ = Z_RDesPoint[7 * 2];
		//右线左侧路肩点向线间中心延伸

		Y_Lnpt = 8;//左线右侧设计完成			   
		Y_LZJ = Y_LDesPoint[7 * 2];
		Y_LStartDesPt[0] = Y_LDesPoint[4 * 2];
		Y_LStartDesPt[1] = Y_LDesPoint[4 * 2 + 1];

		Z_RGrassLength = Y_LGrassLength = 0.0;
		Z_RDQLength = Y_LDQLength = 0.0;


	}


	//计算断面积
	CalDesAllArea(Z_Rnpt, Z_RDesPoint, Z_NewNumR, Z_NewRearpt, Z_Rlmhd, Z_Rhthd, zglthd, 0.0, Z_RZJ, -1,
		Z_RStartDesPt, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI, Z_RLTBPJS,
		Z_RFillArea, Z_RCutArea, Z_RQBTArea, Z_RFillGLTArea, Z_RHJarea);

	CalDesAllArea(Y_Lnpt, Y_LDesPoint, Y_NewNumL, Y_NewLearpt, Y_Llmhd, Y_Lhthd, yglthd, 0.0, Y_LZJ, -1,
		Y_LStartDesPt, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI, Y_LLTBPJS,
		Y_LFillArea, Y_LCutArea, Y_LQBTArea, Y_LFillGLTArea, Y_LHJarea);

	//计算右侧面积 //统计面积
	MidQBTArea = Z_RQBTArea + Y_LQBTArea;
	MidFillArea = Z_RFillArea + Y_LFillArea + MidQBTArea;
	MidCutArea = Z_RCutArea + Y_LCutArea;
	MidFillGLTArea = Z_RFillGLTArea + Y_LFillGLTArea;
	MidHJarea = 0.0;
	if (IfXJGou)
		MidGouJQarea = 0.3*(0.6 + 0.4 + 0.6);
	MidDQLength = Z_RDQLength + Y_LDQLength;
	MidCrassLength = Z_RGrassLength + Y_LGrassLength;

}
void HdmDes::DesFLdHdm_ZWtoYW(double XJJ, int iroad,
	double cml, double projml,
	double Z_RHFR[], double Y_RHFL[],
	double LNewYd, int Z_NewNumR, double Z_NewRearpt[],
	double RNewYd, int Y_NewNumL, double Y_NewLearpt[],
	double &Z_RTW, double &Y_LTW,
	double Z_Rlmhd[3], double Y_Llmhd[3],
	int &Z_Rnpt, double Z_RDesPoint[], int &Y_Lnpt, double Y_LDesPoint[],
	double &MidFillArea, double &MidCutArea,
	double &MidQBTArea, double &MidFillGLTArea, double &MidHJarea, double &MidGouJQarea,
	double &MidDQLength, double &MidCrassLength, bool&IfXJGou
)//设计左挖至右挖
{
	//左线右侧单独设计,得左线边坡点
	double Z_RStartDesPt[2], Y_LStartDesPt[2];
	double Z_RTM[30], Z_RTH[30], Z_RTPTW[30], Z_RTPTI[30];
	double Y_LTM[30], Y_LTH[30], Y_LTPTW[30], Y_LTPTI[30];
	int Z_RLTBPJS, Y_LLTBPJS;
	double Z_RZJ, Y_LZJ, XJGK;
	int Z_RBPptSum, Y_LBPptSum;
	double Z_RBPpt[50], Y_LBPpt[50];
	double BPJD[2];
	double Z_RDQLength, Z_RGrassLength, Y_LDQLength, Y_LGrassLength;
	double zssthd, zglthd, zhjwid, zhthd;
	double yssthd, yglthd, yhjwid, yhthd;
	double Z_RFillArea, Z_RCutArea, Y_LFillArea, Y_LCutArea;
	double Z_RQBTArea, Z_RFillGLTArea, Z_RHJarea;
	double Y_LQBTArea, Y_LFillGLTArea, Y_LHJarea;
	double ZD, ZGK, ZGS, ZGP1, ZGP2, ZCG_JQHD;
	double YD, YGK, YGS, YGP1, YGP2, YCG_JQHD;
	double ZDesBG, YDesBG;
	int TorW;
	double Z_Rhthd, Y_Lhthd;
	double YCG_GDR, ZCG_GDR;

	int j;
	for (j = 0; j < 30; j++)
	{
		Z_RTM[j] = Z_RTH[j] = Z_RTPTW[j] = Z_RTPTI[j] = 0;
		Y_LTM[j] = Y_LTH[j] = Y_LTPTW[j] = Y_LTPTI[j] = 0;
	}

	Z_RLTBPJS = Y_LLTBPJS = 0;
	Z_RZJ = Y_LZJ = XJGK = 0;
	Z_RBPptSum = Y_LBPptSum = 0;
	Z_RDQLength = Z_RGrassLength = Y_LDQLength = Y_LGrassLength = 0;
	zssthd = zglthd = zhjwid = zhthd = 0;
	yssthd = yglthd = yhjwid = yhthd = 0;
	Z_RFillArea = Z_RCutArea = Y_LFillArea = Y_LCutArea = 0;
	Z_RQBTArea = Z_RFillGLTArea = Z_RHJarea = 0;
	Y_LQBTArea = Y_LFillGLTArea = Y_LHJarea = 0;
	ZD = ZGK = ZGS = ZGP1 = ZGP2 = ZCG_JQHD = 0;
	YD = YGK = YGS = YGP1 = YGP2 = YCG_JQHD = 0;
	ZDesBG = YDesBG = 0;
	Z_Rhthd = Y_Lhthd = 0;


	ZDesBG = Z_RHFR[9], YDesBG = Y_RHFL[9];

	Z_RTW = Y_LTW = 1.0;//填挖信息
	Z_RFillArea = Z_RCutArea = Y_LFillArea = Y_LCutArea = 0.0;
	Z_RQBTArea = Z_RFillGLTArea = Z_RHJarea = 0.0;
	Y_LQBTArea = Y_LFillGLTArea = Y_LHJarea = 0.0;

	Z_RStartDesPt[0] = Z_RHFR[4 * 2];//以左线为Y轴
	Z_RStartDesPt[1] = Z_RHFR[4 * 2 + 1] - LNewYd;//地面标高为原点				
	TorW = 1;//挖

	if (XJJ < 0.0001)//左线为绕行
	{
		//取出左线右侧参数
		Z_RLTBPJS = FindWichBP(projml, road[iroad].pm, road[iroad].hdmbz.NYLQBP,
			road[iroad].hdmbz.YLQBP, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI);//左路堑边坡
		Cal_D(projml, road[iroad].pm, road[iroad].hdmbz.NZLQSG, road[iroad].hdmbz.ZLQSG,
			&ZD, &ZGK, &ZGS, &ZGP1, &ZGP2, &ZCG_JQHD, &ZCG_GDR);//路堑边沟宽度
		//清表土厚度
		Z_Rhthd = FindWichHTHD(projml, road[iroad].pm, road[iroad].hdmbz.NYHTHD, road[iroad].hdmbz.YHTHD);
		Z_RZJ = FindWichDQ(projml, road[iroad].pm, road[iroad].hdmbz.NYDQ, road[iroad].hdmbz.YDQ);
		//路面厚
		FindWichHD(projml, road[iroad].pm, road[iroad].hdmbz.NYLMHD, road[iroad].hdmbz.YLMHD, Z_Rlmhd);

		Y_LLTBPJS = FindWichBP(cml, road[0].pm, road[0].hdmbz.NZLQBP,
			road[0].hdmbz.ZLQBP, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI);//左路堤边坡
		Cal_D(cml, road[0].pm, road[0].hdmbz.NZLQSG, road[0].hdmbz.ZLQSG,
			&YD, &YGK, &YGS, &YGP1, &YGP2, &YCG_JQHD, &YCG_GDR);//路堑边沟宽度
		//清表土厚度
		Y_Lhthd = FindWichHTHD(cml, road[0].pm, road[0].hdmbz.NZHTHD, road[0].hdmbz.ZHTHD);
		Y_LZJ = FindWichDQ(cml, road[0].pm, road[0].hdmbz.NZDQ, road[0].hdmbz.ZDQ);
		//路面厚
		FindWichHD(cml, road[0].pm, road[0].hdmbz.NZLMHD, road[0].hdmbz.ZLMHD, Y_Llmhd);

	}
	else
	{
		//取出左线右侧参数
		Z_RLTBPJS = FindWichBP(cml, road[0].pm, road[0].hdmbz.NYLQBP,
			road[0].hdmbz.YLQBP, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI);//左路堑边坡
		Cal_D(cml, road[0].pm, road[0].hdmbz.NZLQSG, road[0].hdmbz.ZLQSG,
			&ZD, &ZGK, &ZGS, &ZGP1, &ZGP2, &ZCG_JQHD, &ZCG_GDR);//路堑边沟宽度
		//清表土厚度
		Z_Rhthd = FindWichHTHD(cml, road[0].pm, road[0].hdmbz.NYHTHD, road[0].hdmbz.YHTHD);
		Z_RZJ = FindWichDQ(cml, road[0].pm, road[0].hdmbz.NYDQ, road[0].hdmbz.YDQ);
		//路面厚
		FindWichHD(cml, road[0].pm, road[0].hdmbz.NYLMHD, road[0].hdmbz.YLMHD, Z_Rlmhd);

		Y_LLTBPJS = FindWichBP(projml, road[iroad].pm, road[iroad].hdmbz.NZLQBP,
			road[iroad].hdmbz.ZLQBP, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI);//左路堤边坡
		Cal_D(projml, road[iroad].pm, road[iroad].hdmbz.NZLQSG, road[iroad].hdmbz.ZLQSG,
			&YD, &YGK, &YGS, &YGP1, &YGP2, &YCG_JQHD, &YCG_GDR);//路堑边沟宽度
		//清表土厚度
		Y_Lhthd = FindWichHTHD(projml, road[iroad].pm, road[iroad].hdmbz.NZHTHD, road[iroad].hdmbz.ZHTHD);
		Y_LZJ = FindWichDQ(projml, road[iroad].pm, road[iroad].hdmbz.NZDQ, road[iroad].hdmbz.ZDQ);
		//路面厚
		FindWichHD(projml, road[iroad].pm, road[iroad].hdmbz.NZLMHD, road[iroad].hdmbz.ZLMHD, Y_Llmhd);
	}
	//-------------------------------------------------------------------------------------------------------------

	Z_Rnpt = 5;
	for (j = 0; j < 5; j++)
	{
		Z_RDesPoint[j * 2] = Z_RHFR[j * 2];
		Z_RDesPoint[j * 2 + 1] = Z_RHFR[j * 2 + 1] - LNewYd;
	}

	Y_Lnpt = 5;
	for (j = 0; j < 5; j++)
	{
		Y_LDesPoint[j * 2] = Y_RHFL[j * 2];
		Y_LDesPoint[j * 2 + 1] = Y_RHFL[j * 2 + 1] - RNewYd;
	}

	double zw, yw, ljdis, deltax, desinf, dtmp;

	XJGK = 0.5;
	zw = Z_RHFR[8] + ZD + Z_RTPTW[0];
	yw = Y_RHFL[8] + YD + Y_LTPTW[0];
	ljdis = fabs(XJJ) - zw - yw;//路肩距离

	if (ljdis > XJGK)//路肩点距离>0.5m,做边坡并做线间沟
	{
		Z_RStartDesPt[0] = zw;
		Z_RStartDesPt[1] = Z_RHFR[9] - LNewYd;
		desinf = DesBPnew(1, Z_RStartDesPt, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI, 0, Z_NewNumR, Z_NewRearpt, 100.0,
			Z_RBPpt, Z_RBPptSum, Z_RZJ, Z_RLTBPJS);//路堑

		//右线左侧单独设计,得右线边坡点
		Y_LZJ = 100.0;
		Y_LStartDesPt[0] = yw;//以左线为Y轴
		Y_LStartDesPt[1] = Y_RHFL[9] - RNewYd;//地面标高为原点				
		desinf = DesBPnew(1, Y_LStartDesPt, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI, 0, Y_NewNumL, Y_NewLearpt, 100.0,
			Y_LBPpt, Y_LBPptSum, Y_LZJ, Y_LLTBPJS);//路堤

		//建立统一坐标系,求出两侧边坡交点,得支距
		int inf = CalBPJD(0.0, fabs(XJJ), Z_RStartDesPt, Z_RBPpt, Z_RBPptSum, Y_LStartDesPt, Y_LBPpt, Y_LBPptSum, LNewYd, RNewYd, BPJD);

		if (inf)//找到交点
		{
			Z_RZJ = BPJD[0];
			Y_LZJ = fabs(XJJ) - Z_RZJ;
		}
		else
		{
			Z_RZJ = Y_LZJ = 100.0;

		}
		//按照支距重新设计左线右侧
		desinf = DesBPnew(1, Z_RStartDesPt, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI, 0, Z_NewNumR, Z_NewRearpt, 100.0,
			Z_RBPpt, Z_RBPptSum, Z_RZJ, Z_RLTBPJS);//路堤
		Z_Rnpt = 9;
		//Z_RDesPoint[0] = Z_RDesPoint[1] = 0.0;
		int j;
		for (j = 0; j < 5; j++)
		{
			Z_RDesPoint[j * 2] = Z_RHFR[j * 2];
			Z_RDesPoint[j * 2 + 1] = Z_RHFR[j * 2 + 1] - LNewYd;
		}

		Z_RDesPoint[5 * 2] = Z_RDesPoint[4 * 2] + ZGS * ZGP1;
		Z_RDesPoint[5 * 2 + 1] = Z_RDesPoint[4 * 2 + 1] - ZGS;
		Z_RDesPoint[6 * 2] = Z_RDesPoint[5 * 2] + ZGK;
		Z_RDesPoint[6 * 2 + 1] = Z_RDesPoint[5 * 2 + 1];
		Z_RDesPoint[7 * 2] = Z_RDesPoint[6 * 2] + ZGS * ZGP2;
		Z_RDesPoint[7 * 2 + 1] = Z_RDesPoint[6 * 2 + 1] + ZGS;
		Z_RDesPoint[8 * 2] = Z_RDesPoint[7 * 2] + Z_RTPTW[0];
		Z_RDesPoint[8 * 2 + 1] = Z_RDesPoint[7 * 2 + 1];

		BPptToDESpt(Z_RBPptSum, Z_RBPpt, Z_Rnpt, Z_RDesPoint, dtmp, dtmp, dtmp, dtmp, Z_RDQLength, Z_RGrassLength);
		//------------------------------------------------------------------------------------
		//右侧点

		desinf = DesBPnew(1, Y_LStartDesPt, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI, 0, Y_NewNumL, Y_NewLearpt, 100.0,
			Y_LBPpt, Y_LBPptSum, Y_LZJ, Y_LLTBPJS);//路堑
		Y_Lnpt = 9;

		for (j = 0; j < 5; j++)
		{
			Y_LDesPoint[j * 2] = Y_RHFL[j * 2];
			Y_LDesPoint[j * 2 + 1] = Y_RHFL[j * 2 + 1] - RNewYd;
		}

		Y_LDesPoint[5 * 2] = Y_LDesPoint[4 * 2] + YGS * YGP1;
		Y_LDesPoint[5 * 2 + 1] = Y_LDesPoint[4 * 2 + 1] - YGS;
		Y_LDesPoint[6 * 2] = Y_LDesPoint[5 * 2] + YGK;
		Y_LDesPoint[6 * 2 + 1] = Y_LDesPoint[5 * 2 + 1];
		Y_LDesPoint[7 * 2] = Y_LDesPoint[6 * 2] + YGS * YGP2;
		Y_LDesPoint[7 * 2 + 1] = Y_LDesPoint[6 * 2 + 1] + YGS;
		Y_LDesPoint[8 * 2] = Y_LDesPoint[7 * 2] + Y_LTPTW[0];
		Y_LDesPoint[8 * 2 + 1] = Y_LDesPoint[7 * 2 + 1];
		BPptToDESpt(Y_LBPptSum, Y_LBPpt, Y_Lnpt, Y_LDesPoint, dtmp, dtmp, dtmp, dtmp, Y_LDQLength, Y_LGrassLength);
	}
	else if (ljdis > 0.5)//不做边坡，只做线间沟
		IfXJGou = true;//无法做边坡+线间沟
	else//左线右侧直接与右线左侧路肩点连接
	{
		zw = Z_RHFR[8];
		yw = Y_RHFL[8];
		ljdis = fabs(XJJ) - zw - yw;//路肩距离
		Z_RDesPoint[Z_Rnpt * 2] = Z_RHFR[4 * 2] + ljdis;
		Z_RDesPoint[Z_Rnpt * 2 + 1] = Y_RHFL[4 * 2 + 1] - LNewYd;
		Z_Rnpt++;
		Z_RTW = Y_LTW = 0.0;
	}

	if (IfXJGou)
	{
		Z_RTW = Y_LTW = 0.0;
		double goudBG;

		ljdis = fabs(XJJ) - Z_RHFR[8] - Y_RHFL[8];
		deltax = 0.5*ljdis;//
		Z_RDesPoint[5 * 2] = Z_RHFR[8] + deltax - 0.2;
		Z_RDesPoint[5 * 2 + 1] = Z_RHFR[9] - 0.04*(deltax - 0.2) - LNewYd;
		Y_LDesPoint[5 * 2] = Y_RHFL[8] + deltax - 0.2;
		Y_LDesPoint[5 * 2 + 1] = Y_RHFL[9] - 0.04*(deltax - 0.2) - RNewYd;

		if (Y_LDesPoint[5 * 2 + 1] > Z_RDesPoint[5 * 2 + 1])
			goudBG = Z_RDesPoint[5 * 2 + 1] - 0.6 + LNewYd;
		else
			goudBG = Y_LDesPoint[5 * 2 + 1] - 0.6 + RNewYd;


		Z_RDesPoint[6 * 2] = Z_RDesPoint[5 * 2];
		Z_RDesPoint[6 * 2 + 1] = goudBG - LNewYd;//沟底标高
		Z_RDesPoint[7 * 2] = Z_RDesPoint[5 * 2] + 0.2;
		Z_RDesPoint[7 * 2 + 1] = goudBG - LNewYd;//沟底标高

		Y_LDesPoint[6 * 2] = Y_LDesPoint[5 * 2];
		Y_LDesPoint[6 * 2 + 1] = goudBG - RNewYd;//沟底标高
		Y_LDesPoint[7 * 2] = Y_LDesPoint[5 * 2] + 0.2;
		Y_LDesPoint[7 * 2 + 1] = goudBG - RNewYd;//沟底标高


		Z_Rnpt = 8;//左线右侧设计完成			   
		Z_RZJ = Z_RDesPoint[7 * 2];
		//右线左侧路肩点向线间中心延伸

		Y_Lnpt = 8;//左线右侧设计完成			   
		Y_LZJ = Y_LDesPoint[7 * 2];
		Y_LStartDesPt[0] = Y_LDesPoint[4 * 2];
		Y_LStartDesPt[1] = Y_LDesPoint[4 * 2 + 1];

		Z_RGrassLength = Y_LGrassLength = 0.0;
		Z_RDQLength = Y_LDQLength = 0.0;
	}
	//计算挖方面积
	CalDesAllArea(Z_Rnpt, Z_RDesPoint, Z_NewNumR, Z_NewRearpt, Z_Rlmhd, Z_Rhthd, zglthd, 0.0, Z_RZJ, -1,
		Z_RStartDesPt, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI, Z_RLTBPJS,
		Z_RFillArea, Z_RCutArea, Z_RQBTArea, Z_RFillGLTArea, Z_RHJarea);

	CalDesAllArea(Y_Lnpt, Y_LDesPoint, Y_NewNumL, Y_NewLearpt, Y_Llmhd, Y_Lhthd, yglthd, 0.0, Y_LZJ, -1,
		Y_LStartDesPt, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI, Y_LLTBPJS,
		Y_LFillArea, Y_LCutArea, Y_LQBTArea, Y_LFillGLTArea, Y_LHJarea);

	//计算右侧面积
	//统计面积
	MidFillArea = Z_RFillArea + Y_LFillArea;
	MidCutArea = Z_RCutArea + Y_LCutArea;
	MidQBTArea = Z_RQBTArea + Y_LQBTArea;
	MidFillGLTArea = Z_RFillGLTArea + Y_LFillGLTArea;
	MidHJarea = Z_RHJarea + Y_LHJarea;
	if (IfXJGou)
		MidGouJQarea = 0.0;
	else
		MidGouJQarea = CalGouJQArea(ZGS, ZGK, ZGP1, ZGP2, ZCG_JQHD) + CalGouJQArea(YGS, YGK, YGP1, YGP2, YCG_JQHD);
	MidDQLength = Z_RDQLength + Y_LDQLength;
	MidCrassLength = Z_RGrassLength + Y_LGrassLength;

}


//输入XJGK-线间沟宽
//XJJ-左右线间距
//Z_RBPpt-左线右侧边坡点
//Z_RBPptSum-左线右侧边坡点数
//Y_LBPpt-右线左侧边坡点
//Y_LBPptSum-右线左侧边坡点数
//ZYd=YYd-左右线路地面标高
//BPJD[]-边坡交点
//return 1-有交点，0-无交点
int HdmDes::CalBPJD(double XJGK, double XJJ, double Z_RStartPt[2], double Z_RBPpt[], int Z_RBPptSum,
	double Y_LStartPt[2], double Y_LBPpt[], int Y_LBPptSum,
	double ZYd, double YYd,
	double BPJD[])
{
	AcGePoint3dArray BPptArray, ZBPptArray;
	AcGePoint3d BPpt;
	double YLpt[100];
	//以左线为统一坐系
	BPpt.set(-Y_LStartPt[0] + XJJ - XJGK, Y_LStartPt[1] + YYd - ZYd, 0);
	BPptArray.append(BPpt);
	int i;
	for (i = 0; i < Y_LBPptSum; i++)
	{
		YLpt[i * 2] = -fabs(Y_LBPpt[i * 2]) + XJJ - XJGK;//移轴并平移一个沟宽
		YLpt[i * 2 + 1] = Y_LBPpt[i * 2 + 1] + YYd - ZYd;
		BPpt.set(YLpt[i * 2], YLpt[i * 2 + 1], 0);
		BPptArray.append(BPpt);
	}
	AcDb2dPolyline Y_LBPLine(AcDb::k2dSimplePoly, BPptArray);

	BPpt.set(Z_RStartPt[0], Z_RStartPt[1], 0);
	ZBPptArray.append(BPpt);
	for (i = 0; i < Z_RBPptSum; i++)
	{
		BPpt.set(Z_RBPpt[i * 2], Z_RBPpt[i * 2 + 1], 0);
		ZBPptArray.append(BPpt);
	}
	AcDb2dPolyline Z_RBPLine(AcDb::k2dSimplePoly, ZBPptArray);

	AcGePoint3dArray ResPts;
	if (Z_RBPLine.intersectWith(&Y_LBPLine, AcDb::kOnBothOperands, ResPts) == Acad::eOk)//平移线与地面线找到交点
	{
		if (ResPts.length() > 0)
		{
			BPJD[0] = ResPts[0].x;
			BPJD[1] = ResPts[0].y;
			return 1;
		}
		else
			return 0;
	}
	return 0;
}
double HdmDes::Cal_deltah(double earpt[], int npt, double x, double desh, double Earh)
{
	int i;
	double earh;

	i = 0;
	x = fabs(x);
	while (earpt[i * 2] < x && i <= npt)
		i++;

	if (i > npt)
		return -10000.0;
	if (fabs(earpt[i * 2] - earpt[(i - 1) * 2]) > 0.001)
		earh = earpt[(i - 1) * 2 + 1] + (x - earpt[(i - 1) * 2])*(earpt[i * 2 + 1] - earpt[(i - 1) * 2 + 1]) / (earpt[i * 2] - earpt[(i - 1) * 2]);
	else
		earh = earpt[(i - 1) * 2 + 1];
	//
	return (desh - earh - Earh);
}

void HdmDes::DesFLdHdm_ZTtoYW(double XJJ, int iroad,
	double cml, double projml,
	double Z_RHFR[], double Y_RHFL[],
	double LNewYd, int Z_NewNumR, double Z_NewRearpt[],
	double RNewYd, int Y_NewNumL, double Y_NewLearpt[],
	double &Z_RTW, double &Y_LTW,
	double Z_Rlmhd[3], double Y_Llmhd[3],
	int &Z_Rnpt, double Z_RDesPoint[], int &Y_Lnpt, double Y_LDesPoint[],
	double &MidFillArea, double &MidCutArea,
	double &MidQBTArea, double &MidFillGLTArea, double &MidHJarea, double &MidGouJQarea,
	double &MidDQLength, double &MidCrassLength, bool&IfXJGou
)//设计左挖至右挖

{
	//左线右侧单独设计,得左线边坡点
	double Z_RStartDesPt[2], Y_LStartDesPt[2];
	double Z_RTM[30], Z_RTH[30], Z_RTPTW[30], Z_RTPTI[30];
	double Y_LTM[30], Y_LTH[30], Y_LTPTW[30], Y_LTPTI[30];
	int Z_RLTBPJS, Y_LLTBPJS;
	double Z_RZJ, Y_LZJ, XJGK;

	double zssthd, zglthd, zhjwid, zhthd;
	double yssthd, yglthd, yhjwid, yhthd;
	double Z_RFillArea, Z_RCutArea, Y_LFillArea, Y_LCutArea;
	double Z_RQBTArea, Z_RFillGLTArea, Z_RHJarea;
	double Y_LQBTArea, Y_LFillGLTArea, Y_LHJarea;
	double ZD, ZGK, ZGS, ZGP1, ZGP2, ZCG_JQHD, ZCG_GDR;
	double YD, YGK, YGS, YGP1, YGP2, YCG_JQHD, YCG_GDR;
	double ZDesBG, YDesBG;
	int TorW, j;
	double Z_Rhthd, Y_Lhthd;

	zssthd = zglthd = zhjwid = zhthd = 0;
	yssthd = yglthd = yhjwid = yhthd = 0;
	Z_RFillArea = Z_RCutArea = Y_LFillArea = Y_LCutArea = 0;
	Z_RQBTArea = Z_RFillGLTArea = Z_RHJarea = 0;
	Y_LQBTArea = Y_LFillGLTArea = Y_LHJarea = 0;
	ZD = ZGK = ZGS = ZGP1 = ZGP2 = ZCG_JQHD = 0;
	YD = YGK = YGS = YGP1 = YGP2 = YCG_JQHD = 0;
	ZDesBG = YDesBG = 0;
	Z_Rhthd = Y_Lhthd = 0;

	ZDesBG = Z_RHFR[9], YDesBG = Y_RHFL[9];

	Z_RTW = Y_LTW = 1.0;//填挖信息

	Z_RFillArea = Z_RCutArea = Y_LFillArea = Y_LCutArea = 0.0;
	Z_RQBTArea = Z_RFillGLTArea = Z_RHJarea = 0.0;
	Y_LQBTArea = Y_LFillGLTArea = Y_LHJarea = 0.0;

	Z_RStartDesPt[0] = Z_RHFR[4 * 2];//以左线为Y轴
	Z_RStartDesPt[1] = Z_RHFR[4 * 2 + 1] - LNewYd;//地面标高为原点				

	Z_Rnpt = 5;
	for (j = 0; j < 5; j++)
	{
		Z_RDesPoint[j * 2] = Z_RHFR[j * 2];
		Z_RDesPoint[j * 2 + 1] = Z_RHFR[j * 2 + 1] - LNewYd;
	}

	Y_Lnpt = 5;
	for (j = 0; j < 5; j++)
	{
		Y_LDesPoint[j * 2] = Y_RHFL[j * 2];
		Y_LDesPoint[j * 2 + 1] = Y_RHFL[j * 2 + 1] - RNewYd;
	}

	TorW = 1;//挖
	if (XJJ < 0.0001)//左线为绕行
	{
		//取出左线右侧参数
		Cal_D(projml, road[iroad].pm, road[iroad].hdmbz.NZLQSG, road[iroad].hdmbz.ZLQSG,
			&ZD, &ZGK, &ZGS, &ZGP1, &ZGP2, &ZCG_JQHD, &ZCG_GDR);//路堑边沟宽度
		//清表土厚度
		Z_Rhthd = FindWichHTHD(projml, road[iroad].pm, road[iroad].hdmbz.NYHTHD, road[iroad].hdmbz.YHTHD);
		Z_RZJ = FindWichDQ(projml, road[iroad].pm, road[iroad].hdmbz.NYDQ, road[iroad].hdmbz.YDQ);
		//路面厚
		FindWichHD(projml, road[iroad].pm, road[iroad].hdmbz.NYLMHD, road[iroad].hdmbz.YLMHD, Z_Rlmhd);

		Y_LLTBPJS = FindWichBP(cml, road[0].pm, road[0].hdmbz.NZLQBP,
			road[0].hdmbz.ZLQBP, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI);//左路堤边坡
		Cal_D(cml, road[0].pm, road[0].hdmbz.NZLQSG, road[0].hdmbz.ZLQSG,
			&YD, &YGK, &YGS, &YGP1, &YGP2, &YCG_JQHD, &YCG_GDR);//路堑边沟宽度
		//清表土厚度
		Y_Lhthd = FindWichHTHD(cml, road[0].pm, road[0].hdmbz.NZHTHD, road[0].hdmbz.ZHTHD);
		Y_LZJ = FindWichDQ(cml, road[0].pm, road[0].hdmbz.NZDQ, road[0].hdmbz.ZDQ);
		//路面厚
		FindWichHD(cml, road[0].pm, road[0].hdmbz.NZLMHD, road[0].hdmbz.ZLMHD, Y_Llmhd);

	}
	else
	{
		//取出左线右侧参数
		Z_RLTBPJS = FindWichBP(cml, road[0].pm, road[0].hdmbz.NYLQBP,
			road[0].hdmbz.YLQBP, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI);//左路堑边坡
		Cal_D(cml, road[0].pm, road[0].hdmbz.NZLQSG, road[0].hdmbz.ZLQSG,
			&ZD, &ZGK, &ZGS, &ZGP1, &ZGP2, &ZCG_JQHD, &ZCG_GDR);//路堑边沟宽度
		//清表土厚度
		Z_Rhthd = FindWichHTHD(cml, road[0].pm, road[0].hdmbz.NYHTHD, road[0].hdmbz.YHTHD);
		Z_RZJ = FindWichDQ(cml, road[0].pm, road[0].hdmbz.NYDQ, road[0].hdmbz.YDQ);
		//路面厚
		FindWichHD(cml, road[0].pm, road[0].hdmbz.NYLMHD, road[0].hdmbz.YLMHD, Z_Rlmhd);

		Y_LLTBPJS = FindWichBP(projml, road[iroad].pm, road[iroad].hdmbz.NZLQBP,
			road[iroad].hdmbz.ZLQBP, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI);//左路堤边坡
		Cal_D(projml, road[iroad].pm, road[iroad].hdmbz.NZLQSG, road[iroad].hdmbz.ZLQSG,
			&YD, &YGK, &YGS, &YGP1, &YGP2, &YCG_JQHD, &YCG_GDR);//路堑边沟宽度
		//清表土厚度
		Y_Lhthd = FindWichHTHD(projml, road[iroad].pm, road[iroad].hdmbz.NZHTHD, road[iroad].hdmbz.ZHTHD);
		Y_LZJ = FindWichDQ(projml, road[iroad].pm, road[iroad].hdmbz.NZDQ, road[iroad].hdmbz.ZDQ);
		//路面厚
		FindWichHD(projml, road[iroad].pm, road[iroad].hdmbz.NZLMHD, road[iroad].hdmbz.ZLMHD, Y_Llmhd);
	}

	//-------------------------------------------------------------------------------------------------------
	double zw, yw, ljdis, deltax, deltah;
	XJGK = 0.5;
	zw = Z_RHFR[8];
	yw = Y_RHFL[8] + YD + Y_LTPTW[0];
	ljdis = fabs(XJJ) - zw - yw;//路肩距离
	IfXJGou = false;//不做线间沟
	deltah = fabs(ZDesBG - YDesBG);

	if (ljdis > XJGK && deltah > ZGS)//路肩点距离>0.5m,做边坡并做线间沟
	{
		if (ZDesBG > YDesBG)//左侧路堤，右侧路堑
		{
			for (j = 0; j < 5; j++)
			{
				Z_RDesPoint[j * 2] = Z_RHFR[j * 2];
				Z_RDesPoint[j * 2 + 1] = Z_RHFR[j * 2 + 1] - LNewYd;
			}
			Z_RDesPoint[0] = 0.0;
			Z_RDesPoint[1] = Z_RDesPoint[3];
			Z_RStartDesPt[0] = Z_RDesPoint[8];
			Z_RStartDesPt[1] = Z_RDesPoint[9];

			Z_Rnpt = 5;
			Z_RTW = 0.0;
			//右侧点

			for (j = 0; j < 5; j++)
			{
				Y_LDesPoint[j * 2] = Y_RHFL[j * 2];
				Y_LDesPoint[j * 2 + 1] = Y_RHFL[j * 2 + 1] - RNewYd;
			}
			Y_LDesPoint[0] = 0.0;
			Y_LDesPoint[1] = Y_LDesPoint[3];
			Y_LDesPoint[5 * 2] = Y_LDesPoint[4 * 2] + YGS * YGP1;
			Y_LDesPoint[5 * 2 + 1] = Y_LDesPoint[4 * 2 + 1] - YGS;
			Y_LDesPoint[6 * 2] = Y_LDesPoint[5 * 2] + YGK;
			Y_LDesPoint[6 * 2 + 1] = Y_LDesPoint[5 * 2 + 1];
			Y_LDesPoint[7 * 2] = Y_LDesPoint[6 * 2] + YGS * YGP2;
			Y_LDesPoint[7 * 2 + 1] = Y_LDesPoint[6 * 2 + 1] + YGS;
			Y_LDesPoint[8 * 2] = Y_LDesPoint[7 * 2] + Y_LTPTW[0];
			Y_LDesPoint[8 * 2 + 1] = Y_LDesPoint[7 * 2 + 1];
			Y_Lnpt = 9;
			Y_LStartDesPt[0] = Y_LDesPoint[8 * 2];
			Y_LStartDesPt[1] = Y_LDesPoint[8 * 2 + 1];

			//左侧增加一个点
			Z_Rnpt = 6;
			Z_RDesPoint[5 * 2] = Z_RDesPoint[4 * 2] + fabs(XJJ) - zw - yw;
			Z_RDesPoint[5 * 2 + 1] = Y_LDesPoint[7 * 2 + 1] + RNewYd - LNewYd;//
			Y_LTW = 1.0;
			TorW = -1;// 填		   
			MidGouJQarea = CalGouJQArea(YGS, YGK, YGP1, YGP2, YCG_JQHD);
		}
		else //左侧路堑，右侧路堤
		{

			for (j = 0; j < 5; j++)
			{
				Z_RDesPoint[j * 2] = Z_RHFR[j * 2];
				Z_RDesPoint[j * 2 + 1] = Z_RHFR[j * 2 + 1] - LNewYd;
			}
			Z_RDesPoint[0] = 0.0;
			Z_RDesPoint[1] = Z_RDesPoint[3];
			Z_RDesPoint[5 * 2] = Z_RDesPoint[4 * 2] + ZGS * ZGP1;
			Z_RDesPoint[5 * 2 + 1] = Z_RDesPoint[4 * 2 + 1] - ZGS;
			Z_RDesPoint[6 * 2] = Z_RDesPoint[5 * 2] + ZGK;
			Z_RDesPoint[6 * 2 + 1] = Z_RDesPoint[5 * 2 + 1];
			Z_RDesPoint[7 * 2] = Z_RDesPoint[6 * 2] + ZGS * ZGP2;
			Z_RDesPoint[7 * 2 + 1] = Z_RDesPoint[6 * 2 + 1] + ZGS;
			Z_RDesPoint[8 * 2] = Z_RDesPoint[7 * 2] + Z_RTPTW[0];
			Z_RDesPoint[8 * 2 + 1] = Z_RDesPoint[7 * 2 + 1];
			Z_RStartDesPt[0] = Z_RDesPoint[8 * 2];
			Z_RStartDesPt[1] = Z_RDesPoint[8 * 2 + 1];
			Z_Rnpt = 9;
			Z_RTW = 1.0;
			//右侧点
			//Y_LDesPoint[0] = 0.0, Y_LDesPoint[1] = 0.0;
			for (j = 0; j < 5; j++)
			{
				Y_LDesPoint[j * 2] = Y_RHFL[j * 2];
				Y_LDesPoint[j * 2 + 1] = Y_RHFL[j * 2 + 1] - RNewYd;
			}
			Y_LDesPoint[0] = 0.0;
			Y_LDesPoint[1] = Y_LDesPoint[3];
			Y_LStartDesPt[0] = Y_LDesPoint[8];
			Y_LStartDesPt[1] = Y_LDesPoint[9];
			//左侧增加一个点
			Y_Lnpt = 6;
			Y_LDesPoint[5 * 2] = Y_LDesPoint[4 * 2] + fabs(XJJ) - Z_RDesPoint[8 * 2] - Y_LDesPoint[3 * 2];
			Y_LDesPoint[5 * 2 + 1] = Z_RDesPoint[7 * 2 + 1] + LNewYd - RNewYd;
			Y_LTW = 0.0;
			TorW = 1;// 挖
			MidGouJQarea = CalGouJQArea(ZGS, ZGK, ZGP1, ZGP2, ZCG_JQHD);
		}
	}
	else if (ljdis > 0.5)//不做边坡，只做线间沟
		IfXJGou = true;//做线间沟	
	else//左线右侧直接与右线左侧路肩点连接
	{
		Z_RTW = Y_LTW = 0.0;
		ljdis = fabs(XJJ) - Z_RHFR[8] - Y_RHFL[8];
		Z_RDesPoint[Z_Rnpt * 2] = Z_RHFR[4 * 2] + ljdis;
		Z_RDesPoint[Z_Rnpt * 2 + 1] = Y_RHFL[4 * 2 + 1] - LNewYd;//沟底标高
		Z_Rnpt++;
	}


	if (IfXJGou)
	{
		Z_RTW = Y_LTW = 0.0;
		double goudBG;

		ljdis = fabs(XJJ) - Z_RHFR[8] - Y_RHFL[8];
		deltax = 0.5*ljdis;//
		Z_RDesPoint[5 * 2] = Z_RHFR[8] + deltax - 0.2;
		Z_RDesPoint[5 * 2 + 1] = Z_RHFR[9] - 0.04*(deltax - 0.2) - LNewYd;
		Y_LDesPoint[5 * 2] = Y_RHFL[8] + deltax - 0.2;
		Y_LDesPoint[5 * 2 + 1] = Y_RHFL[9] - 0.04*(deltax - 0.2) - RNewYd;

		if (Y_LDesPoint[5 * 2 + 1] > Z_RDesPoint[5 * 2 + 1])
			goudBG = Z_RDesPoint[5 * 2 + 1] - 0.6 + LNewYd;
		else
			goudBG = Y_LDesPoint[5 * 2 + 1] - 0.6 + RNewYd;


		Z_RDesPoint[6 * 2] = Z_RDesPoint[5 * 2];
		Z_RDesPoint[6 * 2 + 1] = goudBG - LNewYd;//沟底标高
		Z_RDesPoint[7 * 2] = Z_RDesPoint[5 * 2] + 0.2;
		Z_RDesPoint[7 * 2 + 1] = goudBG - LNewYd;//沟底标高

		Y_LDesPoint[6 * 2] = Y_LDesPoint[5 * 2];
		Y_LDesPoint[6 * 2 + 1] = goudBG - RNewYd;//沟底标高
		Y_LDesPoint[7 * 2] = Y_LDesPoint[5 * 2] + 0.2;
		Y_LDesPoint[7 * 2 + 1] = goudBG - RNewYd;//沟底标高


		Z_Rnpt = 8;//左线右侧设计完成			   
		Z_RZJ = Z_RDesPoint[7 * 2];
		//右线左侧路肩点向线间中心延伸

		Y_Lnpt = 8;//左线右侧设计完成			   
		Y_LZJ = Y_LDesPoint[7 * 2];
		Y_LStartDesPt[0] = Y_LDesPoint[4 * 2];
		Y_LStartDesPt[1] = Y_LDesPoint[4 * 2 + 1];

		TorW = -1;// 填
		MidGouJQarea = 0.3*(0.6 + 0.4 + 0.6);
	}

	//计算挖方面积
	CalDesAllArea(Z_Rnpt, Z_RDesPoint, Z_NewNumR, Z_NewRearpt, Z_Rlmhd, Z_Rhthd, zglthd, 0.0, Z_RZJ, -1,
		Z_RStartDesPt, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI, Z_RLTBPJS,
		Z_RFillArea, Z_RCutArea, Z_RQBTArea, Z_RFillGLTArea, Z_RHJarea);

	CalDesAllArea(Y_Lnpt, Y_LDesPoint, Y_NewNumL, Y_NewLearpt, Y_Llmhd, Y_Lhthd, yglthd, 0.0, Y_LZJ, -1,
		Y_LStartDesPt, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI, Y_LLTBPJS,
		Y_LFillArea, Y_LCutArea, Y_LQBTArea, Y_LFillGLTArea, Y_LHJarea);

	//计算右侧面积 统计面积
	MidFillArea = Z_RFillArea + Y_LFillArea;
	MidCutArea = Z_RCutArea + Y_LCutArea;
	MidQBTArea = Z_RQBTArea + Y_LQBTArea;
	MidFillGLTArea = Z_RFillGLTArea + Y_LFillGLTArea;
	MidHJarea = Z_RHJarea + Y_LHJarea;
	MidDQLength = MidCrassLength = 0.0;
}

int  HdmDes::Design_FLD_Hdm()//设计绕行段横断面
{
	int i;
	int DelSum = 0;
	//	Zdmdlg zdmdlg;
	int inf = 0;

	//L2000:
	//-------------------------------------------------------------------	
	//设置进度条
	ACHAR pszLabel[256];
	_stprintf(pszLabel, L"分离段横断面自动设计");
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);
	//-------------------------------------------------------------------
	//   //写分段里程
	//	for(j=0;j<NZRXD;j++)
	//		fwprintf(fpw,L"%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %d %d\n",
	//		ZRXD[j].RXDsml,ZRXD[j].RXDsml1,ZRXD[j].RXDsml2,
	//		ZRXD[j].RXDeml2,ZRXD[j].RXDeml1,ZRXD[j].RXDeml,
	//		ZRXD[j].RXDZsml,ZRXD[j].RXDZsml1,ZRXD[j].RXDZsml2,
	//		ZRXD[j].RXDZeml2,ZRXD[j].RXDZeml1,ZRXD[j].RXDZeml,ZRXD[j].k1,ZRXD[j].k2);
	//	for(j=0;j<NYRXD;j++)
	//		fwprintf(fpw,L"%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %d %d\n",
	//		YRXD[j].RXDsml,YRXD[j].RXDsml1,YRXD[j].RXDsml2,
	//		YRXD[j].RXDeml2,YRXD[j].RXDeml1,YRXD[j].RXDeml,
	//		YRXD[j].RXDYsml,YRXD[j].RXDYsml1,YRXD[j].RXDYsml2,
	//		YRXD[j].RXDYeml2,YRXD[j].RXDYeml1,YRXD[j].RXDYeml,YRXD[j].k1,YRXD[j].k2);

	for (int irxd = 1; irxd < RoadSum; irxd++)
	{
		for (i = 0; i < road[irxd].NCRS; i++)
		{

			//	ads_printf(L"i=%d zml=%lf\n",i,ZRXD[irxd].Crs[i].cml);
			int Pos = (int)(i*100.0 / road[irxd].NCRS);
			acedSetStatusBarProgressMeterPos(Pos);
			//		InitHdmData(irxd,i);
			///////////////////////////////只设计边坡分离以后的
			Cal_HdmDQinf(irxd, i);
			if (road[irxd].hdmdes[i].cml > road[irxd].LJFLSmlOnFLD - 0.01 && road[irxd].hdmdes[i].cml < road[irxd].LJFLEmlOnFLD + 0.01)//位于分离段上,按单线设计
			{
				//road[irxd].hdmdes[i].xjj = 0.0;//修正线间距
				if (!road[irxd].hdmdes[i].IfHasDes)
					DesLinkCross(irxd, i, -1 * road[irxd].ZxOrYx);
				//				DesACrossOnSingleLine(irxd,i);

				//	for(int m=0;m<6;m++)               //wwq
				//		ZRXD[irxd].Crs[i].WFFLarea[m]=ZRXD[irxd].Crs[i].CutArea*wffl[m]; ///wwq	

			}
		}
	}

	acedRestoreStatusBar();

	return RTNORM;

}

//画指定里程的一线
void HdmDes::Draw_ZX_Hdm(double sml, double eml)
{
	double Learpt[400], Rearpt[400];
	double LBenchPt[400], RBenchPt[400];
	double ZX_LearptOnLJZX[400], ZX_RearptOnLJZX[400];
	double FLX_LearptOnLJZX[400], FLX_RearptOnLJZX[400];
	double ZX_LBenchPtOnLJZX[400], ZX_RBenchPtOnLJZX[400];
	double ZX_EarHOnLJZX, FLX_EarHOnLJZX;
	double ZX_EarHOnXLZX, FLX_EarHOnXLZX;

	int NumLearpt, NumRearpt;
	int OffsetNumLearpt, OffsetNumRearpt;
	//int  DorS;
	int i;
	AcGePoint3d pt;
	CROSS pCross;
	CROSS GLCross;

	if (acdbHostApplicationServices()->workingDatabase()->loadLineTypeFile(L"DASHDOTX2", L"acadiso.lin") != Acad::eOk)
		ads_printf(L"加载DASHDOTX2线形失败!\n");
	CreateLayer(L"Hdm");//建立Hdm层
	//////////////////////////////////////////
	AcGePoint3d pkPt;
	acedInitGet(NULL, NULL);
	if (acedGetPoint(NULL, L"\n请在屏幕上指定绘图原点:", asDblArray(pkPt)) == RTCAN)
		return;

	pt.x = 100.0 + pkPt.x, pt.y = 100.0 + pkPt.y;
	///////////////////////////////////////////zdf改拾取点
	Cal_CrossOriPt(0, pt);//得到每个横断面的绘图原点

	//NCRS=89;
	CString pszLabel = "正在绘制主线横断面";
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);

	for (i = 0; i < road[0].NCRS; i++)//一线
	{
		try
		{
			int pos = (int)i*100.0 / road[0].NCRS;
			acedSetStatusBarProgressMeterPos(pos);
			if (road[0].hdmdes[i].cml > sml - 0.01&&road[0].hdmdes[i].cml < eml + 0.01)
			{
				double Testcml = road[0].hdmdes[i].cml;
				if (road[0].hdmdes[i].DorS == 1)//单路面
				{
					int k;
					for (k = 0; k < road[0].hdmdmx[i].ZEarPtNum; k++)
					{
						Learpt[k * 2] = road[0].hdmdmx[i].ZEarPtAry[k].x;
						Learpt[k * 2 + 1] = road[0].hdmdmx[i].ZEarPtAry[k].y;
					}

					for (k = 0; k < road[0].hdmdmx[i].YEarPtNum; k++)
					{
						Rearpt[k * 2] = road[0].hdmdmx[i].YEarPtAry[k].x;
						Rearpt[k * 2 + 1] = road[0].hdmdmx[i].YEarPtAry[k].y;
					}


					//////////////////////////////////////////////////////////////////////////
					for (k = 0; k < road[0].hdmBench[i].ZEarPtNum; k++)
					{
						LBenchPt[k * 2] = road[0].hdmBench[i].ZEarPtAry[k].x;
						LBenchPt[k * 2 + 1] = road[0].hdmBench[i].ZEarPtAry[k].y;
					}

					for (k = 0; k < road[0].hdmBench[i].YEarPtNum; k++)
					{
						RBenchPt[k * 2] = road[0].hdmBench[i].YEarPtAry[k].x;
						RBenchPt[k * 2 + 1] = road[0].hdmBench[i].YEarPtAry[k].y;
					}
					//////////////////////////////////////////////////////////////////////////

					//		CalNewZB(road[0].hdmdes[i].offsetX,road[0].hdmdmx[i].EarH,Learpt,road[0].hdmdmx[i].ZEarPtNum,Rearpt,road[0].hdmdmx[i].YEarPtNum,
					//			NewYd,NewLearpt,NewNumL,NewRearpt,NewNumR);
					//////////////////////////////////////////////////////////////////////////
					//考虑路基中线与线路中线不重合，将相对于线路中线的地面点数据平移到路基中线（修改）
					ZX_EarHOnXLZX = road[0].hdmdmx[i].EarH;//线路中线处的地面标高
					NumLearpt = road[0].hdmdmx[i].ZEarPtNum;
					NumRearpt = road[0].hdmdmx[i].YEarPtNum;
					CalNewZB(road[0].hdmdes[i].OffsetByXLZX, ZX_EarHOnXLZX, Learpt, NumLearpt, Rearpt, NumRearpt,
						ZX_EarHOnLJZX, ZX_LearptOnLJZX, OffsetNumLearpt, ZX_RearptOnLJZX, OffsetNumRearpt);
					//////////////////////////////////////////////////////////////////////////
					road[0].hdmdes[i].newLYd = road[0].hdmdes[i].newRYd = road[0].hdmdmx[i].EarH;
					//左右都是桥
					if (road[0].hdmdes[i].ZDMXZ == 3 && road[0].hdmdes[i].YDMXZ == 3)
						continue;
					//左右都是隧
					if (road[0].hdmdes[i].ZDMXZ == 4 && road[0].hdmdes[i].YDMXZ == 4)
						continue;

					if (road[0].hdmdes[i].ZDMXZ == -1 || road[0].hdmdes[i].ZDMXZ == -2
						|| road[0].hdmdes[i].YDMXZ == -1 || road[0].hdmdes[i].YDMXZ == -2)
					{
						pt.x = road[0].hdmdes[i].tX0;//桥隧处标注点
						pt.y = road[0].hdmdes[i].tY0;
						BiaoZhuQS(0, road[0].hdmdes[i].cml, pt); //标注桥隧位置
					}

					pCross.m_OriPoint.x = road[0].hdmdes[i].Xo;
					pCross.m_OriPoint.y = road[0].hdmdes[i].Yo;	//每个断面的绘图原点
					pCross.m_BTinf = road[0].hdmdes[i].ZDMXZ;
					//	road[0].hdmdes[i].xlxz=0;road[0].hdmdes[i].r_bh=-1;//一线，用于交互设计

					// 					setCROSSAutoDesignData(pCross,0,i,road[0].hdmdmx[i].EarH,
					// 						Learpt,road[0].hdmdmx[i].ZEarPtNum,Rearpt,road[0].hdmdmx[i].YEarPtNum,
					// 						LBenchPt,road[0].hdmBench[i].ZEarPtNum,RBenchPt,road[0].hdmBench[i].YEarPtNum);

					setCROSSAutoDesignData(pCross, 0, i, ZX_EarHOnLJZX, ZX_LearptOnLJZX, OffsetNumLearpt, ZX_RearptOnLJZX, OffsetNumRearpt,
						LBenchPt, road[0].hdmBench[i].ZEarPtNum, RBenchPt, road[0].hdmBench[i].YEarPtNum);

					pCross.DorS = road[0].hdmdes[i].DorS;
					pCross.offset = road[0].hdmdes[i].offsetX;//一线中心线相对与新的地面线的移动量

				}
				if (road[0].hdmdes[i].DorS == 2)//双路面
				{
					//ads_printf(L"cmlzx=%lf %lf xjj=%lf\n",road[0].hdmdes[i].cml,road[0].hdmdes[i].FLDcml,road[0].hdmdes[i].xjj);				
					double ZX_Yd, ZX_Learpt[400], ZX_Rearpt[400];
					int ZX_NumL, ZX_NumR;
					double YX_Yd, YX_Learpt[400], YX_Rearpt[400];
					int YX_NumL, YX_NumR;

					double ZX_LBenchPt[400], ZX_RBenchPt[400];
					int ZX_BenchNumL, ZX_BenchNumR;
					double YX_LBenchPt[400], YX_RBenchPt[400];
					int YX_BenchNumL, YX_BenchNumR;


					if (road[0].hdmdes[i].xjj < -0.00001)//左线分离
					{
						YX_Yd = road[0].hdmdmx[i].EarH;
						YX_NumL = road[0].hdmdmx[i].ZEarPtNum;
						int k;
						for (k = 0; k < YX_NumL; k++)
						{
							YX_Learpt[k * 2] = road[0].hdmdmx[i].ZEarPtAry[k].x;
							YX_Learpt[k * 2 + 1] = road[0].hdmdmx[i].ZEarPtAry[k].y;
						}
						YX_NumR = road[0].hdmdmx[i].YEarPtNum;
						for (k = 0; k < YX_NumR; k++)
						{
							YX_Rearpt[k * 2] = road[0].hdmdmx[i].YEarPtAry[k].x;
							YX_Rearpt[k * 2 + 1] = road[0].hdmdmx[i].YEarPtAry[k].y;
						}
						//移轴
						CalNewZB(road[0].hdmdes[i].xjj, YX_Yd, YX_Learpt, YX_NumL, YX_Rearpt, YX_NumR,
							ZX_Yd, ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR);


						//////////////////////////////////////////////////////////////////////////
						YX_BenchNumL = road[0].hdmBench[i].ZEarPtNum;
						for (k = 0; k < YX_BenchNumL; k++)
						{
							YX_LBenchPt[k * 2] = road[0].hdmBench[i].ZEarPtAry[k].x;
							YX_LBenchPt[k * 2 + 1] = road[0].hdmBench[i].ZEarPtAry[k].y;
						}
						YX_BenchNumR = road[0].hdmBench[i].YEarPtNum;
						for (k = 0; k < YX_BenchNumR; k++)
						{
							YX_RBenchPt[k * 2] = road[0].hdmBench[i].YEarPtAry[k].x;
							YX_RBenchPt[k * 2 + 1] = road[0].hdmBench[i].YEarPtAry[k].y;
						}
						//移轴
						CalNewZB(road[0].hdmdes[i].xjj, YX_Yd, YX_LBenchPt, YX_BenchNumL, YX_RBenchPt, YX_BenchNumR,
							ZX_Yd, ZX_LBenchPt, ZX_BenchNumL, ZX_RBenchPt, ZX_BenchNumR);
						//////////////////////////////////////////////////////////////////////////


					}

					else
					{
						ZX_Yd = road[0].hdmdmx[i].EarH;
						ZX_NumL = road[0].hdmdmx[i].ZEarPtNum;
						int k;
						for (k = 0; k < ZX_NumL; k++)
						{
							ZX_Learpt[k * 2] = road[0].hdmdmx[i].ZEarPtAry[k].x;
							ZX_Learpt[k * 2 + 1] = road[0].hdmdmx[i].ZEarPtAry[k].y;
						}
						ZX_NumR = road[0].hdmdmx[i].YEarPtNum;
						for (k = 0; k < ZX_NumR; k++)
						{
							ZX_Rearpt[k * 2] = road[0].hdmdmx[i].YEarPtAry[k].x;
							ZX_Rearpt[k * 2 + 1] = road[0].hdmdmx[i].YEarPtAry[k].y;
						}
						//移轴
						CalNewZB(road[0].hdmdes[i].xjj, ZX_Yd, ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR,
							YX_Yd, YX_Learpt, YX_NumL, YX_Rearpt, YX_NumR);

						//////////////////////////////////////////////////////////////////////////
						ZX_BenchNumL = road[0].hdmBench[i].ZEarPtNum;
						for (k = 0; k < ZX_BenchNumL; k++)
						{
							ZX_LBenchPt[k * 2] = road[0].hdmBench[i].ZEarPtAry[k].x;
							ZX_LBenchPt[k * 2 + 1] = road[0].hdmBench[i].ZEarPtAry[k].y;
						}
						ZX_BenchNumR = road[0].hdmBench[i].YEarPtNum;
						for (k = 0; k < ZX_BenchNumR; k++)
						{
							ZX_RBenchPt[k * 2] = road[0].hdmBench[i].YEarPtAry[k].x;
							ZX_RBenchPt[k * 2 + 1] = road[0].hdmBench[i].YEarPtAry[k].y;
						}
						//移轴
						CalNewZB(road[0].hdmdes[i].xjj, ZX_Yd, ZX_LBenchPt, ZX_BenchNumL, ZX_RBenchPt, ZX_BenchNumR,
							YX_Yd, YX_LBenchPt, YX_BenchNumL, YX_RBenchPt, YX_BenchNumR);
						//////////////////////////////////////////////////////////////////////////

					}

					road[0].hdmdes[i].newLYd = ZX_Yd;
					road[0].hdmdes[i].newRYd = YX_Yd;
					if (road[0].hdmdes[i].ZDMXZ == 3 && road[0].hdmdes[i].YDMXZ == 3
						&&
						road[0].hdmdes[i].Y_ZDMXZ == 3 && road[0].hdmdes[i].Y_YDMXZ == 3)
						continue;

					//左右都是隧
					if (road[0].hdmdes[i].ZDMXZ == 4 && road[0].hdmdes[i].YDMXZ == 4
						&&
						road[0].hdmdes[i].Y_ZDMXZ == 4 && road[0].hdmdes[i].Y_YDMXZ == 4)
						continue;

					if (road[0].hdmdes[i].ZDMXZ == -1 ||
						road[0].hdmdes[i].YDMXZ == -1 ||
						road[0].hdmdes[i].ZDMXZ == -2 ||
						road[0].hdmdes[i].YDMXZ == -2 ||
						road[0].hdmdes[i].Y_ZDMXZ == -1 ||
						road[0].hdmdes[i].Y_YDMXZ == -1 ||
						road[0].hdmdes[i].Y_ZDMXZ == -2 ||
						road[0].hdmdes[i].Y_YDMXZ == -2)//桥隧起始里程
					{
						pt.x = road[0].hdmdes[i].tX0;//桥隧处标注点
						pt.y = road[0].hdmdes[i].tY0;
						BiaoZhuQS(0, road[0].hdmdes[i].cml, pt); //标注桥隧位置
					}

					pCross.m_OriPoint.x = road[0].hdmdes[i].Xo;	//每个断面的绘图原点
					pCross.m_OriPoint.y = road[0].hdmdes[i].Yo;
					pCross.m_BTinf = road[0].hdmdes[i].ZDMXZ;

					//				road[0].hdmdes[i].xlxz=0;road[0].hdmdes[i].r_bh=-1;//一线，用于交互设计

					setCROSSAutoDesignData(pCross, 0, i, ZX_Yd,
						ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR,
						ZX_LBenchPt, ZX_BenchNumL, ZX_RBenchPt, ZX_BenchNumR);//左线

					//setCROSSAutoDesignData(pCross,i,ZX_Yd,ZX_Learpt,ZX_NumL,ZX_Rearpt,ZX_NumR);//左线
					pCross.m_YBTinf = road[0].hdmdes[i].Y_YDMXZ;
					if (!((road[0].hdmdes[i].Y_ZDMXZ == 3 && road[0].hdmdes[i].Y_YDMXZ == 3)
						||
						(road[0].hdmdes[i].Y_ZDMXZ == 4 && road[0].hdmdes[i].Y_YDMXZ == 4)
						)
						)
					{
						Y_setCROSSAutoDesignData(pCross, i, YX_Yd);
					}


					//				
					pCross.DorS = road[0].hdmdes[i].DorS;
					//	pCross.offset=0.0;//一线中心线相对与新的地面线的移动量
					//	pCross.Yoffset=0.0;
				}

				//			//////////////绘图部分 
				//			
				//			for(j=0;j<NZRXD;j++)//如果里程在左线的完全绕开的里程段，线间距视为0
				//			{
				//				if(road[0].hdmdes[i].DorS==1&&road[0].hdmdes[i].cml>ZRXD[j].RXDsml2-0.1 &&road[0].hdmdes[i].cml<ZRXD[j].RXDeml2+0.1)
				//				{road[0].hdmdes[i].Zxjj=0;break;}
				//				
				//			}

				//			
				//			if(ZXSM=="单线")
				//			{  road[0].hdmdes[i].Zxjj=0.0;  road[0].hdmdes[i].Yxjj=0.0;}
				//			pCross.zxjj = road[0].hdmdes[i].Zxjj;	
				//			pCross.yxjj = road[0].hdmdes[i].Yxjj;	//绘制中心线
				//            ads_printf(L"%lf\n",pCross.m_cml);
				pCross.Draw();

				road[0].hdmdes[i].LgouId = pCross.LgouId;
				road[0].hdmdes[i].RgouId = pCross.RgouId;

				if (road[0].hdmdes[i].glcml > -0.0001)//有关联断面,绘关联
				{
					//				    ads_printf(L"dml=%lf\n",road[0].hdmdes[i].dml);

					int iroad = GetIRoadByName(road[0].hdmdes[i].glRoadName);
					int jcross = FindIDM(iroad, road[0].hdmdes[i].glcml);

					int k;
					for (k = 0; k < road[iroad].hdmdmx[jcross].ZEarPtNum; k++)
					{
						Learpt[k * 2] = road[iroad].hdmdmx[jcross].ZEarPtAry[k].x;
						Learpt[k * 2 + 1] = road[iroad].hdmdmx[jcross].ZEarPtAry[k].y;
					}

					for (k = 0; k < road[iroad].hdmdmx[jcross].YEarPtNum; k++)
					{
						Rearpt[k * 2] = road[iroad].hdmdmx[jcross].YEarPtAry[k].x;
						Rearpt[k * 2 + 1] = road[iroad].hdmdmx[jcross].YEarPtAry[k].y;
					}

					//////////////////////////////////////////////////////////////////////////
					//横断面台阶
					for (k = 0; k < road[iroad].hdmBench[jcross].ZEarPtNum; k++)
					{
						LBenchPt[k * 2] = road[iroad].hdmBench[jcross].ZEarPtAry[k].x;
						LBenchPt[k * 2 + 1] = road[iroad].hdmBench[jcross].ZEarPtAry[k].y;
					}

					for (k = 0; k < road[iroad].hdmBench[jcross].YEarPtNum; k++)
					{
						RBenchPt[k * 2] = road[iroad].hdmBench[jcross].YEarPtAry[k].x;
						RBenchPt[k * 2 + 1] = road[iroad].hdmBench[jcross].YEarPtAry[k].y;
					}
					//////////////////////////////////////////////////////////////////////////

					FLX_EarHOnXLZX = road[iroad].hdmdmx[jcross].EarH;//线路中线处的地面标高
					NumLearpt = road[iroad].hdmdmx[jcross].ZEarPtNum;
					NumRearpt = road[iroad].hdmdmx[jcross].YEarPtNum;
					CalNewZB(road[iroad].hdmdes[jcross].OffsetByXLZX, FLX_EarHOnXLZX, Learpt, NumLearpt, Rearpt, NumRearpt,
						FLX_EarHOnLJZX, FLX_LearptOnLJZX, OffsetNumLearpt, FLX_RearptOnLJZX, OffsetNumRearpt);

					if (road[iroad].ZxOrYx > 0.0001)//右线分离
					{
						if (road[iroad].hdmdes[jcross].Lnpt > 0 && road[0].hdmdes[i].Rnpt > 0)
						{
							if (road[iroad].hdmdes[jcross].LGouPtNum == 6 || road[iroad].hdmdes[jcross].LGouPtNum == 16)//有线间沟
							{
								GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[0].hdmdes[i].RPTR[road[0].hdmdes[i].Rnpt - 1].x - road[iroad].hdmdes[jcross].Lgou[2 * (road[iroad].hdmdes[jcross].LGouPtNum - 1)])*Sfactor;
								road[iroad].hdmdes[jcross].Lgou[2 * (road[iroad].hdmdes[jcross].LGouPtNum - 1) + 1] = road[0].hdmdes[i].RPTR[road[0].hdmdes[i].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
							}
							else
							{
								GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[0].hdmdes[i].RPTR[road[0].hdmdes[i].Rnpt - 1].x - road[iroad].hdmdes[jcross].RPTL[road[iroad].hdmdes[jcross].Lnpt - 1].x)*Sfactor;
								road[iroad].hdmdes[jcross].RPTL[road[iroad].hdmdes[jcross].Lnpt - 1].y = road[0].hdmdes[i].RPTR[road[0].hdmdes[i].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
							}
						}
						//	dy1 = road[0].hdmdes[i].RPTR[road[0].hdmdes[i].Rnpt-1].y+road[0].hdmdmx[i].EarH-road[0].hdmdes[i].RHFR[1];
						//	dy2 = road[iroad].hdmdes[jcross].RHFL[1] - (road[iroad].hdmdes[jcross].RPTL[road[iroad].hdmdes[jcross].Lnpt-1].y+road[iroad].hdmdmx[jcross].EarH);
						GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[iroad].hdmdes[jcross].RHFL[1]-road[0].hdmdes[i].RHFR[1])*Sfactor;	//每个断面的绘图原点
					}
					else
					{
						if (road[iroad].hdmdes[jcross].Rnpt > 0 && road[0].hdmdes[i].Lnpt > 0)
						{
							if (road[iroad].hdmdes[jcross].RGouPtNum == 6 || road[iroad].hdmdes[jcross].RGouPtNum == 16)
							{
								GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[0].hdmdes[i].RPTL[road[0].hdmdes[i].Lnpt - 1].x - road[iroad].hdmdes[jcross].Rgou[2 * (road[iroad].hdmdes[jcross].RGouPtNum - 1)])*Sfactor;
								road[iroad].hdmdes[jcross].Rgou[2 * (road[iroad].hdmdes[jcross].RGouPtNum - 1) + 1] = road[0].hdmdes[i].RPTL[road[0].hdmdes[i].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
							}
							else
							{
								GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[0].hdmdes[i].RPTL[road[0].hdmdes[i].Lnpt - 1].x - road[iroad].hdmdes[jcross].RPTR[road[iroad].hdmdes[jcross].Rnpt - 1].x)*Sfactor;
								road[iroad].hdmdes[jcross].RPTR[road[iroad].hdmdes[jcross].Rnpt - 1].y = road[0].hdmdes[i].RPTL[road[0].hdmdes[i].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
							}
						}
						GLCross.m_OriPoint.y = pCross.m_OriPoint.y;//+ (road[iroad].hdmdes[jcross].RHFR[1]-road[0].hdmdes[i].RHFL[1])*Sfactor;	//每个断面的绘图原点
					}
					road[iroad].hdmdes[jcross].Ymin = road[0].hdmdes[i].Ymin;

					// 				setCROSSAutoDesignData(GLCross,iroad,jcross,road[iroad].hdmdmx[jcross].EarH,
					// 					Learpt,road[iroad].hdmdmx[jcross].ZEarPtNum,Rearpt,road[iroad].hdmdmx[jcross].YEarPtNum,
					// 					LBenchPt,road[iroad].hdmBench[jcross].ZEarPtNum,RBenchPt,road[iroad].hdmBench[jcross].YEarPtNum);
					setCROSSAutoDesignData(GLCross, iroad, jcross, FLX_EarHOnLJZX, FLX_LearptOnLJZX, OffsetNumLearpt, FLX_RearptOnLJZX, OffsetNumRearpt,
						LBenchPt, road[iroad].hdmBench[jcross].ZEarPtNum, RBenchPt, road[iroad].hdmBench[jcross].YEarPtNum);

					GLCross.DorS = road[iroad].hdmdes[jcross].DorS;
					GLCross.offset = road[iroad].hdmdes[jcross].offsetX;//一线中心线相对与新的地面线的移动量
					GLCross.IsLinkHdm = true;
					if (fabs(road[0].hdmdes[i].xjj) < 3)
						GLCross.BzTWInf = -1;
					GLCross.Draw();

				}

				//画图框	
			}
		}
		catch (...)
		{
			CString ExceptionStr;
			ExceptionStr.Format(L"Draw_ZX_Hdm()函数在i=%d时ckml=%s出现异常", i, road[0].hdmdes[i].ckml);
			AfxMessageBox(ExceptionStr);
		}

	}
	acedSetStatusBarProgressMeterPos(100);
	acedRestoreStatusBar();

}

void HdmDes::BiaoZhuQS(int iroad, double cml, AcGePoint3d pos)//桥隧处不画断面时，标注释
{

	ACHAR Text[80];
	int k;
	AcDbObjectId layerId;
	double sml, eml;
	bool IfbriTun;

	IfbriTun = false;
	for (k = 0; k < road[iroad].NAllBri; k++)
	{
		sml = road[iroad].pm->TYLC(road[iroad].AllBri[k].StDml);
		eml = road[iroad].pm->TYLC(road[iroad].AllBri[k].EdDml);
		if (cml > sml - 0.001&&cml < eml + 0.001)
		{
			_stprintf(Text, L"%0.3lf-%0.3lf%s", road[iroad].AllBri[k].StDml, road[iroad].AllBri[k].EdDml, road[iroad].AllBri[k].BriName);//标注字符串
			IfbriTun = true;
			break;
		}
	}

	for (k = 0; k < road[iroad].NZBri; k++)
	{
		sml = road[iroad].pm->TYLC(road[iroad].ZBri[k].StDml);
		eml = road[iroad].pm->TYLC(road[iroad].ZBri[k].EdDml);
		if (cml > sml - 0.001&&cml < eml + 0.001)
		{
			_stprintf(Text, L"%0.3lf-%0.3lf%s", road[iroad].ZBri[k].StDml, road[iroad].ZBri[k].EdDml, road[iroad].ZBri[k].BriName);//标注字符串
			IfbriTun = true;
			break;
		}
	}
	for (k = 0; k < road[iroad].NYBri; k++)
	{
		sml = road[iroad].pm->TYLC(road[iroad].YBri[k].StDml);
		eml = road[iroad].pm->TYLC(road[iroad].YBri[k].EdDml);
		if (cml > sml - 0.001&&cml < eml + 0.001)
		{
			_stprintf(Text, L"%0.3lf-%0.3lf%s", road[iroad].YBri[k].StDml, road[iroad].YBri[k].EdDml, road[iroad].YBri[k].BriName);//标注字符串
			IfbriTun = true;
			break;
		}
	}


	for (k = 0; k < road[iroad].NAllTun; k++)
	{
		sml = road[iroad].pm->TYLC(road[iroad].AllTun[k].StDml);
		eml = road[iroad].pm->TYLC(road[iroad].AllTun[k].EdDml);
		if (cml > sml - 0.001&&cml < eml + 0.001)
		{
			_stprintf(Text, L"%0.3lf-%0.3lf%s", road[iroad].AllTun[k].StDml, road[iroad].AllTun[k].EdDml, road[iroad].AllTun[k].TunName);//标注字符串
			IfbriTun = true;
			break;
		}
	}

	for (k = 0; k < road[iroad].NZTun; k++)
	{
		sml = road[iroad].pm->TYLC(road[iroad].ZTun[k].StDml);
		eml = road[iroad].pm->TYLC(road[iroad].ZTun[k].EdDml);
		if (cml > sml - 0.001&&cml < eml + 0.001)
		{
			_stprintf(Text, L"%0.3lf-%0.3lf%s", road[iroad].ZTun[k].StDml, road[iroad].ZTun[k].EdDml, road[iroad].ZTun[k].TunName);//标注字符串
			IfbriTun = true;
			break;
		}
	}
	for (k = 0; k < road[iroad].NYTun; k++)
	{
		sml = road[iroad].pm->TYLC(road[iroad].YTun[k].StDml);
		eml = road[iroad].pm->TYLC(road[iroad].YTun[k].EdDml);
		if (cml > sml - 0.001&&cml < eml + 0.001)
		{
			_stprintf(Text, L"%0.3lf-%0.3lf%s", road[iroad].YTun[k].StDml, road[iroad].YTun[k].EdDml, road[iroad].YTun[k].TunName);//标注字符串
			IfbriTun = true;
			break;
		}
	}

	if (IfbriTun)
	{
		layerId = CreateLayer(L"Hdm");
		H_maketext(pos, Text, 0, 5.0, 2, 2, L"宋体", layerId);
	}


}
Adesk::Boolean HdmDes::Y_setCROSSAutoDesignData(CROSS &pCross, int k, double Earh)
{
	//double Earh;
	double  xx, y;
	int i, m;
	int gounum, jsgnum, pjqptnum;
	double PjqPt[14];


	//pCross.m_OriPoint.x = road[0].hdmdes[k].Xo;	
	//pCross.m_OriPoint.y = road[0].hdmdes[k].Yo;	

	_tcscpy(pCross.m_ckml, road[0].hdmdes[k].ckml);
	//1.获取分离段道路编号
	//    int iroad = GetIRoadByName(road[0].hdmdes[k].FLDname);
	//  _tcscpy(pCross.m_FLDckml,road[iroad].pm->XLC(road[0].hdmdes[k].FLDcml));
	pCross.m_cml = road[0].hdmdes[k].cml;
	pCross.m_YZTWH = road[0].hdmdes[k].Y_ZHc;
	pCross.m_YYTWH = road[0].hdmdes[k].Y_YHc;

	//pCross.m_TWH = road[0].hdmdes[k].Hc;

	pCross.Y_LeftDesignLinePart = new DesignLine_ROAD;
	pCross.Y_RightDesignLinePart = new DesignLine_ROAD;

	pCross.Y_LeftDesignLinePart->m_ZorY = -2;
	pCross.Y_RightDesignLinePart->m_ZorY = 2;
	pCross.Y_LeftDesignLinePart->RnewYd = Earh;
	pCross.Y_RightDesignLinePart->RnewYd = Earh;
	_tcscpy(pCross.Y_LeftDesignLinePart->RoadName, road[0].roadname);
	_tcscpy(pCross.Y_RightDesignLinePart->RoadName, road[0].roadname);
	pCross.Y_RightDesignLinePart->hdmno = k;
	pCross.Y_LeftDesignLinePart->hdmno = k;//在hdmdes数组中的边号



	//	GetZXandYXLCinDoubleLM(road[0].hdmdes[k].cml,Zprojml,Yprojml);

	//	pCross.Y_LeftDesignLinePart->m_nLTBPJS= FindWichBP(Yprojml,LeftHdmData.NLDBP,LeftHdmData.LDBP,pCross.Y_LeftDesignLinePart->m_TM,pCross.Y_LeftDesignLinePart->m_TH,pCross.Y_LeftDesignLinePart->m_TPTW,pCross.Y_LeftDesignLinePart->m_TPTI);//路堤边坡
	//	pCross.Y_RightDesignLinePart->m_nLTBPJS= FindWichBP(Yprojml,RightHdmData.NLDBP,RightHdmData.LDBP,pCross.Y_RightDesignLinePart->m_TM,pCross.Y_RightDesignLinePart->m_TH,pCross.Y_RightDesignLinePart->m_TPTW,pCross.Y_RightDesignLinePart->m_TPTI);//路堤边坡
	//	pCross.Y_LeftDesignLinePart->m_nLZBPJS= FindWichBP(Yprojml,LeftHdmData.NLQBP,LeftHdmData.LQBP,pCross.Y_LeftDesignLinePart->m_WM,pCross.Y_LeftDesignLinePart->m_PH,pCross.Y_LeftDesignLinePart->m_ZPTW,pCross.Y_LeftDesignLinePart->m_ZPTI);//路堤边坡
	//	pCross.Y_RightDesignLinePart->m_nLZBPJS= FindWichBP(Yprojml,RightHdmData.NLQBP,RightHdmData.LQBP,pCross.Y_RightDesignLinePart->m_WM,pCross.Y_RightDesignLinePart->m_PH,pCross.Y_RightDesignLinePart->m_ZPTW,pCross.Y_RightDesignLinePart->m_ZPTI);//路堤边坡
	//	
	//	FindIljjk(Yprojml,LeftHdmData.NLJJK,LeftHdmData.LJJK, pCross.Y_LeftDesignLinePart->m_WW[0], pCross.Y_LeftDesignLinePart->m_WW[1]);
	//	FindIljjk(Yprojml,RightHdmData.NLJJK,RightHdmData.LJJK,pCross.Y_RightDesignLinePart->m_WW[0], pCross.Y_RightDesignLinePart->m_WW[1]);
	//	pCross.Y_LeftDesignLinePart->m_XW = FindIljxk(Yprojml,LeftHdmData.NLJXK,LeftHdmData.LJXK);
	//	pCross.Y_RightDesignLinePart->m_XW = FindIljxk(Yprojml,RightHdmData.NLJXK,RightHdmData.LJXK);

	pCross.Y_LeftDesignLinePart->m_DesignPointNum = road[0].hdmdes[k].Y_Lnpt;


	if (pCross.Y_LeftDesignLinePart->m_DesignPoints) { delete pCross.Y_LeftDesignLinePart->m_DesignPoints; pCross.Y_LeftDesignLinePart->m_DesignPoints = NULL; }
	if (road[0].hdmdes[k].Y_Lnpt > 0)
		pCross.Y_LeftDesignLinePart->m_DesignPoints = new AcGePoint3d[pCross.Y_LeftDesignLinePart->m_DesignPointNum];

	pCross.Y_RightDesignLinePart->m_DesignPointNum = road[0].hdmdes[k].Y_Rnpt;
	if (pCross.Y_RightDesignLinePart->m_DesignPoints) { delete pCross.Y_RightDesignLinePart->m_DesignPoints; pCross.Y_RightDesignLinePart->m_DesignPoints = NULL; }
	if (road[0].hdmdes[k].Y_Rnpt > 0)
		pCross.Y_RightDesignLinePart->m_DesignPoints = new AcGePoint3d[pCross.Y_RightDesignLinePart->m_DesignPointNum];

	for (i = 0; i < 5; i++)
	{
		pCross.Y_LeftDesignLinePart->RHF[i * 2] = road[0].hdmdes[k].Y_RHFL[i * 2] + road[0].hdmdes[k].xjj;
		pCross.Y_LeftDesignLinePart->RHF[i * 2 + 1] = road[0].hdmdes[k].Y_RHFL[i * 2 + 1];
		pCross.Y_RightDesignLinePart->RHF[i * 2] = road[0].hdmdes[k].Y_RHFR[i * 2] + road[0].hdmdes[k].xjj;
		pCross.Y_RightDesignLinePart->RHF[i * 2 + 1] = road[0].hdmdes[k].Y_RHFR[i * 2 + 1];

	}

	pCross.Y_LeftDesignLinePart->m_Xcdh = road[0].hdmdes[k].Y_zlmhd[0];
	pCross.Y_LeftDesignLinePart->m_Yljh = road[0].hdmdes[k].Y_zlmhd[1];
	pCross.Y_LeftDesignLinePart->m_Tljh = road[0].hdmdes[k].Y_zlmhd[2];
	pCross.Y_RightDesignLinePart->m_Xcdh = road[0].hdmdes[k].Y_ylmhd[0];
	pCross.Y_RightDesignLinePart->m_Yljh = road[0].hdmdes[k].Y_ylmhd[1];
	pCross.Y_RightDesignLinePart->m_Tljh = road[0].hdmdes[k].Y_ylmhd[2];

	if (fabs(pCross.Y_LeftDesignLinePart->RHF[4]) > fabs(pCross.Y_LeftDesignLinePart->RHF[2]))
		pCross.Y_LeftDesignLinePart->LMHP[0] = (pCross.Y_LeftDesignLinePart->RHF[5] - pCross.Y_LeftDesignLinePart->RHF[3]) / (pCross.Y_LeftDesignLinePart->RHF[4] - pCross.Y_LeftDesignLinePart->RHF[2]);
	else
		pCross.Y_LeftDesignLinePart->LMHP[0] = 0.0;

	if (fabs(pCross.Y_LeftDesignLinePart->RHF[6]) > fabs(pCross.Y_LeftDesignLinePart->RHF[4]))
		pCross.Y_LeftDesignLinePart->LMHP[1] = (pCross.Y_LeftDesignLinePart->RHF[7] - pCross.Y_LeftDesignLinePart->RHF[5]) / (pCross.Y_LeftDesignLinePart->RHF[6] - pCross.Y_LeftDesignLinePart->RHF[4]);
	else
		pCross.Y_LeftDesignLinePart->LMHP[1] = 0.0;

	if (fabs(pCross.Y_LeftDesignLinePart->RHF[8]) > fabs(pCross.Y_LeftDesignLinePart->RHF[6]))
		pCross.Y_LeftDesignLinePart->LMHP[2] = (pCross.Y_LeftDesignLinePart->RHF[9] - pCross.Y_LeftDesignLinePart->RHF[7]) / (pCross.Y_LeftDesignLinePart->RHF[8] - pCross.Y_LeftDesignLinePart->RHF[6]);
	else
		pCross.Y_LeftDesignLinePart->LMHP[2] = 0.0;

	if (pCross.Y_RightDesignLinePart->RHF[4] > pCross.Y_RightDesignLinePart->RHF[2])
		pCross.Y_RightDesignLinePart->LMHP[0] = (pCross.Y_RightDesignLinePart->RHF[5] - pCross.Y_RightDesignLinePart->RHF[3]) / (pCross.Y_RightDesignLinePart->RHF[4] - pCross.Y_RightDesignLinePart->RHF[2]);
	else
		pCross.Y_RightDesignLinePart->LMHP[0] = 0.0;

	if (pCross.Y_RightDesignLinePart->RHF[6] > pCross.Y_RightDesignLinePart->RHF[4])
		pCross.Y_RightDesignLinePart->LMHP[1] = (pCross.Y_RightDesignLinePart->RHF[7] - pCross.Y_RightDesignLinePart->RHF[5]) / (pCross.Y_RightDesignLinePart->RHF[6] - pCross.Y_RightDesignLinePart->RHF[4]);
	else
		pCross.Y_RightDesignLinePart->LMHP[1] = 0.0;

	if (pCross.Y_RightDesignLinePart->RHF[8] > pCross.Y_RightDesignLinePart->RHF[6])
		pCross.Y_RightDesignLinePart->LMHP[2] = (pCross.Y_RightDesignLinePart->RHF[9] - pCross.Y_RightDesignLinePart->RHF[7]) / (pCross.Y_RightDesignLinePart->RHF[8] - pCross.Y_RightDesignLinePart->RHF[6]);
	else
		pCross.Y_RightDesignLinePart->LMHP[2] = 0.0;

	pCross.Y_LeftDesignLinePart->m_FillORCut = road[0].hdmdes[k].Y_Zt;
	//	pCross.Y_LeftDesignLinePart->DorS = road[0].hdmdes[k].DorS;
	pCross.Y_LeftDesignLinePart->BTinf = road[0].hdmdes[k].Y_ZDMXZ;
	//	pCross.Y_LeftDesignLinePart->Y_BTinf = road[0].hdmdes[k].Y_YDMXZ;
	//	pCross.Y_LeftDesignLinePart->xlxz = road[0].hdmdes[k].xlxz;
	//	pCross.Y_LeftDesignLinePart->r_bh = road[0].hdmdes[k].r_bh; 
	pCross.Y_LeftDesignLinePart->cml = road[0].hdmdes[k].cml;

	for (i = 0; i < pCross.Y_LeftDesignLinePart->m_DesignPointNum; i++)
	{
		xx = road[0].hdmdes[k].Y_RPTL[i].x + road[0].hdmdes[k].xjj;
		y = road[0].hdmdes[k].Y_RPTL[i].y + Earh - road[0].hdmdes[k].Ymin;
		pCross.Y_LeftDesignLinePart->m_DesignPoints[i].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.Y_LeftDesignLinePart->m_DesignPoints[i].y = pCross.m_OriPoint.y + y * Sfactor;
	}

	//	if(road[0].hdmdes[k].Y_Lnpt>0)
	//	{
	//		pCross.Y_LeftDesignLinePart->m_DesignPoints[0].x = pCross.Y_LeftDesignLinePart->m_DesignPoints[1].x;
	//		pCross.Y_LeftDesignLinePart->m_DesignPoints[0].y = pCross.Y_LeftDesignLinePart->m_DesignPoints[1].y;
	//	}
	//左侧路堤水沟部分
	//	pCross.LeftLTGouPart = NULL;

	pCross.Y_LeftLTGouPart = new LTGOU_ROAD;
	pCross.Y_LeftLTGouPart->m_cml = pCross.m_cml;

	int goupro;
	if (road[0].hdmdes[k].xjj < 0.0001)//右线为主线
	{
		FindSG(road[0].hdmdes[k].cml, road[0].pm, road[0].hdmbz.NZLDSG, road[0].hdmbz.ZLDSG,
			goupro, pCross.Y_LeftLTGouPart->PSG_JQHD,
			pCross.Y_LeftLTGouPart->m_T2W, pCross.Y_LeftLTGouPart->m_T1W,
			pCross.Y_LeftLTGouPart->m_T2H, pCross.Y_LeftLTGouPart->m_GH,
			pCross.Y_LeftLTGouPart->m_GW, pCross.Y_LeftLTGouPart->m_HH,
			pCross.Y_LeftLTGouPart->m_SP1, pCross.Y_LeftLTGouPart->m_SP2, pCross.Y_LeftLTGouPart->m_SP3, pCross.Y_LeftLTGouPart->m_PSG_GDR);//加浆砌厚度
		pCross.Y_LeftLTGouPart->GouProperty = goupro;
	}
	else if (road[0].hdmdes[k].xjj > 0.0001)//右线为分离线
	{
		int ifld;
		ifld = GetIRoadByName(road[0].hdmdes[k].FLDname);
		FindSG(road[0].hdmdes[k].FLDcml, road[ifld].pm, road[ifld].hdmbz.NZLDSG, road[ifld].hdmbz.ZLDSG,
			goupro, pCross.Y_LeftLTGouPart->PSG_JQHD,
			pCross.Y_LeftLTGouPart->m_T2W, pCross.Y_LeftLTGouPart->m_T1W,
			pCross.Y_LeftLTGouPart->m_T2H, pCross.Y_LeftLTGouPart->m_GH,
			pCross.Y_LeftLTGouPart->m_GW, pCross.Y_LeftLTGouPart->m_HH,
			pCross.Y_LeftLTGouPart->m_SP1, pCross.Y_LeftLTGouPart->m_SP2, pCross.Y_LeftLTGouPart->m_SP3, pCross.Y_LeftLTGouPart->m_PSG_GDR);//加浆砌厚度
		pCross.Y_LeftLTGouPart->GouProperty = goupro;
	}

	pCross.Y_LeftLTGouPart->m_ZorY = -1;
	pCross.Y_LeftLTGouPart->m_LTGouPointNum = 0;

	pCross.Y_LeftJSGouPart = new JSGOU_ROAD;
	_tcscpy(pCross.Y_LeftJSGouPart->m_ckml, pCross.m_ckml);
	if (road[0].hdmdes[k].xjj < 0.0001)//右线为主线
		FindTG(road[0].hdmdes[k].cml, road[0].pm, road[0].hdmbz.NZTG, road[0].hdmbz.ZTG,
			pCross.Y_LeftJSGouPart->BJ, pCross.Y_LeftJSGouPart->GW,
			pCross.Y_LeftJSGouPart->GS, pCross.Y_LeftJSGouPart->SP1,
			pCross.Y_LeftJSGouPart->SP2, pCross.Y_LeftJSGouPart->TG_JQHD, pCross.Y_LeftJSGouPart->TG_GDR);
	else
	{
		int ifld;
		ifld = GetIRoadByName(road[0].hdmdes[k].FLDname);
		FindTG(road[0].hdmdes[k].FLDcml, road[ifld].pm, road[ifld].hdmbz.NZTG, road[ifld].hdmbz.ZTG,
			pCross.Y_LeftJSGouPart->BJ, pCross.Y_LeftJSGouPart->GW,
			pCross.Y_LeftJSGouPart->GS, pCross.Y_LeftJSGouPart->SP1,
			pCross.Y_LeftJSGouPart->SP2, pCross.Y_LeftJSGouPart->TG_JQHD, pCross.Y_LeftJSGouPart->TG_GDR);
	}

	//	FindTG(Yprojml,LeftHdmData.NTG,LeftHdmData.TG,pCross.Y_LeftJSGouPart->BJ,pCross.Y_LeftJSGouPart->GW,
	//		pCross.Y_LeftJSGouPart->GS,pCross.Y_LeftJSGouPart->SP1,
	//		pCross.Y_LeftJSGouPart->SP2,pCross.Y_LeftJSGouPart->TG_JQHD);

	pCross.Y_LeftJSGouPart->m_ZorY = -1;
	pCross.Y_LeftJSGouPart->JSGouPtNum = 0;

	pCross.Y_LeftLTGouPart->GouProperty = road[0].hdmdes[k].Y_LGouProperty;
	if (road[0].hdmdes[k].Y_LGouProperty == 1 && road[0].hdmdes[k].Y_LGouPtNum > 0)
	{
		gounum = 0;
		for (i = 0; i < road[0].hdmdes[k].Y_LGouPtNum; i++)
		{
			xx = road[0].hdmdes[k].Y_Lgou[i * 2] + road[0].hdmdes[k].xjj;
			if (fabs(road[0].hdmdes[k].Y_Lgou[i * 2]) > 0.0001)
			{
				y = road[0].hdmdes[k].Y_Lgou[i * 2 + 1] + Earh - road[0].hdmdes[k].Ymin;
				pCross.Y_LeftLTGouPart->m_LTGouPoints[gounum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.Y_LeftLTGouPart->m_LTGouPoints[gounum].y = pCross.m_OriPoint.y + y * Sfactor;//+ pCross.m_TWH;
				gounum++;
			}
		}
		pCross.Y_LeftLTGouPart->m_LTGouPointNum = gounum;
		if (gounum >= 5)
		{
			pCross.Y_LeftLTGouPart->m_GouBotH = road[0].hdmdes[k].Y_Lgou[2 * 2 + 1] + Earh + pCross.Y_LeftLTGouPart->PSG_JQHD;
			pCross.Y_LeftLTGouPart->m_GouBotX = 0.5*(road[0].hdmdes[k].Y_Lgou[3 * 2] + road[0].hdmdes[k].Y_Lgou[2 * 2]);
			pCross.Y_LeftLTGouPart->m_GouBotPoint.x = 0.5*(pCross.Y_LeftLTGouPart->m_LTGouPoints[3].x + pCross.Y_LeftLTGouPart->m_LTGouPoints[2].x);
			pCross.Y_LeftLTGouPart->m_GouBotPoint.y = pCross.Y_LeftLTGouPart->m_LTGouPoints[3].y;
			pCross.Y_LeftLTGouPart->m_OriGouBotPt = pCross.Y_LeftLTGouPart->m_GouBotPoint;
		}
	}
	else if (road[0].hdmdes[k].Y_LGouProperty == 0)
	{
		AcGePoint3d JD, preJD;
		JD.x = pCross.Y_LeftDesignLinePart->m_DesignPoints[pCross.Y_LeftDesignLinePart->m_DesignPointNum - 1].x;
		JD.y = pCross.Y_LeftDesignLinePart->m_DesignPoints[pCross.Y_LeftDesignLinePart->m_DesignPointNum - 1].y;
		preJD.x = pCross.Y_LeftDesignLinePart->m_DesignPoints[pCross.Y_LeftDesignLinePart->m_DesignPointNum - 2].x;
		preJD.y = pCross.Y_LeftDesignLinePart->m_DesignPoints[pCross.Y_LeftDesignLinePart->m_DesignPointNum - 2].y;
		CalPjqPt(-1, JD, preJD, pjqptnum, PjqPt);
		pCross.Y_LeftLTGouPart->pjqptnum = pjqptnum;
		for (m = 0; m < pjqptnum; m++)
		{
			pCross.Y_LeftLTGouPart->PjqPt[m].x = PjqPt[2 * m];
			pCross.Y_LeftLTGouPart->PjqPt[m].y = PjqPt[2 * m + 1];
		}
	}
	else if (road[0].hdmdes[k].Y_LGouProperty == 2 && road[0].hdmdes[k].Y_LJSGouPtNum > 0)//设置天沟
	{
		jsgnum = 0;
		for (i = 0; i < road[0].hdmdes[k].Y_LJSGouPtNum; i++)
		{
			xx = road[0].hdmdes[k].Y_LJSgou[i * 2] - road[0].hdmdes[k].offsetX + road[0].hdmdes[k].YoffsetX;
			if (fabs(road[0].hdmdes[k].Y_LJSgou[i * 2]) > 0.0001)
			{
				y = road[0].hdmdes[k].Y_LJSgou[i * 2 + 1] + Earh - road[0].hdmdes[k].Ymin;
				pCross.Y_LeftJSGouPart->m_JSGouPoints[jsgnum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.Y_LeftJSGouPart->m_JSGouPoints[jsgnum].y = pCross.m_OriPoint.y + y * Sfactor;
				jsgnum++;
			}
		}
		pCross.Y_LeftJSGouPart->JSGouPtNum = jsgnum;

		pCross.Y_LeftJSGouPart->m_GouBotH = road[0].hdmdes[k].Y_LJSgou[2 * 1 + 1] + Earh;//沟底中心地面高程
		pCross.Y_LeftJSGouPart->m_GouBotX = 0.5*(road[0].hdmdes[k].Y_LJSgou[2 * 2] + road[0].hdmdes[k].Y_LJSgou[2 * 1]);//沟底中心的小x坐标
		pCross.Y_LeftJSGouPart->m_GouBotPoint.x = 0.5*(pCross.Y_LeftJSGouPart->m_JSGouPoints[1].x + pCross.Y_LeftJSGouPart->m_JSGouPoints[2].x);
		pCross.Y_LeftJSGouPart->m_GouBotPoint.y = pCross.Y_LeftJSGouPart->m_JSGouPoints[1].y;
		pCross.Y_LeftJSGouPart->m_OriGouBotPt = pCross.Y_LeftJSGouPart->m_GouBotPoint;
	}

	//右侧

	pCross.Y_RightDesignLinePart->m_FillORCut = road[0].hdmdes[k].Y_Yt;
	//pCross.Y_RightDesignLinePart->DorS = road[0].hdmdes[k].DorS;
	pCross.Y_RightDesignLinePart->BTinf = road[0].hdmdes[k].Y_YDMXZ;
	//pCross.Y_RightDesignLinePart->Y_BTinf = road[0].hdmdes[k].Y_BTinf;
	//	pCross.Y_RightDesignLinePart->xlxz = road[0].hdmdes[k].xlxz;
	//	pCross.Y_RightDesignLinePart->r_bh = road[0].hdmdes[k].r_bh; 
	pCross.Y_RightDesignLinePart->cml = road[0].hdmdes[k].cml;
	for (i = 0; i < pCross.Y_RightDesignLinePart->m_DesignPointNum; i++)
	{
		xx = road[0].hdmdes[k].Y_RPTR[i].x + road[0].hdmdes[k].xjj;//相对于左侧中线坐标的值
		y = road[0].hdmdes[k].Y_RPTR[i].y + Earh - road[0].hdmdes[k].Ymin;
		pCross.Y_RightDesignLinePart->m_DesignPoints[i].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.Y_RightDesignLinePart->m_DesignPoints[i].y = pCross.m_OriPoint.y + y * Sfactor;
	}

	//	if(road[0].hdmdes[k].Y_Rnpt>0)
	//	{
	//		pCross.Y_RightDesignLinePart->m_DesignPoints[0].x = pCross.Y_RightDesignLinePart->m_DesignPoints[1].x;
	//		pCross.Y_RightDesignLinePart->m_DesignPoints[0].y = pCross.Y_RightDesignLinePart->m_DesignPoints[1].y;
	//	}
	//	
	//右侧路堤水沟参数
	// pCross.RightLTGouPart = NULL;

	pCross.Y_RightLTGouPart = new LTGOU_ROAD;
	pCross.Y_RightLTGouPart->m_cml = pCross.m_cml;

	if (road[0].hdmdes[k].xjj < 0.0001)//右线为主线
	{
		FindSG(road[0].hdmdes[k].cml, road[0].pm, road[0].hdmbz.NYLDSG, road[0].hdmbz.YLDSG,
			goupro, pCross.Y_RightLTGouPart->PSG_JQHD,
			pCross.Y_RightLTGouPart->m_T2W, pCross.Y_RightLTGouPart->m_T1W,
			pCross.Y_RightLTGouPart->m_T2H, pCross.Y_RightLTGouPart->m_GH,
			pCross.Y_RightLTGouPart->m_GW, pCross.Y_RightLTGouPart->m_HH,
			pCross.Y_RightLTGouPart->m_SP1, pCross.Y_RightLTGouPart->m_SP2, pCross.Y_RightLTGouPart->m_SP3, pCross.Y_RightLTGouPart->m_PSG_GDR);//加浆砌厚度
		pCross.Y_RightLTGouPart->GouProperty = goupro;
	}
	else if (road[0].hdmdes[k].xjj > 0.0001)//右线为分离线
	{
		int ifld;
		ifld = GetIRoadByName(road[0].hdmdes[k].FLDname);
		FindSG(road[0].hdmdes[k].FLDcml, road[ifld].pm, road[ifld].hdmbz.NYLDSG, road[ifld].hdmbz.YLDSG,
			goupro, pCross.Y_RightLTGouPart->PSG_JQHD,
			pCross.Y_RightLTGouPart->m_T2W, pCross.Y_RightLTGouPart->m_T1W,
			pCross.Y_RightLTGouPart->m_T2H, pCross.Y_RightLTGouPart->m_GH,
			pCross.Y_RightLTGouPart->m_GW, pCross.Y_RightLTGouPart->m_HH,
			pCross.Y_RightLTGouPart->m_SP1, pCross.Y_RightLTGouPart->m_SP2, pCross.Y_RightLTGouPart->m_SP3, pCross.Y_RightLTGouPart->m_PSG_GDR);//加浆砌厚度
		pCross.Y_RightLTGouPart->GouProperty = goupro;
	}
	pCross.Y_RightLTGouPart->m_ZorY = 1;
	pCross.Y_RightLTGouPart->m_LTGouPointNum = 0;

	pCross.Y_RightJSGouPart = new JSGOU_ROAD;
	_tcscpy(pCross.Y_RightJSGouPart->m_ckml, pCross.m_ckml);
	if (road[0].hdmdes[k].xjj < 0.0001)//右线为主线
		FindTG(road[0].hdmdes[k].cml, road[0].pm, road[0].hdmbz.NYTG, road[0].hdmbz.YTG,
			pCross.Y_RightJSGouPart->BJ, pCross.Y_RightJSGouPart->GW,
			pCross.Y_RightJSGouPart->GS, pCross.Y_RightJSGouPart->SP1,
			pCross.Y_RightJSGouPart->SP2, pCross.Y_RightJSGouPart->TG_JQHD, pCross.Y_RightJSGouPart->TG_GDR);
	else
	{
		int ifld;
		ifld = GetIRoadByName(road[0].hdmdes[k].FLDname);
		FindTG(road[0].hdmdes[k].FLDcml, road[ifld].pm, road[ifld].hdmbz.NYTG, road[ifld].hdmbz.YTG,
			pCross.Y_RightJSGouPart->BJ, pCross.Y_RightJSGouPart->GW,
			pCross.Y_RightJSGouPart->GS, pCross.Y_RightJSGouPart->SP1,
			pCross.Y_RightJSGouPart->SP2, pCross.Y_RightJSGouPart->TG_JQHD, pCross.Y_RightJSGouPart->TG_GDR);
	}

	//	FindTG(Yprojml,RightHdmData.NTG,RightHdmData.TG,pCross.Y_RightJSGouPart->BJ,pCross.Y_RightJSGouPart->GW,
	//		pCross.Y_RightJSGouPart->GS,pCross.Y_RightJSGouPart->SP1,
	//		pCross.Y_RightJSGouPart->SP2,pCross.Y_RightJSGouPart->TG_JQHD);

	pCross.Y_RightJSGouPart->m_ZorY = -1;
	pCross.Y_RightJSGouPart->JSGouPtNum = 0;

	pCross.Y_RightLTGouPart->GouProperty = road[0].hdmdes[k].Y_RGouProperty;

	if (road[0].hdmdes[k].Y_RGouProperty == 1 && road[0].hdmdes[k].Y_RGouPtNum > 0)//有路堤水沟
	{
		gounum = 0;
		pCross.Y_RightLTGouPart->m_LTGouPointNum = 0;
		for (i = 0; i < road[0].hdmdes[k].Y_RGouPtNum; i++)
		{
			xx = road[0].hdmdes[k].Y_Rgou[i * 2] + road[0].hdmdes[k].xjj;
			if (xx > 0.0001)
			{
				y = road[0].hdmdes[k].Y_Rgou[i * 2 + 1] + Earh - road[0].hdmdes[k].Ymin;
				pCross.Y_RightLTGouPart->m_LTGouPoints[gounum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.Y_RightLTGouPart->m_LTGouPoints[gounum].y = pCross.m_OriPoint.y + y * Sfactor;//+ pCross.m_TWH;
				gounum++;
			}
		}
		pCross.Y_RightLTGouPart->m_LTGouPointNum = gounum;
		pCross.Y_RightLTGouPart->m_GouBotH = road[0].hdmdes[k].Y_Rgou[3 * 2 + 1] + Earh + pCross.Y_RightLTGouPart->PSG_JQHD;
		if (gounum >= 5)
		{
			pCross.Y_RightLTGouPart->m_GouBotX = 0.5*(road[0].hdmdes[k].Y_Rgou[3 * 2] + road[0].hdmdes[k].Y_Rgou[2 * 2]);

			pCross.Y_RightLTGouPart->m_GouBotPoint.x = 0.5*(pCross.Y_RightLTGouPart->m_LTGouPoints[3].x + pCross.Y_RightLTGouPart->m_LTGouPoints[2].x);
			pCross.Y_RightLTGouPart->m_GouBotPoint.y = pCross.Y_RightLTGouPart->m_LTGouPoints[3].y;
			pCross.Y_RightLTGouPart->m_OriGouBotPt = pCross.Y_RightLTGouPart->m_GouBotPoint;
		}
	}
	else if (road[0].hdmdes[k].Y_RGouProperty == 0)
	{
		AcGePoint3d JD, preJD;
		JD.x = pCross.Y_RightDesignLinePart->m_DesignPoints[pCross.Y_RightDesignLinePart->m_DesignPointNum - 1].x;
		JD.y = pCross.Y_RightDesignLinePart->m_DesignPoints[pCross.Y_RightDesignLinePart->m_DesignPointNum - 1].y;
		preJD.x = pCross.Y_RightDesignLinePart->m_DesignPoints[pCross.Y_RightDesignLinePart->m_DesignPointNum - 2].x;
		preJD.y = pCross.Y_RightDesignLinePart->m_DesignPoints[pCross.Y_RightDesignLinePart->m_DesignPointNum - 2].y;
		CalPjqPt(1, JD, preJD, pjqptnum, PjqPt);
		pCross.Y_RightLTGouPart->pjqptnum = pjqptnum;
		for (m = 0; m < pjqptnum; m++)
		{
			pCross.Y_RightLTGouPart->PjqPt[m].x = PjqPt[2 * m];
			pCross.Y_RightLTGouPart->PjqPt[m].y = PjqPt[2 * m + 1];
		}
	}

	else if (road[0].hdmdes[k].Y_RGouProperty == 2 && road[0].hdmdes[k].Y_RJSGouPtNum > 0)//设置天沟
	{
		jsgnum = 0;
		for (i = 0; i < road[0].hdmdes[k].Y_RJSGouPtNum; i++)
		{
			xx = road[0].hdmdes[k].Y_RJSgou[i * 2] + road[0].hdmdes[k].xjj;
			if (fabs(xx) > 0.0001)
			{
				y = road[0].hdmdes[k].Y_RJSgou[i * 2 + 1] + Earh - road[0].hdmdes[k].Ymin;
				pCross.Y_RightJSGouPart->m_JSGouPoints[jsgnum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.Y_RightJSGouPart->m_JSGouPoints[jsgnum].y = pCross.m_OriPoint.y + y * Sfactor;
				jsgnum++;
			}
		}

		pCross.Y_RightJSGouPart->JSGouPtNum = jsgnum;

		pCross.Y_RightJSGouPart->m_GouBotH = road[0].hdmdes[k].Y_RJSgou[2 * 1 + 1] + Earh;//沟底中心地面高程
		pCross.Y_RightJSGouPart->m_GouBotX = 0.5*(road[0].hdmdes[k].Y_RJSgou[2 * 2] + road[0].hdmdes[k].Y_RJSgou[2 * 1]);//沟底中心的小x坐标
		pCross.Y_RightJSGouPart->m_GouBotPoint.x = 0.5*(pCross.Y_RightJSGouPart->m_JSGouPoints[1].x + pCross.Y_RightJSGouPart->m_JSGouPoints[2].x);
		pCross.Y_RightJSGouPart->m_GouBotPoint.y = pCross.Y_RightJSGouPart->m_JSGouPoints[1].y;
		pCross.Y_RightJSGouPart->m_OriGouBotPt = pCross.Y_RightJSGouPart->m_GouBotPoint;

	}

	//画天沟的浆切 
	if (road[0].hdmdes[k].Y_LGouProperty == 2 && road[0].hdmdes[k].Y_LJSGouPtNum > 0)
	{
		TGhasJQ(-1, pCross.Y_LeftJSGouPart->m_JSGouPoints, pCross.Y_LeftJSGouPart->TG_JQHD,
			pCross.Y_LeftJSGouPart->SP1, pCross.Y_LeftJSGouPart->SP2, pCross.Y_LeftJSGouPart->GS, pCross.Y_LeftJSGouPart->TG_GDR,
			pCross.Y_LeftJSGouPart->JqPtNum, pCross.Y_LeftJSGouPart->JqPt,
			pCross.LeftEarthLinePart->m_EarthPointNum, pCross.LeftEarthLinePart->m_EarthPoints);

	}
	if (road[0].hdmdes[k].Y_RGouProperty == 2 && road[0].hdmdes[k].Y_RJSGouPtNum > 0)
	{
		TGhasJQ(1, pCross.Y_RightJSGouPart->m_JSGouPoints, pCross.Y_RightJSGouPart->TG_JQHD,
			pCross.Y_RightJSGouPart->SP1, pCross.Y_RightJSGouPart->SP2, pCross.Y_RightJSGouPart->GS, pCross.Y_RightJSGouPart->TG_GDR,
			pCross.Y_RightJSGouPart->JqPtNum, pCross.Y_RightJSGouPart->JqPt,
			pCross.RightEarthLinePart->m_EarthPointNum, pCross.RightEarthLinePart->m_EarthPoints);

	}
	//画路堑的侧沟浆切

	double D;
	if (pCross.Y_LeftDesignLinePart->m_DesignPointNum > 0 && (fabs(pCross.Y_LeftDesignLinePart->m_FillORCut - 1.0) < 0.001 || fabs(pCross.Y_LeftDesignLinePart->m_FillORCut - 3.0) < 0.001))
	{

		if (pCross.xjj < 0.0001)//右线为主线
			Cal_D(road[0].hdmdes[k].cml, road[0].pm, road[0].hdmbz.NZLQSG, road[0].hdmbz.ZLQSG,
				&D, &pCross.Y_LeftDesignLinePart->GK,
				&pCross.Y_LeftDesignLinePart->GS, &pCross.Y_LeftDesignLinePart->GP1,
				&pCross.Y_LeftDesignLinePart->GP2, &pCross.Y_LeftDesignLinePart->CG_JQHD, &pCross.Y_LeftDesignLinePart->CG_GDR);
		else
		{
			int ifld;
			ifld = GetIRoadByName(road[0].hdmdes[k].FLDname);
			Cal_D(road[0].hdmdes[k].FLDcml, road[ifld].pm, road[ifld].hdmbz.NZLQSG, road[ifld].hdmbz.ZLQSG,
				&D, &pCross.Y_LeftDesignLinePart->GK,
				&pCross.Y_LeftDesignLinePart->GS, &pCross.Y_LeftDesignLinePart->GP1,
				&pCross.Y_LeftDesignLinePart->GP2, &pCross.Y_LeftDesignLinePart->CG_JQHD, &pCross.Y_LeftDesignLinePart->CG_GDR);
		}

		if (pCross.Y_LeftDesignLinePart->m_DesignPointNum > 7)//增加该判断条件，否则CGhasJQ()出现数组越界。李伟 2008-03-09
		{
			// 			   CGhasJQ(-1,pCross.Y_LeftDesignLinePart->m_DesignPoints,pCross.Y_LeftDesignLinePart->CG_JQHD,
			// 				   pCross.Y_LeftDesignLinePart->GP1,pCross.Y_LeftDesignLinePart->GP2,pCross.Y_LeftDesignLinePart->GS,
			// 				   pCross.Y_LeftDesignLinePart->JqPtNum,pCross.Y_LeftDesignLinePart->JqPt);
			CGhasJQ(-1, pCross.Y_LeftDesignLinePart->m_DesignPoints, pCross.Y_LeftDesignLinePart->CG_JQHD, pCross.Y_LeftDesignLinePart->CG_GDR,
				pCross.Y_LeftDesignLinePart->JqPtNum, pCross.Y_LeftDesignLinePart->JqPt);
		}

	}

	if (pCross.Y_RightDesignLinePart->m_DesignPointNum > 0 && (fabs(pCross.Y_RightDesignLinePart->m_FillORCut - 1.0) < 0.001 || fabs(pCross.Y_RightDesignLinePart->m_FillORCut - 3.0) < 0.001))
	{

		if (pCross.xjj < 0.0001)//右线为主线
			Cal_D(road[0].hdmdes[k].cml, road[0].pm, road[0].hdmbz.NYLQSG, road[0].hdmbz.YLQSG,
				&D, &pCross.Y_RightDesignLinePart->GK,
				&pCross.Y_RightDesignLinePart->GS, &pCross.Y_RightDesignLinePart->GP1,
				&pCross.Y_RightDesignLinePart->GP2, &pCross.Y_RightDesignLinePart->CG_JQHD, &pCross.Y_RightDesignLinePart->CG_GDR);
		else
		{
			int ifld;
			ifld = GetIRoadByName(road[0].hdmdes[k].FLDname);
			Cal_D(road[0].hdmdes[k].FLDcml, road[ifld].pm, road[ifld].hdmbz.NYLQSG, road[ifld].hdmbz.YLQSG,
				&D, &pCross.Y_RightDesignLinePart->GK,
				&pCross.Y_RightDesignLinePart->GS, &pCross.Y_RightDesignLinePart->GP1,
				&pCross.Y_RightDesignLinePart->GP2, &pCross.Y_RightDesignLinePart->CG_JQHD, &pCross.Y_RightDesignLinePart->CG_GDR);
		}

		if (pCross.Y_RightDesignLinePart->m_DesignPointNum > 7)//增加该判断条件，否则CGhasJQ()出现数组越界。李伟 2008-03-09
		{
			// 			   CGhasJQ(1,pCross.Y_RightDesignLinePart->m_DesignPoints,pCross.Y_RightDesignLinePart->CG_JQHD,
			// 				   pCross.Y_RightDesignLinePart->GP1,pCross.Y_RightDesignLinePart->GP2,pCross.Y_RightDesignLinePart->GS,
			// 				   pCross.Y_RightDesignLinePart->JqPtNum,pCross.Y_RightDesignLinePart->JqPt);
			CGhasJQ(1, pCross.Y_RightDesignLinePart->m_DesignPoints, pCross.Y_RightDesignLinePart->CG_JQHD, pCross.Y_RightDesignLinePart->CG_GDR,
				pCross.Y_RightDesignLinePart->JqPtNum, pCross.Y_RightDesignLinePart->JqPt);
		}

	}
	//画水沟浆切

	if (road[0].hdmdes[k].Y_LGouProperty == 1 && road[0].hdmdes[k].Y_LGouPtNum > 0)
		// 		   SGhasJQ(-1,pCross.Y_LeftLTGouPart->m_LTGouPointNum,pCross.Y_LeftLTGouPart->m_LTGouPoints,pCross.Y_LeftLTGouPart->PSG_JQHD,
			// 		   pCross.Y_LeftLTGouPart->m_SP1,pCross.Y_LeftLTGouPart->m_SP2,pCross.Y_LeftLTGouPart->m_GH,pCross.Y_LeftLTGouPart->m_PSG_GDR,
				// 		   pCross.Y_LeftLTGouPart->JqPtNum,pCross.Y_LeftLTGouPart->JqPt);
		SGhasJQ(-1, pCross.Y_LeftLTGouPart->m_LTGouPointNum, pCross.Y_LeftLTGouPart->m_LTGouPoints, pCross.Y_LeftLTGouPart->PSG_JQHD,
			pCross.Y_LeftLTGouPart->JqPtNum, pCross.Y_LeftLTGouPart->JqPt);
	if (road[0].hdmdes[k].Y_RGouProperty == 1 && road[0].hdmdes[k].Y_RGouPtNum > 0)
		// 		   SGhasJQ(1,pCross.Y_RightLTGouPart->m_LTGouPointNum,pCross.Y_RightLTGouPart->m_LTGouPoints,pCross.Y_RightLTGouPart->PSG_JQHD,
			// 		   pCross.Y_RightLTGouPart->m_SP1,pCross.Y_RightLTGouPart->m_SP2,pCross.Y_RightLTGouPart->m_GH,pCross.Y_RightLTGouPart->m_PSG_GDR,
				// 		   pCross.Y_RightLTGouPart->JqPtNum,pCross.Y_RightLTGouPart->JqPt);
		SGhasJQ(1, pCross.Y_RightLTGouPart->m_LTGouPointNum, pCross.Y_RightLTGouPart->m_LTGouPoints, pCross.Y_RightLTGouPart->PSG_JQHD,
			pCross.Y_RightLTGouPart->JqPtNum, pCross.Y_RightLTGouPart->JqPt);

	SetDZoomCorner(pCross, 0, k);//设置双路面的Zoom角


	return Adesk::kTrue;
}

Adesk::Boolean HdmDes::setCROSSAutoDesignData(CROSS &pCross, int iroad, int k, double Earh, double newLearpt[], int newNumL, double newRearpt[], int newNumR, double newLBenchpt[], int newBenchNumL, double newRBenchpt[], int newBenchNumR)
{
	double  xx, y;
	int i, j, m;
	int gounum, jsgnum, pjqptnum;
	double PjqPt[14];
	//int RQqPtNum;
	//double LJqPt[20];

	pCross.OffsetByXLZX = road[iroad].hdmdes[k].OffsetByXLZX;
	_tcscpy(pCross.m_ckml, road[iroad].hdmdes[k].ckml);
	_tcscpy(pCross.m_FLDckml, pCross.m_ckml);
	if (road[iroad].hdmdes[k].DorS == 2)
	{
		int irxd = GetIRoadByName(road[iroad].hdmdes[k].FLDname);
		_tcscpy(pCross.m_FLDckml, road[irxd].pm->XLC(road[iroad].hdmdes[k].FLDcml));
	}
	pCross.m_cml = road[iroad].hdmdes[k].cml;
	pCross.m_ZTWH = road[iroad].hdmdes[k].ZHc;
	pCross.m_YTWH = road[iroad].hdmdes[k].YHc;
	pCross.IfSetDQ = road[iroad].hdmdes[k].IfSetDQ;

	pCross.m_FillArea = road[iroad].hdmdes[k].at;
	pCross.m_CutArea = road[iroad].hdmdes[k].aw;
	//pCross.m_BTinf = road[iroad].hdmdes[k].BTinf;	

	pCross.xjj = road[iroad].hdmdes[k].xjj;// - road[iroad].hdmdes[k].Zxjj;	
	pCross.DX = road[iroad].hdmdes[k].DX;//出图需要

	//pCross.zxjj = road[iroad].hdmdes[k].Zxjj;	
	//pCross.offset=road[iroad].hdmdes[k].offsetX;

	//CalNewDMGC(k,road[iroad].hdmdes[k].Zxjj,road[iroad].hdmdes[k].EarH,Earh);//一线坐标平移一个左线间距后的地面高层
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//设计点
	pCross.LeftDesignLinePart = new DesignLine_ROAD;
	pCross.RightDesignLinePart = new DesignLine_ROAD;

	pCross.LeftDesignLinePart->m_ZorY = -1;
	pCross.RightDesignLinePart->m_ZorY = 1;
	pCross.LeftDesignLinePart->LnewYd = Earh;
	pCross.RightDesignLinePart->LnewYd = Earh;
	_tcscpy(pCross.LeftDesignLinePart->RoadName, road[iroad].roadname);
	_tcscpy(pCross.RightDesignLinePart->RoadName, road[iroad].roadname);
	pCross.RightDesignLinePart->hdmno = k;
	pCross.LeftDesignLinePart->hdmno = k;

	FindWichArcBp(pCross.m_cml, road[iroad].pm, road[iroad].hdmbz.NZARCBP, road[iroad].hdmbz.ZARCBP, pCross.LeftDesignLinePart->m_ArcBpR);
	FindWichArcBp(pCross.m_cml, road[iroad].pm, road[iroad].hdmbz.NYARCBP, road[iroad].hdmbz.YARCBP, pCross.RightDesignLinePart->m_ArcBpR);
	pCross.LeftDesignLinePart->m_sfactor = Sfactor;
	pCross.RightDesignLinePart->m_sfactor = Sfactor;

	//
	//		pCross.LeftDesignLinePart->m_nLTBPJS=FindWichBP(pCross.m_cml,road[iroad].pm,road[iroad].hdmbz.NZLDBP,road[iroad].hdmbz.ZLDBP,pCross.LeftDesignLinePart->m_TM,pCross.LeftDesignLinePart->m_TH,pCross.LeftDesignLinePart->m_TPTW,pCross.LeftDesignLinePart->m_TPTI);//左路堤边坡
	//		pCross.RightDesignLinePart->m_nLTBPJS= FindWichBP(pCross.m_cml,road[iroad].pm,road[iroad].hdmbz.NYLDBP,road[iroad].hdmbz.YLDBP,pCross.RightDesignLinePart->m_TM,pCross.RightDesignLinePart->m_TH,pCross.RightDesignLinePart->m_TPTW,pCross.RightDesignLinePart->m_TPTI);//路堤边坡
	//		pCross.LeftDesignLinePart->m_nLZBPJS= FindWichBP(pCross.m_cml,road[iroad].pm,road[iroad].hdmbz.NZLQBP,road[iroad].hdmbz.ZLQBP,pCross.LeftDesignLinePart->m_WM,pCross.LeftDesignLinePart->m_PH,pCross.LeftDesignLinePart->m_ZPTW,pCross.LeftDesignLinePart->m_ZPTI);//路堤边坡
	//		pCross.RightDesignLinePart->m_nLZBPJS= FindWichBP(pCross.m_cml,road[iroad].pm,road[iroad].hdmbz.NYLQBP,road[iroad].hdmbz.YLQBP,pCross.RightDesignLinePart->m_WM,pCross.RightDesignLinePart->m_PH,pCross.RightDesignLinePart->m_ZPTW,pCross.RightDesignLinePart->m_ZPTI);//路堤边坡
	//	   	   
	//		FindIljjk(pCross.m_cml,road[iroad].pm,road[iroad].hdmbz.NZPWD,road[iroad].hdmbz.ZPWD, pCross.LeftDesignLinePart->m_WW[0], pCross.LeftDesignLinePart->m_WW[1]);
	//		FindIljjk(pCross.m_cml,road[iroad].pm,road[iroad].hdmbz.NYPWD,road[iroad].hdmbz.YPWD,pCross.RightDesignLinePart->m_WW[0], pCross.RightDesignLinePart->m_WW[1]);
	//		pCross.LeftDesignLinePart->m_XW  = FindIljxk(pCross.m_cml,road[iroad].pm,road[iroad].hdmbz.NZDM,road[iroad].hdmbz.ZDM);
	//		pCross.RightDesignLinePart->m_XW = FindIljxk(pCross.m_cml,road[iroad].pm,road[iroad].hdmbz.NYDM,road[iroad].hdmbz.YDM);


	//		if(road[iroad].hdmdes[k].xjj<-0.00001)//左线分离(应从分离线取值)
	//		{
	//		}

	pCross.LeftDesignLinePart->m_DesignPointNum = road[iroad].hdmdes[k].Lnpt;

	if (pCross.LeftDesignLinePart->m_DesignPoints) { delete pCross.LeftDesignLinePart->m_DesignPoints, pCross.LeftDesignLinePart->m_DesignPoints = NULL; }
	if (road[iroad].hdmdes[k].Lnpt > 0)
		pCross.LeftDesignLinePart->m_DesignPoints = new AcGePoint3d[pCross.LeftDesignLinePart->m_DesignPointNum];
	pCross.RightDesignLinePart->m_DesignPointNum = road[iroad].hdmdes[k].Rnpt;
	if (pCross.RightDesignLinePart->m_DesignPoints) { delete pCross.RightDesignLinePart->m_DesignPoints, pCross.RightDesignLinePart->m_DesignPoints = NULL; }
	if (road[iroad].hdmdes[k].Rnpt > 0)
		pCross.RightDesignLinePart->m_DesignPoints = new AcGePoint3d[pCross.RightDesignLinePart->m_DesignPointNum];
	for (i = 0; i < 10; i++)
	{
		pCross.LeftDesignLinePart->RHF[i] = road[iroad].hdmdes[k].RHFL[i];
		pCross.RightDesignLinePart->RHF[i] = road[iroad].hdmdes[k].RHFR[i];
	}

	pCross.LeftDesignLinePart->m_Xcdh = road[iroad].hdmdes[k].zlmhd[0];
	pCross.LeftDesignLinePart->m_Yljh = road[iroad].hdmdes[k].zlmhd[1];
	pCross.LeftDesignLinePart->m_Tljh = road[iroad].hdmdes[k].zlmhd[2];
	pCross.RightDesignLinePart->m_Xcdh = road[iroad].hdmdes[k].ylmhd[0];
	pCross.RightDesignLinePart->m_Yljh = road[iroad].hdmdes[k].ylmhd[1];
	pCross.RightDesignLinePart->m_Tljh = road[iroad].hdmdes[k].ylmhd[2];

	//////////////////////////////////////////////////////////////////////////
	pCross.LeftDesignLinePart->m_GouPropty = road[iroad].hdmdes[k].LGouProperty;
	pCross.RightDesignLinePart->m_GouPropty = road[iroad].hdmdes[k].RGouProperty;
	//////////////////////////////////////////////////////////////////////////
	/*
	if(fabs(road[iroad].hdmdes[k].cml-4800)<0.1)
	for(int m=0;m<4;m++)
	ads_printf(L"\ncml=%lf,yd=%lf,rhf=%lf,rhf=%lf",pCross.LeftDesignLinePart->cml,pCross.LeftDesignLinePart->LnewYd,pCross.LeftDesignLinePart->RHF[m*2],pCross.LeftDesignLinePart->RHF[m*2+1]); */

	if (fabs(pCross.LeftDesignLinePart->RHF[4]) > fabs(pCross.LeftDesignLinePart->RHF[2]))
		pCross.LeftDesignLinePart->LMHP[0] = (pCross.LeftDesignLinePart->RHF[5] - pCross.LeftDesignLinePart->RHF[3]) / (pCross.LeftDesignLinePart->RHF[4] - pCross.LeftDesignLinePart->RHF[2]);
	else
		pCross.LeftDesignLinePart->LMHP[0] = 0.0;

	if (fabs(pCross.LeftDesignLinePart->RHF[6]) > fabs(pCross.LeftDesignLinePart->RHF[4]))
		pCross.LeftDesignLinePart->LMHP[1] = (pCross.LeftDesignLinePart->RHF[7] - pCross.LeftDesignLinePart->RHF[5]) / (pCross.LeftDesignLinePart->RHF[6] - pCross.LeftDesignLinePart->RHF[4]);
	else
		pCross.LeftDesignLinePart->LMHP[1] = 0.0;

	if (fabs(pCross.LeftDesignLinePart->RHF[8]) > fabs(pCross.LeftDesignLinePart->RHF[6]))
		pCross.LeftDesignLinePart->LMHP[2] = (pCross.LeftDesignLinePart->RHF[9] - pCross.LeftDesignLinePart->RHF[7]) / (pCross.LeftDesignLinePart->RHF[8] - pCross.LeftDesignLinePart->RHF[6]);
	else
		pCross.LeftDesignLinePart->LMHP[2] = 0.0;

	if (pCross.RightDesignLinePart->RHF[4] > pCross.RightDesignLinePart->RHF[2])
		pCross.RightDesignLinePart->LMHP[0] = (pCross.RightDesignLinePart->RHF[5] - pCross.RightDesignLinePart->RHF[3]) / (pCross.RightDesignLinePart->RHF[4] - pCross.RightDesignLinePart->RHF[2]);
	else
		pCross.RightDesignLinePart->LMHP[0] = 0.0;

	if (pCross.RightDesignLinePart->RHF[6] > pCross.RightDesignLinePart->RHF[4])
		pCross.RightDesignLinePart->LMHP[1] = (pCross.RightDesignLinePart->RHF[7] - pCross.RightDesignLinePart->RHF[5]) / (pCross.RightDesignLinePart->RHF[6] - pCross.RightDesignLinePart->RHF[4]);
	else
		pCross.RightDesignLinePart->LMHP[1] = 0.0;

	if (pCross.RightDesignLinePart->RHF[8] > pCross.RightDesignLinePart->RHF[6])
		pCross.RightDesignLinePart->LMHP[2] = (pCross.RightDesignLinePart->RHF[9] - pCross.RightDesignLinePart->RHF[7]) / (pCross.RightDesignLinePart->RHF[8] - pCross.RightDesignLinePart->RHF[6]);
	else
		pCross.RightDesignLinePart->LMHP[2] = 0.0;


	pCross.LeftDesignLinePart->CG_GDR = road[iroad].hdmdes[k].ZCG_GDR;//沟底半径

	pCross.LeftDesignLinePart->m_FillORCut = road[iroad].hdmdes[k].Zt;
	//		pCross.LeftDesignLinePart->DorS = road[iroad].hdmdes[k].DorS;
	pCross.LeftDesignLinePart->BTinf = road[iroad].hdmdes[k].ZDMXZ;
	//		pCross.LeftDesignLinePart->ZYBTinf = road[iroad].hdmdes[k].YDMXZ;

	//		pCross.LeftDesignLinePart->xlxz = road[iroad].hdmdes[k].xlxz;
	//		pCross.LeftDesignLinePart->r_bh = road[iroad].hdmdes[k].r_bh;
	pCross.LeftDesignLinePart->cml = road[iroad].hdmdes[k].cml;

	for (i = 0; i < pCross.LeftDesignLinePart->m_DesignPointNum; i++)
	{
		xx = road[iroad].hdmdes[k].RPTL[i].x;
		y = road[iroad].hdmdes[k].RPTL[i].y + Earh - road[iroad].hdmdes[k].Ymin;
		pCross.LeftDesignLinePart->m_DesignPoints[i].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.LeftDesignLinePart->m_DesignPoints[i].y = pCross.m_OriPoint.y + y * Sfactor;
	}

	if (road[iroad].hdmdes[k].Lnpt > 0)
	{
		pCross.LeftDesignLinePart->BPLen = fabs(road[iroad].hdmdes[k].RPTL[road[iroad].hdmdes[k].Lnpt - 1].x);
		pCross.LeftDesignLinePart->BPH = road[iroad].hdmdes[k].RPTL[road[iroad].hdmdes[k].Lnpt - 1].y - road[iroad].hdmdes[k].RPTL[0].y;
	}


	//右侧
	pCross.RightDesignLinePart->m_FillORCut = road[iroad].hdmdes[k].Yt;
	pCross.RightDesignLinePart->BTinf = road[iroad].hdmdes[k].YDMXZ;
	//	pCross.RightDesignLinePart->Y_BTinf = road[iroad].hdmdes[k].YDMXZ;
	//    pCross.RightDesignLinePart->xlxz = road[iroad].hdmdes[k].xlxz;
	//	pCross.RightDesignLinePart->r_bh = road[iroad].hdmdes[k].r_bh; 
	pCross.RightDesignLinePart->cml = road[iroad].hdmdes[k].cml;
	for (i = 0; i < pCross.RightDesignLinePart->m_DesignPointNum; i++)
	{
		xx = road[iroad].hdmdes[k].RPTR[i].x;
		y = road[iroad].hdmdes[k].RPTR[i].y + Earh - road[iroad].hdmdes[k].Ymin;
		pCross.RightDesignLinePart->m_DesignPoints[i].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.RightDesignLinePart->m_DesignPoints[i].y = pCross.m_OriPoint.y + y * Sfactor;
	}
	/*
	if(road[iroad].hdmdes[k].Rnpt>0)
	{
	pCross.RightDesignLinePart->m_DesignPoints[0].x = pCross.m_OriPoint.x;
	pCross.RightDesignLinePart->m_DesignPoints[0].y = pCross.RightDesignLinePart->m_DesignPoints[1].y;
	}*/


	if (road[iroad].hdmdes[k].Rnpt > 0)
	{
		pCross.RightDesignLinePart->BPLen = fabs(road[iroad].hdmdes[k].RPTR[road[iroad].hdmdes[k].Rnpt - 1].x);
		pCross.RightDesignLinePart->BPH = road[iroad].hdmdes[k].RPTR[road[iroad].hdmdes[k].Rnpt - 1].y - road[iroad].hdmdes[k].RPTR[0].y;
	}


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
	//画带有浆切的侧沟
	pCross.LeftLTGouPart = new LTGOU_ROAD;
	pCross.LeftLTGouPart->m_cml = pCross.m_cml;
	pCross.LeftLTGouPart->m_IfSetBotH = road[iroad].hdmdes[k].LIfSetGouH;

	int goupro;
	//	if(pCross.xjj>-0.0001)//左线为主线
	//	{
	goupro = pCross.LeftLTGouPart->GouProperty;
	FindSG(pCross.m_cml, road[iroad].pm, road[iroad].hdmbz.NZLDSG, road[iroad].hdmbz.ZLDSG,
		goupro, pCross.LeftLTGouPart->PSG_JQHD,
		pCross.LeftLTGouPart->m_T2W, pCross.LeftLTGouPart->m_T1W,
		pCross.LeftLTGouPart->m_T2H, pCross.LeftLTGouPart->m_GH,
		pCross.LeftLTGouPart->m_GW, pCross.LeftLTGouPart->m_HH,
		pCross.LeftLTGouPart->m_SP1, pCross.LeftLTGouPart->m_SP2, pCross.LeftLTGouPart->m_SP3, pCross.LeftLTGouPart->m_PSG_GDR);//加浆砌厚度
	//	}

	/*

	else//左线为分离线
	{
	int ifld;
	ifld = GetIRoadByName(road[iroad].hdmdes[k].FLDname);
	FindSG(road[iroad].hdmdes[k].FLDcml,road[ifld].pm,road[ifld].hdmbz.NZLDSG,road[ifld].hdmbz.ZLDSG,
	goupro,pCross.LeftLTGouPart->PSG_JQHD,
	pCross.LeftLTGouPart->m_T2W,pCross.LeftLTGouPart->m_T1W,
	pCross.LeftLTGouPart->m_T2H,pCross.LeftLTGouPart->m_GH,
	pCross.LeftLTGouPart->m_GW,pCross.LeftLTGouPart->m_HH,
	pCross.LeftLTGouPart->m_SP1,pCross.LeftLTGouPart->m_SP2,pCross.LeftLTGouPart->m_SP3);//加浆砌厚度
	pCross.LeftLTGouPart->GouProperty = goupro;
	}
	*/
	pCross.LeftLTGouPart->m_ZorY = -1;

	pCross.LeftLTGouPart->m_LTGouPointNum = 0;

	pCross.LeftJSGouPart = new JSGOU_ROAD;
	_tcscpy(pCross.LeftJSGouPart->m_ckml, pCross.m_ckml);
	//	if(pCross.xjj>-0.0001)//左线为主线
	FindTG(pCross.m_cml, road[iroad].pm, road[iroad].hdmbz.NZTG, road[iroad].hdmbz.ZTG, pCross.LeftJSGouPart->BJ, pCross.LeftJSGouPart->GW,
		pCross.LeftJSGouPart->GS, pCross.LeftJSGouPart->SP1,
		pCross.LeftJSGouPart->SP2, pCross.LeftJSGouPart->TG_JQHD, pCross.LeftJSGouPart->TG_GDR);
	/*
	else
	{
	int ifld;
	ifld = GetIRoadByName(road[iroad].hdmdes[k].FLDname);
	FindTG(road[iroad].hdmdes[k].FLDcml,road[ifld].pm,road[ifld].hdmbz.NZTG,road[ifld].hdmbz.ZTG,
	pCross.LeftJSGouPart->BJ,pCross.LeftJSGouPart->GW,
	pCross.LeftJSGouPart->GS,pCross.LeftJSGouPart->SP1,
	pCross.LeftJSGouPart->SP2,pCross.LeftJSGouPart->TG_JQHD);
	}*/

	//	
	pCross.LeftJSGouPart->m_ZorY = -1;
	pCross.LeftJSGouPart->JSGouPtNum = 0;
	pCross.LeftLTGouPart->GouProperty = road[iroad].hdmdes[k].LGouProperty;

	if (pCross.LeftDesignLinePart->m_DesignPointNum > 0)
		pCross.LeftLTGouPart->m_PJDpt = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1];

	if ((road[iroad].hdmdes[k].LGouProperty == 1 || road[iroad].hdmdes[k].LGouProperty == 3) && road[iroad].hdmdes[k].LGouPtNum > 0)	//20200430新增LGouProperty==3情况
	{
		gounum = 0;
		for (i = 0; i < road[iroad].hdmdes[k].LGouPtNum; i++)
		{
			xx = road[iroad].hdmdes[k].Lgou[i * 2];
			if (fabs(xx) > 0.0001)
			{
				y = road[iroad].hdmdes[k].Lgou[i * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
				pCross.LeftLTGouPart->m_LTGouPoints[gounum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.LeftLTGouPart->m_LTGouPoints[gounum].y = pCross.m_OriPoint.y + y * Sfactor;//+ pCross.m_TWH;
				gounum++;
			}
		}

		//*************start	20200430	针对修改过的路堤沟做修改**********************
		if (road[iroad].hdmdes[k].LGouProperty == 3 && road[iroad].hdmdes[k].LGouPtNum >= 9)
		{
			//road[iroad].hdmdes[k].LGouPtNum -= 9;
			pCross.LeftLTGouPart->JqPtNum = 9;
			gounum -= 9;

			for (int JQIndex = 0; JQIndex < pCross.LeftLTGouPart->JqPtNum; JQIndex++)
			{
				int GutterIndex = JQIndex + (road[iroad].hdmdes[k].LGouPtNum - pCross.LeftLTGouPart->JqPtNum);
				pCross.LeftLTGouPart->JqPt[JQIndex].x = pCross.LeftLTGouPart->m_LTGouPoints[GutterIndex].x;
				pCross.LeftLTGouPart->JqPt[JQIndex].y = pCross.LeftLTGouPart->m_LTGouPoints[GutterIndex].y;
			}
		}
		//*************end	20200430	针对修改过的路堤沟做修改**********************
			

		pCross.LeftLTGouPart->m_LTGouPointNum = gounum;
		if (gounum >= 5 && gounum < 15)
		{
			if (gounum == 6)
				pCross.LeftLTGouPart->m_GouBotH = road[iroad].hdmdes[k].Lgou[2 * 2 + 1] + Earh;
			else
				pCross.LeftLTGouPart->m_GouBotH = road[iroad].hdmdes[k].Lgou[2 * 2 + 1] + Earh + pCross.LeftLTGouPart->PSG_JQHD;
			pCross.LeftLTGouPart->m_GouBotX = 0.5*(road[iroad].hdmdes[k].Lgou[3 * 2] + road[iroad].hdmdes[k].Lgou[2 * 2]);
			pCross.LeftLTGouPart->m_GouBotPoint.x = 0.5*(pCross.LeftLTGouPart->m_LTGouPoints[3].x + pCross.LeftLTGouPart->m_LTGouPoints[2].x);
			pCross.LeftLTGouPart->m_GouBotPoint.y = pCross.LeftLTGouPart->m_LTGouPoints[3].y;
			pCross.LeftLTGouPart->m_OriGouBotPt = pCross.LeftLTGouPart->m_GouBotPoint;
		}
		if (gounum >= 15)
		{
			if (gounum == 16)
				pCross.LeftLTGouPart->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].Lgou[7 * 2 + 1] + road[iroad].hdmdes[k].Lgou[8 * 2 + 1]) + Earh;
			else
				pCross.LeftLTGouPart->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].Lgou[7 * 2 + 1] + road[iroad].hdmdes[k].Lgou[8 * 2 + 1]) + Earh + pCross.LeftLTGouPart->PSG_JQHD;
			pCross.LeftLTGouPart->m_GouBotX = 0.5 * (road[iroad].hdmdes[k].Lgou[7 * 2] + road[iroad].hdmdes[k].Lgou[8 * 2]);
			pCross.LeftLTGouPart->m_GouBotPoint.x = 0.5*(pCross.LeftLTGouPart->m_LTGouPoints[7].x + pCross.LeftLTGouPart->m_LTGouPoints[8].x);
			pCross.LeftLTGouPart->m_GouBotPoint.y = 0.5 * (pCross.LeftLTGouPart->m_LTGouPoints[7].y + pCross.LeftLTGouPart->m_LTGouPoints[8].y);
			pCross.LeftLTGouPart->m_OriGouBotPt = pCross.LeftLTGouPart->m_GouBotPoint;
		}
	}
	else if (road[iroad].hdmdes[k].LGouProperty == 0 && pCross.LeftDesignLinePart->m_DesignPointNum > 0)
	{

		AcGePoint3d JD, preJD;
		JD.x = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].x;
		JD.y = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
		preJD.x = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 2].x;
		preJD.y = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 2].y;
		CalPjqPt(-1, JD, preJD, pjqptnum, PjqPt);
		pCross.LeftLTGouPart->pjqptnum = pjqptnum;
		for (m = 0; m < pjqptnum; m++)
		{
			pCross.LeftLTGouPart->PjqPt[m].x = PjqPt[2 * m];
			pCross.LeftLTGouPart->PjqPt[m].y = PjqPt[2 * m + 1];
		}

	}
	else if ((road[iroad].hdmdes[k].LGouProperty == 2 || road[iroad].hdmdes[k].LGouProperty == 4) && road[iroad].hdmdes[k].LJSGouPtNum > 0)//设置天沟
	{
		jsgnum = 0;
		for (i = 0; i < road[iroad].hdmdes[k].LJSGouPtNum; i++)
		{
			xx = road[iroad].hdmdes[k].LJSgou[i * 2];
			if (fabs(xx) > 0.0001)
			{
				y = road[iroad].hdmdes[k].LJSgou[i * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
				pCross.LeftJSGouPart->m_JSGouPoints[jsgnum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.LeftJSGouPart->m_JSGouPoints[jsgnum].y = pCross.m_OriPoint.y + y * Sfactor;
				jsgnum++;
			}
		}
		pCross.LeftJSGouPart->JSGouPtNum = jsgnum;

		//*************start	20200430	针对修改过的天沟做修改**********************
		if (road[iroad].hdmdes[k].LGouProperty == 4)
		{
			pCross.LeftJSGouPart->JqPtNum = road[iroad].hdmdes[k].LJSGouPtNum;

			for (int JQIndex = 0; JQIndex < pCross.LeftJSGouPart->JqPtNum; JQIndex++)
			{
				pCross.LeftJSGouPart->JqPt[JQIndex].x = pCross.LeftJSGouPart->m_JSGouPoints[JQIndex].x;
				pCross.LeftJSGouPart->JqPt[JQIndex].y = pCross.LeftJSGouPart->m_JSGouPoints[JQIndex].y;
			}
		}
		//*************end	20200430	针对修改过的天沟做修改**********************

		if (jsgnum >= 4 && pCross.LeftJSGouPart->TG_GDR < 0.001)
		{
			pCross.LeftJSGouPart->m_GouBotH = road[iroad].hdmdes[k].LJSgou[1 * 2 + 1] + Earh;//沟底中心地面高程
			pCross.LeftJSGouPart->m_GouBotX = 0.5*(road[iroad].hdmdes[k].LJSgou[1 * 2] + road[iroad].hdmdes[k].LJSgou[2 * 2]);//沟底中心的小x坐标
			pCross.LeftJSGouPart->m_GouBotPoint.x = 0.5*(pCross.LeftJSGouPart->m_JSGouPoints[1].x + pCross.LeftJSGouPart->m_JSGouPoints[2].x);
			pCross.LeftJSGouPart->m_GouBotPoint.y = pCross.LeftJSGouPart->m_JSGouPoints[1].y;
			pCross.LeftJSGouPart->m_OriGouBotPt = pCross.LeftJSGouPart->m_GouBotPoint;
		}
		if (jsgnum >= 14 && pCross.LeftJSGouPart->TG_GDR > 0.001)
		{
			pCross.LeftJSGouPart->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].LJSgou[6 * 2 + 1] + road[iroad].hdmdes[k].LJSgou[7 * 2 + 1]) + Earh;//沟底中心地面高程
			pCross.LeftJSGouPart->m_GouBotX = 0.5 * (road[iroad].hdmdes[k].LJSgou[6 * 2] + road[iroad].hdmdes[k].LJSgou[7 * 2]);//沟底中心的小x坐标
			pCross.LeftJSGouPart->m_GouBotPoint.x = 0.5*(pCross.LeftJSGouPart->m_JSGouPoints[6].x + pCross.LeftJSGouPart->m_JSGouPoints[7].x);
			pCross.LeftJSGouPart->m_GouBotPoint.y = 0.5 * (pCross.LeftJSGouPart->m_JSGouPoints[6].y + pCross.LeftJSGouPart->m_JSGouPoints[7].y);
			pCross.LeftJSGouPart->m_OriGouBotPt = pCross.LeftJSGouPart->m_GouBotPoint;
		}

	}

	//   
	//右侧路堤水沟参数
	// pCross.RightLTGouPart = NULL;
	pCross.RightLTGouPart = new LTGOU_ROAD;
	pCross.RightLTGouPart->m_cml = pCross.m_cml;
	pCross.RightLTGouPart->m_IfSetBotH = road[iroad].hdmdes[k].RIfSetGouH;
	pCross.RightLTGouPart->m_ZorY = 1;
	pCross.RightDesignLinePart->CG_GDR = road[iroad].hdmdes[k].YCG_GDR;//沟底半径
	//	if(pCross.xjj>-0.0001)//左线为主线
	//	{
	FindSG(pCross.m_cml, road[iroad].pm, road[iroad].hdmbz.NYLDSG, road[iroad].hdmbz.YLDSG,
		goupro, pCross.RightLTGouPart->PSG_JQHD,
		pCross.RightLTGouPart->m_T2W, pCross.RightLTGouPart->m_T1W,
		pCross.RightLTGouPart->m_T2H, pCross.RightLTGouPart->m_GH,
		pCross.RightLTGouPart->m_GW, pCross.RightLTGouPart->m_HH,
		pCross.RightLTGouPart->m_SP1, pCross.RightLTGouPart->m_SP2, pCross.RightLTGouPart->m_SP3, pCross.RightLTGouPart->m_PSG_GDR);//加浆砌厚度
	pCross.RightLTGouPart->GouProperty = goupro;
	//	}
	/*
	else
	{
	int ifld;
	ifld = GetIRoadByName(road[iroad].hdmdes[k].FLDname);
	FindSG(road[iroad].hdmdes[k].FLDcml,road[ifld].pm,road[ifld].hdmbz.NZLDSG,road[ifld].hdmbz.ZLDSG,
	goupro,pCross.RightLTGouPart->PSG_JQHD,
	pCross.RightLTGouPart->m_T2W,pCross.RightLTGouPart->m_T1W,
	pCross.RightLTGouPart->m_T2H,pCross.RightLTGouPart->m_GH,
	pCross.RightLTGouPart->m_GW,pCross.RightLTGouPart->m_HH,
	pCross.RightLTGouPart->m_SP1,pCross.RightLTGouPart->m_SP2,pCross.RightLTGouPart->m_SP3);//加浆砌厚度
	pCross.RightLTGouPart->GouProperty = goupro;
	}

	*/

	pCross.RightJSGouPart = new JSGOU_ROAD;
	//if(pCross.xjj>-0.0001)//左线为主线
	FindTG(pCross.m_cml, road[iroad].pm, road[iroad].hdmbz.NYTG, road[iroad].hdmbz.YTG, pCross.RightJSGouPart->BJ, pCross.RightJSGouPart->GW,
		pCross.RightJSGouPart->GS, pCross.RightJSGouPart->SP1,
		pCross.RightJSGouPart->SP2, pCross.RightJSGouPart->TG_JQHD, pCross.RightJSGouPart->TG_GDR);
	/*
	else
	{
	int ifld;
	ifld = GetIRoadByName(road[iroad].hdmdes[k].FLDname);
	FindTG(road[iroad].hdmdes[k].FLDcml,road[ifld].pm,road[ifld].hdmbz.NYTG,road[ifld].hdmbz.YTG,pCross.RightJSGouPart->BJ,pCross.RightJSGouPart->GW,
	pCross.RightJSGouPart->GS,pCross.RightJSGouPart->SP1,
	pCross.RightJSGouPart->SP2,pCross.RightJSGouPart->TG_JQHD);
	}
	*/

	_tcscpy(pCross.RightJSGouPart->m_ckml, pCross.m_ckml);
	pCross.RightJSGouPart->m_ZorY = 1;
	pCross.RightJSGouPart->JSGouPtNum = 0;
	pCross.RightLTGouPart->GouProperty = road[iroad].hdmdes[k].RGouProperty;

	if (pCross.RightDesignLinePart->m_DesignPointNum > 0)
		pCross.RightLTGouPart->m_PJDpt = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1];


	if ((road[iroad].hdmdes[k].RGouProperty == 1 || road[iroad].hdmdes[k].RGouProperty == 3) && road[iroad].hdmdes[k].RGouPtNum > 0)//有路堤水沟		//20200430新增LGouProperty==3情况
	{
		gounum = 0;
		pCross.RightLTGouPart->m_LTGouPointNum = 0;
		for (i = 0; i < road[iroad].hdmdes[k].RGouPtNum; i++)
		{
			xx = road[iroad].hdmdes[k].Rgou[i * 2];
			if (xx > 0.0001)
			{
				y = road[iroad].hdmdes[k].Rgou[i * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
				pCross.RightLTGouPart->m_LTGouPoints[gounum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.RightLTGouPart->m_LTGouPoints[gounum].y = pCross.m_OriPoint.y + y * Sfactor;//+ pCross.m_TWH;
				gounum++;
			}
		}

		//*************start	20200430	针对修改过的路堤沟做修改**********************
		if (road[iroad].hdmdes[k].RGouProperty == 3 && road[iroad].hdmdes[k].RGouPtNum >= 9)
		{
			//road[iroad].hdmdes[k].RGouPtNum -= 9;
			pCross.RightLTGouPart->JqPtNum = 9;
			gounum -= 9;

			for (int JQIndex = 0; JQIndex < pCross.RightLTGouPart->JqPtNum; JQIndex++)
			{
				int GutterIndex = JQIndex + (road[iroad].hdmdes[k].RGouPtNum - pCross.RightLTGouPart->JqPtNum);
				pCross.RightLTGouPart->JqPt[JQIndex].x = pCross.RightLTGouPart->m_LTGouPoints[GutterIndex].x;
				pCross.RightLTGouPart->JqPt[JQIndex].y = pCross.RightLTGouPart->m_LTGouPoints[GutterIndex].y;
			}
		}
		//*************end	20200430	针对修改过的路堤沟做修改**********************

		pCross.RightLTGouPart->m_LTGouPointNum = gounum;
		if (gounum >= 5 && gounum < 15)
		{
			if (gounum == 6)
				pCross.RightLTGouPart->m_GouBotH = road[iroad].hdmdes[k].Rgou[2 * 2 + 1] + Earh;
			else
				pCross.RightLTGouPart->m_GouBotH = road[iroad].hdmdes[k].Rgou[2 * 2 + 1] + Earh + pCross.RightLTGouPart->PSG_JQHD;
			pCross.RightLTGouPart->m_GouBotX = 0.5*(road[iroad].hdmdes[k].Rgou[3 * 2] + road[iroad].hdmdes[k].Rgou[2 * 2]);
			pCross.RightLTGouPart->m_GouBotPoint.x = 0.5*(pCross.RightLTGouPart->m_LTGouPoints[3].x + pCross.RightLTGouPart->m_LTGouPoints[2].x);
			pCross.RightLTGouPart->m_GouBotPoint.y = pCross.RightLTGouPart->m_LTGouPoints[3].y;
			pCross.RightLTGouPart->m_OriGouBotPt = pCross.RightLTGouPart->m_GouBotPoint;
		}
		if (gounum >= 15)
		{
			if (gounum == 16)
				pCross.RightLTGouPart->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].Rgou[7 * 2 + 1] + road[iroad].hdmdes[k].Rgou[8 * 2 + 1]) + Earh;
			else
				pCross.RightLTGouPart->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].Rgou[7 * 2 + 1] + road[iroad].hdmdes[k].Rgou[8 * 2 + 1]) + Earh + pCross.RightLTGouPart->PSG_JQHD;
			pCross.RightLTGouPart->m_GouBotX = 0.5*(road[iroad].hdmdes[k].Rgou[7 * 2] + road[iroad].hdmdes[k].Rgou[8 * 2]);
			pCross.RightLTGouPart->m_GouBotPoint.x = 0.5*(pCross.RightLTGouPart->m_LTGouPoints[7].x + pCross.RightLTGouPart->m_LTGouPoints[8].x);
			pCross.RightLTGouPart->m_GouBotPoint.y = 0.5 * (pCross.RightLTGouPart->m_LTGouPoints[7].y + pCross.RightLTGouPart->m_LTGouPoints[8].y);
			pCross.RightLTGouPart->m_OriGouBotPt = pCross.RightLTGouPart->m_GouBotPoint;
		}

	}
	else if (road[iroad].hdmdes[k].RGouProperty == 0 && road[iroad].hdmdes[k].RJSGouPtNum > 0)
	{

		AcGePoint3d JD, preJD;
		JD.x = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].x;
		JD.y = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y;
		preJD.x = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 2].x;
		preJD.y = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 2].y;
		CalPjqPt(1, JD, preJD, pjqptnum, PjqPt);
		pCross.RightLTGouPart->pjqptnum = pjqptnum;
		for (m = 0; m < pjqptnum; m++)
		{
			pCross.RightLTGouPart->PjqPt[m].x = PjqPt[2 * m];
			pCross.RightLTGouPart->PjqPt[m].y = PjqPt[2 * m + 1];

		}

	}
	else if ((road[iroad].hdmdes[k].RGouProperty == 2 || road[iroad].hdmdes[k].RGouProperty == 4) && road[iroad].hdmdes[k].RJSGouPtNum > 0)//设置天沟
	{
		jsgnum = 0;
		for (i = 0; i < road[iroad].hdmdes[k].RJSGouPtNum; i++)
		{
			xx = road[iroad].hdmdes[k].RJSgou[i * 2];

			if (fabs(xx) > 0.0001)
			{
				y = road[iroad].hdmdes[k].RJSgou[i * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
				pCross.RightJSGouPart->m_JSGouPoints[jsgnum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.RightJSGouPart->m_JSGouPoints[jsgnum].y = pCross.m_OriPoint.y + y * Sfactor;
				jsgnum++;
			}
		}
		pCross.RightJSGouPart->JSGouPtNum = jsgnum;

		//*************start	20200430	针对修改过的天沟做修改**********************
		if (road[iroad].hdmdes[k].RGouProperty == 4)
		{
			pCross.RightJSGouPart->JqPtNum = road[iroad].hdmdes[k].RJSGouPtNum;

			for (int JQIndex = 0; JQIndex < pCross.RightJSGouPart->JqPtNum; JQIndex++)
			{
				pCross.RightJSGouPart->JqPt[JQIndex].x = pCross.RightJSGouPart->m_JSGouPoints[JQIndex].x;
				pCross.RightJSGouPart->JqPt[JQIndex].y = pCross.RightJSGouPart->m_JSGouPoints[JQIndex].y;
			}
		}
		//*************end	20200430	针对修改过的天沟做修改**********************

		if (jsgnum >= 4 && pCross.RightJSGouPart->TG_GDR < 0.001)
		{
			pCross.RightJSGouPart->m_GouBotH = road[iroad].hdmdes[k].RJSgou[2 * 1 + 1] + Earh;//沟底中心地面高程
			pCross.RightJSGouPart->m_GouBotX = 0.5*(road[iroad].hdmdes[k].RJSgou[2 * 2] + road[iroad].hdmdes[k].RJSgou[2 * 1]);//沟底中心的小x坐标
			pCross.RightJSGouPart->m_GouBotPoint.x = 0.5*(pCross.RightJSGouPart->m_JSGouPoints[1].x + pCross.RightJSGouPart->m_JSGouPoints[2].x);
			pCross.RightJSGouPart->m_GouBotPoint.y = pCross.RightJSGouPart->m_JSGouPoints[1].y;
			pCross.RightJSGouPart->m_OriGouBotPt = pCross.RightJSGouPart->m_GouBotPoint;
		}
		if (jsgnum >= 14 && pCross.RightJSGouPart->TG_GDR > 0.001)
		{
			pCross.RightJSGouPart->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].RJSgou[2 * 6 + 1] + road[iroad].hdmdes[k].RJSgou[2 * 7 + 1]) + Earh;//沟底中心地面高程
			pCross.RightJSGouPart->m_GouBotX = 0.5*(road[iroad].hdmdes[k].RJSgou[2 * 6] + road[iroad].hdmdes[k].RJSgou[2 * 7]);//沟底中心的小x坐标
			pCross.RightJSGouPart->m_GouBotPoint.x = 0.5*(pCross.RightJSGouPart->m_JSGouPoints[6].x + pCross.RightJSGouPart->m_JSGouPoints[7].x);
			pCross.RightJSGouPart->m_GouBotPoint.y = 0.5 * (pCross.RightJSGouPart->m_JSGouPoints[6].y + pCross.RightJSGouPart->m_JSGouPoints[7].y);
			pCross.RightJSGouPart->m_OriGouBotPt = pCross.RightJSGouPart->m_GouBotPoint;
		}

	}
	pCross.m_EarH = road[iroad].hdmdmx[k].EarH;
	pCross.m_EarHOnLJZX = Earh;
	pCross.LeftEarthLinePart = new EarthLine_ROAD;
	pCross.RightEarthLinePart = new EarthLine_ROAD;
	_tcscpy(pCross.LeftEarthLinePart->m_ckml, pCross.m_ckml);
	_tcscpy(pCross.RightEarthLinePart->m_ckml, pCross.m_ckml);
	pCross.LeftEarthLinePart->m_cml = pCross.m_cml;
	pCross.RightEarthLinePart->m_cml = pCross.m_cml;
	pCross.LeftEarthLinePart->m_twh = pCross.m_ZTWH;
	pCross.RightEarthLinePart->m_twh = pCross.m_YTWH;
	pCross.LeftEarthLinePart->EarH = pCross.RightEarthLinePart->EarH = road[iroad].hdmdmx[k].EarH;
	pCross.LeftEarthLinePart->m_sfactor = Sfactor;		//20190819	新增	比例尺
	pCross.RightEarthLinePart->m_sfactor = Sfactor;		//20190819	新增	比例尺
	//    if(pCross.LeftDesignLinePart->m_FillORCut<0.1 || pCross.RightDesignLinePart->m_FillORCut<0.1)

	pCross.LeftEarthLinePart->HTHD = road[iroad].hdmdes[k].ZHTHD;
	pCross.RightEarthLinePart->HTHD = road[iroad].hdmdes[k].YHTHD;

	// 	   else
	// 	   {
	// 		   pCross.LeftEarthLinePart->HTHD = 0.0;
	// 		   pCross.RightEarthLinePart->HTHD = 0.0;
	// 	   }


	_tcscpy(pCross.LeftEarthLinePart->m_ZorY, L"左侧");
	_tcscpy(pCross.RightEarthLinePart->m_ZorY, L"右侧");
	pCross.LeftEarthLinePart->m_EarthPointNum = newNumL;
	pCross.RightEarthLinePart->m_EarthPointNum = newNumR;
	if (pCross.LeftEarthLinePart->m_EarthPoints) { delete pCross.LeftEarthLinePart->m_EarthPoints; pCross.LeftEarthLinePart->m_EarthPoints = NULL; }
	if (pCross.LeftEarthLinePart->m_EarthPointNum > 0)
	{
		pCross.LeftEarthLinePart->m_EarthPoints = new AcGePoint3d[pCross.LeftEarthLinePart->m_EarthPointNum];
		y = Earh - road[iroad].hdmdes[k].Ymin;
		pCross.LeftEarthLinePart->m_EarthPoints[0].x = pCross.m_OriPoint.x;
		pCross.LeftEarthLinePart->m_EarthPoints[0].y = pCross.m_OriPoint.y + y * Sfactor;
	}
	if (pCross.RightEarthLinePart->m_EarthPoints) { delete pCross.RightEarthLinePart->m_EarthPoints, pCross.RightEarthLinePart->m_EarthPoints = NULL; }
	if (pCross.RightEarthLinePart->m_EarthPointNum > 0)
	{
		pCross.RightEarthLinePart->m_EarthPoints = new AcGePoint3d[pCross.RightEarthLinePart->m_EarthPointNum];
		y = Earh - road[iroad].hdmdes[k].Ymin;
		pCross.RightEarthLinePart->m_EarthPoints[0].x = pCross.m_OriPoint.x;
		pCross.RightEarthLinePart->m_EarthPoints[0].y = pCross.m_OriPoint.y + y * Sfactor;
	}

	pCross.LeftEarthLinePart->m_OriPoint.x = pCross.m_OriPoint.x;
	pCross.LeftEarthLinePart->m_OriPoint.y = pCross.m_OriPoint.y;
	//     pCross.LeftEarthLinePart->bzpoint.x=pCross.LeftEarthLinePart->m_EarthPoints[0].x-road[iroad].hdmdes[k].offsetX*Sfactor;//地面高程标注点,
	pCross.LeftEarthLinePart->bzpoint.x = pCross.LeftEarthLinePart->m_EarthPoints[0].x - road[iroad].hdmdes[k].offsetX*Sfactor - road[iroad].hdmdes[k].OffsetByXLZX*Sfactor;//地面高程标注点,
	y = road[iroad].hdmdmx[k].EarH - road[iroad].hdmdes[k].Ymin;
	pCross.LeftEarthLinePart->bzpoint.y = pCross.m_OriPoint.y + y * Sfactor;//地面高程标注点,与一线有关
	for (j = 1; j < pCross.LeftEarthLinePart->m_EarthPointNum; j++)
	{
		xx = -1.0*newLearpt[j * 2];
		y = newLearpt[j * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;

		pCross.LeftEarthLinePart->m_EarthPoints[j].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.LeftEarthLinePart->m_EarthPoints[j].y = pCross.m_OriPoint.y + y * Sfactor;

	}
	pCross.RightEarthLinePart->m_OriPoint.x = pCross.m_OriPoint.x;
	pCross.RightEarthLinePart->m_OriPoint.y = pCross.m_OriPoint.y;
	for (j = 1; j < pCross.RightEarthLinePart->m_EarthPointNum; j++)
	{
		xx = newRearpt[j * 2];
		y = newRearpt[j * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
		pCross.RightEarthLinePart->m_EarthPoints[j].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.RightEarthLinePart->m_EarthPoints[j].y = pCross.m_OriPoint.y + y * Sfactor;

	}



	//////////////////////////////////////////////////////////////////////////
	pCross.LeftEarthLinePart->m_BenchPointNum = newBenchNumL;
	pCross.RightEarthLinePart->m_BenchPointNum = newBenchNumR;
	if (pCross.LeftEarthLinePart->m_BenchPoints) { delete pCross.LeftEarthLinePart->m_BenchPoints; pCross.LeftEarthLinePart->m_BenchPoints = NULL; }
	if (pCross.LeftEarthLinePart->m_BenchPointNum > 0)
	{
		pCross.LeftEarthLinePart->m_BenchPoints = new AcGePoint3d[pCross.LeftEarthLinePart->m_BenchPointNum];
	}
	if (pCross.RightEarthLinePart->m_BenchPoints) { delete pCross.RightEarthLinePart->m_BenchPoints, pCross.RightEarthLinePart->m_BenchPoints = NULL; }
	if (pCross.RightEarthLinePart->m_BenchPointNum > 0)
	{
		pCross.RightEarthLinePart->m_BenchPoints = new AcGePoint3d[pCross.RightEarthLinePart->m_BenchPointNum];
	}

	for (j = 0; j < pCross.LeftEarthLinePart->m_BenchPointNum; j++)
	{
		xx = -1.0*newLBenchpt[j * 2];
		y = newLBenchpt[j * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
		pCross.LeftEarthLinePart->m_BenchPoints[j].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.LeftEarthLinePart->m_BenchPoints[j].y = pCross.m_OriPoint.y + y * Sfactor;

	}

	for (j = 0; j < pCross.RightEarthLinePart->m_BenchPointNum; j++)
	{
		xx = newRBenchpt[j * 2];
		y = newRBenchpt[j * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
		pCross.RightEarthLinePart->m_BenchPoints[j].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.RightEarthLinePart->m_BenchPoints[j].y = pCross.m_OriPoint.y + y * Sfactor;
	}

	//////////////////////////////////////////////////////////////////////////

	//画天沟的浆切

	if (road[iroad].hdmdes[k].LGouProperty == 2 && road[iroad].hdmdes[k].LJSGouPtNum > 0)
	{
		TGhasJQ(-1, pCross.LeftJSGouPart->m_JSGouPoints, pCross.LeftJSGouPart->TG_JQHD,
			pCross.LeftJSGouPart->SP1, pCross.LeftJSGouPart->SP2, pCross.LeftJSGouPart->GS, pCross.LeftJSGouPart->TG_GDR,
			pCross.LeftJSGouPart->JqPtNum, pCross.LeftJSGouPart->JqPt,
			pCross.LeftEarthLinePart->m_EarthPointNum, pCross.LeftEarthLinePart->m_EarthPoints);

	}
	if (road[iroad].hdmdes[k].RGouProperty == 2 && road[iroad].hdmdes[k].RJSGouPtNum > 0)
	{
		TGhasJQ(1, pCross.RightJSGouPart->m_JSGouPoints, pCross.RightJSGouPart->TG_JQHD,
			pCross.RightJSGouPart->SP1, pCross.RightJSGouPart->SP2, pCross.RightJSGouPart->GS, pCross.RightJSGouPart->TG_GDR,
			pCross.RightJSGouPart->JqPtNum, pCross.RightJSGouPart->JqPt,
			pCross.RightEarthLinePart->m_EarthPointNum, pCross.RightEarthLinePart->m_EarthPoints);

	}

	//画路堑的侧沟浆切
	double D;
	if (road[iroad].hdmdes[k].Lnpt > 0 && (fabs(pCross.LeftDesignLinePart->m_FillORCut - 1.0) < 0.001 || fabs(pCross.LeftDesignLinePart->m_FillORCut - 3.0) < 0.001))
	{
		// if(pCross.xjj>-0.0001)//左线为主线
		Cal_D(road[iroad].hdmdes[k].cml, road[iroad].pm, road[iroad].hdmbz.NZLQSG, road[iroad].hdmbz.ZLQSG, &D, &pCross.LeftDesignLinePart->GK,
			&pCross.LeftDesignLinePart->GS, &pCross.LeftDesignLinePart->GP1,
			&pCross.LeftDesignLinePart->GP2, &pCross.LeftDesignLinePart->CG_JQHD, &pCross.LeftDesignLinePart->CG_GDR);
		/*
		else
		{
		int ifld;
		ifld = GetIRoadByName(road[iroad].hdmdes[k].FLDname);
		Cal_D(road[iroad].hdmdes[k].FLDcml,road[ifld].pm,road[ifld].hdmbz.NZLQSG,road[ifld].hdmbz.ZLQSG,
		&D,&pCross.LeftDesignLinePart->GK,
		&pCross.LeftDesignLinePart->GS,&pCross.LeftDesignLinePart->GP1,
		&pCross.LeftDesignLinePart->GP2,&pCross.LeftDesignLinePart->CG_JQHD);
		}*/
		//		   if (pCross.LeftDesignLinePart->m_DesignPointNum>7)//增加该判断条件，否则CGhasJQ()出现数组越界。李伟 2008-03-09
		//		   {
		// 			   CGhasJQ(-1,pCross.LeftDesignLinePart->m_DesignPoints,pCross.LeftDesignLinePart->CG_JQHD,
		// 				   pCross.LeftDesignLinePart->GP1,pCross.LeftDesignLinePart->GP2,pCross.LeftDesignLinePart->GS,
		// 				   pCross.LeftDesignLinePart->JqPtNum,pCross.LeftDesignLinePart->JqPt);
		//			   CGhasJQ(-1,pCross.LeftDesignLinePart->m_DesignPoints,pCross.LeftDesignLinePart->CG_JQHD,pCross.LeftDesignLinePart->CG_GDR,
		// 				   pCross.LeftDesignLinePart->JqPtNum,pCross.LeftDesignLinePart->JqPt);
		//		   }

	}

	if (road[iroad].hdmdes[k].Rnpt > 0 && (fabs(pCross.RightDesignLinePart->m_FillORCut - 1.0) < 0.001 || fabs(pCross.RightDesignLinePart->m_FillORCut - 3.0) < 0.001))
	{
		//	   if(pCross.xjj>-0.0001)//左线为主线
		Cal_D(road[iroad].hdmdes[k].cml, road[iroad].pm, road[iroad].hdmbz.NYLQSG, road[iroad].hdmbz.YLQSG, &D, &pCross.RightDesignLinePart->GK,
			&pCross.RightDesignLinePart->GS, &pCross.RightDesignLinePart->GP1,
			&pCross.RightDesignLinePart->GP2, &pCross.RightDesignLinePart->CG_JQHD, &pCross.RightDesignLinePart->CG_GDR);
		/*
		else
		{
		int ifld;
		ifld = GetIRoadByName(road[iroad].hdmdes[k].FLDname);
		Cal_D(road[iroad].hdmdes[k].FLDcml,road[ifld].pm,road[ifld].hdmbz.NYLQSG,road[ifld].hdmbz.YLQSG,
		&D,&pCross.RightDesignLinePart->GK,
		&pCross.RightDesignLinePart->GS,&pCross.RightDesignLinePart->GP1,
		&pCross.RightDesignLinePart->GP2,&pCross.RightDesignLinePart->CG_JQHD);
		}
		*/
		//		   if (pCross.RightDesignLinePart->m_DesignPointNum>7)//增加该判断条件，否则CGhasJQ()出现数组越界。李伟 2008-03-09
		//		   {
		// 			   CGhasJQ(1,pCross.RightDesignLinePart->m_DesignPoints,pCross.RightDesignLinePart->CG_JQHD,
		// 				   pCross.RightDesignLinePart->GP1,pCross.RightDesignLinePart->GP2,pCross.RightDesignLinePart->GS,
		// 				   pCross.RightDesignLinePart->JqPtNum,pCross.RightDesignLinePart->JqPt);
		// 			   CGhasJQ(1,pCross.RightDesignLinePart->m_DesignPoints,pCross.RightDesignLinePart->CG_JQHD,pCross.RightDesignLinePart->CG_GDR,
		// 				   pCross.RightDesignLinePart->JqPtNum,pCross.RightDesignLinePart->JqPt);
		//		   }

	}
	//画水沟的浆切
	if (road[iroad].hdmdes[k].LGouProperty == 1 && road[iroad].hdmdes[k].LGouPtNum > 0)
		// 	     SGhasJQ(-1,pCross.LeftLTGouPart->m_LTGouPointNum,pCross.LeftLTGouPart->m_LTGouPoints,pCross.LeftLTGouPart->PSG_JQHD,
			// 			   pCross.LeftLTGouPart->m_SP1,pCross.LeftLTGouPart->m_SP2,pCross.LeftLTGouPart->m_GH,pCross.LeftLTGouPart->m_PSG_GDR,
				// 			   pCross.LeftLTGouPart->JqPtNum,pCross.LeftLTGouPart->JqPt);
	{
		// 			if (pCross.LeftLTGouPart->m_LTGouPointNum==6 || pCross.LeftLTGouPart->m_LTGouPointNum==16)
		// 			{
		// 				Cal_D(road[iroad].hdmdes[k].cml,road[iroad].pm,road[iroad].hdmbz.NZLQSG,road[iroad].hdmbz.ZLQSG,&D,&pCross.LeftDesignLinePart->GK,
		// 					&pCross.LeftDesignLinePart->GS,&pCross.LeftDesignLinePart->GP1,
		// 			   &pCross.LeftDesignLinePart->GP2,&pCross.LeftDesignLinePart->CG_JQHD,&pCross.LeftDesignLinePart->CG_GDR);
		// 				pCross.LeftLTGouPart->PSG_JQHD = pCross.LeftDesignLinePart->CG_GDR;
		// 			}

		SGhasJQ(-1, pCross.LeftLTGouPart->m_LTGouPointNum, pCross.LeftLTGouPart->m_LTGouPoints, pCross.LeftLTGouPart->PSG_JQHD,
			pCross.LeftLTGouPart->JqPtNum, pCross.LeftLTGouPart->JqPt);
	}

	if (road[iroad].hdmdes[k].RGouProperty == 1 && road[iroad].hdmdes[k].RGouPtNum > 0)
		// 		   SGhasJQ(1,pCross.RightLTGouPart->m_LTGouPointNum,pCross.RightLTGouPart->m_LTGouPoints,pCross.RightLTGouPart->PSG_JQHD,
			// 		   pCross.RightLTGouPart->m_SP1,pCross.RightLTGouPart->m_SP2,pCross.RightLTGouPart->m_GH,pCross.RightLTGouPart->m_PSG_GDR,
				// 		   pCross.RightLTGouPart->JqPtNum,pCross.RightLTGouPart->JqPt);
	{
		// 			if (pCross.RightLTGouPart->m_LTGouPointNum==6 || pCross.RightLTGouPart->m_LTGouPointNum==16)
		// 			{
		// 				Cal_D(road[iroad].hdmdes[k].cml,road[iroad].pm,road[iroad].hdmbz.NYLQSG,road[iroad].hdmbz.YLQSG,&D,&pCross.RightDesignLinePart->GK,
		// 					&pCross.RightDesignLinePart->GS,&pCross.RightDesignLinePart->GP1,
		// 		      &pCross.RightDesignLinePart->GP2,&pCross.RightDesignLinePart->CG_JQHD,&pCross.RightDesignLinePart->CG_GDR);
		// 				pCross.RightLTGouPart->PSG_JQHD = pCross.RightDesignLinePart->CG_JQHD;
		// 			}
		SGhasJQ(1, pCross.RightLTGouPart->m_LTGouPointNum, pCross.RightLTGouPart->m_LTGouPoints, pCross.RightLTGouPart->PSG_JQHD,
			pCross.RightLTGouPart->JqPtNum, pCross.RightLTGouPart->JqPt);
	}


	/*
	//线间沟的浆切
	if(road[iroad].hdmdes[k].DorS==2)
	{
	pCross.RightDesignLinePart->DorS=road[iroad].hdmdes[k].DorS;
	Cal_D(road[iroad].hdmdes[k].cml,RightHdmData.NLQSG,RightHdmData.LQSG,&D,&pCross.RightDesignLinePart->GK,
	&pCross.RightDesignLinePart->GS,&pCross.RightDesignLinePart->GP1,
	&pCross.RightDesignLinePart->GP2,&pCross.RightDesignLinePart->CG_JQHD);
	XJGhasJQ(1,pCross.RightDesignLinePart->m_DesignPointNum, pCross.RightDesignLinePart->m_DesignPoints,
	pCross.RightDesignLinePart->CG_JQHD,pCross.RightDesignLinePart->XGJqPtNum,pCross.RightDesignLinePart->XGJqPt);
	}*/


	double Ymin, Ymax;
	if (pCross.LeftDesignLinePart->m_DesignPointNum > 0)
		Ymax = pCross.LeftDesignLinePart->m_DesignPoints[0].y > pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y ? pCross.LeftDesignLinePart->m_DesignPoints[0].y : pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
	if (pCross.RightDesignLinePart->m_DesignPointNum > 0)
		Ymax = Ymax < pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y ? pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y : Ymax;
	if (pCross.LeftDesignLinePart->m_DesignPointNum > 0)
		Ymin = pCross.LeftDesignLinePart->m_DesignPoints[0].y < pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y ? pCross.LeftDesignLinePart->m_DesignPoints[0].y : pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
	if (pCross.RightDesignLinePart->m_DesignPointNum > 0)
		Ymin = Ymin > pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y ? pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y : Ymin;
	if (!pCross.IsLinkHdm && (pCross.RightDesignLinePart->m_DesignPointNum > 0 || pCross.LeftDesignLinePart->m_DesignPointNum > 0))
		SetSZoomCorner(pCross, iroad, k);//设置单路面Zoom两个角点

	/////////////////////////////////////  
	//标注内容
	pCross.Note = new HdmText_ROAD;
	pCross.Note->DorS = road[iroad].hdmdes[k].DorS;//单双路面;
	pCross.Note->XJJ = road[iroad].hdmdes[k].xjj;
	_tcscpy(pCross.Note->m_ckml, road[iroad].hdmdes[k].ckml);
	_tcscpy(pCross.Note->FLD_ckml, pCross.m_FLDckml);

	pCross.Note->EarH = road[iroad].hdmdmx[k].EarH;
	//if(fabs(road[iroad].hdmdes[k].ZHc-road[iroad].hdmdes[k].YHc)<0.001)
	pCross.Note->ZZ_twh = road[iroad].hdmdes[k].ZHc;//暂时标左侧
	pCross.Note->ZY_twh = road[iroad].hdmdes[k].YHc;//暂时标右侧
	pCross.Note->YZ_twh = road[iroad].hdmdes[k].Y_ZHc;//暂时标左侧
	pCross.Note->YY_twh = road[iroad].hdmdes[k].Y_YHc;//暂时标右侧

	pCross.Note->m_fillarea = road[iroad].hdmdes[k].at;
	pCross.Note->m_cutarea = road[iroad].hdmdes[k].aw;
	pCross.Note->DuoluoInf = road[iroad].hdmdes[k].DuanLuoInf;
	pCross.Note->DorS = road[iroad].hdmdes[k].DorS;
	pCross.Note->offsetX = road[iroad].hdmdes[k].offsetX;
	pCross.Note->YoffsetX = road[iroad].hdmdes[k].YoffsetX;
	pCross.Note->BTinf = road[iroad].hdmdes[k].ZDMXZ;
	pCross.Note->Y_BTinf = road[iroad].hdmdes[k].YDMXZ;
	pCross.Note->LZDK = road[iroad].hdmdes[k].LZDK;
	pCross.Note->RZDK = road[iroad].hdmdes[k].RZDK;
	pCross.Note->Z_LFillArea = road[iroad].hdmdes[k].Z_LFillArea; pCross.Note->MidFillArea = road[iroad].hdmdes[k].MidFillArea; pCross.Note->Y_RFillArea = road[iroad].hdmdes[k].Y_RFillArea;
	pCross.Note->Z_LCutArea = road[iroad].hdmdes[k].Z_LCutArea; pCross.Note->MidCutArea = road[iroad].hdmdes[k].MidCutArea; pCross.Note->Y_RCutArea = road[iroad].hdmdes[k].Y_RCutArea;
	pCross.Note->Z_LFillSSTArea = road[iroad].hdmdes[k].Z_LFillSSTArea; pCross.Note->MidFillSSTArea = road[iroad].hdmdes[k].MidFillSSTArea; pCross.Note->Y_RFillSSTArea = road[iroad].hdmdes[k].Y_RFillSSTArea;//填渗水土面积
	pCross.Note->Z_LQBTArea = road[iroad].hdmdes[k].Z_LQBTArea; pCross.Note->MidQBTArea = road[iroad].hdmdes[k].MidQBTArea; pCross.Note->Y_RQBTArea = road[iroad].hdmdes[k].Y_RQBTArea;
	pCross.Note->Z_LFillBetterSoilArea = road[iroad].hdmdes[k].Z_LFillBetterSoilArea; pCross.Note->MidFillGLTArea = road[iroad].hdmdes[k].MidFillGLTArea; pCross.Note->Y_RFillBetterSoilArea = road[iroad].hdmdes[k].Y_RFillBetterSoilArea;
	pCross.Note->Z_LHJarea = road[iroad].hdmdes[k].Z_LHJarea; pCross.Note->MidHJarea = road[iroad].hdmdes[k].MidHJarea; pCross.Note->Y_RHJarea = road[iroad].hdmdes[k].Y_RHJarea;
	pCross.Note->Z_LSGJQarea = road[iroad].hdmdes[k].Z_LSGJQarea; pCross.Note->MidGouJQarea = road[iroad].hdmdes[k].MidGouJQarea; pCross.Note->Y_RSGJQarea = road[iroad].hdmdes[k].Y_RSGJQarea;
	pCross.Note->Z_LDQlength = road[iroad].hdmdes[k].Z_LDQlength; pCross.Note->MidDQlength = road[iroad].hdmdes[k].MidDQlength; pCross.Note->Y_RDQlength = road[iroad].hdmdes[k].Y_RDQlength;//挡墙坡长
	pCross.Note->Z_LGrasslength = road[iroad].hdmdes[k].Z_LGrasslength; pCross.Note->MidGrasslength = road[iroad].hdmdes[k].MidGrasslength; pCross.Note->Y_RGrasslength = road[iroad].hdmdes[k].Y_RGrasslength;//铺草坡长
	pCross.Note->Z_LGouTarea = road[iroad].hdmdes[k].Z_LGouTarea; pCross.Note->Y_RGouTarea = road[iroad].hdmdes[k].Y_RGouTarea;
	pCross.Note->Z_LGouWarea = road[iroad].hdmdes[k].Z_LGouWarea; pCross.Note->Y_RGouWarea = road[iroad].hdmdes[k].Y_RGouWarea;

	// 标注在一线下
	//形成边坡字符
	pCross.LeftDesignLinePart->SetBPStr(pCross.LeftDesignLinePart->m_FillORCut, pCross.LeftDesignLinePart->m_DesignPointNum, pCross.LeftDesignLinePart->m_DesignPoints, pCross.Note->m_ZBP, pCross.Note->m_ZSlopPt, -1);
	pCross.RightDesignLinePart->SetBPStr(pCross.RightDesignLinePart->m_FillORCut, pCross.RightDesignLinePart->m_DesignPointNum, pCross.RightDesignLinePart->m_DesignPoints, pCross.Note->m_YBP, pCross.Note->m_YSlopPt, 1);
	pCross.RightDesignLinePart->l_earthline = pCross.LeftEarthLinePart;
	pCross.RightDesignLinePart->r_earthline = pCross.RightEarthLinePart;
	pCross.LeftDesignLinePart->l_earthline = pCross.LeftEarthLinePart;
	pCross.LeftDesignLinePart->r_earthline = pCross.RightEarthLinePart;
	pCross.LeftDesignLinePart->LTGou = pCross.LeftLTGouPart;
	pCross.LeftDesignLinePart->JSGou = pCross.LeftJSGouPart;
	pCross.LeftDesignLinePart->Note = pCross.Note;
	pCross.RightDesignLinePart->LTGou = pCross.RightLTGouPart;
	pCross.RightDesignLinePart->JSGou = pCross.RightJSGouPart;
	pCross.RightDesignLinePart->Note = pCross.Note;

	return Adesk::kTrue;
}


Adesk::Boolean HdmDes::setCROSSAutoDesignData(CROSS &pCross, RoadHdmdata &ZDroad, int k, CRSDAT *LinkRoad, double Earh, double newLearpt[], int newNumL, double newRearpt[], int newNumR)
{
	double  xx, y;
	int i, j, m;
	int gounum, jsgnum, pjqptnum;
	double PjqPt[14];
	//int RQqPtNum;
	//double LJqPt[20];

	LinkRoad->DorS = 1;
	_tcscpy(pCross.m_ckml, LinkRoad->ckml);
	_tcscpy(pCross.m_FLDckml, pCross.m_ckml);
	if (LinkRoad->DorS == 2)
	{
		int irxd = GetIRoadByName(LinkRoad->FLDname);
		_tcscpy(pCross.m_FLDckml, road[irxd].pm->XLC(LinkRoad->FLDcml));
	}
	pCross.m_cml = LinkRoad->cml;
	CString GH;
	double dml = ZDroad.pm->XLC(LinkRoad->cml, GH);
	_tcscpy(LinkRoad->ckml, ZDroad.pm->LCchr(GH, dml, 3));

	pCross.m_ZTWH = LinkRoad->ZHc;
	pCross.m_YTWH = LinkRoad->YHc;

	pCross.m_FillArea = LinkRoad->at;
	pCross.m_CutArea = LinkRoad->aw;
	pCross.IfSetDQ = LinkRoad->IfSetDQ;
	//pCross.m_BTinf = LinkRoad->BTinf;	

	pCross.xjj = LinkRoad->xjj;// - LinkRoad->Zxjj;	
	pCross.DX = LinkRoad->DX;//出图需要

	//	pCross.ZHTHD=LinkRoad->ZHTHD;
	//	pCross.YHTHD=LinkRoad->YHTHD;
	//CalNewDMGC(k,LinkRoad->Zxjj,LinkRoad->EarH,Earh);//一线坐标平移一个左线间距后的地面高层
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//设计点
	pCross.LeftDesignLinePart = new DesignLine_ROAD;
	pCross.RightDesignLinePart = new DesignLine_ROAD;

	pCross.LeftDesignLinePart->m_ZorY = -1;
	pCross.RightDesignLinePart->m_ZorY = 1;
	pCross.LeftDesignLinePart->LnewYd = Earh;
	pCross.RightDesignLinePart->LnewYd = Earh;
	_tcscpy(pCross.LeftDesignLinePart->RoadName, ZDroad.roadname);
	_tcscpy(pCross.RightDesignLinePart->RoadName, ZDroad.roadname);
	pCross.RightDesignLinePart->hdmno = k;
	pCross.LeftDesignLinePart->hdmno = k;

	//
	//		pCross.LeftDesignLinePart->m_nLTBPJS=FindWichBP(pCross.m_cml,ZDroad.pm,ZDroad.hdmbz.NZLDBP,ZDroad.hdmbz.ZLDBP,pCross.LeftDesignLinePart->m_TM,pCross.LeftDesignLinePart->m_TH,pCross.LeftDesignLinePart->m_TPTW,pCross.LeftDesignLinePart->m_TPTI);//左路堤边坡
	//		pCross.RightDesignLinePart->m_nLTBPJS= FindWichBP(pCross.m_cml,ZDroad.pm,ZDroad.hdmbz.NYLDBP,ZDroad.hdmbz.YLDBP,pCross.RightDesignLinePart->m_TM,pCross.RightDesignLinePart->m_TH,pCross.RightDesignLinePart->m_TPTW,pCross.RightDesignLinePart->m_TPTI);//路堤边坡
	//		pCross.LeftDesignLinePart->m_nLZBPJS= FindWichBP(pCross.m_cml,ZDroad.pm,ZDroad.hdmbz.NZLQBP,ZDroad.hdmbz.ZLQBP,pCross.LeftDesignLinePart->m_WM,pCross.LeftDesignLinePart->m_PH,pCross.LeftDesignLinePart->m_ZPTW,pCross.LeftDesignLinePart->m_ZPTI);//路堤边坡
	//		pCross.RightDesignLinePart->m_nLZBPJS= FindWichBP(pCross.m_cml,ZDroad.pm,ZDroad.hdmbz.NYLQBP,ZDroad.hdmbz.YLQBP,pCross.RightDesignLinePart->m_WM,pCross.RightDesignLinePart->m_PH,pCross.RightDesignLinePart->m_ZPTW,pCross.RightDesignLinePart->m_ZPTI);//路堤边坡
	//	   	   
	//		FindIljjk(pCross.m_cml,ZDroad.pm,ZDroad.hdmbz.NZPWD,ZDroad.hdmbz.ZPWD, pCross.LeftDesignLinePart->m_WW[0], pCross.LeftDesignLinePart->m_WW[1]);
	//		FindIljjk(pCross.m_cml,ZDroad.pm,ZDroad.hdmbz.NYPWD,ZDroad.hdmbz.YPWD,pCross.RightDesignLinePart->m_WW[0], pCross.RightDesignLinePart->m_WW[1]);
	//		pCross.LeftDesignLinePart->m_XW  = FindIljxk(pCross.m_cml,ZDroad.pm,ZDroad.hdmbz.NZDM,ZDroad.hdmbz.ZDM);
	//		pCross.RightDesignLinePart->m_XW = FindIljxk(pCross.m_cml,ZDroad.pm,ZDroad.hdmbz.NYDM,ZDroad.hdmbz.YDM);


	//		if(LinkRoad->xjj<-0.00001)//左线分离(应从分离线取值)
	//		{
	//		}

	pCross.LeftDesignLinePart->m_DesignPointNum = LinkRoad->Lnpt;

	if (pCross.LeftDesignLinePart->m_DesignPoints) { delete pCross.LeftDesignLinePart->m_DesignPoints, pCross.LeftDesignLinePart->m_DesignPoints = NULL; }
	if (LinkRoad->Lnpt > 0)
		pCross.LeftDesignLinePart->m_DesignPoints = new AcGePoint3d[pCross.LeftDesignLinePart->m_DesignPointNum];
	pCross.RightDesignLinePart->m_DesignPointNum = LinkRoad->Rnpt;
	if (pCross.RightDesignLinePart->m_DesignPoints) { delete pCross.RightDesignLinePart->m_DesignPoints, pCross.RightDesignLinePart->m_DesignPoints = NULL; }
	if (LinkRoad->Rnpt > 0)
		pCross.RightDesignLinePart->m_DesignPoints = new AcGePoint3d[pCross.RightDesignLinePart->m_DesignPointNum];
	for (i = 0; i < 10; i++)
	{
		pCross.LeftDesignLinePart->RHF[i] = LinkRoad->RHFL[i];
		pCross.RightDesignLinePart->RHF[i] = LinkRoad->RHFR[i];
	}

	pCross.LeftDesignLinePart->m_Xcdh = LinkRoad->zlmhd[0];
	pCross.LeftDesignLinePart->m_Yljh = LinkRoad->zlmhd[1];
	pCross.LeftDesignLinePart->m_Tljh = LinkRoad->zlmhd[2];
	pCross.RightDesignLinePart->m_Xcdh = LinkRoad->ylmhd[0];
	pCross.RightDesignLinePart->m_Yljh = LinkRoad->ylmhd[1];
	pCross.RightDesignLinePart->m_Tljh = LinkRoad->ylmhd[2];

	/*
	if(fabs(LinkRoad->cml-4800)<0.1)
	for(int m=0;m<4;m++)
	ads_printf(L"\ncml=%lf,yd=%lf,rhf=%lf,rhf=%lf",pCross.LeftDesignLinePart->cml,pCross.LeftDesignLinePart->LnewYd,pCross.LeftDesignLinePart->RHF[m*2],pCross.LeftDesignLinePart->RHF[m*2+1]); */

	if (fabs(pCross.LeftDesignLinePart->RHF[4]) > fabs(pCross.LeftDesignLinePart->RHF[2]))
		pCross.LeftDesignLinePart->LMHP[0] = (pCross.LeftDesignLinePart->RHF[5] - pCross.LeftDesignLinePart->RHF[3]) / (pCross.LeftDesignLinePart->RHF[4] - pCross.LeftDesignLinePart->RHF[2]);
	else
		pCross.LeftDesignLinePart->LMHP[0] = 0.0;

	if (fabs(pCross.LeftDesignLinePart->RHF[6]) > fabs(pCross.LeftDesignLinePart->RHF[4]))
		pCross.LeftDesignLinePart->LMHP[1] = (pCross.LeftDesignLinePart->RHF[7] - pCross.LeftDesignLinePart->RHF[5]) / (pCross.LeftDesignLinePart->RHF[6] - pCross.LeftDesignLinePart->RHF[4]);
	else
		pCross.LeftDesignLinePart->LMHP[1] = 0.0;

	if (fabs(pCross.LeftDesignLinePart->RHF[8]) > fabs(pCross.LeftDesignLinePart->RHF[6]))
		pCross.LeftDesignLinePart->LMHP[2] = (pCross.LeftDesignLinePart->RHF[9] - pCross.LeftDesignLinePart->RHF[7]) / (pCross.LeftDesignLinePart->RHF[8] - pCross.LeftDesignLinePart->RHF[6]);
	else
		pCross.LeftDesignLinePart->LMHP[2] = 0.0;

	if (pCross.RightDesignLinePart->RHF[4] > pCross.RightDesignLinePart->RHF[2])
		pCross.RightDesignLinePart->LMHP[0] = (pCross.RightDesignLinePart->RHF[5] - pCross.RightDesignLinePart->RHF[3]) / (pCross.RightDesignLinePart->RHF[4] - pCross.RightDesignLinePart->RHF[2]);
	else
		pCross.RightDesignLinePart->LMHP[0] = 0.0;

	if (pCross.RightDesignLinePart->RHF[6] > pCross.RightDesignLinePart->RHF[4])
		pCross.RightDesignLinePart->LMHP[1] = (pCross.RightDesignLinePart->RHF[7] - pCross.RightDesignLinePart->RHF[5]) / (pCross.RightDesignLinePart->RHF[6] - pCross.RightDesignLinePart->RHF[4]);
	else
		pCross.RightDesignLinePart->LMHP[1] = 0.0;

	if (pCross.RightDesignLinePart->RHF[8] > pCross.RightDesignLinePart->RHF[6])
		pCross.RightDesignLinePart->LMHP[2] = (pCross.RightDesignLinePart->RHF[9] - pCross.RightDesignLinePart->RHF[7]) / (pCross.RightDesignLinePart->RHF[8] - pCross.RightDesignLinePart->RHF[6]);
	else
		pCross.RightDesignLinePart->LMHP[2] = 0.0;

	pCross.LeftDesignLinePart->m_FillORCut = LinkRoad->Zt;
	//		pCross.LeftDesignLinePart->DorS = LinkRoad->DorS;
	pCross.LeftDesignLinePart->BTinf = LinkRoad->ZDMXZ;
	//		pCross.LeftDesignLinePart->ZYBTinf = LinkRoad->YDMXZ;

	//		pCross.LeftDesignLinePart->xlxz = LinkRoad->xlxz;
	//		pCross.LeftDesignLinePart->r_bh = LinkRoad->r_bh;
	pCross.LeftDesignLinePart->cml = LinkRoad->cml;

	for (i = 1; i < pCross.LeftDesignLinePart->m_DesignPointNum; i++)
	{
		xx = LinkRoad->RPTL[i].x;
		y = LinkRoad->RPTL[i].y + Earh - LinkRoad->Ymin;
		pCross.LeftDesignLinePart->m_DesignPoints[i].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.LeftDesignLinePart->m_DesignPoints[i].y = pCross.m_OriPoint.y + y * Sfactor;
	}
	if (LinkRoad->Lnpt > 0)
	{
		pCross.LeftDesignLinePart->m_DesignPoints[0].x = pCross.m_OriPoint.x;
		pCross.LeftDesignLinePart->m_DesignPoints[0].y = pCross.LeftDesignLinePart->m_DesignPoints[1].y;
	}

	if (LinkRoad->Lnpt > 0)
	{
		pCross.LeftDesignLinePart->BPLen = fabs(LinkRoad->RPTL[LinkRoad->Lnpt - 1].x);
		pCross.LeftDesignLinePart->BPH = LinkRoad->RPTL[LinkRoad->Lnpt - 1].y - LinkRoad->RPTL[0].y;
	}

	//右侧
	pCross.RightDesignLinePart->m_FillORCut = LinkRoad->Yt;
	pCross.RightDesignLinePart->BTinf = LinkRoad->YDMXZ;
	//	pCross.RightDesignLinePart->Y_BTinf = LinkRoad->YDMXZ;
	//    pCross.RightDesignLinePart->xlxz = LinkRoad->xlxz;
	//	pCross.RightDesignLinePart->r_bh = LinkRoad->r_bh; 
	pCross.RightDesignLinePart->cml = LinkRoad->cml;
	for (i = 1; i < pCross.RightDesignLinePart->m_DesignPointNum; i++)
	{
		xx = LinkRoad->RPTR[i].x;
		y = LinkRoad->RPTR[i].y + Earh - LinkRoad->Ymin;
		pCross.RightDesignLinePart->m_DesignPoints[i].x = pCross.m_OriPoint.x + xx * Sfactor;
		pCross.RightDesignLinePart->m_DesignPoints[i].y = pCross.m_OriPoint.y + y * Sfactor;
	}
	if (LinkRoad->Rnpt > 0)
	{
		pCross.RightDesignLinePart->m_DesignPoints[0].x = pCross.m_OriPoint.x;
		pCross.RightDesignLinePart->m_DesignPoints[0].y = pCross.RightDesignLinePart->m_DesignPoints[1].y;
	}
	if (LinkRoad->Rnpt > 0)
	{
		pCross.RightDesignLinePart->BPLen = fabs(LinkRoad->RPTR[LinkRoad->Rnpt - 1].x);
		pCross.RightDesignLinePart->BPH = LinkRoad->RPTR[LinkRoad->Rnpt - 1].y - LinkRoad->RPTR[0].y;
	}


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
	//画带有浆切的侧沟
	pCross.LeftLTGouPart = new LTGOU_ROAD;
	pCross.LeftLTGouPart->m_cml = pCross.m_cml;
	pCross.LeftLTGouPart->m_IfSetBotH = LinkRoad->LIfSetGouH;

	int goupro;
	if (pCross.xjj > 0.0001)//左线为主线
	{
		goupro = pCross.LeftLTGouPart->GouProperty;
		FindSG(pCross.m_cml, ZDroad.pm, ZDroad.hdmbz.NZLDSG, ZDroad.hdmbz.ZLDSG,
			goupro, pCross.LeftLTGouPart->PSG_JQHD,
			pCross.LeftLTGouPart->m_T2W, pCross.LeftLTGouPart->m_T1W,
			pCross.LeftLTGouPart->m_T2H, pCross.LeftLTGouPart->m_GH,
			pCross.LeftLTGouPart->m_GW, pCross.LeftLTGouPart->m_HH,
			pCross.LeftLTGouPart->m_SP1, pCross.LeftLTGouPart->m_SP2, pCross.LeftLTGouPart->m_SP3, pCross.LeftLTGouPart->m_PSG_GDR);//加浆砌厚度
	}

	else//左线为分离线
	{
		int ifld;
		ifld = GetIRoadByName(LinkRoad->FLDname);
		FindSG(LinkRoad->FLDcml, road[ifld].pm, road[ifld].hdmbz.NZLDSG, road[ifld].hdmbz.ZLDSG,
			goupro, pCross.LeftLTGouPart->PSG_JQHD,
			pCross.LeftLTGouPart->m_T2W, pCross.LeftLTGouPart->m_T1W,
			pCross.LeftLTGouPart->m_T2H, pCross.LeftLTGouPart->m_GH,
			pCross.LeftLTGouPart->m_GW, pCross.LeftLTGouPart->m_HH,
			pCross.LeftLTGouPart->m_SP1, pCross.LeftLTGouPart->m_SP2, pCross.LeftLTGouPart->m_SP3, pCross.LeftLTGouPart->m_PSG_GDR);//加浆砌厚度
		pCross.LeftLTGouPart->GouProperty = goupro;
	}
	pCross.LeftLTGouPart->m_ZorY = -1;

	pCross.LeftLTGouPart->m_LTGouPointNum = 0;

	pCross.LeftJSGouPart = new JSGOU_ROAD;
	_tcscpy(pCross.LeftJSGouPart->m_ckml, pCross.m_ckml);
	if (pCross.xjj > 0.0001)//左线为主线
		FindTG(pCross.m_cml, ZDroad.pm, ZDroad.hdmbz.NZTG, ZDroad.hdmbz.ZTG, pCross.LeftJSGouPart->BJ, pCross.LeftJSGouPart->GW,
			pCross.LeftJSGouPart->GS, pCross.LeftJSGouPart->SP1,
			pCross.LeftJSGouPart->SP2, pCross.LeftJSGouPart->TG_JQHD, pCross.LeftJSGouPart->TG_GDR);
	else
	{
		int ifld;
		ifld = GetIRoadByName(LinkRoad->FLDname);
		FindTG(LinkRoad->FLDcml, road[ifld].pm, road[ifld].hdmbz.NZTG, road[ifld].hdmbz.ZTG,
			pCross.LeftJSGouPart->BJ, pCross.LeftJSGouPart->GW,
			pCross.LeftJSGouPart->GS, pCross.LeftJSGouPart->SP1,
			pCross.LeftJSGouPart->SP2, pCross.LeftJSGouPart->TG_JQHD, pCross.LeftJSGouPart->TG_GDR);
	}
	//	
	pCross.LeftJSGouPart->m_ZorY = -1;
	pCross.LeftJSGouPart->JSGouPtNum = 0;
	pCross.LeftLTGouPart->GouProperty = LinkRoad->LGouProperty;

	if (pCross.LeftDesignLinePart->m_DesignPointNum > 0)
		pCross.LeftLTGouPart->m_PJDpt = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1];

	if (LinkRoad->LGouProperty == 1 && LinkRoad->LGouPtNum > 0)
	{
		gounum = 0;
		for (i = 0; i < LinkRoad->LGouPtNum; i++)
		{
			xx = LinkRoad->Lgou[i * 2];
			if (fabs(xx) > 0.0001)
			{
				y = LinkRoad->Lgou[i * 2 + 1] + Earh - LinkRoad->Ymin;
				pCross.LeftLTGouPart->m_LTGouPoints[gounum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.LeftLTGouPart->m_LTGouPoints[gounum].y = pCross.m_OriPoint.y + y * Sfactor;//+ pCross.m_TWH;
				gounum++;
			}
		}

		pCross.LeftLTGouPart->m_LTGouPointNum = gounum;
		if (gounum >= 5)
		{
			pCross.LeftLTGouPart->m_GouBotH = LinkRoad->Lgou[2 * 2 + 1] + Earh + pCross.LeftLTGouPart->PSG_JQHD;
			pCross.LeftLTGouPart->m_GouBotX = 0.5*(LinkRoad->Lgou[3 * 2] + LinkRoad->Lgou[2 * 2]);
			pCross.LeftLTGouPart->m_GouBotPoint.x = 0.5*(pCross.LeftLTGouPart->m_LTGouPoints[3].x + pCross.LeftLTGouPart->m_LTGouPoints[2].x);
			pCross.LeftLTGouPart->m_GouBotPoint.y = pCross.LeftLTGouPart->m_LTGouPoints[3].y;
			pCross.LeftLTGouPart->m_OriGouBotPt = pCross.LeftLTGouPart->m_GouBotPoint;
		}
	}
	else if (LinkRoad->LGouProperty == 0 && pCross.LeftDesignLinePart->m_DesignPointNum > 0)
	{

		AcGePoint3d JD, preJD;
		JD.x = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].x;
		JD.y = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
		preJD.x = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 2].x;
		preJD.y = pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 2].y;
		CalPjqPt(-1, JD, preJD, pjqptnum, PjqPt);
		pCross.LeftLTGouPart->pjqptnum = pjqptnum;
		for (m = 0; m < pjqptnum; m++)
		{
			pCross.LeftLTGouPart->PjqPt[m].x = PjqPt[2 * m];
			pCross.LeftLTGouPart->PjqPt[m].y = PjqPt[2 * m + 1];
		}

	}
	else if (LinkRoad->LGouProperty == 2 && LinkRoad->LJSGouPtNum > 0)//设置天沟
	{
		jsgnum = 0;
		for (i = 0; i < LinkRoad->LJSGouPtNum; i++)
		{
			xx = LinkRoad->LJSgou[i * 2];
			if (fabs(xx) > 0.0001)
			{
				y = LinkRoad->LJSgou[i * 2 + 1] + Earh - LinkRoad->Ymin;
				pCross.LeftJSGouPart->m_JSGouPoints[jsgnum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.LeftJSGouPart->m_JSGouPoints[jsgnum].y = pCross.m_OriPoint.y + y * Sfactor;
				jsgnum++;
			}

		}
		pCross.LeftJSGouPart->JSGouPtNum = jsgnum;

		pCross.LeftJSGouPart->m_GouBotH = LinkRoad->LJSgou[2 * 1 + 1] + Earh;//沟底中心地面高程
		pCross.LeftJSGouPart->m_GouBotX = 0.5*(LinkRoad->LJSgou[2 * 2] + LinkRoad->LJSgou[2 * 1]);//沟底中心的小x坐标
		pCross.LeftJSGouPart->m_GouBotPoint.x = 0.5*(pCross.LeftJSGouPart->m_JSGouPoints[1].x + pCross.LeftJSGouPart->m_JSGouPoints[2].x);
		pCross.LeftJSGouPart->m_GouBotPoint.y = pCross.LeftJSGouPart->m_JSGouPoints[1].y;
		pCross.LeftJSGouPart->m_OriGouBotPt = pCross.LeftJSGouPart->m_GouBotPoint;
	}

	//   
	//右侧路堤水沟参数
	// pCross.RightLTGouPart = NULL;
	pCross.RightLTGouPart = new LTGOU_ROAD;
	pCross.RightLTGouPart->m_cml = pCross.m_cml;
	pCross.RightLTGouPart->m_IfSetBotH = LinkRoad->RIfSetGouH;
	pCross.RightLTGouPart->m_ZorY = 1;
	if (pCross.RightDesignLinePart->m_DesignPointNum > 0)
		pCross.RightLTGouPart->m_PJDpt = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1];

	if (pCross.xjj > 0.0001)//左线为主线
	{
		FindSG(pCross.m_cml, ZDroad.pm, ZDroad.hdmbz.NZLDSG, ZDroad.hdmbz.ZLDSG,
			goupro, pCross.RightLTGouPart->PSG_JQHD,
			pCross.RightLTGouPart->m_T2W, pCross.RightLTGouPart->m_T1W,
			pCross.RightLTGouPart->m_T2H, pCross.RightLTGouPart->m_GH,
			pCross.RightLTGouPart->m_GW, pCross.RightLTGouPart->m_HH,
			pCross.RightLTGouPart->m_SP1, pCross.RightLTGouPart->m_SP2, pCross.RightLTGouPart->m_SP3, pCross.RightLTGouPart->m_PSG_GDR);//加浆砌厚度
		pCross.RightLTGouPart->GouProperty = goupro;
	}
	else
	{
		int ifld;
		ifld = GetIRoadByName(LinkRoad->FLDname);
		FindSG(LinkRoad->FLDcml, road[ifld].pm, road[ifld].hdmbz.NZLDSG, road[ifld].hdmbz.ZLDSG,
			goupro, pCross.RightLTGouPart->PSG_JQHD,
			pCross.RightLTGouPart->m_T2W, pCross.RightLTGouPart->m_T1W,
			pCross.RightLTGouPart->m_T2H, pCross.RightLTGouPart->m_GH,
			pCross.RightLTGouPart->m_GW, pCross.RightLTGouPart->m_HH,
			pCross.RightLTGouPart->m_SP1, pCross.RightLTGouPart->m_SP2, pCross.RightLTGouPart->m_SP3, pCross.RightLTGouPart->m_PSG_GDR);//加浆砌厚度
		pCross.RightLTGouPart->GouProperty = goupro;
	}


	pCross.RightJSGouPart = new JSGOU_ROAD;
	if (pCross.xjj > 0.0001)//左线为主线
		FindTG(pCross.m_cml, ZDroad.pm, ZDroad.hdmbz.NYTG, ZDroad.hdmbz.YTG, pCross.RightJSGouPart->BJ, pCross.RightJSGouPart->GW,
			pCross.RightJSGouPart->GS, pCross.RightJSGouPart->SP1,
			pCross.RightJSGouPart->SP2, pCross.RightJSGouPart->TG_JQHD, pCross.RightJSGouPart->TG_GDR);
	else
	{
		int ifld;
		ifld = GetIRoadByName(LinkRoad->FLDname);
		FindTG(LinkRoad->FLDcml, road[ifld].pm, road[ifld].hdmbz.NYTG, road[ifld].hdmbz.YTG, pCross.RightJSGouPart->BJ, pCross.RightJSGouPart->GW,
			pCross.RightJSGouPart->GS, pCross.RightJSGouPart->SP1,
			pCross.RightJSGouPart->SP2, pCross.RightJSGouPart->TG_JQHD, pCross.RightJSGouPart->TG_GDR);
	}

	_tcscpy(pCross.RightJSGouPart->m_ckml, pCross.m_ckml);
	pCross.RightJSGouPart->m_ZorY = 1;
	pCross.RightJSGouPart->JSGouPtNum = 0;
	pCross.RightLTGouPart->GouProperty = LinkRoad->RGouProperty;

	if (LinkRoad->RGouProperty == 1 && LinkRoad->RGouPtNum > 0)//有路堤水沟
	{
		gounum = 0;
		pCross.RightLTGouPart->m_LTGouPointNum = 0;
		for (i = 0; i < LinkRoad->RGouPtNum; i++)
		{
			xx = LinkRoad->Rgou[i * 2];
			if (xx > 0.0001)
			{
				y = LinkRoad->Rgou[i * 2 + 1] + Earh - LinkRoad->Ymin;
				pCross.RightLTGouPart->m_LTGouPoints[gounum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.RightLTGouPart->m_LTGouPoints[gounum].y = pCross.m_OriPoint.y + y * Sfactor;//+ pCross.m_TWH;
				gounum++;
			}
		}
		pCross.RightLTGouPart->m_LTGouPointNum = gounum;
		if (gounum >= 5)
		{
			pCross.RightLTGouPart->m_GouBotH = LinkRoad->Rgou[2 * 2 + 1] + Earh + pCross.RightLTGouPart->PSG_JQHD;
			pCross.RightLTGouPart->m_GouBotX = 0.5*(LinkRoad->Rgou[3 * 2] + LinkRoad->Rgou[2 * 2]);
			pCross.RightLTGouPart->m_GouBotPoint.x = 0.5*(pCross.RightLTGouPart->m_LTGouPoints[3].x + pCross.RightLTGouPart->m_LTGouPoints[2].x);
			pCross.RightLTGouPart->m_GouBotPoint.y = pCross.RightLTGouPart->m_LTGouPoints[3].y;
			pCross.RightLTGouPart->m_OriGouBotPt = pCross.RightLTGouPart->m_GouBotPoint;
		}

	}
	else if (LinkRoad->RGouProperty == 0)
	{

		AcGePoint3d JD, preJD;
		JD.x = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].x;
		JD.y = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y;
		preJD.x = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 2].x;
		preJD.y = pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 2].y;
		CalPjqPt(1, JD, preJD, pjqptnum, PjqPt);
		pCross.RightLTGouPart->pjqptnum = pjqptnum;
		for (m = 0; m < pjqptnum; m++)
		{
			pCross.RightLTGouPart->PjqPt[m].x = PjqPt[2 * m];
			pCross.RightLTGouPart->PjqPt[m].y = PjqPt[2 * m + 1];

		}

	}
	else if (LinkRoad->RGouProperty == 2 && LinkRoad->RJSGouPtNum > 0)//设置天沟
	{
		jsgnum = 0;
		for (i = 0; i < LinkRoad->RJSGouPtNum; i++)
		{
			xx = LinkRoad->RJSgou[i * 2];

			if (fabs(xx) > 0.0001)
			{
				y = LinkRoad->RJSgou[i * 2 + 1] + Earh - LinkRoad->Ymin;
				pCross.RightJSGouPart->m_JSGouPoints[jsgnum].x = pCross.m_OriPoint.x + xx * Sfactor;
				pCross.RightJSGouPart->m_JSGouPoints[jsgnum].y = pCross.m_OriPoint.y + y * Sfactor;
				jsgnum++;
			}
		}
		pCross.RightJSGouPart->JSGouPtNum = jsgnum;
		pCross.RightJSGouPart->m_GouBotH = LinkRoad->RJSgou[2 * 1 + 1] + Earh;//沟底中心地面高程
		pCross.RightJSGouPart->m_GouBotX = 0.5*(LinkRoad->RJSgou[2 * 2] + LinkRoad->RJSgou[2 * 1]);//沟底中心的小x坐标
		pCross.RightJSGouPart->m_GouBotPoint.x = 0.5*(pCross.RightJSGouPart->m_JSGouPoints[1].x + pCross.RightJSGouPart->m_JSGouPoints[2].x);
		pCross.RightJSGouPart->m_GouBotPoint.y = pCross.RightJSGouPart->m_JSGouPoints[1].y;
		pCross.RightJSGouPart->m_OriGouBotPt = pCross.RightJSGouPart->m_GouBotPoint;
	}
	pCross.m_EarH = ZDroad.hdmdmx[k].EarH;
	//	   pCross.LeftEarthLinePart = new EarthLine;
	//	   pCross.RightEarthLinePart = new EarthLine;
	//	   _tcscpy(pCross.LeftEarthLinePart->m_ckml,pCross.m_ckml);
	//	   _tcscpy(pCross.RightEarthLinePart->m_ckml,pCross.m_ckml);
	//	   pCross.LeftEarthLinePart->m_cml = pCross.m_cml;
	//	   pCross.RightEarthLinePart->m_cml = pCross.m_cml;
	//	   pCross.LeftEarthLinePart->m_twh = pCross.m_ZTWH ;
	//	   pCross.RightEarthLinePart->m_twh = pCross.m_YTWH ;
	//	   pCross.LeftEarthLinePart->EarH = pCross.RightEarthLinePart->EarH = ZDroad.hdmdmx[k].EarH;
	//
	//	   _tcscpy(pCross.LeftEarthLinePart->m_ZorY ,L"左侧");
	//	   _tcscpy(pCross.RightEarthLinePart->m_ZorY ,L"右侧");
	//	   pCross.LeftEarthLinePart->m_EarthPointNum = newNumL ;
	//	   pCross.RightEarthLinePart->m_EarthPointNum = newNumR ;
	//	   if(pCross.LeftEarthLinePart->m_EarthPoints){delete pCross.LeftEarthLinePart->m_EarthPoints;pCross.LeftEarthLinePart->m_EarthPoints=NULL;}
	//	   if(pCross.LeftEarthLinePart->m_EarthPointNum>0)
	//	   {
	//		   pCross.LeftEarthLinePart->m_EarthPoints = new AcGePoint3d[pCross.LeftEarthLinePart->m_EarthPointNum];
	//		   y = Earh -  LinkRoad->Ymin;
	//		   pCross.LeftEarthLinePart->m_EarthPoints[0].x = pCross.m_OriPoint.x;
	//		   pCross.LeftEarthLinePart->m_EarthPoints[0].y = pCross.m_OriPoint.y + y*Sfactor;
	//	   }
	//	   if(pCross.RightEarthLinePart->m_EarthPoints){delete pCross.RightEarthLinePart->m_EarthPoints,pCross.RightEarthLinePart->m_EarthPoints=NULL;}
	//	   if(pCross.RightEarthLinePart->m_EarthPointNum>0)
	//	   {
	//		   pCross.RightEarthLinePart->m_EarthPoints = new AcGePoint3d[pCross.RightEarthLinePart->m_EarthPointNum];
	//		   y = Earh -  LinkRoad->Ymin;
	//		   pCross.RightEarthLinePart->m_EarthPoints[0].x = pCross.m_OriPoint.x;
	//		   pCross.RightEarthLinePart->m_EarthPoints[0].y = pCross.m_OriPoint.y+ y*Sfactor;
	//	   }
	//
	//       pCross.LeftEarthLinePart->m_OriPoint.x=pCross.m_OriPoint.x;
	//	   pCross.LeftEarthLinePart->m_OriPoint.y=pCross.m_OriPoint.y;
	//       pCross.LeftEarthLinePart->bzpoint.x=pCross.LeftEarthLinePart->m_EarthPoints[0].x-LinkRoad->offsetX*Sfactor;//地面高程标注点,
	//	    y = ZDroad.hdmdmx[k].EarH -  LinkRoad->Ymin;
	//	   pCross.LeftEarthLinePart->bzpoint.y = pCross.m_OriPoint.y + y*Sfactor;//地面高程标注点,与一线有关
	//	   for(j=1; j<pCross.LeftEarthLinePart->m_EarthPointNum; j++)
	//	   {
	//			   xx = -1.0*newLearpt[j*2];
	//			   y = newLearpt[j*2+1] +Earh - LinkRoad->Ymin;
	//			   
	//			   pCross.LeftEarthLinePart->m_EarthPoints[j].x = pCross.m_OriPoint.x + xx*Sfactor;
	//			   pCross.LeftEarthLinePart->m_EarthPoints[j].y = pCross.m_OriPoint.y + y*Sfactor;
	//			  
	//	   }
	//	   pCross.RightEarthLinePart->m_OriPoint.x=pCross.m_OriPoint.x;
	//	   pCross.RightEarthLinePart->m_OriPoint.y=pCross.m_OriPoint.y;
	//	   for(j=1; j<pCross.RightEarthLinePart->m_EarthPointNum; j++)
	//	   {
	//	   		   xx = newRearpt[j*2];
	//			   y = newRearpt[j*2+1] + Earh - LinkRoad->Ymin;
	//			   pCross.RightEarthLinePart->m_EarthPoints[j].x = pCross.m_OriPoint.x + xx*Sfactor;
	//			   pCross.RightEarthLinePart->m_EarthPoints[j].y = pCross.m_OriPoint.y + y*Sfactor;
	//			   
	//	   }
	//  			   

	//画天沟的浆切

	if (LinkRoad->LGouProperty == 2 && LinkRoad->LJSGouPtNum > 0)
	{
		TGhasJQ(-1, pCross.LeftJSGouPart->m_JSGouPoints, pCross.LeftJSGouPart->TG_JQHD,
			pCross.LeftJSGouPart->SP1, pCross.LeftJSGouPart->SP2, pCross.LeftJSGouPart->GS, pCross.LeftJSGouPart->TG_GDR,
			pCross.LeftJSGouPart->JqPtNum, pCross.LeftJSGouPart->JqPt,
			pCross.LeftEarthLinePart->m_EarthPointNum, pCross.LeftEarthLinePart->m_EarthPoints);

	}
	if (LinkRoad->RGouProperty == 2 && LinkRoad->RJSGouPtNum > 0)
	{
		TGhasJQ(1, pCross.RightJSGouPart->m_JSGouPoints, pCross.RightJSGouPart->TG_JQHD,
			pCross.RightJSGouPart->SP1, pCross.RightJSGouPart->SP2, pCross.RightJSGouPart->GS, pCross.RightJSGouPart->TG_GDR,
			pCross.RightJSGouPart->JqPtNum, pCross.RightJSGouPart->JqPt,
			pCross.RightEarthLinePart->m_EarthPointNum, pCross.RightEarthLinePart->m_EarthPoints);

	}

	//画路堑的侧沟浆切
	double D;
	if (LinkRoad->Lnpt > 0 && LinkRoad->ZZJ > 0.001 && (fabs(pCross.LeftDesignLinePart->m_FillORCut - 1.0) < 0.001 || fabs(pCross.LeftDesignLinePart->m_FillORCut - 3.0) < 0.001))
	{
		if (pCross.xjj > 0.0001)//左线为主线
			Cal_D(LinkRoad->cml, ZDroad.pm, ZDroad.hdmbz.NZLQSG, ZDroad.hdmbz.ZLQSG, &D, &pCross.LeftDesignLinePart->GK,
				&pCross.LeftDesignLinePart->GS, &pCross.LeftDesignLinePart->GP1,
				&pCross.LeftDesignLinePart->GP2, &pCross.LeftDesignLinePart->CG_JQHD, &pCross.LeftDesignLinePart->CG_GDR);
		else
		{
			int ifld;
			ifld = GetIRoadByName(LinkRoad->FLDname);
			Cal_D(LinkRoad->FLDcml, road[ifld].pm, road[ifld].hdmbz.NZLQSG, road[ifld].hdmbz.ZLQSG,
				&D, &pCross.LeftDesignLinePart->GK,
				&pCross.LeftDesignLinePart->GS, &pCross.LeftDesignLinePart->GP1,
				&pCross.LeftDesignLinePart->GP2, &pCross.LeftDesignLinePart->CG_JQHD, &pCross.LeftDesignLinePart->CG_GDR);
		}

		//		   if (pCross.LeftDesignLinePart->m_DesignPointNum>7)//增加该判断条件，否则CGhasJQ()出现数组越界。李伟 2008-03-09
		//		   {
		// 			   CGhasJQ(-1,pCross.LeftDesignLinePart->m_DesignPoints,pCross.LeftDesignLinePart->CG_JQHD,
		// 				   pCross.LeftDesignLinePart->GP1,pCross.LeftDesignLinePart->GP2,pCross.LeftDesignLinePart->GS,
		// 				   pCross.LeftDesignLinePart->JqPtNum,pCross.LeftDesignLinePart->JqPt);
		//			   CGhasJQ(-1,pCross.LeftDesignLinePart->m_DesignPoints,pCross.LeftDesignLinePart->CG_JQHD,pCross.LeftDesignLinePart->CG_GDR,
		//				   pCross.LeftDesignLinePart->JqPtNum,pCross.LeftDesignLinePart->JqPt);
		//		   }

	}

	if (LinkRoad->Rnpt > 0 && (fabs(pCross.RightDesignLinePart->m_FillORCut - 1.0) < 0.001 || fabs(pCross.RightDesignLinePart->m_FillORCut - 3.0) < 0.001))
	{
		if (pCross.xjj > 0.0001)//左线为主线
			Cal_D(LinkRoad->cml, ZDroad.pm, ZDroad.hdmbz.NYLQSG, ZDroad.hdmbz.YLQSG, &D, &pCross.RightDesignLinePart->GK,
				&pCross.RightDesignLinePart->GS, &pCross.RightDesignLinePart->GP1,
				&pCross.RightDesignLinePart->GP2, &pCross.RightDesignLinePart->CG_JQHD, &pCross.RightDesignLinePart->CG_GDR);
		else
		{
			int ifld;
			ifld = GetIRoadByName(LinkRoad->FLDname);
			Cal_D(LinkRoad->FLDcml, road[ifld].pm, road[ifld].hdmbz.NYLQSG, road[ifld].hdmbz.YLQSG,
				&D, &pCross.RightDesignLinePart->GK,
				&pCross.RightDesignLinePart->GS, &pCross.RightDesignLinePart->GP1,
				&pCross.RightDesignLinePart->GP2, &pCross.RightDesignLinePart->CG_JQHD, &pCross.RightDesignLinePart->CG_GDR);
		}

		if (pCross.RightDesignLinePart->m_DesignPointNum > 7)//增加该判断条件，否则CGhasJQ()出现数组越界。李伟 2008-03-09
		{
			// 			   CGhasJQ(1,pCross.RightDesignLinePart->m_DesignPoints,pCross.RightDesignLinePart->CG_JQHD,
			// 				   pCross.RightDesignLinePart->GP1,pCross.RightDesignLinePart->GP2,pCross.RightDesignLinePart->GS,
			// 				   pCross.RightDesignLinePart->JqPtNum,pCross.RightDesignLinePart->JqPt);
			//  			   CGhasJQ(1,pCross.RightDesignLinePart->m_DesignPoints,pCross.RightDesignLinePart->CG_JQHD,pCross.RightDesignLinePart->CG_GDR,
			//  				   pCross.RightDesignLinePart->JqPtNum,pCross.RightDesignLinePart->JqPt);
		}

	}
	//画水沟的浆切
	if (LinkRoad->LGouProperty == 1 && LinkRoad->LGouPtNum > 0)
		// 	     SGhasJQ(-1,pCross.LeftLTGouPart->m_LTGouPointNum,pCross.LeftLTGouPart->m_LTGouPoints,pCross.LeftLTGouPart->PSG_JQHD,
			// 			   pCross.LeftLTGouPart->m_SP1,pCross.LeftLTGouPart->m_SP2,pCross.LeftLTGouPart->m_GH,pCross.LeftLTGouPart->m_PSG_GDR,
				// 			   pCross.LeftLTGouPart->JqPtNum,pCross.LeftLTGouPart->JqPt);
	{

		SGhasJQ(-1, pCross.LeftLTGouPart->m_LTGouPointNum, pCross.LeftLTGouPart->m_LTGouPoints, pCross.LeftLTGouPart->PSG_JQHD,
			pCross.LeftLTGouPart->JqPtNum, pCross.LeftLTGouPart->JqPt);
	}
	if (LinkRoad->RGouProperty == 1 && LinkRoad->RGouPtNum > 0)
		// 		   SGhasJQ(1,pCross.RightLTGouPart->m_LTGouPointNum,pCross.RightLTGouPart->m_LTGouPoints,pCross.RightLTGouPart->PSG_JQHD,
			// 		   pCross.RightLTGouPart->m_SP1,pCross.RightLTGouPart->m_SP2,pCross.RightLTGouPart->m_GH,pCross.RightLTGouPart->m_PSG_GDR,
				// 		   pCross.RightLTGouPart->JqPtNum,pCross.RightLTGouPart->JqPt);
		SGhasJQ(1, pCross.RightLTGouPart->m_LTGouPointNum, pCross.RightLTGouPart->m_LTGouPoints, pCross.RightLTGouPart->PSG_JQHD,
			pCross.RightLTGouPart->JqPtNum, pCross.RightLTGouPart->JqPt);
	/*
	//线间沟的浆切
	if(LinkRoad->DorS==2)
	{
	pCross.RightDesignLinePart->DorS=LinkRoad->DorS;
	Cal_D(LinkRoad->cml,RightHdmData.NLQSG,RightHdmData.LQSG,&D,&pCross.RightDesignLinePart->GK,
	&pCross.RightDesignLinePart->GS,&pCross.RightDesignLinePart->GP1,
	&pCross.RightDesignLinePart->GP2,&pCross.RightDesignLinePart->CG_JQHD);
	XJGhasJQ(1,pCross.RightDesignLinePart->m_DesignPointNum, pCross.RightDesignLinePart->m_DesignPoints,
	pCross.RightDesignLinePart->CG_JQHD,pCross.RightDesignLinePart->XGJqPtNum,pCross.RightDesignLinePart->XGJqPt);
	}*/


	double Ymin, Ymax;
	if (pCross.LeftDesignLinePart->m_DesignPointNum > 0)
		Ymax = pCross.LeftDesignLinePart->m_DesignPoints[0].y > pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y ? pCross.LeftDesignLinePart->m_DesignPoints[0].y : pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
	if (pCross.RightDesignLinePart->m_DesignPointNum > 0)
		Ymax = Ymax < pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y ? pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y : Ymax;
	if (pCross.LeftDesignLinePart->m_DesignPointNum > 0)
		Ymin = pCross.LeftDesignLinePart->m_DesignPoints[0].y < pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y ? pCross.LeftDesignLinePart->m_DesignPoints[0].y : pCross.LeftDesignLinePart->m_DesignPoints[pCross.LeftDesignLinePart->m_DesignPointNum - 1].y;
	if (pCross.RightDesignLinePart->m_DesignPointNum > 0)
		Ymin = Ymin > pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y ? pCross.RightDesignLinePart->m_DesignPoints[pCross.RightDesignLinePart->m_DesignPointNum - 1].y : Ymin;
	if (!pCross.IsLinkHdm && (pCross.RightDesignLinePart->m_DesignPointNum > 0 || pCross.LeftDesignLinePart->m_DesignPointNum > 0))
		SetSZoomCorner(pCross, ZDroad, k);//设置单路面Zoom两个角点

	/////////////////////////////////////  
	//标注内容
	pCross.Note = new HdmText_ROAD;
	pCross.Note->DorS = LinkRoad->DorS;//单双路面;
	pCross.Note->XJJ = LinkRoad->xjj;
	_tcscpy(pCross.Note->m_ckml, LinkRoad->ckml);
	_tcscpy(pCross.Note->FLD_ckml, pCross.m_FLDckml);

	pCross.Note->EarH = ZDroad.hdmdmx[k].EarH;
	//if(fabs(LinkRoad->ZHc-LinkRoad->YHc)<0.001)
	pCross.Note->ZZ_twh = LinkRoad->ZHc;//暂时标左侧
	pCross.Note->ZY_twh = LinkRoad->YHc;//暂时标右侧
	pCross.Note->YZ_twh = LinkRoad->Y_ZHc;//暂时标左侧
	pCross.Note->YY_twh = LinkRoad->Y_YHc;//暂时标右侧

	pCross.Note->m_fillarea = LinkRoad->at;
	pCross.Note->m_cutarea = LinkRoad->aw;
	pCross.Note->DuoluoInf = LinkRoad->DuanLuoInf;
	pCross.Note->DorS = LinkRoad->DorS;
	pCross.Note->offsetX = LinkRoad->offsetX;
	pCross.Note->YoffsetX = LinkRoad->YoffsetX;
	pCross.Note->BTinf = LinkRoad->ZDMXZ;
	pCross.Note->Y_BTinf = LinkRoad->YDMXZ;
	pCross.Note->LZDK = LinkRoad->LZDK;
	pCross.Note->RZDK = LinkRoad->RZDK;
	pCross.Note->Z_LFillArea = LinkRoad->Z_LFillArea; pCross.Note->MidFillArea = LinkRoad->MidFillArea; pCross.Note->Y_RFillArea = LinkRoad->Y_RFillArea;
	pCross.Note->Z_LCutArea = LinkRoad->Z_LCutArea; pCross.Note->MidCutArea = LinkRoad->MidCutArea; pCross.Note->Y_RCutArea = LinkRoad->Y_RCutArea;
	pCross.Note->Z_LFillSSTArea = LinkRoad->Z_LFillSSTArea; pCross.Note->MidFillSSTArea = LinkRoad->MidFillSSTArea; pCross.Note->Y_RFillSSTArea = LinkRoad->Y_RFillSSTArea;//填渗水土面积
	pCross.Note->Z_LQBTArea = LinkRoad->Z_LQBTArea; pCross.Note->MidQBTArea = LinkRoad->MidQBTArea; pCross.Note->Y_RQBTArea = LinkRoad->Y_RQBTArea;
	pCross.Note->Z_LFillBetterSoilArea = LinkRoad->Z_LFillBetterSoilArea; pCross.Note->MidFillGLTArea = LinkRoad->MidFillGLTArea; pCross.Note->Y_RFillBetterSoilArea = LinkRoad->Y_RFillBetterSoilArea;
	pCross.Note->Z_LHJarea = LinkRoad->Z_LHJarea; pCross.Note->MidHJarea = LinkRoad->MidHJarea; pCross.Note->Y_RHJarea = LinkRoad->Y_RHJarea;
	pCross.Note->Z_LSGJQarea = LinkRoad->Z_LSGJQarea; pCross.Note->MidGouJQarea = LinkRoad->MidGouJQarea; pCross.Note->Y_RSGJQarea = LinkRoad->Y_RSGJQarea;
	pCross.Note->Z_LDQlength = LinkRoad->Z_LDQlength; pCross.Note->MidDQlength = LinkRoad->MidDQlength; pCross.Note->Y_RDQlength = LinkRoad->Y_RDQlength;//挡墙坡长
	pCross.Note->Z_LGrasslength = LinkRoad->Z_LGrasslength; pCross.Note->MidGrasslength = LinkRoad->MidGrasslength; pCross.Note->Y_RGrasslength = LinkRoad->Y_RGrasslength;//铺草坡长
	pCross.Note->Z_LGouTarea = LinkRoad->Z_LGouTarea; pCross.Note->Y_RGouTarea = LinkRoad->Y_RGouTarea;
	pCross.Note->Z_LGouWarea = LinkRoad->Z_LGouWarea; pCross.Note->Y_RGouWarea = LinkRoad->Y_RGouWarea;

	// 标注在一线下
	//形成边坡字符
	pCross.LeftDesignLinePart->SetBPStr(pCross.LeftDesignLinePart->m_FillORCut, pCross.LeftDesignLinePart->m_DesignPointNum, pCross.LeftDesignLinePart->m_DesignPoints, pCross.Note->m_ZBP, pCross.Note->m_ZSlopPt, -1);
	pCross.RightDesignLinePart->SetBPStr(pCross.RightDesignLinePart->m_FillORCut, pCross.RightDesignLinePart->m_DesignPointNum, pCross.RightDesignLinePart->m_DesignPoints, pCross.Note->m_YBP, pCross.Note->m_YSlopPt, 1);

	return Adesk::kTrue;
}

void HdmDes::Draw_FLD_Hdm(int iroad)
{
	double Learpt[400], Rearpt[400];
	double LBenchPt[400], RBenchPt[400];
	double ZX_LearptOnLJZX[400], ZX_RearptOnLJZX[400];
	double FLX_LearptOnLJZX[400], FLX_RearptOnLJZX[400];
	double ZX_EarHOnLJZX, FLX_EarHOnLJZX;
	double ZX_EarHOnXLZX, FLX_EarHOnXLZX;
	int OffsetNumLearpt, OffsetNumRearpt;
	int NumLearpt, NumRearpt;

	//int  DorS;
	int i;
	AcGePoint3d pt;
	CROSS pCross;
	CROSS GLCross;

	if (acdbHostApplicationServices()->workingDatabase()->loadLineTypeFile(L"DASHDOTX2", L"acadiso.lin") != Acad::eOk)
		//	ads_printf(L"加载DASHDOTX2线形失败!\n");
		CreateLayer(L"Hdm");//建立Hdm层

//计算绘图起点

	CalFLDDrawStartPt(iroad, pt);

	Cal_CrossOriPt(iroad, pt);//得到每个横断面的绘图原点


	CString pszLabel = "正在绘制分离线横断面";
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);
	for (i = 0; i < road[iroad].NCRS; i++)
	{
		try
		{
			int pos = (int)i*100.0 / road[iroad].NCRS;
			acedSetStatusBarProgressMeterPos(pos);
			if (road[iroad].hdmdes[i].cml > road[iroad].LJFLSmlOnFLD - 0.01 &&
				road[iroad].hdmdes[i].cml < road[iroad].LJFLEmlOnFLD + 0.01)//位于分离段上,按单线设计
			{
				int k;
				for (k = 0; k < road[iroad].hdmdmx[i].ZEarPtNum; k++)
				{
					Learpt[k * 2] = road[iroad].hdmdmx[i].ZEarPtAry[k].x;
					Learpt[k * 2 + 1] = road[iroad].hdmdmx[i].ZEarPtAry[k].y;
				}
				for (k = 0; k < road[iroad].hdmdmx[i].YEarPtNum; k++)
				{
					Rearpt[k * 2] = road[iroad].hdmdmx[i].YEarPtAry[k].x;
					Rearpt[k * 2 + 1] = road[iroad].hdmdmx[i].YEarPtAry[k].y;
				}

				//////////////////////////////////////////////////////////////////////////
				for (k = 0; k < road[iroad].hdmBench[i].ZEarPtNum; k++)
				{
					LBenchPt[k * 2] = road[iroad].hdmBench[i].ZEarPtAry[k].x;
					LBenchPt[k * 2 + 1] = road[iroad].hdmBench[i].ZEarPtAry[k].y;
				}
				for (k = 0; k < road[iroad].hdmBench[i].YEarPtNum; k++)
				{
					RBenchPt[k * 2] = road[iroad].hdmBench[i].YEarPtAry[k].x;
					RBenchPt[k * 2 + 1] = road[iroad].hdmBench[i].YEarPtAry[k].y;
				}
				//////////////////////////////////////////////////////////////////////////
				//考虑路基中线与线路中线不重合，将相对于线路中线的地面点数据平移到路基中线（修改）
				ZX_EarHOnXLZX = road[iroad].hdmdmx[i].EarH;//线路中线处的地面标高
				NumLearpt = road[iroad].hdmdmx[i].ZEarPtNum;
				NumRearpt = road[iroad].hdmdmx[i].YEarPtNum;
				CalNewZB(road[iroad].hdmdes[i].OffsetByXLZX, ZX_EarHOnXLZX, Learpt, NumLearpt, Rearpt, NumRearpt,
					ZX_EarHOnLJZX, ZX_LearptOnLJZX, OffsetNumLearpt, ZX_RearptOnLJZX, OffsetNumRearpt);
				//////////////////////////////////////////////////////////////////////////
				road[iroad].hdmdes[i].newLYd = road[iroad].hdmdes[i].newRYd = road[iroad].hdmdmx[i].EarH;
				//左右都是桥
				if (road[iroad].hdmdes[i].ZDMXZ == 3 && road[iroad].hdmdes[i].YDMXZ == 3)
					continue;
				//左右都是隧
				if (road[iroad].hdmdes[i].ZDMXZ == 4 && road[iroad].hdmdes[i].YDMXZ == 4)
					continue;

				if (road[iroad].hdmdes[i].ZDMXZ == -1 || road[iroad].hdmdes[i].ZDMXZ == -2
					|| road[iroad].hdmdes[i].YDMXZ == -1 || road[iroad].hdmdes[i].YDMXZ == -2)
				{
					pt.x = road[iroad].hdmdes[i].tX0;//桥隧处标注点
					pt.y = road[iroad].hdmdes[i].tY0;
					BiaoZhuQS(iroad, road[iroad].hdmdes[i].cml, pt); //标注桥隧位置
				}

				pCross.m_OriPoint.x = road[iroad].hdmdes[i].Xo;
				pCross.m_OriPoint.y = road[iroad].hdmdes[i].Yo;	//每个断面的绘图原点
				pCross.m_BTinf = road[iroad].hdmdes[i].ZDMXZ;
				//	road[iroad].hdmdes[i].xlxz=0;road[iroad].hdmdes[i].r_bh=-1;//一线，用于交互设计

				// 				setCROSSAutoDesignData(pCross,iroad,i,road[iroad].hdmdmx[i].EarH,
				// 					Learpt,road[iroad].hdmdmx[i].ZEarPtNum,Rearpt,road[iroad].hdmdmx[i].YEarPtNum,
				// 					LBenchPt,road[iroad].hdmBench[i].ZEarPtNum,RBenchPt,road[iroad].hdmBench[i].YEarPtNum);

				setCROSSAutoDesignData(pCross, iroad, i, ZX_EarHOnLJZX,
					ZX_LearptOnLJZX, OffsetNumLearpt, ZX_RearptOnLJZX, OffsetNumRearpt,
					LBenchPt, road[iroad].hdmBench[i].ZEarPtNum, RBenchPt, road[iroad].hdmBench[i].YEarPtNum);

				road[iroad].hdmdes[i].DorS = 1;
				pCross.DorS = road[iroad].hdmdes[i].DorS;
				pCross.offset = road[iroad].hdmdes[i].offsetX;//一线中心线相对与新的地面线的移动量

				pCross.Draw();

				road[iroad].hdmdes[i].LgouId = pCross.LgouId;
				road[iroad].hdmdes[i].RgouId = pCross.RgouId;
				//画图框
				if (road[iroad].hdmdes[i].glcml > -0.0001)//有关联断面,绘关联
				{
					int glroad = GetIRoadByName(road[iroad].hdmdes[i].glRoadName);
					int jcross = FindIDM(glroad, road[iroad].hdmdes[i].glcml);
					//				    ads_printf(L"dml=%lf gldml=%lf glroad=%d\n",road[iroad].hdmdes[i].dml,road[glroad].hdmdes[jcross].dml,glroad);	
					int k;
					for (k = 0; k < road[glroad].hdmdmx[jcross].ZEarPtNum; k++)
					{
						Learpt[k * 2] = road[glroad].hdmdmx[jcross].ZEarPtAry[k].x;
						Learpt[k * 2 + 1] = road[glroad].hdmdmx[jcross].ZEarPtAry[k].y;
					}
					for (k = 0; k < road[glroad].hdmdmx[jcross].YEarPtNum; k++)
					{
						Rearpt[k * 2] = road[glroad].hdmdmx[jcross].YEarPtAry[k].x;
						Rearpt[k * 2 + 1] = road[glroad].hdmdmx[jcross].YEarPtAry[k].y;
					}

					//////////////////////////////////////////////////////////////////////////
					//横断面台阶
					for (k = 0; k < road[glroad].hdmBench[jcross].ZEarPtNum; k++)
					{
						LBenchPt[k * 2] = road[glroad].hdmBench[jcross].ZEarPtAry[k].x;
						LBenchPt[k * 2 + 1] = road[glroad].hdmBench[jcross].ZEarPtAry[k].y;
					}
					for (k = 0; k < road[glroad].hdmBench[jcross].YEarPtNum; k++)
					{
						RBenchPt[k * 2] = road[glroad].hdmBench[jcross].YEarPtAry[k].x;
						RBenchPt[k * 2 + 1] = road[glroad].hdmBench[jcross].YEarPtAry[k].y;
					}
					//////////////////////////////////////////////////////////////////////////

					//////////////////////////////////////////////////////////////////////////
					//考虑路基中线与线路中线不重合，将相对于线路中线的地面点数据平移到路基中线（修改）
					FLX_EarHOnXLZX = road[glroad].hdmdmx[jcross].EarH;//线路中线处的地面标高
					NumLearpt = road[glroad].hdmdmx[jcross].ZEarPtNum;
					NumRearpt = road[glroad].hdmdmx[jcross].YEarPtNum;
					CalNewZB(road[glroad].hdmdes[jcross].OffsetByXLZX, FLX_EarHOnXLZX, Learpt, NumLearpt, Rearpt, NumRearpt,
						FLX_EarHOnLJZX, FLX_LearptOnLJZX, OffsetNumLearpt, FLX_RearptOnLJZX, OffsetNumRearpt);
					//////////////////////////////////////////////////////////////////////////

					if (road[iroad].ZxOrYx < 0.0001)//右线分离
					{
						if (road[glroad].hdmdes[jcross].Lnpt > 0)
						{
							if (road[iroad].hdmdes[i].RGouPtNum == 6 || road[iroad].hdmdes[i].RGouPtNum == 16)
							{
								GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[iroad].hdmdes[i].Rgou[2 * (road[iroad].hdmdes[i].RGouPtNum - 1)] - road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].x)*Sfactor;
								road[iroad].hdmdes[i].Rgou[2 * (road[iroad].hdmdes[i].RGouPtNum - 1) + 1] = -road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
							}
							else
							{
								GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[iroad].hdmdes[i].RPTR[road[iroad].hdmdes[i].Rnpt - 1].x - road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].x)*Sfactor;
								//							road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt-1].y = road[iroad].hdmdes[i].RPTR[road[iroad].hdmdes[i].Rnpt-1].y + road[iroad].hdmdmx[i].EarH - road[glroad].hdmdmx[jcross].EarH;
								road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].y = road[iroad].hdmdes[i].RPTR[road[iroad].hdmdes[i].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
							}

						}
						//	dy1 = road[iroad].hdmdes[i].RPTR[road[iroad].hdmdes[i].Rnpt-1].y+road[iroad].hdmdmx[i].EarH-road[iroad].hdmdes[i].RHFR[1];
						//	dy2 = road[iroad].hdmdes[jcross].RHFL[1] - (road[iroad].hdmdes[jcross].RPTL[road[iroad].hdmdes[jcross].Lnpt-1].y+road[iroad].hdmdmx[jcross].EarH);
						GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[iroad].hdmdes[jcross].RHFL[1]-road[iroad].hdmdes[i].RHFR[1])*Sfactor;	//每个断面的绘图原点
					}
					else
					{
						if (road[glroad].hdmdes[jcross].Rnpt > 0)
						{
							if (road[iroad].hdmdes[i].LGouPtNum == 6 || road[iroad].hdmdes[i].LGouPtNum == 16)
							{
								GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[iroad].hdmdes[i].Lgou[2 * (road[iroad].hdmdes[i].LGouPtNum - 1)] - road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].x)*Sfactor;
								//							road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt-1].y = road[iroad].hdmdes[i].RPTL[road[iroad].hdmdes[i].Lnpt-1].y + road[iroad].hdmdmx[i].EarH - road[glroad].hdmdmx[jcross].EarH;
								road[iroad].hdmdes[i].Lgou[2 * (road[iroad].hdmdes[i].LGouPtNum - 1) + 1] = -road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
							}
							else
							{
								GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[iroad].hdmdes[i].RPTL[road[iroad].hdmdes[i].Lnpt - 1].x - road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].x)*Sfactor;
								//							road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt-1].y = road[iroad].hdmdes[i].RPTL[road[iroad].hdmdes[i].Lnpt-1].y + road[iroad].hdmdmx[i].EarH - road[glroad].hdmdmx[jcross].EarH;
								road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].y = road[iroad].hdmdes[i].RPTL[road[iroad].hdmdes[i].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;

							}
						}
						GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[glroad].hdmdes[jcross].RHFR[1]-road[iroad].hdmdes[i].RHFL[1])*Sfactor;	//每个断面的绘图原点
					}
					road[glroad].hdmdes[jcross].Ymin = road[iroad].hdmdes[i].Ymin;
					GLCross.IsLinkHdm = true;
					// 					setCROSSAutoDesignData(GLCross,glroad,jcross,road[glroad].hdmdmx[jcross].EarH,
					// 						Learpt,road[glroad].hdmdmx[jcross].ZEarPtNum,Rearpt,road[glroad].hdmdmx[jcross].YEarPtNum,
					// 						LBenchPt,road[glroad].hdmBench[jcross].ZEarPtNum,RBenchPt,road[glroad].hdmBench[jcross].YEarPtNum);

					setCROSSAutoDesignData(GLCross, glroad, jcross, FLX_EarHOnLJZX,
						FLX_LearptOnLJZX, OffsetNumLearpt, FLX_RearptOnLJZX, OffsetNumRearpt,
						LBenchPt, road[glroad].hdmBench[jcross].ZEarPtNum, RBenchPt, road[glroad].hdmBench[jcross].YEarPtNum);

					road[glroad].hdmdes[jcross].DorS = 1;
					GLCross.DorS = road[glroad].hdmdes[jcross].DorS;
					GLCross.offset = road[glroad].hdmdes[jcross].offsetX;//一线中心线相对与新的地面线的移动量

					//					if(fabs(road[iroad].hdmdes[i].dml-200200)<0.1)
					//						ads_printf(L"fldxjj1=%lf\n",road[iroad].hdmdes[i].xjj);
					//				   ads_printf(L"xjj=%lf %lf %lf\n",road[iroad].hdmdes[i].xjj,pCross.m_OriPoint.x,GLCross.m_OriPoint.x);
					if (fabs(road[iroad].hdmdes[i].xjj) < 3)
						GLCross.BzTWInf = -1;

					GLCross.Draw();

				}

				//画图框	
			}

		}
		catch (...)
		{
			CString ExceptionStr;
			ExceptionStr.Format(L"Draw_FLD_Hdm()函数在i=%d出现异常", i);
		}
	}
	acedSetStatusBarProgressMeterPos(100);
	acedRestoreStatusBar();

}

void HdmDes::CalFLDDrawStartPt(int iroad, AcGePoint3d &pt)
{
	double sml;
	pt.x = 0.0, pt.y = 0.0;
	if (iroad < 1)
		return;
	sml = road[iroad].LJFLSmlOnZx;
	int i;
	for (i = 0; i < road[0].NCRS; i++)
	{
		if (sml < road[0].hdmdes[i].cml + 0.1)
			break;
	}
	if (i < road[0].NCRS - 1)
	{
		pt.x = road[0].hdmdes[i].Xo;//得到绕行段在一线的绘图起点

		if (road[0].hdmdes[i].xjj > 0.0)
			pt.y = road[0].hdmdes[i].Yo - 500 * Sfactor;
		else
			pt.y = road[0].hdmdes[i].Yo + 500 * Sfactor;

	}

}
//依据道路名获取编号
int HdmDes::GetIRoadByName(CString FLDname)
{
	for (int i = 0; i < RoadSum; i++)
	{
		if (road[i].roadname == FLDname)
			return i;
	}
	return 0;
}

//导入横断面设计成果
void HdmDes::ShowCross()
{
	//1读文件 
	if (!ReadFile(false))//横断面标准
		return;

	ReadBDFile();

	//从鼻端文件中读取左右关联道路，若道路总数>0按互通处理，否则按分离式处理
	CString xl1;
	xl1.Format(L"%s,%s", road[0].pm->mdbname, road[0].roadname);

	//	SetHdmLm();//求路面
	FindAndReadLinkRoad_for3d(xl1);
	ads_printf(L"读数据库OK!\n");

	if (ZRoadSum + YRoadSum < 1)//主线无关联道路,只考虑分离式路基设计
	{
		//横断面成果
		if (RoadSum > 0)
		{
			for (int i = 0; i < RoadSum; i++)
			{

				if (!ReadHdmResultFile(i))
					return;

				if (!ReadHdmAreaFile(i))
					return;
			}
			CalTorWforPSandDM(0);
			Draw_ZX_Hdm(road[0].hdmdes[0].cml, road[0].hdmdes[road[0].NCRS - 1].cml);

			//for(i=1; i<RoadSum; i++)
			//	Draw_FLD_Hdm(i);      

			//if(daohang) delete daohang;
			//daohang = NULL;
			//daohang	 = new CHdmDaoHang;
			//daohang->Create(IDD_GENZHONG,acedGetAcadFrame());
			//daohang->ShowWindow(SW_SHOW);
		}
		else
			ads_printf(L"道路总数为0!\n");
	}
	else//有匝道
	{

		if (RoadSum > 0)
		{
			for (int i = 0; i < RoadSum; i++)
			{
				if (!ReadHdmResultFile(i))
					return;
				if (!ReadHdmAreaFile(i))
					return;
			}
			CalTorWforPSandDM(0);
			if (road[0].NCRS > 0)
				Draw_ZD_Hdm(road[0].hdmdes[0].cml, road[0].hdmdes[road[0].NCRS - 1].cml);
			if (daohang) delete daohang;
			daohang = NULL;
			daohang = new CHdmDaoHang;
			daohang->Create(IDD_GENZHONG, acedGetAcadFrame());
			daohang->ShowWindow(SW_SHOW);
		}
		else
			ads_printf(L"道路总数为0!\n");
	}
	if (daohang)
	{
		delete daohang;
	}
	daohang = NULL;
	daohang = new CHdmDaoHang();

	daohang->Create(IDD_GENZHONG, acedGetAcadFrame());
	daohang->ShowWindow(SW_SHOW);
}
//读hdmresult文件
bool HdmDes::ReadHdmResultFile(int i, CString fname)
{
	CString filename;
	FILE *fpr;
	int NCRS;


	filename = Cworkdir + "\\data\\" + "hdmresult." + Pro + "." + road[i].roadname;
	if ((fpr = _wfopen(filename, L"r")) == NULL)
	{
		//20200329梁柱
		ads_printf(L"无法打开%s的hdmresult文件!",filename);
		return  false;
	}
	fwscanf(fpr, L"%d", &NCRS);
	NCRS = fabs(1.0*NCRS);

	//开空间
	if (NCRS > 0)
	{

		if (road[i].NCRS > 0 && road[i].hdmdes)
		{
			for (int j = 0; j < road[i].NCRS; j++)
			{

				if (road[i].hdmdes[j].RPTL.length() > 0)
					road[i].hdmdes[j].RPTL.removeSubArray(0, road[i].hdmdes[j].RPTL.length() - 1);
				if (road[i].hdmdes[j].RPTR.length() > 0)
					road[i].hdmdes[j].RPTR.removeSubArray(0, road[i].hdmdes[j].RPTR.length() - 1);
				if (road[i].hdmdes[j].Y_RPTL.length() > 0)
					road[i].hdmdes[j].Y_RPTL.removeSubArray(0, road[i].hdmdes[j].Y_RPTL.length() - 1);
				if (road[i].hdmdes[j].Y_RPTR.length() > 0)
					road[i].hdmdes[j].Y_RPTR.removeSubArray(0, road[i].hdmdes[j].Y_RPTR.length() - 1);
			}
		}

		if (road[i].hdmdes) delete[]road[i].hdmdes;
		road[i].hdmdes = NULL;

		road[i].NCRS = NCRS;
		road[i].hdmdes = new CRSDAT[road[i].NCRS];

	}
	else
	{
		fclose(fpr);
		return false;
	}

	if (i > 0)//分离段
		fwscanf(fpr, L"%lf%lf%lf%lf%lf%lf",
			&road[i].SmlOnZx, &road[i].LJFLSmlOnZx, &road[i].LJFLSmlOnFLD,
			&road[i].EmlOnZx, &road[i].LJFLEmlOnZx, &road[i].LJFLEmlOnFLD);

	for (int j = 0; j < road[i].NCRS; j++)
	{

		ReadACrossResultData(fpr, i, j);

	}

	fclose(fpr);
	return true;
}
void HdmDes::ReadACrossResultData(FILE *fpr, int iroad, int jcross)
{
	ACHAR tmp[256];

	//第一行	整体信息
	fwscanf(fpr, L"%lf%lf%d%d%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%s",
		&road[iroad].hdmdes[jcross].cml,
		&road[iroad].hdmdes[jcross].dml,
		&road[iroad].hdmdes[jcross].IsInsertHdm,
		&road[iroad].hdmdes[jcross].IfSetDQ,
		&road[iroad].hdmdes[jcross].LZDK,
		&road[iroad].hdmdes[jcross].RZDK,
		&road[iroad].hdmdes[jcross].Ldeltah,
		&road[iroad].hdmdes[jcross].Rdeltah,
		//	&road[iroad].hdmdes[jcross].Y_Ldeltah,
		&road[iroad].hdmdes[jcross].ZCG_GDR,
		&road[iroad].hdmdes[jcross].YCG_GDR,
		&road[iroad].hdmdes[jcross].newLYd,
		//		&road[iroad].hdmdes[jcross].newRYd,	
		&road[iroad].hdmdes[jcross].OffsetByXLZX,
		&road[iroad].hdmdes[jcross].xjj,
		&road[iroad].hdmdes[jcross].ZHTHD,
		&road[iroad].hdmdes[jcross].YHTHD,
		&road[iroad].hdmdes[jcross].glcml,
		tmp
	);
	road[iroad].hdmdes[jcross].newRYd = road[iroad].hdmdes[jcross].newLYd;
	road[iroad].hdmdes[jcross].IfHasZlink = 0;
	road[iroad].hdmdes[jcross].IfHasYlink = 0;
	road[iroad].hdmdes[jcross].FLDname = tmp;
	road[iroad].hdmdes[jcross].glRoadName = tmp;

	CString GH;
	double dml = road[iroad].pm->XLC(road[iroad].hdmdes[jcross].cml, GH);
	_tcscpy(road[iroad].hdmdes[jcross].ckml, road[iroad].pm->LCchr(GH, dml, 3));
	//1.写左线左侧
	//第二行	左断面性质
	fwscanf(fpr, L"%d", &road[iroad].hdmdes[jcross].ZDMXZ);

	//第三行	左路面厚度
	int j;
	for (j = 0; j < 3; j++)
		fwscanf(fpr, L"%lf", &road[iroad].hdmdes[jcross].zlmhd[j]);

	//第四行	路面点
	for (j = 0; j < 5; j++)
		fwscanf(fpr, L"%lf%lf", &road[iroad].hdmdes[jcross].RHFL[2 * j], &road[iroad].hdmdes[jcross].RHFL[2 * j + 1]);
	//第五行	左设计点
	fwscanf(fpr, L"%lf%lf%d", &road[iroad].hdmdes[jcross].Zt, &road[iroad].hdmdes[jcross].ZHc, &road[iroad].hdmdes[jcross].Lnpt);//换行

	if (road[iroad].hdmdes[jcross].RPTL.length() > 0)
		road[iroad].hdmdes[jcross].RPTL.removeSubArray(0, road[iroad].hdmdes[jcross].RPTL.length() - 1);

	for (j = 0; j < road[iroad].hdmdes[jcross].Lnpt; j++)
	{
		double x, y;
		fwscanf(fpr, L"%lf%lf", &x, &y);
		AcGePoint3d pt(x, y, 0);
		road[iroad].hdmdes[jcross].RPTL.append(pt);
	}
	//第六行	排水沟和截水沟
	fwscanf(fpr, L"%d%lf%d%d%d",
		&road[iroad].hdmdes[jcross].LIfSetGouH,
		&road[iroad].hdmdes[jcross].LGouH,
		&road[iroad].hdmdes[jcross].LGouProperty,
		&road[iroad].hdmdes[jcross].LGouPtNum,
		&road[iroad].hdmdes[jcross].LJSGouPtNum);
	//左排水沟
	for (j = 0; j < road[iroad].hdmdes[jcross].LGouPtNum; j++)
		fwscanf(fpr, L"%lf%lf", &road[iroad].hdmdes[jcross].Lgou[j * 2], &road[iroad].hdmdes[jcross].Lgou[j * 2 + 1]);
	//左截水沟
	for (j = 0; j < road[iroad].hdmdes[jcross].LJSGouPtNum; j++)
	{
		fwscanf(fpr, L"%lf%lf", &road[iroad].hdmdes[jcross].LJSgou[j * 2], &road[iroad].hdmdes[jcross].LJSgou[j * 2 + 1]);
	}
	//2.写左线右侧
	//第七行	左线右侧	断面性质
	fwscanf(fpr, L"%d", &road[iroad].hdmdes[jcross].YDMXZ);
	//第八行	左线右侧	路面厚度
	for (j = 0; j < 3; j++)
		fwscanf(fpr, L"%lf", &road[iroad].hdmdes[jcross].ylmhd[j]);

	//第九行	左线右侧	路面点
	for (j = 0; j < 5; j++)
		fwscanf(fpr, L"%lf%lf", &road[iroad].hdmdes[jcross].RHFR[2 * j], &road[iroad].hdmdes[jcross].RHFR[2 * j + 1]);
	//第十行	左线右侧	设计点
	fwscanf(fpr, L"%lf%lf%d ", &road[iroad].hdmdes[jcross].Yt, &road[iroad].hdmdes[jcross].YHc, &road[iroad].hdmdes[jcross].Rnpt);
	if (road[iroad].hdmdes[jcross].RPTR.length() > 0)
		road[iroad].hdmdes[jcross].RPTR.removeSubArray(0, road[iroad].hdmdes[jcross].RPTR.length() - 1);
	for (j = 0; j < road[iroad].hdmdes[jcross].Rnpt; j++)
	{
		double x, y;
		fwscanf(fpr, L"%lf%lf", &x, &y);
		AcGePoint3d pt(x, y, 0);
		road[iroad].hdmdes[jcross].RPTR.append(pt);
	}
	//第十一行	左线右侧	水沟点
	fwscanf(fpr, L"%d%lf%d%d%d", &road[iroad].hdmdes[jcross].RIfSetGouH, &road[iroad].hdmdes[jcross].RGouH, &road[iroad].hdmdes[jcross].RGouProperty, &road[iroad].hdmdes[jcross].RGouPtNum, &road[iroad].hdmdes[jcross].RJSGouPtNum);
	//第十二行	左线右侧	排水沟点
	for (j = 0; j < road[iroad].hdmdes[jcross].RGouPtNum; j++)
		fwscanf(fpr, L"%lf%lf", &road[iroad].hdmdes[jcross].Rgou[j * 2], &road[iroad].hdmdes[jcross].Rgou[j * 2 + 1]);
	//第十二行	左线右侧	截水沟
	for (j = 0; j < road[iroad].hdmdes[jcross].RJSGouPtNum; j++)
		fwscanf(fpr, L"%lf%lf", &road[iroad].hdmdes[jcross].RJSgou[j * 2], &road[iroad].hdmdes[jcross].RJSgou[j * 2 + 1]);

	if (road[iroad].hdmdes[jcross].IfHasZlink)//左有关联道路
	{
		road[iroad].hdmdes[jcross].zlink = new CRSDAT;
		fwscanf(fpr, L"%lf%lf%lf%lf%lf%lf%lf%lf%lf%s",
			&road[iroad].hdmdes[jcross].zlink->cml,
			&road[iroad].hdmdes[jcross].zlink->dml,
			&road[iroad].hdmdes[jcross].zlink->newLYd,
			&road[iroad].hdmdes[jcross].zlink->newRYd,
			&road[iroad].hdmdes[jcross].zlink->xjj,
			&road[iroad].hdmdes[jcross].zlink->FillArea,
			&road[iroad].hdmdes[jcross].zlink->CutArea,
			&road[iroad].hdmdes[jcross].zlink->Ldeltah,
			&road[iroad].hdmdes[jcross].zlink->Rdeltah,

			tmp
		);


		road[iroad].hdmdes[jcross].zlink->glRoadName = tmp;
		//1.写左线左侧
		fwscanf(fpr, L"%d", &road[iroad].hdmdes[jcross].zlink->ZDMXZ);

		//写路面点
		for (j = 0; j < 3; j++)
			fwscanf(fpr, L"%lf ", &road[iroad].hdmdes[jcross].zlink->zlmhd[j]);

		//写路面点
		for (j = 0; j < 5; j++)
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].zlink->RHFL[2 * j], &road[iroad].hdmdes[jcross].zlink->RHFL[2 * j + 1]);

		//左设计点
		fwscanf(fpr, L"%lf%lf%d ", &road[iroad].hdmdes[jcross].zlink->Zt, &road[iroad].hdmdes[jcross].zlink->ZHc, &road[iroad].hdmdes[jcross].zlink->Lnpt);//换行

		if (road[iroad].hdmdes[jcross].zlink->RPTL.length() > 0)
			road[iroad].hdmdes[jcross].zlink->RPTL.removeSubArray(0, road[iroad].hdmdes[jcross].zlink->RPTL.length() - 1);

		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->Lnpt; j++)
		{
			double x, y;
			fwscanf(fpr, L"%lf%lf", &x, &y);
			AcGePoint3d pt(x, y, 0);
			road[iroad].hdmdes[jcross].zlink->RPTL.append(pt);
		}

		//左水沟点
		fwscanf(fpr, L"%d%lf%d%d%d ", &road[iroad].hdmdes[jcross].zlink->LIfSetGouH, &road[iroad].hdmdes[jcross].zlink->LGouH, &road[iroad].hdmdes[jcross].zlink->LGouProperty, &road[iroad].hdmdes[jcross].zlink->LGouPtNum, &road[iroad].hdmdes[jcross].zlink->LJSGouPtNum);
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->LGouPtNum; j++)
		{
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].zlink->Lgou[j * 2], &road[iroad].hdmdes[jcross].zlink->Lgou[j * 2 + 1]);
		}

		//左截水沟
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->LJSGouPtNum; j++)
		{
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].zlink->LJSgou[j * 2], &road[iroad].hdmdes[jcross].zlink->LJSgou[j * 2 + 1]);
		}

		//2.写左线右侧
		//写路面点
		fwscanf(fpr, L"%d", &road[iroad].hdmdes[jcross].zlink->YDMXZ);
		for (j = 0; j < 3; j++)
			fwscanf(fpr, L"%lf ", &road[iroad].hdmdes[jcross].zlink->ylmhd[j]);

		for (j = 0; j < 5; j++)
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].zlink->RHFR[2 * j], &road[iroad].hdmdes[jcross].zlink->RHFR[2 * j + 1]);
		//右设计点
		fwscanf(fpr, L"%lf%lf%d ", &road[iroad].hdmdes[jcross].zlink->Yt, &road[iroad].hdmdes[jcross].zlink->YHc, &road[iroad].hdmdes[jcross].zlink->Rnpt);

		if (road[iroad].hdmdes[jcross].zlink->RPTR.length() > 0)
			road[iroad].hdmdes[jcross].zlink->RPTR.removeSubArray(0, road[iroad].hdmdes[jcross].zlink->RPTR.length() - 1);

		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->Rnpt; j++)
		{
			double x, y;
			fwscanf(fpr, L"%lf%lf", &x, &y);
			AcGePoint3d pt(x, y, 0);
			road[iroad].hdmdes[jcross].zlink->RPTR.append(pt);
		}

		//右水沟点
		fwscanf(fpr, L"%d%lf%d%d%d ", &road[iroad].hdmdes[jcross].zlink->RIfSetGouH, &road[iroad].hdmdes[jcross].zlink->RGouH, &road[iroad].hdmdes[jcross].zlink->RGouProperty, &road[iroad].hdmdes[jcross].zlink->RGouPtNum, &road[iroad].hdmdes[jcross].zlink->RJSGouPtNum);
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->RGouPtNum; j++)
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].zlink->Rgou[j * 2], &road[iroad].hdmdes[jcross].zlink->Rgou[j * 2 + 1]);
		//右截水沟
		for (j = 0; j < road[iroad].hdmdes[jcross].zlink->RJSGouPtNum; j++)
		{
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].zlink->RJSgou[j * 2], &road[iroad].hdmdes[jcross].zlink->RJSgou[j * 2 + 1]);
		}

	}

	if (road[iroad].hdmdes[jcross].IfHasYlink)//左有关联道路
	{
		road[iroad].hdmdes[jcross].ylink = new CRSDAT;
		fwscanf(fpr, L"%lf%lf%lf%lf%lf%lf%lf%lf%lf%s",
			&road[iroad].hdmdes[jcross].ylink->cml,
			&road[iroad].hdmdes[jcross].ylink->dml,
			&road[iroad].hdmdes[jcross].ylink->newLYd,
			&road[iroad].hdmdes[jcross].ylink->newRYd,
			&road[iroad].hdmdes[jcross].ylink->xjj,
			&road[iroad].hdmdes[jcross].ylink->FillArea,
			&road[iroad].hdmdes[jcross].ylink->CutArea,
			&road[iroad].hdmdes[jcross].ylink->Ldeltah,
			&road[iroad].hdmdes[jcross].ylink->Rdeltah,
			tmp
		);
		road[iroad].hdmdes[jcross].ylink->glRoadName = tmp;
		//1.写左线左侧
		fwscanf(fpr, L"%d", &road[iroad].hdmdes[jcross].ylink->ZDMXZ);
		//写路面点
		for (j = 0; j < 3; j++)
			fwscanf(fpr, L"%lf ", &road[iroad].hdmdes[jcross].ylink->zlmhd[j]);
		//写路面点
		for (j = 0; j < 5; j++)
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].ylink->RHFL[2 * j], &road[iroad].hdmdes[jcross].ylink->RHFL[2 * j + 1]);
		//左设计点
		fwscanf(fpr, L"%lf%lf%d ", &road[iroad].hdmdes[jcross].ylink->Zt, &road[iroad].hdmdes[jcross].ylink->ZHc, &road[iroad].hdmdes[jcross].ylink->Lnpt);//换行

		if (road[iroad].hdmdes[jcross].ylink->RPTL.length() > 0)
			road[iroad].hdmdes[jcross].ylink->RPTL.removeSubArray(0, road[iroad].hdmdes[jcross].ylink->RPTL.length() - 1);

		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->Lnpt; j++)
		{
			double x, y;
			fwscanf(fpr, L"%lf%lf", &x, &y);
			AcGePoint3d pt(x, y, 0);
			road[iroad].hdmdes[jcross].ylink->RPTL.append(pt);
		}
		//左水沟点
		fwscanf(fpr, L"%d%lf%d%d%d ", &road[iroad].hdmdes[jcross].ylink->LIfSetGouH, &road[iroad].hdmdes[jcross].ylink->LGouH, &road[iroad].hdmdes[jcross].ylink->LGouProperty, &road[iroad].hdmdes[jcross].ylink->LGouPtNum, &road[iroad].hdmdes[jcross].ylink->LJSGouPtNum);
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->LGouPtNum; j++)
		{
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].ylink->Lgou[j * 2], &road[iroad].hdmdes[jcross].ylink->Lgou[j * 2 + 1]);
		}
		//左截水沟
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->LJSGouPtNum; j++)
		{
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].ylink->LJSgou[j * 2], &road[iroad].hdmdes[jcross].ylink->LJSgou[j * 2 + 1]);
		}
		//2.写左线右侧
		//写路面点
		fwscanf(fpr, L"%d", &road[iroad].hdmdes[jcross].ylink->YDMXZ);
		for (j = 0; j < 3; j++)
			fwscanf(fpr, L"%lf ", &road[iroad].hdmdes[jcross].ylink->ylmhd[j]);

		for (j = 0; j < 5; j++)
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].ylink->RHFR[2 * j], &road[iroad].hdmdes[jcross].ylink->RHFR[2 * j + 1]);
		//右设计点
		fwscanf(fpr, L"%lf%lf%d ", &road[iroad].hdmdes[jcross].ylink->Yt, &road[iroad].hdmdes[jcross].ylink->YHc, &road[iroad].hdmdes[jcross].ylink->Rnpt);
		if (road[iroad].hdmdes[jcross].ylink->RPTR.length() > 0)
			road[iroad].hdmdes[jcross].ylink->RPTR.removeSubArray(0, road[iroad].hdmdes[jcross].ylink->RPTR.length() - 1);

		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->Rnpt; j++)
		{
			double x, y;
			fwscanf(fpr, L"%lf%lf", &x, &y);
			AcGePoint3d pt(x, y, 0);
			road[iroad].hdmdes[jcross].ylink->RPTR.append(pt);
		}
		//右水沟点
		fwscanf(fpr, L"%d%lf%d%d%d ", &road[iroad].hdmdes[jcross].ylink->RIfSetGouH, &road[iroad].hdmdes[jcross].ylink->RGouH, &road[iroad].hdmdes[jcross].ylink->RGouProperty, &road[iroad].hdmdes[jcross].ylink->RGouPtNum, &road[iroad].hdmdes[jcross].ylink->RJSGouPtNum);
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->RGouPtNum; j++)
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].ylink->Rgou[j * 2], &road[iroad].hdmdes[jcross].ylink->Rgou[j * 2 + 1]);
		//右截水沟
		for (j = 0; j < road[iroad].hdmdes[jcross].ylink->RJSGouPtNum; j++)
		{
			fwscanf(fpr, L"%lf%lf ", &road[iroad].hdmdes[jcross].ylink->RJSgou[j * 2], &road[iroad].hdmdes[jcross].ylink->RJSgou[j * 2 + 1]);
		}
	}
	road[iroad].hdmdes[jcross].DorS = 1;
	/*

	if(road[iroad].hdmdes[jcross].DorS==2)//双路面
	{
	fwscanf(fpr,L"%d",&road[iroad].hdmdes[jcross].Y_ZDMXZ);
	for(j=0;j<3;j++)
	fwscanf(fpr,L"%lf",&road[iroad].hdmdes[jcross].Y_zlmhd[j]);

	//3.写右线左侧
	//写路面点
	for(j=0;j<4;j++)
	fwscanf(fpr,L"%lf%lf",&road[iroad].hdmdes[jcross].Y_RHFL[2*j],&road[iroad].hdmdes[jcross].Y_RHFL[2*j+1]);
	fwscanf(fpr,L""); //一行空行
	//右左设计点
	int itmp;
	double tmp;
	fwscanf(fpr,L"%lf%lf%d",&road[iroad].hdmdes[jcross].Y_Zt,&road[iroad].hdmdes[jcross].Y_ZHc,&road[iroad].hdmdes[jcross].Y_Lnpt);
	if(road[iroad].hdmdes[jcross].Y_RPTL.length()>0)
	road[iroad].hdmdes[jcross].Y_RPTL.removeSubArray(0,road[iroad].hdmdes[jcross].Y_RPTL.length()-1);

	for(j=0;j<road[iroad].hdmdes[jcross].Y_Lnpt;j++)
	{
	double x,y;
	fwscanf(fpr,L"%lf%lf",&x,&y);
	AcGePoint3d pt(x,y,0);
	road[iroad].hdmdes[jcross].Y_RPTL.append(pt);
	}	//右水沟点

	//		fwscanf(fpr,L"%lf%lf",&road[iroad].hdmdes[jcross].Y_RPTL[j].x,&road[iroad].hdmdes[jcross].Y_RPTL[j].y);
	//右左水沟点
	fwscanf(fpr,L"%d%lf%d%d%d",&itmp,&tmp,&road[iroad].hdmdes[jcross].Y_LGouProperty,&road[iroad].hdmdes[jcross].Y_LGouPtNum,&road[iroad].hdmdes[jcross].Y_LJSGouPtNum);
	for(j=0; j<road[iroad].hdmdes[jcross].Y_LGouPtNum; j++)
	fwscanf(fpr,L"%lf%lf",&road[iroad].hdmdes[jcross].Y_Lgou[j*2],&road[iroad].hdmdes[jcross].Y_Lgou[j*2+1]);
	//右左截水沟
	for(j=0;j<road[iroad].hdmdes[jcross].Y_LJSGouPtNum;j++)
	fwscanf(fpr,L"%lf%lf",&road[iroad].hdmdes[jcross].Y_LJSgou[j*2],&road[iroad].hdmdes[jcross].Y_LJSgou[j*2+1]);

	//3.写右线右侧
	fwscanf(fpr,L"%d",&road[iroad].hdmdes[jcross].Y_YDMXZ);
	for(j=0;j<3;j++)
	fwscanf(fpr,L"%lf",&road[iroad].hdmdes[jcross].Y_ylmhd[j]);
	//写路面点
	for(j=0;j<4;j++)
	fwscanf(fpr,L"%lf%lf",&road[iroad].hdmdes[jcross].Y_RHFR[2*j],&road[iroad].hdmdes[jcross].Y_RHFR[2*j+1]);

	//写地面线
	//	fwscanf(fpr,L"%d ",&road[iroad].hdmdes[jcross].NumL);
	//	for(j=0;j<&road[iroad].hdmdes[jcross].NumL;j++)
	//		fwscanf(fpr,L"%lf%lf",&road[iroad].hdmdes[jcross].Learpt[j*2],&road[iroad].hdmdes[jcross].Learpt[j*2+1]);
	//	fwscanf(fpr,L"%d ",&road[iroad].hdmdes[jcross].NumR);
	//	for(j=0;j<&road[iroad].hdmdes[jcross].NumR;j++)
	//		fwscanf(fpr,L"%lf%lf",&road[iroad].hdmdes[jcross].Rearpt[j*2],&road[iroad].hdmdes[jcross].Rearpt[j*2+1]);

	//右右设计点
	fwscanf(fpr,L"%lf%lf%d",&road[iroad].hdmdes[jcross].Y_Yt,&road[iroad].hdmdes[jcross].Y_YHc,&road[iroad].hdmdes[jcross].Y_Rnpt);
	if(road[iroad].hdmdes[jcross].Y_RPTR.length()>0)
	road[iroad].hdmdes[jcross].Y_RPTR.removeSubArray(0,road[iroad].hdmdes[jcross].Y_RPTR.length()-1);

	for(j=0;j<road[iroad].hdmdes[jcross].Y_Rnpt;j++)
	{
	double x,y;
	fwscanf(fpr,L"%lf%lf",&x,&y);
	AcGePoint3d pt(x,y,0);
	road[iroad].hdmdes[jcross].Y_RPTR.append(pt);
	}	//右水沟点

	//右右水沟点
	fwscanf(fpr,L"%d%lf%d%d%d",&road[iroad].hdmdes[jcross].RIfSetGouH,&road[iroad].hdmdes[jcross].RGouH,&road[iroad].hdmdes[jcross].Y_RGouProperty,&road[iroad].hdmdes[jcross].Y_RGouPtNum,&road[iroad].hdmdes[jcross].Y_RJSGouPtNum);
	for(j=0; j<road[iroad].hdmdes[jcross].Y_RGouPtNum; j++)
	fwscanf(fpr,L"%lf%lf",&road[iroad].hdmdes[jcross].Y_Rgou[j*2],&road[iroad].hdmdes[jcross].Y_Rgou[j*2+1]);
	//右右截水沟
	for(j=0;j<road[iroad].hdmdes[jcross].Y_RJSGouPtNum;j++)
	fwscanf(fpr,L"%lf%lf",&road[iroad].hdmdes[jcross].Y_RJSgou[j*2],&road[iroad].hdmdes[jcross].Y_RJSgou[j*2+1]);
	}*/
}
//读hdmresult文件
bool HdmDes::ReadHdmAreaFile(int i, CString fname)
{
	CString filename;
	FILE *fpr;
	int ncrs;
	///*if (!_tcscmp(fname, NULL))
	//{
	//	filename = Cworkdir + "\\data\\" + "HdmDetailArea." + Pro + "." + road[i].roadname;
	//}
	//else
	//{
	//	filename = fname;
	//}*/

	filename = Cworkdir + "\\data\\" + "HdmDetailArea." + Pro + "." + road[i].roadname;
	if ((fpr = _wfopen(filename, L"r")) == NULL)
	{
		//20200329梁柱
		ads_printf(L"无法打开%s的hdmarea文件!", filename);
		return false;
	}
	fwscanf(fpr, L"%d", &ncrs);
	//开空间
	if (ncrs > 0)
	{
		for (int j = 0; j < ncrs; j++)
			ReadACrossAreaData(fpr, i, j);
	}

	fclose(fpr);
	return true;

}
void HdmDes::ReadACrossAreaData(FILE * fpr, int iroad, int jcross)
{
	double tmp;
	int itmp;
	//第1行：基本信息
	fwscanf(fpr, L"%lf%d%d%d%d%d", &tmp, &road[iroad].hdmdes[jcross].IsInsertHdm, &itmp, &itmp, &itmp, &itmp);
	//第2行：填方信息
	fwscanf(fpr, L"%d%lf%lf%lf%lf", &itmp, &road[iroad].hdmdes[jcross].FillArea, &road[iroad].hdmdes[jcross].Z_LFillArea, &road[iroad].hdmdes[jcross].MidFillArea, &road[iroad].hdmdes[jcross].Y_RFillArea);
	//第3行：挖方信息
	fwscanf(fpr, L"%lf%lf%lf%lf", &road[iroad].hdmdes[jcross].CutArea, &road[iroad].hdmdes[jcross].Z_LCutArea, &road[iroad].hdmdes[jcross].MidCutArea, &road[iroad].hdmdes[jcross].Y_RCutArea);
	//第4行：？
	for (int j = 0; j < 6; j++)
		fwscanf(fpr, L"%lf", &tmp);
	//fwscanf(fpr,L"%lf%lf%lf%lf",&road[iroad].hdmdes[jcross].FillSSTArea,&road[iroad].hdmdes[jcross].Z_LFillSSTArea,&road[iroad].hdmdes[jcross].MidFillSSTArea,&road[iroad].hdmdes[jcross].Y_RFillSSTArea);
	//第5行：清表土面积
	fwscanf(fpr, L"%lf%lf%lf%lf", &road[iroad].hdmdes[jcross].QBTArea, &road[iroad].hdmdes[jcross].Z_LQBTArea, &road[iroad].hdmdes[jcross].MidQBTArea, &road[iroad].hdmdes[jcross].Y_RQBTArea);
	//fwscanf(fpr,L"%lf%lf%lf%lf",&road[iroad].hdmdes[jcross].FillBetterSoilArea,&road[iroad].hdmdes[jcross].Z_LFillBetterSoilArea,&road[iroad].hdmdes[jcross].MidFillGLTArea,&road[iroad].hdmdes[jcross].Y_RFillBetterSoilArea);
	//ads_printf(L"%lf%lf%lf%lf%lf",&road[iroad].hdmdes[jcross].cml,&road[iroad].hdmdes[jcross].FillBetterSoilArea,&road[iroad].hdmdes[jcross].Z_LFillBetterSoilArea,&road[iroad].hdmdes[jcross].MidFillGLTArea,&road[iroad].hdmdes[jcross].Y_RFillBetterSoilArea);
	//fwscanf(fpr,L"%lf%lf%lf%lf",&road[iroad].hdmdes[jcross].HJarea,&road[iroad].hdmdes[jcross].Z_LHJarea,&road[iroad].hdmdes[jcross].MidHJarea,&road[iroad].hdmdes[jcross].Y_RHJarea);
	//第6行：浆砌面积
	fwscanf(fpr, L"%lf%lf%lf%lf", &road[iroad].hdmdes[jcross].SGJQarea, &road[iroad].hdmdes[jcross].Z_LSGJQarea, &road[iroad].hdmdes[jcross].MidGouJQarea, &road[iroad].hdmdes[jcross].Y_RSGJQarea);
	//第7行：挡墙坡长
	fwscanf(fpr, L"%lf%lf%lf%lf", &road[iroad].hdmdes[jcross].DQlength, &road[iroad].hdmdes[jcross].Z_LDQlength, &road[iroad].hdmdes[jcross].MidDQlength, &road[iroad].hdmdes[jcross].Y_RDQlength);
	//铺草坡长
	fwscanf(fpr, L"%lf%lf%lf%lf", &road[iroad].hdmdes[jcross].Grasslength, &road[iroad].hdmdes[jcross].Z_LGrasslength, &road[iroad].hdmdes[jcross].MidGrasslength, &road[iroad].hdmdes[jcross].Y_RGrasslength);
	//水沟填面积
	fwscanf(fpr, L"%lf%lf%lf", &road[iroad].hdmdes[jcross].GouTarea, &road[iroad].hdmdes[jcross].Z_LGouTarea, &road[iroad].hdmdes[jcross].Y_RGouTarea);
	//水沟挖面积
	fwscanf(fpr, L"%lf%lf%lf", &road[iroad].hdmdes[jcross].GouWarea, &road[iroad].hdmdes[jcross].Z_LGouWarea, &road[iroad].hdmdes[jcross].Y_RGouWarea);
	road[iroad].hdmdes[jcross].at = road[iroad].hdmdes[jcross].FillArea;
	road[iroad].hdmdes[jcross].aw = road[iroad].hdmdes[jcross].CutArea;

}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void HdmDes::ChangeBp(int selectmode, AcDbObjectId DesId, double BPJS, double m_M[], double  m_H[], double m_PTW[])
{
	int ii0, ii1, kk;
	ii0 = ii1 = kk = 0;
	SelectDM(DesId, selectmode, ii0, ii1, kk);//选出单个断面，返回一个ii
	ModifySomeBP(DesId, ii0, ii1, BPJS, m_M, m_H, m_PTW);

}
//修改一段里程断面的边坡参数,当前选种的边坡单独处理
void HdmDes::ModifySomeBP(AcDbObjectId DesId, int ii0, int ii1, int bpjs, double m_M[], double m_H[], double m_PTW[])
{
	int i, j, zory;
	double cml1;
	AcDbObjectId desId;
	AcDbObject* pObj = NULL;
	AcDbEntity * pEnt = NULL;
	DesignLine_ROAD * desline = NULL;
	DesignLine_ROAD *cur_desline = NULL;
	int m_ZorY, iroad;
	CString roadname, curRoadName;
	if (acdbOpenObject(pObj, DesId, AcDb::kForRead) != Acad::eOk)
		return;
	pObj->close();
	cur_desline = DesignLine_ROAD::cast(pObj);
	m_ZorY = cur_desline->m_ZorY;
	curRoadName = cur_desline->RoadName;
	iroad = GetIRoadByName(curRoadName);

	for (i = 0; i < DesLineInfor.length(); i++)
	{
		cml1 = ((ent_Id_Des*)DesLineInfor[i])->cml;
		zory = ((ent_Id_Des*)DesLineInfor[i])->zory;
		roadname = ((ent_Id_Des*)DesLineInfor[i])->roadname;
		if (roadname == curRoadName)
		{
			for (j = ii0; j <= ii1; j++)
			{
				if (fabs(road[iroad].hdmdes[j].cml - cml1) < 0.1&&zory == m_ZorY)
				{
					desId = ((ent_Id_Des*)DesLineInfor[i])->entityId;

					if (acdbOpenObject(pObj, desId, AcDb::kForRead) != Acad::eOk)
						return;
					pObj->close();
					//if(pObj->isKindOf(DesignLine_ROAD::desc()))
					//{							
					//	desline=DesignLine_ROAD::cast(pObj);
					if (acdbOpenObject(pObj, desId, AcDb::kForWrite) == Acad::eOk)
					{
						acDocManager->lockDocument(acDocManager->curDocument(), AcAp::kWrite);
						desline = DesignLine_ROAD::cast(pObj);
						desline->assertWriteEnabled();//加响应器修改实体时，不可少
						passCS(desline, bpjs, m_M, m_H, m_PTW);
						desline->close();
						acDocManager->unlockDocument(acDocManager->curDocument());
						break;
					}
					//}
				}
			}
		}
	}
}
//根据路堤，路站给设计线传递边坡参数
void HdmDes::passCS(DesignLine_ROAD * desline, int bpjs, double m_M[], double m_H[], double m_PTW[])
{
	int i;

	if (desline->m_FillORCut < 0.01)
	{

		desline->m_nLTBPJS = bpjs;
		for (i = 0; i < bpjs; i++)
		{
			desline->m_TM[i] = m_M[i];
			desline->m_TH[i] = m_H[i];
			desline->m_TPTW[i] = m_PTW[i];
		}

	}
	else
	{
		desline->m_nLZBPJS = bpjs;
		for (i = 0; i < bpjs; i++)
		{
			desline->m_WM[i] = m_M[i];
			desline->m_PH[i] = m_H[i];
			desline->m_ZPTW[i] = m_PTW[i];
		}
	}
}

//选择与指定断面有相同填挖信息的里程段的断面序号 ,kk是当前断面，ii0是里程断的首断面，ii1是里程断的尾断面
//selectmode: 0-单个，1-本段,2-全线
void HdmDes::SelectDM(AcDbObjectId DesId, int selectmode, int &ii0, int &ii1, int & kk)
{
	bool iffind;
	int j;
	DesignLine_ROAD * desline = NULL;
	AcDbObject* pObj = NULL;
	if (acdbOpenObject(pObj, DesId, AcDb::kForRead) != Acad::eOk)
		return;
	pObj->close();
	desline = DesignLine_ROAD::cast(pObj);
	int iroad;
	iroad = GetIRoadByName(desline->RoadName);

	for (j = 0; j < road[iroad].NCRS; j++)
		if (fabs(desline->cml - road[iroad].hdmdes[j].cml) < 0.01)
		{
			kk = j; iffind = true; break;
		}//找到选择断面kk

	if (iffind)//找到
	{
		if (selectmode == 0)//只交互单个断面
		{
			ii0 = kk; ii1 = kk; return;
		}///
		else if (selectmode == 2)//全线
		{
			ii0 = 0; ii1 = road[iroad].NCRS - 1; return;
		}
		else//本段
		{
			//向前找寻填挖信息不一样的断面
			for (j = kk - 1; j >= 0; j--)
			{
				if (desline->m_ZorY == -1)
				{
					//桥隧中
					//				   if(road[iroad].hdmdes[j].ZDMXZ==3||road[iroad].hdmdes[j].ZDMXZ==4)
					//					continue;
					//				    if(road[iroad].hdmdes[j].Lnpt==0) break;
					if ((desline->m_FillORCut<0.1 && road[iroad].hdmdes[j].Zt>0.1)
						||
						(desline->m_FillORCut > 0.1 && road[iroad].hdmdes[j].Zt < 0.1))
						break;
				}
				if (desline->m_ZorY == 1)
				{
					if ((desline->m_FillORCut<0.1 && road[iroad].hdmdes[j].Yt>0.1)
						||
						(desline->m_FillORCut > 0.1 && road[iroad].hdmdes[j].Yt < 0.1))
						break;
				}
				if (desline->m_ZorY == -2)//右线左侧
				{
					//	if(hdmdes.Crs[j].Y_Rnpt==0) break;
					if ((desline->m_FillORCut<0.1 && road[iroad].hdmdes[j].Y_Zt>0.1)
						||
						(desline->m_FillORCut > 0.1 && road[iroad].hdmdes[j].Y_Zt < 0.1))
						break;
				}
				if (desline->m_ZorY == 2)//右线右侧
				{
					//	if(hdmdes.Crs[j].Y_Rnpt==0) break;
					if ((desline->m_FillORCut<0.1 && road[iroad].hdmdes[j].Y_Yt>0.1)
						||
						(desline->m_FillORCut > 0.1 && road[iroad].hdmdes[j].Y_Yt < 0.1))
						break;
				}

			}
			if (j == -1) ii0 = 0;
			ii0 = j + 1;

			//向后找寻填挖信息不一样的断面					
			//ads_printf(L"\ncml=%lf",hdmdes.Crs[ii0].cml);
			for (j = kk + 1; j < road[iroad].NCRS; j++)//找寻填挖信息不一样的断面///
			{
				if (desline->m_ZorY == -1)
				{
					//桥隧中
					//				   if(road[iroad].hdmdes[j].ZDMXZ==3||road[iroad].hdmdes[j].ZDMXZ==4)
					//					continue;
					//				    if(road[iroad].hdmdes[j].Lnpt==0) break;
					if ((desline->m_FillORCut<0.1 && road[iroad].hdmdes[j].Zt>0.1)
						||
						(desline->m_FillORCut > 0.1 && road[iroad].hdmdes[j].Zt < 0.1))
						break;
				}
				if (desline->m_ZorY == 1)
				{
					if ((desline->m_FillORCut<0.1 && road[iroad].hdmdes[j].Yt>0.1)
						||
						(desline->m_FillORCut > 0.1 && road[iroad].hdmdes[j].Yt < 0.1))
						break;
				}
				if (desline->m_ZorY == -2)//右线左侧
				{
					//	if(hdmdes.Crs[j].Y_Rnpt==0) break;
					if ((desline->m_FillORCut<0.1 && road[iroad].hdmdes[j].Y_Zt>0.1)
						||
						(desline->m_FillORCut > 0.1 && road[iroad].hdmdes[j].Y_Zt < 0.1))
						break;
				}
				if (desline->m_ZorY == 2)//右线右侧
				{
					//	if(hdmdes.Crs[j].Y_Rnpt==0) break;
					if ((desline->m_FillORCut<0.1 && road[iroad].hdmdes[j].Y_Yt>0.1)
						||
						(desline->m_FillORCut > 0.1 && road[iroad].hdmdes[j].Y_Yt < 0.1))
						break;
				}

			}
			//if(j==hdmdes.NCRS) ii1=hdmdes.NCRS-1;////
			ii1 = j - 1;
			//	ads_printf(L"\n$$ii1=%d,cml=%lf",ii1,hdmdes.Crs[ii1].cml);
		}

	}

}

///第ii个断面的进行交互
void HdmDes::SDM_AutoDesign(DesignLine_ROAD *designline, EarthLine_ROAD * l_earthline, LTGOU_ROAD * LTGou, JSGOU_ROAD* JSGou, EarthLine_ROAD * r_earthline, HdmText_ROAD *Note)
{
	//1、由Note的DorS得到断面是单路面还是双路面
	double DorS;
	int iroad, ii;

	iroad = GetIRoadByName(designline->RoadName);
	ii = designline->hdmno;
	DorS = Note->DorS;

	if (DorS == 1)
		SDM_SingleLMAutoDesign(iroad, ii, designline, LTGou, JSGou, l_earthline, r_earthline, Note);
	else
	{
		ads_printf(L"交互修改双线横断面的功能将在升级版推出!\n");
		//	SDM_DoubleLMAutoDesign(iroad,ii,designline,LTGou,JSGou,l_earthline,r_earthline,Note);
	}

	//ads_printf(L"OK!");
	//3、更新HdmResultData中相应断面的饿信息
	//4、hdmZDK DMZTT hdmArea的相关信息进行更新

}

///////////以下为交互设计
//以下为交互设计
//单路面戴帽子，几统计面积
void HdmDes::SDM_SingleLMAutoDesign(int iroad, int j, DesignLine_ROAD *designline, LTGOU_ROAD *LTGou, JSGOU_ROAD * JSGou, EarthLine_ROAD * l_earthline, EarthLine_ROAD * r_earthline, HdmText_ROAD *Note)
{
	int i;
	double *L_EarPtList, *R_EarPtList;
	int L_EarPtSum, R_EarPtSum;
	double cml;
	int ZorY;
	double xori, yori;
	//单路面	
	double LDesPoint[500], RDesPoint[500], LFillArea, LCutArea, RFillArea, RCutArea;
	double LGouH, LGouX, RGouH, RGouX;
	double LFillBetterSoilArea, LQBTArea, LGouTarea, LGouWarea, LSGJQarea, LDQlength, LGrasslength;
	double RFillBetterSoilArea, RQBTArea, RGouTarea, RGouWarea, RSGJQarea, RDQlength, RGrasslength;
	int Lnpt, Rnpt;
	double TM[30], TH[30], TPTW[30], TPTI[30], WM[30], PH[30], ZPTW[30], ZPTI[30], lmhd[3];
	int nLTBPJS, nLZBPJS;
	int k;

	L_EarPtSum = l_earthline->m_EarthPointNum;
	//if(L_EarPtList) {delete []L_EarPtList;L_EarPtList=NULL;}
	L_EarPtList = new double[(l_earthline->m_EarthPointNum + 1) * 2];
	xori = l_earthline->m_OriPoint.x;
	yori = l_earthline->m_OriPoint.y;
	for (i = 0; i < l_earthline->m_EarthPointNum; i++)
	{
		L_EarPtList[i * 2] = fabs(l_earthline->m_EarthPoints[i].x - xori) / Sfactor;//x为正
		L_EarPtList[i * 2 + 1] = (l_earthline->m_EarthPoints[i].y - yori) / Sfactor + road[iroad].hdmdes[j].Ymin - designline->LnewYd;
	}
	R_EarPtSum = r_earthline->m_EarthPointNum;
	//if(R_EarPtList) {delete []R_EarPtList;R_EarPtList=NULL;}
	R_EarPtList = new double[(r_earthline->m_EarthPointNum + 1) * 2];
	xori = r_earthline->m_OriPoint.x;
	yori = r_earthline->m_OriPoint.y;

	for (i = 0; i < r_earthline->m_EarthPointNum; i++)
	{
		R_EarPtList[i * 2] = fabs(r_earthline->m_EarthPoints[i].x - xori) / Sfactor;//x为正
		R_EarPtList[i * 2 + 1] = (r_earthline->m_EarthPoints[i].y - yori) / Sfactor + road[iroad].hdmdes[j].Ymin - designline->LnewYd;
		//ads_printf(L"\n^^^^^%lf,%lf,%lf,%lf,%lf,%lf",r_earthline->m_EarthPoints[i].y,yori,road[iroad].hdmdes[j].Ymin,designline->LnewYd,R_EarPtList[i*2],R_EarPtList[i*2+1]);
	}
	cml = road[iroad].hdmdes[j].cml;
	ZorY = designline->m_ZorY;
	//2、由Note的offsetX调用calNewZB();得到新的地面线坐标(不需要)

	//3、CrosNew();自动代帽子由地面线、路面点
	AcGePoint3d pt;
	double ZJ = 1000;
	//	ClearSZ(ii,Crs);//清空数组
	if (ZorY == -1)//左线左侧
	{
		if (road[iroad].hdmdes[j].ZDMXZ == 3 || road[iroad].hdmdes[j].ZDMXZ == 4)
			return;

		nLTBPJS = designline->m_nLTBPJS;
		for (i = 0; i < designline->m_nLTBPJS; i++)
		{
			TM[i] = designline->m_TM[i];
			TH[i] = designline->m_TH[i];

			TPTW[i] = designline->m_TPTW[i];
			TPTI[i] = designline->m_TPTI[i];
		}
		nLZBPJS = designline->m_nLZBPJS;
		for (i = 0; i < designline->m_nLZBPJS; i++)
		{
			WM[i] = designline->m_WM[i];
			PH[i] = designline->m_PH[i];
			ZPTW[i] = designline->m_ZPTW[i];
			ZPTI[i] = designline->m_ZPTI[i];
		}

		road[iroad].hdmdes[j].LGouProperty = LTGou->GouProperty;
		SDM_CrosNew(//输入
			iroad,//道路号
			-1, j, designline->LnewYd, L_EarPtSum, L_EarPtList,
			designline->RHF,
			nLTBPJS, TM, TH, TPTW, TPTI,
			nLZBPJS, WM, PH, ZPTW, ZPTI,
			LTGou->PSG_JQHD, LTGou->m_T2W, LTGou->m_T1W, LTGou->m_T2H, LTGou->m_GH, LTGou->m_GW, LTGou->m_HH, LTGou->m_SP1, LTGou->m_SP2, LTGou->m_SP3, LTGou->m_PSG_GDR,
			LTGou->m_IfSetBotH, LTGou->m_GouBotH,
			designline->GK, designline->GS, designline->GP1, designline->GP2, designline->CG_JQHD, designline->CG_GDR,
			JSGou->BJ, JSGou->GW, JSGou->GS, JSGou->SP1, JSGou->SP2, JSGou->TG_JQHD, JSGou->TG_GDR,
			//输出
			lmhd,
			road[iroad].hdmdes[j].Ldeltah, road[iroad].hdmdes[j].Zt, road[iroad].hdmdes[j].ZHc, Lnpt, LDesPoint,
			LFillArea, LFillBetterSoilArea, LQBTArea, LCutArea,
			road[iroad].hdmdes[j].LZDK,
			road[iroad].hdmdes[j].LGouProperty, road[iroad].hdmdes[j].LGouPtNum, road[iroad].hdmdes[j].Lgou, LGouH, LGouX, LGouTarea, LGouWarea,
			road[iroad].hdmdes[j].LJSGouPtNum, road[iroad].hdmdes[j].LJSgou,
			LSGJQarea, LDQlength, LGrasslength);

		road[iroad].hdmdes[j].GouTarea = LGouTarea + Note->Y_RGouTarea;//水沟填面积
		road[iroad].hdmdes[j].GouWarea = LGouWarea + Note->Y_RGouWarea;//水沟挖面积
		road[iroad].hdmdes[j].QBTArea = LQBTArea + Note->Y_RQBTArea;//清表土面积
		road[iroad].hdmdes[j].FillArea = LFillArea + LGouTarea + Note->Y_RFillArea;//填面积
		road[iroad].hdmdes[j].CutArea = LCutArea + LGouWarea + Note->Y_RCutArea; //挖面积
		//	road[iroad].hdmdes[j].FillBetterSoilArea = LFillBetterSoilArea+Note->Y_RFillBetterSoilArea;//填改良土面积
		//	road[iroad].hdmdes[j].FillSSTArea = LFillSSTArea + Note->Y_RFillSSTArea;//填渗水土面积
		//	road[iroad].hdmdes[j].HJarea =  LHJarea + Note->Y_RHJarea;//护肩面积
		road[iroad].hdmdes[j].SGJQarea = LSGJQarea + Note->Y_RSGJQarea;//浆砌面积
		road[iroad].hdmdes[j].DQlength = LDQlength + Note->Y_RDQlength;//挡墙坡长
		road[iroad].hdmdes[j].Grasslength = LGrasslength + Note->Y_RGrasslength;//铺草坡长

		road[iroad].hdmdes[j].Z_LFillArea = LFillArea;//填面积
		road[iroad].hdmdes[j].Z_LCutArea = LCutArea; //挖面积
		//	road[iroad].hdmdes[j].Z_LFillBetterSoilArea = LFillBetterSoilArea;//填改良土面积
		//	road[iroad].hdmdes[j].Z_LFillSSTArea = LFillSSTArea;//填渗水土面积
		road[iroad].hdmdes[j].Z_LQBTArea = LQBTArea;//清表土面积
		road[iroad].hdmdes[j].Z_LGouTarea = LGouTarea;//水沟填面积
		road[iroad].hdmdes[j].Z_LGouWarea = LGouWarea;//水沟挖面积
		//	road[iroad].hdmdes[j].Z_LHJarea =  LHJarea ;//护肩面积
		road[iroad].hdmdes[j].Z_LSGJQarea = LSGJQarea;//浆砌面积
		road[iroad].hdmdes[j].Z_LDQlength = LDQlength;//挡墙坡长
		road[iroad].hdmdes[j].Z_LGrasslength = LGrasslength;//铺草坡长

		road[iroad].hdmdes[j].at = road[iroad].hdmdes[j].FillArea;
		road[iroad].hdmdes[j].aw = road[iroad].hdmdes[j].CutArea;

		if (road[iroad].hdmdes[j].RPTL.length() > 0)
			road[iroad].hdmdes[j].RPTL.removeSubArray(0, road[iroad].hdmdes[j].RPTL.length() - 1);

		road[iroad].hdmdes[j].Lnpt = Lnpt;
		if (road[iroad].hdmdes[j].RPTL.length() > 0)
			road[iroad].hdmdes[j].RPTL.removeSubArray(0, road[iroad].hdmdes[j].RPTL.length() - 1);

		for (k = 0; k < Lnpt; k++)
		{
			pt.x = -1.0*LDesPoint[k * 2];
			pt.y = LDesPoint[k * 2 + 1];
			road[iroad].hdmdes[j].RPTL.append(pt);
		}
		road[iroad].hdmdes[j].Ljdnum = road[iroad].hdmdes[j].Lnpt - 1;
		for (k = 0; k < road[iroad].hdmdes[j].LJSGouPtNum; k++)
			road[iroad].hdmdes[j].LJSgou[k * 2] = -1 * road[iroad].hdmdes[j].LJSgou[k * 2];
		for (int kk = 0; kk < road[iroad].hdmdes[j].LGouPtNum; kk++)
			road[iroad].hdmdes[j].Lgou[kk * 2] = -1 * road[iroad].hdmdes[j].Lgou[kk * 2];

		//*************start	20200430新增	天沟属性 *************	
		if (LTGou->GouProperty == 4)
			road[iroad].hdmdes[j].LGouProperty = LTGou->GouProperty;
		//*************end	20200430新增	天沟属性 *************	

		SDM_L_setCROSSAutoDesignData(iroad, j, designline->LnewYd, designline, LTGou, JSGou, l_earthline, r_earthline, Note);

		//*************start	20200430新增	如果是修改过的路堤水沟，那么需要更新路堤沟的数组 *************	
		//路堤水沟
		int CurJQIndex = 0;
		for (int kk = road[iroad].hdmdes[j].LGouPtNum; kk < road[iroad].hdmdes[j].LGouPtNum + LTGou->JqPtNum; kk++)
		{
			double Gutter_X = (LTGou->JqPt[CurJQIndex].x - l_earthline->m_OriPoint.x) / Sfactor;
			double temp_Y = (LTGou->JqPt[CurJQIndex].y - l_earthline->m_OriPoint.y) / Sfactor;
			double Gutter_Y = temp_Y + road[iroad].hdmdes[j].Ymin - designline->LnewYd;

			road[iroad].hdmdes[j].Lgou[kk * 2] = Gutter_X;
			road[iroad].hdmdes[j].Lgou[kk * 2 + 1] = Gutter_Y;

			CurJQIndex++;
		}

		road[iroad].hdmdes[j].LGouPtNum += LTGou->JqPtNum;

		//天沟

		road[iroad].hdmdes[j].LJSGouPtNum = JSGou->JqPtNum;
		for (int kk = 0; kk < JSGou->JqPtNum; kk++)
		{
			double Gutter_X = (JSGou->JqPt[kk].x - l_earthline->m_OriPoint.x) / Sfactor;
			double temp_Y = (JSGou->JqPt[kk].y - l_earthline->m_OriPoint.y) / Sfactor;
			double Gutter_Y = temp_Y + road[iroad].hdmdes[j].Ymin - designline->LnewYd;

			road[iroad].hdmdes[j].LJSgou[kk * 2] = Gutter_X;
			road[iroad].hdmdes[j].LJSgou[kk * 2 + 1] = Gutter_Y;
		}
		//*************end	20200430新增	如果是修改过的路堤水沟，那么需要更新路堤沟的数组 *************	
	}
	else if (ZorY == 1)//左线右侧
	{
		if (road[iroad].hdmdes[j].YDMXZ == 3 || road[iroad].hdmdes[j].YDMXZ == 4)
			return;

		nLTBPJS = designline->m_nLTBPJS;
		for (i = 0; i < designline->m_nLTBPJS; i++)
		{
			TM[i] = designline->m_TM[i];
			TH[i] = designline->m_TH[i];

			TPTW[i] = designline->m_TPTW[i];
			TPTI[i] = designline->m_TPTI[i];
		}
		nLZBPJS = designline->m_nLZBPJS;
		for (i = 0; i < designline->m_nLZBPJS; i++)
		{
			WM[i] = designline->m_WM[i];
			PH[i] = designline->m_PH[i];
			ZPTW[i] = designline->m_ZPTW[i];
			ZPTI[i] = designline->m_ZPTI[i];
		}
		road[iroad].hdmdes[j].RGouProperty = LTGou->GouProperty;

		//20190930	初始化天沟参数
		for (int m = 0; m < road[iroad].hdmdes[j].RJSGouPtNum * 2; m++)
			road[iroad].hdmdes[j].RJSgou[m] = 0;
		road[iroad].hdmdes[j].RJSGouPtNum = 0;

		SDM_CrosNew(//输入
			iroad,//道路号
			1, j, designline->LnewYd, R_EarPtSum, R_EarPtList,
			designline->RHF,
			nLTBPJS, TM, TH, TPTW, TPTI,
			nLZBPJS, WM, PH, ZPTW, ZPTI,
			LTGou->PSG_JQHD, LTGou->m_T2W, LTGou->m_T1W, LTGou->m_T2H, LTGou->m_GH, LTGou->m_GW, LTGou->m_HH, LTGou->m_SP1, LTGou->m_SP2, LTGou->m_SP3, LTGou->m_PSG_GDR,
			LTGou->m_IfSetBotH, LTGou->m_GouBotH,
			designline->GK, designline->GS, designline->GP1, designline->GP2, designline->CG_JQHD, designline->CG_GDR,
			JSGou->BJ, JSGou->GW, JSGou->GS, JSGou->SP1, JSGou->SP2, JSGou->TG_JQHD, JSGou->TG_GDR,
			//输出
			lmhd,
			road[iroad].hdmdes[j].Rdeltah, road[iroad].hdmdes[j].Yt, road[iroad].hdmdes[j].YHc, Rnpt, RDesPoint,
			RFillArea, RFillBetterSoilArea, RQBTArea, RCutArea,
			road[iroad].hdmdes[j].RZDK,
			road[iroad].hdmdes[j].RGouProperty, road[iroad].hdmdes[j].RGouPtNum, road[iroad].hdmdes[j].Rgou, RGouH, RGouX, RGouTarea, RGouWarea,
			road[iroad].hdmdes[j].RJSGouPtNum, road[iroad].hdmdes[j].RJSgou,
			RSGJQarea, RDQlength, RGrasslength);

		road[iroad].hdmdes[j].QBTArea = Note->Z_LQBTArea + RQBTArea;//清表土面积
		road[iroad].hdmdes[j].FillArea = Note->Z_LFillArea + RFillArea + RGouTarea;//填面积
		road[iroad].hdmdes[j].CutArea = Note->Z_LCutArea + RCutArea + RGouWarea; //挖面积
		//	road[iroad].hdmdes[j].FillBetterSoilArea = Note->Z_LFillBetterSoilArea+RFillBetterSoilArea;//填改良土面积
		//	road[iroad].hdmdes[j].FillSSTArea = Note->Z_LFillSSTArea + RFillSSTArea;//填渗水土面积

		road[iroad].hdmdes[j].GouTarea = Note->Z_LGouTarea + RGouTarea;//水沟填面积
		road[iroad].hdmdes[j].GouWarea = Note->Z_LGouWarea + RGouWarea;//水沟挖面积
		//		road[iroad].hdmdes[j].HJarea =  Note->Z_LHJarea + RHJarea;//护肩面积
		road[iroad].hdmdes[j].SGJQarea = Note->Z_LSGJQarea + RSGJQarea;//浆砌面积
		road[iroad].hdmdes[j].DQlength = Note->Z_LDQlength + RDQlength;//挡墙坡长
		road[iroad].hdmdes[j].Grasslength = Note->Z_LGrasslength + RGrasslength;//铺草坡长

		road[iroad].hdmdes[j].Y_RFillArea = RFillArea;//填面积
		road[iroad].hdmdes[j].Y_RCutArea = RCutArea; //挖面积
		//	road[iroad].hdmdes[j].Y_RFillBetterSoilArea = RFillBetterSoilArea;//填改良土面积
		//	road[iroad].hdmdes[j].Y_RFillSSTArea =  RFillSSTArea;//填渗水土面积
		road[iroad].hdmdes[j].Y_RQBTArea = RQBTArea;//清表土面积
		road[iroad].hdmdes[j].Y_RGouTarea = RGouTarea;//水沟填面积
		road[iroad].hdmdes[j].Y_RGouWarea = RGouWarea;//水沟挖面积
		//	road[iroad].hdmdes[j].Y_RHJarea =   RHJarea;//护肩面积
		road[iroad].hdmdes[j].Y_RSGJQarea = RSGJQarea;//浆砌面积
		road[iroad].hdmdes[j].Y_RDQlength = RDQlength;//挡墙坡长
		road[iroad].hdmdes[j].Y_RGrasslength = RGrasslength;//铺草坡长

		road[iroad].hdmdes[j].at = road[iroad].hdmdes[j].FillArea;
		road[iroad].hdmdes[j].aw = road[iroad].hdmdes[j].CutArea;
		//ads_printf(L"\n##aw2=%lf,z_L=%lf,R=%lf",road[iroad].hdmdes[j].aw,Note->Z_LCutArea,RCutArea);
		if (road[iroad].hdmdes[j].RPTR.length() > 0)
			road[iroad].hdmdes[j].RPTR.removeSubArray(0, road[iroad].hdmdes[j].RPTR.length() - 1);
		road[iroad].hdmdes[j].Rnpt = Rnpt;
		if (road[iroad].hdmdes[j].RPTR.length() > 0)
			road[iroad].hdmdes[j].RPTR.removeSubArray(0, road[iroad].hdmdes[j].RPTR.length() - 1);

		for (k = 0; k < Rnpt; k++)
		{
			pt.x = RDesPoint[k * 2];
			pt.y = RDesPoint[k * 2 + 1];
			road[iroad].hdmdes[j].RPTR.append(pt);
		}

		//*************start	20200430新增	天沟属性 *************	
		if (LTGou->GouProperty == 4)
			road[iroad].hdmdes[j].RGouProperty = LTGou->GouProperty;
		//*************end	20200430新增	天沟属性 *************	

		SDM_R_setCROSSAutoDesignData(iroad, j, designline->LnewYd, designline, LTGou, JSGou, l_earthline, r_earthline, Note);

		//*************start	20200430新增	如果是修改过的路堤水沟、天沟，那么需要更新路堤沟、天沟的数组 *************	
		//路堤水沟
		int CurJQIndex = 0;
		for (int kk = road[iroad].hdmdes[j].RGouPtNum; kk < road[iroad].hdmdes[j].RGouPtNum + LTGou->JqPtNum; kk++)
		{
			double Gutter_X = (LTGou->JqPt[CurJQIndex].x - r_earthline->m_OriPoint.x) / Sfactor;
			double temp_Y = (LTGou->JqPt[CurJQIndex].y - r_earthline->m_OriPoint.y) / Sfactor;
			double Gutter_Y = temp_Y + road[iroad].hdmdes[j].Ymin - designline->LnewYd;

			road[iroad].hdmdes[j].Rgou[kk * 2] = Gutter_X;
			road[iroad].hdmdes[j].Rgou[kk * 2 + 1] = Gutter_Y;

			CurJQIndex++;
		}

		road[iroad].hdmdes[j].RGouPtNum += LTGou->JqPtNum;

		//天沟
		road[iroad].hdmdes[j].RJSGouPtNum = JSGou->JqPtNum;
		for (int kk = 0; kk < JSGou->JqPtNum; kk++)
		{
			double Gutter_X = (JSGou->JqPt[kk].x - r_earthline->m_OriPoint.x) / Sfactor;
			double temp_Y = (JSGou->JqPt[kk].y - r_earthline->m_OriPoint.y) / Sfactor;
			double Gutter_Y = temp_Y + road[iroad].hdmdes[j].Ymin - designline->LnewYd;

			road[iroad].hdmdes[j].RJSgou[kk * 2] = Gutter_X;
			road[iroad].hdmdes[j].RJSgou[kk * 2 + 1] = Gutter_Y;
		}
		//*************end	20200430新增	如果是修改过的路堤水沟、天沟，那么需要更新路堤沟、天沟的数组 *************	
	}
}

int HdmDes::SDM_CrosNew(//输入
	int iroad,//道路号
	int MR, int iCross,
	double Yd, int EarPtSum, double EarPtList[],
	double RHF[8],
	int nLTBPJS,
	double TM[30], double TH[30], double TPTW[30], double TPTI[30],
	int nLZBPJS,
	double WM[30], double PH[30], double ZPTW[30], double ZPTI[30],
	double PSG_JQHD, double T2W, double T1W, double T2H, double GH, double GW, double HH, double SP1, double SP2, double SP3, double PSG_GDR,		//路堤水沟参数
	int IfSetGouBotH, double GouBotH,
	double ParaGK, double ParaGS, double ParaGP1, double ParaGP2, double ParaCG_JQHD, double ParaCG_GDR,	//20190927新增	侧沟参数
	double ParaTG_BJ, double ParaTG_GW, double ParaTG_GS, double ParaTG_SP1, double ParaTG_SP2, double ParaTG_JQHD, double ParaTG_GDR,	//20190928新增	天沟参数
	//输出
	double lmhd[3],
	double &deltah, double& FillORCut, double& TWH,
	int& DesPtSum, double DesPtList[],
	//填土面积，填石面积，清表土面积,挖方面积
	double& FillArea, double &FillGLTArea, double& QBTArea, double& CutArea,
	//用地宽
	double& ZDK,
	//排水沟性质(1-水沟，0-坡脚墙)，点数,坐标，沟中心x,y,填面积（包括排水沟和天沟），挖面积（包括排水沟和天沟）
	int &GouProperty, int &GouPtNum, double gou[], double &GouH, double &GouX, double &GouTarea, double &GouWarea,
	//截水沟点数,坐标
	int &JSGouPtNum, double JSgou[],
	//三沟浆砌面积,挡墙长度,铺草长度
	double &AllGouJQArea, double &DQlength, double &Grasslength)

{
	int DQinf, i, BPptSum;
	double D, GK, GS, GP1, GP2;
	double LUZLMK, LUTLMK, LJXK, LTJK, LZJK, ZWW[2], YWW[2];
	double ZW, RW, XZ, YZ;
	int inf, EarPtNum1, EarPtNum2, desinf, k;
	double EarH_LT, EarH_LZ, DesH_LT, DesH_LZ, dh, BJX, BJY;
	double StartDesPt[2], BPpt[50];
	double WallType, WallH, WallTopSoilH, hthd;
	double hjwid, glthd;//渗水土厚度,护肩宽度,改良土厚度
	double PSGouJQarea, CGouJQarea, JSGouJQarea, PJWallJQArea, XJGouJQarea;
	double CG_JQHD, TG_JQHD;
	int IfTG;//是否有天沟
	double TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_GDR;
	double HJarea;
	double ZJ;
	double CG_GDR;
	double ArcBP_R;//弧形边坡半径
	double CTwid;//超填宽度
	double WideXJG, HighXJG, NBPXJG, WBPXJG, JQHDXJG, GDRXJG;
	double TmpCG_GDR = 0.0;
	bool IsAutoLDTP, IsAutoLQTP, IsAutoJKTLJ;
	IsAutoLDTP = IsAutoLQTP = IsAutoJKTLJ = false;
	hjwid = 0.0;
	//////////////////////////////////////////////////////////////////////////
	double cml = road[iroad].hdmdes[iCross].cml;
	double OffsetByXLZX = road[iroad].hdmdes[iCross].OffsetByXLZX;
	road[iroad].hdmBench[iCross].BTxz = road[iroad].hdmdmx[iCross].BTxz;
	road[iroad].hdmBench[iCross].EarH = road[iroad].hdmdmx[iCross].EarH;
	_tcscpy(road[iroad].hdmBench[iCross].flag, road[iroad].hdmdmx[iCross].flag);
	road[iroad].hdmBench[iCross].lc = road[iroad].hdmdmx[iCross].lc;
	road[iroad].hdmBench[iCross].lcflag = road[iroad].hdmdmx[iCross].lcflag;
	// 	if (MR<0)//左侧
	// 	{
	// 		road[iroad].hdmBench[iCross].ZEarPtNum = 0;
	// 		road[iroad].hdmBench[iCross].ZEarPtAry.RemoveAll();
	// 	}
	// 	else
	// 	{
	// 		road[iroad].hdmBench[iCross].YEarPtNum = 0;
	// 		road[iroad].hdmBench[iCross].YEarPtAry.RemoveAll();
	// 	}
	//////////////////////////////////////////////////////////////////////////

	PSGouJQarea = CGouJQarea = JSGouJQarea = PJWallJQArea = XJGouJQarea = 0.0;
	ArcBP_R = 0.0;
	//	bool IfSetGouBotH;
	//	double GouBotH;

	///////////////////////设置初始值////////////////////////////////////////////////////
	//水沟初始值
	GouPtNum = 0;
	GouH = GouX = GouTarea = GouWarea = 0.0;
	JSGouPtNum = 0;//截水沟点数 

	for (i = 0; i < 34; i++)
	{
		gou[i] = 0.0;
		JSgou[i] = 0.0;
	}
	//面积初始值
	FillArea = FillGLTArea = QBTArea = CutArea = 0.0;
	//挡墙及铺草边坡长度初始值
	DQlength = Grasslength = 0;
	//水沟浆砌面积
	AllGouJQArea = 0.0;
	///////////////////////设置初始值////////////////////////////////////////////////////
	if (fabs(OffsetByXLZX) < 0.001)
		TWH = RHF[1] - Yd;//填挖高
	else
	{
		double DesHOnXLZX = RHF[1];
		if (MR < 0)
			DesHOnXLZX = CalDesH(cml, road[iroad].ZZM, road[iroad].AllZM);
		else
			DesHOnXLZX = CalDesH(cml, road[iroad].YZM, road[iroad].AllZM);
		TWH = DesHOnXLZX - road[iroad].hdmdmx[iCross].EarH;
	}
	ZW = FindIljxk(cml, road[iroad].pm, road[iroad].hdmbz.NZDM, road[iroad].hdmbz.ZDM);//左侧限制宽
	RW = FindIljxk(cml, road[iroad].pm, road[iroad].hdmbz.NYDM, road[iroad].hdmbz.YDM);//右侧限制宽
	FindIljjk(cml, road[iroad].pm, road[iroad].hdmbz.NZPWD, road[iroad].hdmbz.ZPWD, ZWW[0], ZWW[1]);//左侧占地加宽
	FindIljjk(cml, road[iroad].pm, road[iroad].hdmbz.NYPWD, road[iroad].hdmbz.YPWD, YWW[0], YWW[1]);//右侧占地加宽

	WallType = -1;
	WallH = 0.0;
	WallTopSoilH = 0.0;

	//20190927新增	赋值侧沟参数
	GK = ParaGK;
	GS = ParaGS;
	GP1 = ParaGP1;
	GP2 = ParaGP2;
	CG_JQHD = ParaCG_JQHD;
	CG_GDR = ParaCG_GDR;
	D = GK + GS * (GP1 + GP2);

	//20190928新增	赋值天沟参数
	IfTG = TRUE;
	TG_BJ = ParaTG_BJ;
	TG_GW = ParaTG_GW;
	TG_GS = ParaTG_GS;
	TG_SP1 = ParaTG_SP1;
	TG_SP2 = ParaTG_SP2;
	TG_JQHD = ParaTG_JQHD;
	TG_GDR = ParaTG_GDR;
	if (TG_BJ == 0.0 && TG_GW == 0.0 && TG_GS == 0.0 && TG_SP1 == 0.0 && TG_SP2 == 0.0 && TG_JQHD == 0.0 && TG_GDR == 0.0)
		IfTG = FALSE;
	else
		IfTG = TRUE;

	//2.改良土厚度
	//	glthd = FindGLTHD(cml,road[iroad].pm,road[iroad].hdmbz.NLDTL,road[iroad].hdmbz.LDTL);
	glthd = 0.0;
	if (MR < 0)//左侧
	{
		//1.排水沟
		//取出护坡道宽，横坡，沟宽，沟深，内侧坡，外侧坡，浆汽厚度
		//     FindSG(cml,road[iroad].pm,road[iroad].hdmbz.NZLDSG,road[iroad].hdmbz.ZLDSG,GouProperty,
		//			   PSG_JQHD,T2W,T1W,T2H,GH,GW,HH,SP1,SP2,SP3);
		//  IfSetGouBotH = FindGouBotH(cml,road[iroad].pm,road[iroad].hdmbz.NZGouPD,road[iroad].hdmbz.ZGouPD,GouBotH);
		GouBotH = GouBotH - Yd;
		//2.天沟(0-无天沟,1-有天沟) 
		//IfTG = FindTG(cml, road[iroad].pm, road[iroad].hdmbz.NZTG, road[iroad].hdmbz.ZTG, TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_JQHD, TG_GDR);
		DQinf = 0;
		//3.侧沟

		//Cal_D(cml,road[iroad].pm,road[iroad].hdmbz.NZLQSG,road[iroad].hdmbz.ZLQSG,&D,&GK,&GS,&GP1,&GP2,&CG_JQHD,&CG_GDR);//路堑边沟宽度

		//	nLTBPJS=FindWichBP(cml,road[iroad].pm,road[iroad].hdmbz.NZLDBP,road[iroad].hdmbz.ZLDBP,TM,TH,TPTW,TPTI);//左路堤边坡
		//	nLZBPJS=FindWichBP(cml,road[iroad].pm,road[iroad].hdmbz.NZLQBP,road[iroad].hdmbz.ZLQBP,WM,PH,ZPTW,ZPTI);//左路堑边坡
		//////////////////////////////////////////////////////////////////////////
		//判别是否做弧形边坡，半径记录在最后一级边坡限制高<0, 如：-2表示2m半径
		if (nLZBPJS > 0 && PH[nLZBPJS - 1] < -0.001)//
		{
			ArcBP_R = fabs(PH[nLZBPJS - 1]);
			PH[nLZBPJS - 1] = 100.0;
		}
		//////////////////////////////////////////////////////////////////////////

		LJXK = ZW;//路基限宽
		LTJK = ZWW[0];//路堤加宽
		LZJK = ZWW[1];//路堑加宽
		//清表土厚度
		hthd = FindWichHTHD(cml, road[iroad].pm, road[iroad].hdmbz.NZHTHD, road[iroad].hdmbz.ZHTHD);
		ZJ = FindWichDQ(cml, road[iroad].pm, road[iroad].hdmbz.NZDQ, road[iroad].hdmbz.ZDQ);
		//路面厚
		FindWichHD(cml, road[iroad].pm, road[iroad].hdmbz.NZLMHD, road[iroad].hdmbz.ZLMHD, lmhd);
		IsAutoLDTP = FindIsAutoLDTP(cml, road[iroad].pm, road[iroad].hdmbz.NZLDTP, road[iroad].hdmbz.ZLDTP);
		IsAutoLQTP = FindIsAutoLQTP(cml, road[iroad].pm, road[iroad].hdmbz.NZLQTP, road[iroad].hdmbz.ZLQTP);
		IsAutoJKTLJ = FindIsAutoJKTLJ(cml, road[iroad].pm, road[iroad].hdmbz.NZTLJJK, road[iroad].hdmbz.ZTLJJK);
	}
	else//右侧
	{
		//排水沟
		//   FindSG(cml,road[iroad].pm,road[iroad].hdmbz.NYLDSG,road[iroad].hdmbz.YLDSG,GouProperty,
		//			   PSG_JQHD,T2W,T1W,T2H,GH,GW,HH,SP1,SP2,SP3);
		//    IfSetGouBotH = FindGouBotH(cml,road[iroad].pm,road[iroad].hdmbz.NYGouPD,road[iroad].hdmbz.YGouPD,GouBotH);
		GouBotH = GouBotH - Yd;
		//1.天沟 
		//IfTG = FindTG(cml,road[iroad].pm,road[iroad].hdmbz.NYTG,road[iroad].hdmbz.YTG,TG_BJ,TG_GW,TG_GS,TG_SP1,TG_SP2,TG_JQHD,TG_GDR);
		DQinf = 0;
		//Cal_D(cml,road[iroad].pm,road[iroad].hdmbz.NYLQSG,road[iroad].hdmbz.YLQSG,&D,&GK,&GS,&GP1,&GP2,&CG_JQHD,&CG_GDR);//路堑边沟宽度

		////  nLTBPJS=FindWichBP(cml,road[iroad].pm,road[iroad].hdmbz.NYLDBP,road[iroad].hdmbz.YLDBP,TM,TH,TPTW,TPTI);//左路堤边坡
		// nLZBPJS=FindWichBP(cml,road[iroad].pm,road[iroad].hdmbz.NYLQBP,road[iroad].hdmbz.YLQBP,WM,PH,ZPTW,ZPTI);//左路堑边坡
		//////////////////////////////////////////////////////////////////////////
		if (nLZBPJS > 0 && PH[nLZBPJS - 1] < -0.001)//
		{
			ArcBP_R = fabs(PH[nLZBPJS - 1]);
			PH[nLZBPJS - 1] = 100.0;
		}
		//////////////////////////////////////////////////////////////////////////

		LTJK = YWW[0];
		LZJK = YWW[1];
		LJXK = RW;//路基限宽
		//清表土厚度
		hthd = FindWichHTHD(cml, road[iroad].pm, road[iroad].hdmbz.NYHTHD, road[iroad].hdmbz.YHTHD);
		ZJ = FindWichDQ(cml, road[iroad].pm, road[iroad].hdmbz.NYDQ, road[iroad].hdmbz.YDQ);
		FindWichHD(cml, road[iroad].pm, road[iroad].hdmbz.NYLMHD, road[iroad].hdmbz.YLMHD, lmhd);
		IsAutoLDTP = FindIsAutoLDTP(cml, road[iroad].pm, road[iroad].hdmbz.NYLDTP, road[iroad].hdmbz.YLDTP);
		IsAutoLQTP = FindIsAutoLQTP(cml, road[iroad].pm, road[iroad].hdmbz.NYLQTP, road[iroad].hdmbz.YLQTP);
		IsAutoJKTLJ = FindIsAutoJKTLJ(cml, road[iroad].pm, road[iroad].hdmbz.NYTLJJK, road[iroad].hdmbz.YTLJJK);
	}
	//PSGouJQarea,CGouJQarea,JSGouPtNumarea,AllGouJQArea;
	//计算标准面积
	//排水沟浆砌
	PSGouJQarea = CalGouJQArea(GH, GW, SP1, SP2, PSG_JQHD);
	//侧沟浆砌
	CGouJQarea = CalGouJQArea(GS, GK, GP1, GP2, CG_JQHD);
	//截水沟浆砌
	JSGouJQarea = CalGouJQArea(TG_GS, TG_GW, TG_SP1, TG_SP2, TG_JQHD);
	//坡脚墙浆砌
	PJWallJQArea = 0.5 * 1;

	FillArea = 0.0;
	CutArea = 0.0;

	//建立统一坐标系,原点X=0,Y=RHF[1];
	DesPtSum = 5;
	//	Ymlev = RHF[7];
	for (i = 0; i < 5; i++)
	{
		DesPtList[i * 2] = RHF[i * 2];
		DesPtList[i * 2 + 1] = RHF[i * 2 + 1] - Yd;//都相对中桩

		//	 ads_printf(L"\n~~~~~des=%lf,%lf,%lf,%lf,%lf",RHF[i*2],RHF[i*2+1],Yd,DesPtList[(i+1)*2],DesPtList[(i+1)*2+1]);
	}
	//初值
	GouH = DesPtList[4 * 2 + 1] - GS;
	GouX = DesPtList[4 * 2] + GS * SP1 + 0.5*GK;
	ZDK = DesPtList[(DesPtSum - 1) * 2] + LTJK;

	CalDesArea(0, DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, FillArea, CutArea);

	/*	 for(i=0; i<EarPtSum; i++)
	{
	EarPtList[i*2+1] -= TWH;
	}*/

	//////////////////////////////////////////////////////////////////////////
	//考虑自动推平和填平
	if (fabs(DesPtList[4 * 2] - DesPtList[3 * 2]) > 0.1 && (IsAutoLDTP || IsAutoLQTP))
	{
		double TLJYd;//土路肩处Yd
		inf = Gety(DesPtList[2 * 4], EarPtSum, EarPtList, TLJYd, EarPtNum2);
		if (inf == 0)
		{
			return -1;
		}
		dh = DesPtList[2 * 4 + 1] - TLJYd;
		deltah = dh;
		if (dh >= 0.0 && IsAutoLDTP)
		{
			bool AutoTP = false;//是否自动填平
			double JDPt[2];//推平交点坐标
			double TPDist = 0.0;//推平后交点与土路肩水平距离
			double GouWide;//推平沟宽
			GouWide = GK + GS * (GP1 + GP2);
			double TLJPt[2];
			double TLJPL = (DesPtList[3 * 2 + 1] - DesPtList[4 * 2 + 1]) / (DesPtList[4 * 2] - DesPtList[3 * 2]);//土路肩坡率
			TLJPt[0] = DesPtList[4 * 2];
			TLJPt[1] = DesPtList[4 * 2 + 1];
			AutoTP = IsAutoTP(-1, EarPtSum, EarPtList, TLJPt, TLJPL, GouWide, JDPt, TPDist);
			if (AutoTP)//需要自动填平
			{
				FillORCut = 0;//推平
				int AutoTPDesInf;
				if (MR < 0)
					nLZBPJS = FindWichBP(cml, road[iroad].pm, road[iroad].hdmbz.NZLQBP, road[iroad].hdmbz.ZLQBP, WM, PH, ZPTW, ZPTI);//左路堑边坡
				else
					nLZBPJS = FindWichBP(cml, road[iroad].pm, road[iroad].hdmbz.NYLQBP, road[iroad].hdmbz.YLQBP, WM, PH, ZPTW, ZPTI);//右路堑边坡
				AutoTPDesInf = AutoTPLQDes(TPDist, DesPtSum, DesPtList, EarPtSum, EarPtList, GK, GS, GP1, GP2, CG_GDR, WM[0], ZPTI[0], GouH, GouX, GouPtNum, gou);//设计自动填平路堑
				if (AutoTPDesInf == 1)//正常完成
				{
					GouProperty = 1;
					BJX = gou[(GouPtNum - 1) * 2];
					BJY = gou[(GouPtNum - 1) * 2 + 1];
					ZDK = gou[(GouPtNum - 1) * 2] + LZJK;
					double NewDmxPtList[400];
					int NewDmxPtNum;
					FormNewDmx(EarPtSum, EarPtList, DesPtSum, DesPtList, NewDmxPtNum, NewDmxPtList);
					CalGouArea(NewDmxPtNum, NewDmxPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
					DQlength = 0.0;
					Grasslength = 0.0;
					//				ads_printf(L"\n路堤填平断面cml=%lf,DesPtSum=%d",cml,DesPtSum);
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
						StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					return 1;
				}
			}
		}

		if (dh < 0.0 && IsAutoLQTP)
		{
			bool AutoTP = false;//是否自动填平
			double JDPt[2];//填平交点坐标
			double TPDist = 0.0;//填平后交点与土路肩水平距离
			double GouWide;//填平沟宽
			GouWide = GK + GS * (GP1 + GP2);
			double TLJPt[2];
			double TLJPL = (DesPtList[3 * 2 + 1] - DesPtList[4 * 2 + 1]) / (DesPtList[4 * 2] - DesPtList[3 * 2]);//土路肩坡率
			TLJPt[0] = DesPtList[4 * 2];
			TLJPt[1] = DesPtList[4 * 2 + 1];
			AutoTP = IsAutoTP(1, EarPtSum, EarPtList, TLJPt, TLJPL, GouWide, JDPt, TPDist);
			if (AutoTP)//需要自动推平
			{
				FillORCut = 0;//推平
				int AutoTPDesInf;
				AutoTPDesInf = AutoTPLDDes(TPDist, DesPtSum, DesPtList, EarPtSum, EarPtList, GK, GS, GP1, GP2, CG_GDR, TPTI[0], GouH, GouX, GouPtNum, gou);//设计自动填平路堑
				if (AutoTPDesInf == 1)//正常完成推平设计
				{
					if (GouPtNum == 0)
					{
						GouProperty = -1;
						BJX = DesPtList[(DesPtSum - 1) * 2];
						BJY = DesPtList[(DesPtSum - 1) * 2 + 1];
						ZDK = DesPtList[(DesPtSum - 1) * 2] + LTJK;
					}
					else
					{
						GouProperty = 1;
						BJX = gou[(GouPtNum - 1) * 2];
						BJY = gou[(GouPtNum - 1) * 2 + 1];
						ZDK = gou[(GouPtNum - 1) * 2] + LTJK;
						double NewDmxPtList[400];
						int NewDmxPtNum;
						FormNewDmx(EarPtSum, EarPtList, DesPtSum, DesPtList, NewDmxPtNum, NewDmxPtList);
						CalGouArea(NewDmxPtNum, NewDmxPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
					}

					DQlength = 0.0;
					Grasslength = 0.0;
					//				ads_printf(L"\n路堑推平断面cml=%lf,DesPtSum=%d",cml,DesPtSum);
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, 1,
						StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					return 1;
				}
			}
		}
	}
	//////////////////////////////////////////////////////////////////////////

	//计算LUTLMK处地面高
	LUTLMK = RHF[8];
	//DesH_LT = RHF[7] - Ymlev;
	DesH_LT = RHF[9] - Yd;
	LUZLMK = LUTLMK + D + ZPTW[0];
	//DesH_LZ = RHF[7] - Ymlev + D*ZPTI[0]*0.01;//考虑平台
	DesH_LZ = RHF[9] - Yd + ZPTW[0] * ZPTI[0] * 0.01;//考虑平台???liwei是否应该是DesH_LZ = RHF[9] - Yd + D+ZPTI[0]*0.01

	inf = Gety(LUTLMK, EarPtSum, EarPtList, EarH_LT, EarPtNum1);
	if (inf == 0)
	{
		//  WrErrFile(inf,MR,ckml);
		return -1;
	}

	dh = DesH_LT - EarH_LT;
	deltah = dh;
	//	 if(dh>0.0)//路堤路面宽处设计高大于地面高,路堤


	double InfactGS = GS;
	if (CG_GDR > 0.001)
	{
		InfactGS = GS + CG_GDR - sqrt(CG_GDR*CG_GDR - 0.25*GK*GK);
	}






	if (dh > GS || GouProperty == 2 && dh > 0.0)//（路堤路面宽处设计高高于地面一个路堑沟深）或（按路肩沟设计，且路堤路面宽处设计高大于地面高）
	{

		//////////////////////////////////////////////////////////////////////////
		//考虑开挖台阶
		double CutBenchStartPt[2];//开挖台阶起点，暂定为坡脚点
		CutBenchStartPt[0] = CutBenchStartPt[1] = 0.0;
		//////////////////////////////////////////////////////////////////////////

		FillORCut = 0.0;//填方
		//护肩面积
		StartDesPt[0] = DesPtList[4 * 2];
		StartDesPt[1] = DesPtList[4 * 2 + 1];
		if (DQinf != 1)//未设置挡墙
		{
			desinf = DesBPnew(-1, StartDesPt, TM, TH, TPTW, TPTI, EarPtNum1, EarPtSum, EarPtList, LJXK, BPpt, BPptSum, ZJ, nLTBPJS);//路堤
			BPptToDESpt(BPptSum, BPpt, DesPtSum, DesPtList, LTJK, BJX, BJY, ZDK, DQlength, Grasslength);
			//////////////////////////////////////////////////////////////////////////
			//线间沟
			if (iroad && ZJ < 1e-6)//有线间沟
			{
				FindGLDMXJG(cml, road[iroad].pm, road[iroad].hdmbz.NGLDMXJG, road[iroad].hdmbz.GLDMXJG,
					WideXJG, HighXJG, NBPXJG, WBPXJG, JQHDXJG, GDRXJG);
				XJGDes(DesPtSum, DesPtList, WideXJG, HighXJG, NBPXJG, WBPXJG, GDRXJG, GouH, GouX, GouPtNum, gou);
				//线间沟浆砌
				GouProperty = 1;
				FillORCut = 0;//路堤做路堑沟
				BJX = gou[(GouPtNum - 1) * 2];
				BJY = gou[(GouPtNum - 1) * 2 + 1];
				ZDK = gou[(GouPtNum - 1) * 2] + LZJK;
				DQlength = 0.0;
				Grasslength = 0.0;

				CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
					StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
					FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
				double NewDmxPtList[400];
				int NewDmxPtNum;
				FormNewDmx(EarPtSum, EarPtList, DesPtSum, DesPtList, NewDmxPtNum, NewDmxPtList);
				CalGouArea(NewDmxPtNum, NewDmxPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
				return 1;
			}
			//计算断面积
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
				StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);

		}

		if (desinf != 1)
			GouProperty = -1;
		if (desinf == 1)//找到交点,先判断是否需要自动加宽土路肩再做水沟、脚墙和路肩沟
		{
			//////////////////////////////////////////////////////////////////////////
			//考虑低填方路堤自动加宽土路肩
			if (DesPtList[4 * 2 + 1] - DesPtList[(DesPtSum - 1) * 2 + 1]<3.0 && DesPtList[4 * 2 + 1] - DesPtList[(DesPtSum - 1) * 2 + 1]>0.0 && IsAutoJKTLJ)//填方高度小于3.0m
			{
				double JKPt[2];//土路肩加宽点
				double JDPt[2];//加宽路堤与地面线的交点
				JKPt[0] = DesPtList[4 * 2] + 1.0;
				JKPt[1] = DesPtList[4 * 2 + 1] - 1.0 / 6.0;
				double JKPtYd;//加宽点Yd
				desinf = Gety(JKPt[0], EarPtSum, EarPtList, JKPtYd, EarPtNum1);
				inf = CALXY(EarPtNum1, EarPtSum, -1, 1.5, JKPt[0], JKPt[0], 100.0, &JDPt[0], &JDPt[1], EarPtList);
				if (inf == 0 && (DesPtList[4 * 2 + 1] - JDPt[1]) < 4.0)//有交点且按自动加宽设计后填方高度小于4.0m
				{
					TM[0] = 6.0;
					TH[0] = 1.0 / 6.0;
					TPTW[0] = 0.0;
					TPTI[0] = 0.0;
					TM[1] = 1.5;
					TH[1] = 100.0;
					TPTW[1] = 0.0;
					TPTI[1] = 0.0;
					nLTBPJS = 2;
					desinf = Gety(DesPtList[4 * 2], EarPtSum, EarPtList, EarH_LT, EarPtNum1);
					desinf = DesBPnew(-1, StartDesPt, TM, TH, TPTW, TPTI, EarPtNum1, EarPtSum, EarPtList, LJXK, BPpt, BPptSum, ZJ, nLTBPJS);//路堤
					DesPtSum = 5;
					BPptToDESpt(BPptSum, BPpt, DesPtSum, DesPtList, LTJK, BJX, BJY, ZDK, DQlength, Grasslength);
					T1W = 0.0;
					HH = 0.0;
					//							 ads_printf(L"\n土路肩加宽断面cml=%lf,DesPtSum=%d",cml,DesPtSum);
				}
			}
			//////////////////////////////////////////////////////////////////////////


			//计算断面积
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
				StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
			//////////////////////////////////////////////////////////////////////////
			//考虑是否需要在填方地段自动设计挖方水沟
			// 					 int AutoDesTFLQSGHdmInf;
			// 					 if (MR<0)
			// 						 nLZBPJS=FindWichBP(cml,road[iroad].pm,road[iroad].hdmbz.NZLQBP,road[iroad].hdmbz.ZLQBP,WM,PH,ZPTW,ZPTI);//左路堑边坡
			// 					 else
			// 						 nLZBPJS=FindWichBP(cml,road[iroad].pm,road[iroad].hdmbz.NYLQBP,road[iroad].hdmbz.YLQBP,WM,PH,ZPTW,ZPTI);//左路堑边坡
			// 					 AutoDesTFLQSGHdmInf = AutoDesTFLQSGHdm(DesPtSum,DesPtList,EarPtSum,EarPtList,GK,GS,GP1,GP2,CG_GDR,ZPTI[0],GouH,GouX,GouPtNum,gou);			
			// 					 if (AutoDesTFLQSGHdmInf==1)//正常完成
			// 					 {
			// 						 GouProperty = 1;
			// 						 FillORCut = 0;//路堤做路堑沟
			// 						 BJX = gou[(GouPtNum-1)*2];
			// 						 BJY = gou[(GouPtNum-1)*2+1];		
			// 						 ZDK = gou[(GouPtNum-1)*2] + LZJK;
			// 						 DQlength = 0.0;
			// 						 Grasslength = 0.0;
			// 						 //						 ads_printf(L"\n路堤做路堑沟cml=%lf,DesPtSum=%d",cml,DesPtSum);
			// 						 
			// 						 
			// 						 CalDesAllArea(DesPtSum,DesPtList,EarPtSum,EarPtList,lmhd,hthd,glthd,0,ZJ,-1,
			// 							 StartDesPt,WM,PH,ZPTW,ZPTI,nLZBPJS,
			// 							 FillArea,CutArea,QBTArea,FillGLTArea,HJarea); 
			// 						 double NewDmxPtList[400];
			// 						 int NewDmxPtNum;
			// 						 FormNewDmx(EarPtSum,EarPtList,DesPtSum,DesPtList,NewDmxPtNum,NewDmxPtList);
			// 						 CalGouArea(NewDmxPtNum,NewDmxPtList,GouPtNum,gou,GouTarea,GouWarea);//计算水沟面积
			// 						 
			// 						 return 1;
			// 					 }
			//////////////////////////////////////////////////////////////////////////


			//////////////////////////////////////////////////////////////////////////
			//考虑开挖台阶
			// 					 CutBenchStartPt[0] = DesPtList[2*(DesPtSum-1)];
			// 					 CutBenchStartPt[1] = DesPtList[2*(DesPtSum-1)+1];
			//////////////////////////////////////////////////////////////////////////


			//////////////////////////////////////////////////////////////////////////
			//考虑开挖台阶
			// 					 int CutBenchInf = 0;
			// 					 double CutBenchArea = 0.0;
			// 					 int BenchPtSum = 0;
			// 					 double BenchPtList[400];
			// 					 for (int i=0; i<200; i++)
			// 					 {
			// 						 BenchPtList[2*i] = 0.0;
			// 						 BenchPtList[2*i+1] = 0.0;
			// 					 }
			// 					 
			// 					 double LMPtList[10];//路面点数组
			// 					 for(i=0; i<5; i++)
			// 					 {
			// 						 LMPtList[i*2] = DesPtList[i*2];
			// 						 LMPtList[i*2+1] = DesPtList[i*2+1];
			// 					 }
			// 					 CutBenchInf = AutoCutBench(CutBenchStartPt,BenchPtSum,BenchPtList,EarPtSum,EarPtList,LMPtList,lmhd,CutBenchArea);
			// 					 
			// 					 if (CutBenchInf==1)
			// 					 {
			// 						 CutArea += CutBenchArea;
			// 						 FillArea += CutBenchArea;
			// 						 if (MR<0)
			// 						 {
			// 							 road[iroad].hdmBench[iCross].ZEarPtAry.RemoveAll();
			// 							 road[iroad].hdmBench[iCross].ZEarPtNum = BenchPtSum;
			// 							 road[iroad].hdmBench[iCross].ZEarPtAry.SetSize(BenchPtSum);
			// 							 for (int iPt=0; iPt<BenchPtSum; iPt++)
			// 							 {
			// 								 road[iroad].hdmBench[iCross].ZEarPtAry[iPt].x = BenchPtList[2*iPt];
			// 								 road[iroad].hdmBench[iCross].ZEarPtAry[iPt].y = BenchPtList[2*iPt+1];
			// 							 }
			// 						 }
			// 						 else
			// 						 {
			// 							 road[iroad].hdmBench[iCross].YEarPtAry.RemoveAll();
			// 							 road[iroad].hdmBench[iCross].YEarPtNum = BenchPtSum;
			// 							 road[iroad].hdmBench[iCross].YEarPtAry.SetSize(BenchPtSum);
			// 							 for (int iPt=0; iPt<BenchPtSum; iPt++)
			// 							 {
			// 								 road[iroad].hdmBench[iCross].YEarPtAry[iPt].x = BenchPtList[2*iPt];
			// 								 road[iroad].hdmBench[iCross].YEarPtAry[iPt].y = BenchPtList[2*iPt+1];
			// 							 }
			// 						 }
			// 					 }
			//////////////////////////////////////////////////////////////////////////
		}

		//路堤水沟
		if (GouProperty == 1 || GouProperty == 3)//水沟		20200430新增GouProperty==3的情况，这是代表用户单独修改的路堤水沟
		{
			//排水沟
			double GouWide = GK + GS * (GP1 + GP2);
			double dmhp = GetDmhp(DesPtList[(DesPtSum - 1) * 2], DesPtList[(DesPtSum - 1) * 2] + (GouWide + 2.0) * 2, EarPtList, EarPtSum);
			int wfsginf = 0;
			inf = 0;
			if (dmhp < 0.15)//地面线向下倾斜
				inf = DesLTGou(IfSetGouBotH, GouBotH, T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, gou, DesPtList, DesPtSum, EarPtList, EarPtSum, WM[0], GouH, GouX, BJX, PSG_JQHD, PSG_GDR);
			else
			{
				if (MR < 0)
					nLZBPJS = FindWichBP(cml, road[iroad].pm, road[iroad].hdmbz.NZLQBP, road[iroad].hdmbz.ZLQBP, WM, PH, ZPTW, ZPTI);//左路堑边坡
				else
					nLZBPJS = FindWichBP(cml, road[iroad].pm, road[iroad].hdmbz.NYLQBP, road[iroad].hdmbz.YLQBP, WM, PH, ZPTW, ZPTI);//右路堑边坡
				//wfsginf = AutoDesTFLQSGHdm(DesPtSum,DesPtList,EarPtSum,EarPtList,GK,GS,GP1,GP2,CG_GDR,ZPTI[0],GouH,GouX,GouPtNum,gou);			
				wfsginf = AutoDesTFLQSGHdm(DesPtSum, DesPtList, EarPtSum, EarPtList, GW, GH, SP1, SP2, CG_GDR, ZPTI[0], GouH, GouX, GouPtNum, gou);
				if (wfsginf != 1)
					inf = DesLTGou(IfSetGouBotH, GouBotH, T2W, T1W, T2H, GH, GW, HH, SP1, SP2, SP3, gou, DesPtList, DesPtSum, EarPtList, EarPtSum, WM[0], GouH, GouX, BJX, PSG_JQHD, PSG_GDR);
				else
				{
					BJX = gou[(GouPtNum - 1) * 2];//占地宽计算用
					BJY = gou[(GouPtNum - 1) * 2 + 1];
				}

			}
			double NewDmxPtList[400];
			int NewDmxPtNum;
			//将设计线与地面线合成新的地面线
			if (inf == 1 || wfsginf == 1)
			{

				int t = 0;
				while (t < 18 && fabs(gou[t * 2])>0.001)
					t++;
				GouPtNum = t;
				if (inf == 1)
				{
					FormNewDmx(EarPtSum, EarPtList, DesPtSum, DesPtList, NewDmxPtNum, NewDmxPtList);
					CalGouArea(NewDmxPtNum, NewDmxPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
				}
				else
				{
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积
				}

				AllGouJQArea += PSGouJQarea;//统计浆汽面积
				ZDK = BJX + LTJK;
			}
		}
		else if (GouProperty == 0)//脚墙
		{
			GouPtNum = 0;
			AllGouJQArea += PJWallJQArea;//统计浆汽面积
		}
		else if (GouProperty == 2 || GouProperty == 4)//路肩沟	20200430
		{
			FillORCut = 3.0;
			//做路堑水沟
			if ((DesPtList[4 * 2] + GH * SP1 + GH * SP2 + GW) <= ZJ)
			{
				FillORCut = 3.0;
				DesPtList[5 * 2] = DesPtList[4 * 2] + GH * SP1;
				DesPtList[5 * 2 + 1] = DesPtList[4 * 2 + 1] - GH;
				DesPtList[6 * 2] = DesPtList[5 * 2] + GW;
				DesPtList[6 * 2 + 1] = DesPtList[5 * 2 + 1];
				DesPtList[7 * 2] = DesPtList[6 * 2] + GH * SP2;
				DesPtList[7 * 2 + 1] = DesPtList[6 * 2 + 1] + GH;
				DesPtList[8 * 2] = DesPtList[7 * 2];//+ 0.5;//土埂
				DesPtList[8 * 2 + 1] = DesPtList[7 * 2 + 1];
				GouH = DesPtList[5 * 2 + 1];
				GouX = DesPtList[4 * 2] + GH * SP1 + 0.5 * GW;
				DesPtSum = 9;
				AllGouJQArea += CGouJQarea;//统计侧沟浆汽面积
				//拟修改
				gou[2 * GouPtNum] = DesPtList[4 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[4 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[5 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[5 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[6 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[6 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[7 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[7 * 2 + 1];
				GouPtNum++;

				StartDesPt[0] = DesPtList[8 * 2];
				StartDesPt[1] = DesPtList[8 * 2 + 1];
				inf = Gety(DesPtList[8 * 2], EarPtSum, EarPtList, EarH_LZ, EarPtNum2);
				if (inf == 0)//找不到对应点
				{
					//    WrErrFile(inf,MR,ckml);
					ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, -1,
						StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					return -1;
				}

				dh = DesPtList[8 * 2 + 1] - EarH_LZ;
				if (dh < 0.0)//设计高小于地面高,路堑
					inf = CALXY(EarPtNum2, EarPtSum, 1, SP3, StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);
				else  //路堤
					inf = CALXY(EarPtNum2, EarPtSum, -1, SP3, StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);

				if (inf == 0)//找到交点
				{
					DesPtList[9 * 2] = XZ;
					DesPtList[9 * 2 + 1] = YZ;
					DesPtSum = 10;
					//////////////////////////////////////////////////////////////////////////
					//考虑开挖台阶
					//if (dh > 0.0)
					//{
					//	CutBenchStartPt[0] = DesPtList[9 * 2];
					//	CutBenchStartPt[1] = DesPtList[9 * 2 + 1];
					//}
					//////////////////////////////////////////////////////////////////////////
				}
				else
				{
					//    WrErrFile(-3,MR,ckml);
					return -1;
				}
			}
			else
				FillORCut = 0.0;
			ZDK = DesPtList[(DesPtSum - 1) * 2] + LTJK;
			CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, 1,//1-挖方
				StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
		}

		if (desinf == 0 || desinf == -1)//调整参数或设挡后仍然交不上，则将最后一个设计点与其对应的地面点直接连接起来
		{
			inf = Gety(DesPtList[(DesPtSum - 1) * 2], EarPtSum, EarPtList, EarH_LT, EarPtNum1);
			if (inf != 0)
			{
				DesPtSum++;
				if (EarPtNum1 < EarPtSum)
				{
					if (EarPtSum > 1)
						k = EarPtNum1 + 1;
					else
						k = 0;
				}
				else
					k = EarPtSum - 1;

				DesPtList[(DesPtSum - 1) * 2] = EarPtList[k * 2];
				DesPtList[(DesPtSum - 1) * 2 + 1] = EarPtList[k * 2 + 1];
			}
			// 	   WrErrFile(1,MR,ckml);//边坡交不上
			return -1;
		}
		return 1;//正常
	}
	else //考虑路堑
	{
		GouProperty = -1;//初值
		inf = Gety(LUZLMK, EarPtSum, EarPtList, EarH_LZ, EarPtNum2);
		if (inf == 0)
		{
			//  WrErrFile(inf,MR,ckml);
			return -1;
		}

		AllGouJQArea += CGouJQarea;//统计侧沟浆汽面积
		dh = DesH_LZ - EarH_LZ;

		if (dh < 0.0)//设计高小于地面高,路堑
		{


			StartDesPt[0] = LUZLMK;
			StartDesPt[1] = DesPtList[4 * 2 + 1];

			if (ZJ > LUZLMK)
			{
				desinf = DesLZ(GouPtNum, gou, GS, GK, GP1, GP2, DesH_LZ, LUZLMK, WM, PH, ZPTW, ZPTI, EarPtNum2, EarPtSum, EarPtList, LJXK, DesPtList, DesPtSum, FillORCut, ZJ, DQinf, WallType, WallH, nLZBPJS, DQlength, Grasslength);
				//////////////////////////////////////////////////////////////////////////
				//线间沟
				if (iroad && ZJ < 1e-6)//路堑边坡需要推平
				{
					double GLDMLQTPDist;//关联断面路堑推平水平距离
					FindGLDMLQBPTP(cml, road[iroad].pm, road[iroad].hdmbz.NGLDMLQBPTP, road[iroad].hdmbz.GLDMLQBPTP, GLDMLQTPDist);
					DesPtSum++;
					DesPtList[2 * (DesPtSum - 1)] = DesPtList[2 * (DesPtSum - 2)] + GLDMLQTPDist;
					DesPtList[2 * (DesPtSum - 1) + 1] = DesPtList[2 * (DesPtSum - 2) + 1];
					BJX = DesPtList[(DesPtSum - 1) * 2];
					BJY = DesPtList[(DesPtSum - 1) * 2 + 1];
					ZDK = DesPtList[(DesPtSum - 1) * 2] + LTJK;
					DQlength = 0.0;
					Grasslength = 0.0;
					//				ads_printf(L"\n路堑推平断面cml=%lf,DesPtSum=%d",cml,DesPtSum);
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, 0, ZJ, -1,
						StartDesPt, TM, TH, TPTW, TPTI, nLTBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					return 1;
				}
				//////////////////////////////////////////////////////////////////////////

				//设计弧形边坡
				//	 DesArcBp(ArcBP_R,EarPtNum2,EarPtSum,EarPtList,DesPtList,DesPtSum);			 

				if (desinf == -1 || desinf == 0)//如果边坡交不到地面线，则将最后一个设计点与对于地面点直接连接
				{
					inf = Gety(DesPtList[(DesPtSum - 1) * 2], EarPtSum, EarPtList, EarH_LT, EarPtNum1);
					if (inf != 0)
					{
						DesPtSum++;
						if (EarPtNum1 < EarPtSum)
							k = EarPtNum1 + 1;
						else
							k = EarPtSum - 1;
						DesPtList[(DesPtSum - 1) * 2] = EarPtList[k * 2];
						DesPtList[(DesPtSum - 1) * 2 + 1] = EarPtList[k * 2 + 1];
					}
					//    WrErrFile(1,MR,ckml);
					//	 return -1;
				}

				if (IfTG)//要做天沟
				{
					inf = DesTGou(TG_BJ, TG_GW, TG_GS, TG_SP1, TG_SP2, TG_GDR, DesPtList, DesPtSum, EarPtList, EarPtSum, JSGouPtNum, JSgou);
					if (inf == 1 && JSGouPtNum > 3)//成功设计水沟
					{
						GouProperty = 2;//成功设置天沟
						BJX = JSgou[(JSGouPtNum - 1) * 2];//边界线					 
						ZDK = BJX + LZJK;

						CalGouArea(EarPtSum, EarPtList, JSGouPtNum, JSgou, GouTarea, GouWarea);//计算水沟面积
						AllGouJQArea += JSGouJQarea;//统计浆汽面积

					}
					else
					{
						IfTG = FALSE;
						JSGouPtNum = 0;
					}
				}


			}
			else
			{
				FillORCut = 0.0;
			}

			if (TmpCG_GDR < 0.001)//非蝶形沟
			{
				CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
				CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, 1,
					StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
					FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
			}
			else//蝶形沟
			{
				if (DesPtSum > 7)//有路堑水沟
				{
					//1计算出沟底弧形点
					double spt[2], ept[2], pt[20];
					spt[0] = DesPtList[5 * 2], spt[1] = DesPtList[5 * 2 + 1];
					ept[0] = DesPtList[6 * 2], ept[1] = DesPtList[6 * 2 + 1];
					GetArcPt(spt, ept, TmpCG_GDR, 10, pt);
					//2修正设计点
					int ptsum = DesPtSum + 10, npt;
					double despt[200];
					npt = 0;
					for (i = 0; i <= 5; i++)
					{
						despt[npt * 2] = DesPtList[i * 2];
						despt[npt * 2 + 1] = DesPtList[i * 2 + 1];
						npt++;
					}
					for (i = 0; i < 10; i++)
					{
						despt[npt * 2] = pt[i * 2];
						despt[npt * 2 + 1] = pt[i * 2 + 1];

						npt++;
					}
					for (i = 6; i < DesPtSum; i++)
					{
						despt[npt * 2] = DesPtList[i * 2];
						despt[npt * 2 + 1] = DesPtList[i * 2 + 1];
						npt++;
					}


					DesPtSum = npt;
					for (i = 0; i < DesPtSum; i++)
					{
						DesPtList[i * 2] = despt[i * 2];
						DesPtList[i * 2 + 1] = despt[i * 2 + 1];

					}
					//3计算面积
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, 1,
						StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
				}


			}

			if (!IfTG)//要做天沟
				ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
			return 1;
		}
		else//路堤宽处,填高小于沟深,路堑宽处,判断为做路堤
		{
			GouProperty = -1;//初值
			FillORCut = 3.0;
			//做路堑水沟
			if ((DesPtList[4 * 2] + GS * SP1 + GS * SP2 + GK) <= ZJ)
			{
				FillORCut = 3.0;
				DesPtList[5 * 2] = DesPtList[4 * 2] + GS * GP1;
				DesPtList[5 * 2 + 1] = DesPtList[4 * 2 + 1] - GS;
				DesPtList[6 * 2] = DesPtList[5 * 2] + GK;
				DesPtList[6 * 2 + 1] = DesPtList[5 * 2 + 1];
				DesPtList[7 * 2] = DesPtList[6 * 2] + GS * GP2;
				DesPtList[7 * 2 + 1] = DesPtList[6 * 2 + 1] + GS;
				DesPtList[8 * 2] = DesPtList[7 * 2] + 0.5;//土埂
				DesPtList[8 * 2 + 1] = DesPtList[7 * 2 + 1];
				GouH = DesPtList[5 * 2 + 1];
				GouX = DesPtList[4 * 2] + GS * SP1 + 0.5*GK;
				DesPtSum = 9;
				AllGouJQArea += CGouJQarea;//统计侧沟浆汽面积
				//拟修改
				gou[2 * GouPtNum] = DesPtList[4 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[4 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[5 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[5 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[6 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[6 * 2 + 1];
				GouPtNum++;
				gou[2 * GouPtNum] = DesPtList[7 * 2];
				gou[2 * GouPtNum + 1] = DesPtList[7 * 2 + 1];
				GouPtNum++;

				StartDesPt[0] = DesPtList[8 * 2];
				StartDesPt[1] = DesPtList[8 * 2 + 1];
				inf = Gety(DesPtList[8 * 2], EarPtSum, EarPtList, EarH_LZ, EarPtNum2);
				if (inf == 0)//找不到对应点
				{
					//    WrErrFile(inf,MR,ckml);
					ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
					CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
					CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, -1,
						StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
						FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
					return -1;
				}

				dh = DesPtList[8 * 2 + 1] - EarH_LZ;
				if (dh < 0.0)//设计高小于地面高,路堑
					inf = CALXY(EarPtNum2, EarPtSum, 1, WM[0], StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);
				else  //路堤
					inf = CALXY(EarPtNum2, EarPtSum, -1, 1, StartDesPt[0], StartDesPt[1], 100, &XZ, &YZ, EarPtList);

				if (inf == 0)//找到交点
				{
					DesPtList[9 * 2] = XZ;
					DesPtList[9 * 2 + 1] = YZ;
					DesPtSum = 10;
				}
				else
				{
					//    WrErrFile(-3,MR,ckml);
					return -1;
				}
			}
			else
				FillORCut = 0.0;

			ZDK = DesPtList[(DesPtSum - 1) * 2] + LZJK;
			CalGouArea(EarPtSum, EarPtList, GouPtNum, gou, GouTarea, GouWarea);//计算水沟面积 拟修改
			CalDesAllArea(DesPtSum, DesPtList, EarPtSum, EarPtList, lmhd, hthd, glthd, hjwid, ZJ, 1,//1-挖方
				StartDesPt, WM, PH, ZPTW, ZPTI, nLZBPJS,
				FillArea, CutArea, QBTArea, FillGLTArea, HJarea);
		}

	}

	return 1;
}

//EarH 路基中心地面线高层
Adesk::Boolean HdmDes::SDM_L_setCROSSAutoDesignData(int iroad, int k, double Earh, DesignLine_ROAD *designline, LTGOU_ROAD *LTGou, JSGOU_ROAD * JSGou, EarthLine_ROAD * l_earthline, EarthLine_ROAD * r_earthline, HdmText_ROAD *Note)
{
	double  xx, y;
	int i, m;
	int gounum, jsgnum, pjqptnum;
	double PjqPt[20];
	if (designline->m_ZorY == -1)
	{
		designline->m_DesignPointNum = road[iroad].hdmdes[k].Lnpt;
		if (designline->m_DesignPoints) { delete designline->m_DesignPoints, designline->m_DesignPoints = NULL; }

		if (road[iroad].hdmdes[k].Lnpt > 0)
			designline->m_DesignPoints = new AcGePoint3d[designline->m_DesignPointNum];
		designline->m_FillORCut = road[iroad].hdmdes[k].Zt;
		//////////////////////////////////////////////////////////////////////////
		// 		  l_earthline->m_BenchPointNum = road[iroad].hdmBench[k].ZEarPtNum;
		// 		  if(l_earthline->m_BenchPoints){delete l_earthline->m_BenchPoints,l_earthline->m_BenchPoints=NULL;}
		// 		  
		// 		  if(l_earthline->m_BenchPointNum>0)
		// 			  l_earthline->m_BenchPoints = new AcGePoint3d[l_earthline->m_BenchPointNum];
		// 		  for(i=0; i<l_earthline->m_BenchPointNum ; i++)
		// 		  {
		// 			  xx = -road[iroad].hdmBench[k].ZEarPtAry[i].x;
		// 			  y = road[iroad].hdmBench[k].ZEarPtAry[i].y + Earh- road[iroad].hdmdes[k].Ymin;
		// 			  l_earthline->m_BenchPoints[i].x =  l_earthline->m_OriPoint.x + xx*Sfactor;
		// 			  l_earthline->m_BenchPoints[i].y =  l_earthline->m_OriPoint.y + y*Sfactor;
		// 		  }
		//////////////////////////////////////////////////////////////////////////
		std::vector<AcGePoint3d> watchpt;

		for (i = 1; i < designline->m_DesignPointNum; i++)
		{
			xx = road[iroad].hdmdes[k].RPTL[i].x;
			y = road[iroad].hdmdes[k].RPTL[i].y + Earh - road[iroad].hdmdes[k].Ymin;
			designline->m_DesignPoints[i].x = l_earthline->m_OriPoint.x + xx * Sfactor;
			designline->m_DesignPoints[i].y = l_earthline->m_OriPoint.y + y * Sfactor;
			watchpt.push_back(designline->m_DesignPoints[i]);
		}

		if (road[iroad].hdmdes[k].Lnpt > 0)
		{
			designline->m_DesignPoints[0].x = l_earthline->m_OriPoint.x;
			designline->m_DesignPoints[0].y = designline->m_DesignPoints[1].y;
		}
		//画带有浆切的侧沟
		//对坡脚点赋值
		if (designline->m_DesignPointNum > 0)
			LTGou->m_PJDpt = designline->m_DesignPoints[designline->m_DesignPointNum - 1];
		LTGou->GouProperty = road[iroad].hdmdes[k].LGouProperty;
		if ((road[iroad].hdmdes[k].LGouProperty == 1 || road[iroad].hdmdes[k].LGouProperty == 3) && road[iroad].hdmdes[k].LGouPtNum > 0)	//20200430
		{
			gounum = 0;
			for (i = 0; i < road[iroad].hdmdes[k].LGouPtNum; i++)
			{
				xx = road[iroad].hdmdes[k].Lgou[i * 2];
				if (fabs(xx) > 0.0001)
				{
					y = road[iroad].hdmdes[k].Lgou[i * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
					LTGou->m_LTGouPoints[gounum].x = l_earthline->m_OriPoint.x + xx * Sfactor;
					LTGou->m_LTGouPoints[gounum].y = l_earthline->m_OriPoint.y + y * Sfactor;//+ pCross.m_TWH;
					gounum++;
				}
			}

			LTGou->m_LTGouPointNum = gounum;
			if (gounum >= 5 && gounum < 15)
			{
				if (gounum == 6)
					LTGou->m_GouBotH = road[iroad].hdmdes[k].Lgou[2 * 2 + 1] + Earh;
				else
					LTGou->m_GouBotH = road[iroad].hdmdes[k].Lgou[2 * 2 + 1] + Earh + LTGou->PSG_JQHD;
				LTGou->m_GouBotX = 0.5*(road[iroad].hdmdes[k].Lgou[3 * 2] + road[iroad].hdmdes[k].Lgou[2 * 2]);
				LTGou->m_GouBotPoint.x = 0.5*(LTGou->m_LTGouPoints[3].x + LTGou->m_LTGouPoints[2].x);
				LTGou->m_GouBotPoint.y = LTGou->m_LTGouPoints[3].y;
				LTGou->m_OriGouBotPt = LTGou->m_GouBotPoint;
			}
			if (gounum >= 15)
			{
				if (gounum == 16)
					LTGou->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].Lgou[7 * 2 + 1] + road[iroad].hdmdes[k].Lgou[8 * 2 + 1]) + Earh;
				else
					LTGou->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].Lgou[7 * 2 + 1] + road[iroad].hdmdes[k].Lgou[8 * 2 + 1]) + Earh + LTGou->PSG_JQHD;
				LTGou->m_GouBotX = 0.5 * (road[iroad].hdmdes[k].Lgou[7 * 2] + road[iroad].hdmdes[k].Lgou[8 * 2]);
				LTGou->m_GouBotPoint.x = 0.5*(LTGou->m_LTGouPoints[7].x + LTGou->m_LTGouPoints[8].x);
				LTGou->m_GouBotPoint.y = 0.5 * (LTGou->m_LTGouPoints[7].y + LTGou->m_LTGouPoints[8].y);
				LTGou->m_OriGouBotPt = LTGou->m_GouBotPoint;
			}


		}
		else if (road[iroad].hdmdes[k].LGouProperty == 0 && road[iroad].hdmdes[k].LGouPtNum > 0)
		{

			AcGePoint3d JD, preJD;
			JD.x = designline->m_DesignPoints[designline->m_DesignPointNum - 1].x;
			JD.y = designline->m_DesignPoints[designline->m_DesignPointNum - 1].y;
			preJD.x = designline->m_DesignPoints[designline->m_DesignPointNum - 2].x;
			preJD.y = designline->m_DesignPoints[designline->m_DesignPointNum - 2].y;
			CalPjqPt(-1, JD, preJD, pjqptnum, PjqPt);
			LTGou->pjqptnum = pjqptnum;
			for (m = 0; m < pjqptnum; m++)
			{
				LTGou->PjqPt[m].x = PjqPt[2 * m];
				LTGou->PjqPt[m].y = PjqPt[2 * m + 1];
			}


		}
		else if ((road[iroad].hdmdes[k].LGouProperty == 2 || road[iroad].hdmdes[k].LGouProperty == 4) && road[iroad].hdmdes[k].LGouPtNum > 0)//设置天沟	20200430
		{
			jsgnum = 0;
			for (i = 0; i < road[iroad].hdmdes[k].LJSGouPtNum; i++)
			{
				xx = road[iroad].hdmdes[k].LJSgou[i * 2];
				if (fabs(xx) > 0.0001)
				{
					y = road[iroad].hdmdes[k].LJSgou[i * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
					JSGou->m_JSGouPoints[jsgnum].x = l_earthline->m_OriPoint.x + xx * Sfactor;
					JSGou->m_JSGouPoints[jsgnum].y = l_earthline->m_OriPoint.y + y * Sfactor;
					jsgnum++;
				}

			}
			JSGou->JSGouPtNum = jsgnum;

			if (jsgnum >= 4 && JSGou->TG_GDR < 0.001)
			{
				JSGou->m_GouBotH = road[iroad].hdmdes[k].LJSgou[1 * 2 + 1] + Earh;//沟底中心地面高程
				JSGou->m_GouBotX = 0.5*(road[iroad].hdmdes[k].LJSgou[1 * 2] + road[iroad].hdmdes[k].LJSgou[2 * 2]);//沟底中心的小x坐标
				JSGou->m_GouBotPoint.x = 0.5*(JSGou->m_JSGouPoints[1].x + JSGou->m_JSGouPoints[2].x);
				JSGou->m_GouBotPoint.y = JSGou->m_JSGouPoints[1].y;
				JSGou->m_OriGouBotPt = JSGou->m_GouBotPoint;
			}
			if (jsgnum >= 14 && JSGou->TG_GDR > 0.001)
			{
				JSGou->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].LJSgou[6 * 2 + 1] + road[iroad].hdmdes[k].LJSgou[7 * 2 + 1]) + Earh;//沟底中心地面高程
				JSGou->m_GouBotX = 0.5 * (road[iroad].hdmdes[k].LJSgou[6 * 2] + road[iroad].hdmdes[k].LJSgou[7 * 2]);//沟底中心的小x坐标
				JSGou->m_GouBotPoint.x = 0.5*(JSGou->m_JSGouPoints[6].x + JSGou->m_JSGouPoints[7].x);
				JSGou->m_GouBotPoint.y = 0.5 * (JSGou->m_JSGouPoints[6].y + JSGou->m_JSGouPoints[7].y);
				JSGou->m_OriGouBotPt = JSGou->m_GouBotPoint;
			}

		}

		//天沟的浆切
		if ((road[iroad].hdmdes[k].LGouProperty == 2 || road[iroad].hdmdes[k].LGouProperty == 4) && road[iroad].hdmdes[k].LGouPtNum > 0)	//20200430
		{
			TGhasJQ(-1, JSGou->m_JSGouPoints, JSGou->TG_JQHD,
				JSGou->SP1, JSGou->SP2, JSGou->GS, JSGou->TG_GDR,
				JSGou->JqPtNum, JSGou->JqPt,
				l_earthline->m_EarthPointNum, l_earthline->m_EarthPoints);

		}

		//画路堑的侧沟浆切
		double D;
		if (fabs(designline->m_FillORCut - 1.0) < 0.001 || fabs(designline->m_FillORCut - 3.0) < 0.001)
		{
			//				  if (designline->m_DesignPointNum>7)//增加该判断条件，否则CGhasJQ()出现数组越界。李伟 2008-03-09
			//				  {
			// 					  CGhasJQ(-1,designline->m_DesignPoints,designline->CG_JQHD,
			// 						  designline->GP1,designline->GP2,designline->GS,
			// 						  designline->JqPtNum,designline->JqPt);
			// 					  CGhasJQ(-1,designline->m_DesignPoints,designline->CG_JQHD,designline->CG_GDR,
			// 						  designline->JqPtNum,designline->JqPt);
			//				  }

		}
		//画水沟的浆切

		if (road[iroad].hdmdes[k].LGouProperty == 1 || road[iroad].hdmdes[k].LGouProperty == 3)			//20200430
			// 				  SGhasJQ(-1,LTGou->m_LTGouPointNum,LTGou->m_LTGouPoints,LTGou->PSG_JQHD,
				// 				  LTGou->m_SP1,LTGou->m_SP2,LTGou->m_GH,LTGou->m_PSG_GDR, LTGou->JqPtNum,LTGou->JqPt);
			SGhasJQ(-1, LTGou->m_LTGouPointNum, LTGou->m_LTGouPoints, LTGou->PSG_JQHD,
				LTGou->JqPtNum, LTGou->JqPt);

		designline->SetBPStr(designline->m_FillORCut, designline->m_DesignPointNum, designline->m_DesignPoints, Note->m_ZBP, Note->m_ZSlopPt, -1);


		/////////////////////////////////////  
		//标注内容

		Note->m_fillarea = road[iroad].hdmdes[k].at;
		Note->m_cutarea = road[iroad].hdmdes[k].aw;
		Note->LZDK = road[iroad].hdmdes[k].LZDK;

		//	   ads_printf(L"\n###cml=%lf,zl=%lf,yr=%lf",road[iroad].hdmdes[k].cml,road[iroad].hdmdes[k].Z_LFillArea ,road[iroad].hdmdes[k].Y_RFillArea);

		Note->Z_LFillArea = road[iroad].hdmdes[k].Z_LFillArea; Note->MidFillArea = road[iroad].hdmdes[k].MidFillArea; Note->Y_RFillArea = road[iroad].hdmdes[k].Y_RFillArea;
		Note->Z_LCutArea = road[iroad].hdmdes[k].Z_LCutArea; Note->MidCutArea = road[iroad].hdmdes[k].MidCutArea; Note->Y_RCutArea = road[iroad].hdmdes[k].Y_RCutArea;
		//	   Note->Z_LFillSSTArea = road[iroad].hdmdes[k].Z_LFillSSTArea ;Note->MidFillSSTArea=road[iroad].hdmdes[k].MidFillSSTArea;Note->Y_RFillSSTArea=road[iroad].hdmdes[k].Y_RFillSSTArea;//填渗水土面积
		Note->Z_LQBTArea = road[iroad].hdmdes[k].Z_LQBTArea; Note->MidQBTArea = road[iroad].hdmdes[k].MidQBTArea; Note->Y_RQBTArea = road[iroad].hdmdes[k].Y_RQBTArea;
		//	   Note->Z_LFillBetterSoilArea=road[iroad].hdmdes[k].Z_LFillBetterSoilArea ; Note->MidFillGLTArea=road[iroad].hdmdes[k].MidFillGLTArea ;Note->Y_RFillBetterSoilArea=road[iroad].hdmdes[k].Y_RFillBetterSoilArea;
		//	   Note->Z_LHJarea=road[iroad].hdmdes[k].Z_LHJarea ;Note->MidHJarea=road[iroad].hdmdes[k].MidHJarea ;Note->Y_RHJarea=road[iroad].hdmdes[k].Y_RHJarea;
		Note->Z_LSGJQarea = road[iroad].hdmdes[k].Z_LSGJQarea; Note->MidGouJQarea = road[iroad].hdmdes[k].MidGouJQarea; Note->Y_RSGJQarea = road[iroad].hdmdes[k].Y_RSGJQarea;
		Note->Z_LDQlength = road[iroad].hdmdes[k].Z_LDQlength; Note->MidDQlength = road[iroad].hdmdes[k].MidDQlength; Note->Y_RDQlength = road[iroad].hdmdes[k].Y_RDQlength;//挡墙坡长
		Note->Z_LGrasslength = road[iroad].hdmdes[k].Z_LGrasslength; Note->MidGrasslength = road[iroad].hdmdes[k].MidGrasslength; Note->Y_RGrasslength = road[iroad].hdmdes[k].Y_RGrasslength;//铺草坡长
		Note->Z_LGouTarea = road[iroad].hdmdes[k].Z_LGouTarea; Note->Y_RGouTarea = road[iroad].hdmdes[k].Y_RGouTarea;
		Note->Z_LGouWarea = road[iroad].hdmdes[k].Z_LGouWarea; Note->Y_RGouWarea = road[iroad].hdmdes[k].Y_RGouWarea;

	}
	return Adesk::kTrue;
}

Adesk::Boolean HdmDes::SDM_R_setCROSSAutoDesignData(int iroad, int k, double Earh, DesignLine_ROAD *designline, LTGOU_ROAD *LTGou, JSGOU_ROAD * JSGou, EarthLine_ROAD * l_earthline, EarthLine_ROAD * r_earthline, HdmText_ROAD *Note)
{
	int i;
	double xx, y;
	int gounum, pjqptnum;
	double PjqPt[20];
	if (designline->m_ZorY == 1)
	{
		designline->m_DesignPointNum = road[iroad].hdmdes[k].Rnpt;
		if (designline->m_DesignPoints) { delete designline->m_DesignPoints, designline->m_DesignPoints = NULL; }
		if (road[iroad].hdmdes[k].Rnpt > 0)
			designline->m_DesignPoints = new AcGePoint3d[designline->m_DesignPointNum];
		designline->m_FillORCut = road[iroad].hdmdes[k].Yt;

		//////////////////////////////////////////////////////////////////////////
		// 		r_earthline->m_BenchPointNum = road[iroad].hdmBench[k].YEarPtNum;
		// 		if(r_earthline->m_BenchPoints){delete r_earthline->m_BenchPoints,r_earthline->m_BenchPoints=NULL;}
		// 		
		// 		if(r_earthline->m_BenchPointNum>0)
		// 			  r_earthline->m_BenchPoints = new AcGePoint3d[r_earthline->m_BenchPointNum];
		// 		for(i=0; i<r_earthline->m_BenchPointNum ; i++)
		// 		{
		// 			xx = road[iroad].hdmBench[k].YEarPtAry[i].x;
		// 			y = road[iroad].hdmBench[k].YEarPtAry[i].y + Earh- road[iroad].hdmdes[k].Ymin;
		// 			r_earthline->m_BenchPoints[i].x =  r_earthline->m_OriPoint.x + xx*Sfactor;
		// 			r_earthline->m_BenchPoints[i].y =  r_earthline->m_OriPoint.y + y*Sfactor;
		// 		}
		//////////////////////////////////////////////////////////////////////////
		for (i = 1; i < road[iroad].hdmdes[k].Rnpt; i++)
		{
			xx = road[iroad].hdmdes[k].RPTR[i].x;
			y = road[iroad].hdmdes[k].RPTR[i].y + Earh - road[iroad].hdmdes[k].Ymin;
			designline->m_DesignPoints[i].x = r_earthline->m_OriPoint.x + xx * Sfactor;
			designline->m_DesignPoints[i].y = r_earthline->m_OriPoint.y + y * Sfactor;
			//if(fabs(road[iroad].hdmdes[k].cml-4800)<0.1)
			//ads_printf(L"\n^^^road[iroad].hdmdes[k].cml=%lf,x=%lf,y=%lf",road[iroad].hdmdes[k].cml,road[iroad].hdmdes[k].RPTR[i].x,road[iroad].hdmdes[k].RPTR[i].y);
		}
		if (road[iroad].hdmdes[k].Rnpt > 0)
		{
			designline->m_DesignPoints[0].x = r_earthline->m_OriPoint.x;
			designline->m_DesignPoints[0].y = designline->m_DesignPoints[1].y;
		}

		//对坡脚点赋值
		if (designline->m_DesignPointNum > 0)
			LTGou->m_PJDpt = designline->m_DesignPoints[designline->m_DesignPointNum - 1];
		//画带有浆切的侧沟
		LTGou->GouProperty = road[iroad].hdmdes[k].RGouProperty;

		if ((road[iroad].hdmdes[k].RGouProperty == 1 || road[iroad].hdmdes[k].RGouProperty == 3) && road[iroad].hdmdes[k].RGouPtNum > 0)	//20200430新增
		{
			gounum = 0;
			for (i = 0; i < road[iroad].hdmdes[k].RGouPtNum; i++)
			{
				xx = road[iroad].hdmdes[k].Rgou[i * 2];
				if (fabs(xx) > 0.0001)
				{
					y = road[iroad].hdmdes[k].Rgou[i * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
					LTGou->m_LTGouPoints[gounum].x = r_earthline->m_OriPoint.x + xx * Sfactor;
					LTGou->m_LTGouPoints[gounum].y = r_earthline->m_OriPoint.y + y * Sfactor;//+ pCross.m_TWH;
					gounum++;
				}
			}

			LTGou->m_LTGouPointNum = gounum;
			if (gounum >= 5 && gounum < 15)
			{
				if (gounum == 6)
					LTGou->m_GouBotH = road[iroad].hdmdes[k].Rgou[2 * 2 + 1] + Earh;
				else
					LTGou->m_GouBotH = road[iroad].hdmdes[k].Rgou[2 * 2 + 1] + Earh + LTGou->PSG_JQHD;
				LTGou->m_GouBotX = 0.5*(road[iroad].hdmdes[k].Rgou[3 * 2] + road[iroad].hdmdes[k].Rgou[2 * 2]);
				LTGou->m_GouBotPoint.x = 0.5*(LTGou->m_LTGouPoints[3].x + LTGou->m_LTGouPoints[2].x);
				LTGou->m_GouBotPoint.y = LTGou->m_LTGouPoints[3].y;
				LTGou->m_OriGouBotPt = LTGou->m_GouBotPoint;
			}
			if (gounum >= 15)
			{
				if (gounum == 16)
					LTGou->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].Rgou[7 * 2 + 1] + road[iroad].hdmdes[k].Rgou[8 * 2 + 1]) + Earh;
				else
					LTGou->m_GouBotH = 0.5 * (road[iroad].hdmdes[k].Rgou[7 * 2 + 1] + road[iroad].hdmdes[k].Rgou[8 * 2 + 1]) + Earh + LTGou->PSG_JQHD;
				LTGou->m_GouBotX = 0.5 * (road[iroad].hdmdes[k].Rgou[7 * 2] + road[iroad].hdmdes[k].Rgou[8 * 2]);
				LTGou->m_GouBotPoint.x = 0.5*(LTGou->m_LTGouPoints[7].x + LTGou->m_LTGouPoints[8].x);
				LTGou->m_GouBotPoint.y = 0.5 * (LTGou->m_LTGouPoints[7].y + LTGou->m_LTGouPoints[8].y);
				LTGou->m_OriGouBotPt = LTGou->m_GouBotPoint;
			}

		}
		else if (road[iroad].hdmdes[k].RGouProperty == 0 && road[iroad].hdmdes[k].RGouPtNum > 0)
		{

			AcGePoint3d JD, preJD;
			JD.x = designline->m_DesignPoints[designline->m_DesignPointNum - 1].x;
			JD.y = designline->m_DesignPoints[designline->m_DesignPointNum - 1].y;
			preJD.x = designline->m_DesignPoints[designline->m_DesignPointNum - 2].x;
			preJD.y = designline->m_DesignPoints[designline->m_DesignPointNum - 2].y;
			CalPjqPt(1, JD, preJD, pjqptnum, PjqPt);
			LTGou->pjqptnum = pjqptnum;
			for (int m = 0; m < pjqptnum; m++)
			{
				LTGou->PjqPt[m].x = PjqPt[2 * m];
				LTGou->PjqPt[m].y = PjqPt[2 * m + 1];
			}


		}
		else if ((road[iroad].hdmdes[k].RGouProperty == 2 || road[iroad].hdmdes[k].RGouProperty == 4) && road[iroad].hdmdes[k].RGouPtNum > 0)//设置天沟	20200430
		{
			int jsgnum = 0;
			for (i = 0; i < road[iroad].hdmdes[k].RJSGouPtNum; i++)
			{
				xx = road[iroad].hdmdes[k].RJSgou[i * 2];
				if (fabs(xx) > 0.0001)
				{
					y = road[iroad].hdmdes[k].RJSgou[i * 2 + 1] + Earh - road[iroad].hdmdes[k].Ymin;
					JSGou->m_JSGouPoints[jsgnum].x = r_earthline->m_OriPoint.x + xx * Sfactor;
					JSGou->m_JSGouPoints[jsgnum].y = r_earthline->m_OriPoint.y + y * Sfactor;
					jsgnum++;
				}

			}
			JSGou->JSGouPtNum = jsgnum;

			JSGou->m_GouBotH = road[iroad].hdmdes[k].RJSgou[2 * 1 + 1] + Earh;//沟底中心地面高程
			JSGou->m_GouBotX = 0.5*(road[iroad].hdmdes[k].RJSgou[2 * 2] + road[iroad].hdmdes[k].RJSgou[2 * 1]);//沟底中心的小x坐标
			JSGou->m_GouBotPoint.x = 0.5*(JSGou->m_JSGouPoints[1].x + JSGou->m_JSGouPoints[2].x);
			JSGou->m_GouBotPoint.y = JSGou->m_JSGouPoints[1].y;
			JSGou->m_OriGouBotPt = JSGou->m_GouBotPoint;

		}
		//天沟的浆切
		if (road[iroad].hdmdes[k].RGouProperty == 2 || road[iroad].hdmdes[k].RGouProperty == 4)
		{
			TGhasJQ(1, JSGou->m_JSGouPoints, JSGou->TG_JQHD,
				JSGou->SP1, JSGou->SP2, JSGou->GS, JSGou->TG_GDR,
				JSGou->JqPtNum, JSGou->JqPt,
				r_earthline->m_EarthPointNum, r_earthline->m_EarthPoints);

		}

		//画路堑的侧沟浆切
		if (fabs(designline->m_FillORCut - 1.0) < 0.001 || fabs(designline->m_FillORCut - 3.0) < 0.001)
		{

			//			if (designline->m_DesignPointNum>7)//增加该判断条件，否则CGhasJQ()出现数组越界。李伟 2008-03-09
			// 			CGhasJQ(1,designline->m_DesignPoints,designline->CG_JQHD,
			// 				designline->GP1,designline->GP2,designline->GS,
			// 				designline->JqPtNum,designline->JqPt);
			// 				CGhasJQ(1,designline->m_DesignPoints,designline->CG_JQHD,designline->CG_GDR,
			// 						designline->JqPtNum,designline->JqPt);
		}
		//画水沟的浆切

		if (road[iroad].hdmdes[k].RGouProperty == 1 || road[iroad].hdmdes[k].RGouProperty == 3)		//20200430
			// 			SGhasJQ(1,LTGou->m_LTGouPointNum,LTGou->m_LTGouPoints,LTGou->PSG_JQHD,
				// 			LTGou->m_SP1,LTGou->m_SP2,LTGou->m_GH,LTGou->m_PSG_GDR,LTGou->JqPtNum,LTGou->JqPt);
			SGhasJQ(1, LTGou->m_LTGouPointNum, LTGou->m_LTGouPoints, LTGou->PSG_JQHD,
				LTGou->JqPtNum, LTGou->JqPt);

		/////////////////////////////////////  
		//标注内容
		designline->SetBPStr(designline->m_FillORCut, designline->m_DesignPointNum, designline->m_DesignPoints, Note->m_YBP, Note->m_YSlopPt, 1);
		Note->m_fillarea = road[iroad].hdmdes[k].at;
		Note->m_cutarea = road[iroad].hdmdes[k].aw;
		Note->RZDK = road[iroad].hdmdes[k].RZDK;

		Note->Z_LFillArea = road[iroad].hdmdes[k].Z_LFillArea; Note->MidFillArea = road[iroad].hdmdes[k].MidFillArea; Note->Y_RFillArea = road[iroad].hdmdes[k].Y_RFillArea;
		Note->Z_LCutArea = road[iroad].hdmdes[k].Z_LCutArea; Note->MidCutArea = road[iroad].hdmdes[k].MidCutArea; Note->Y_RCutArea = road[iroad].hdmdes[k].Y_RCutArea;
		//	Note->Z_LFillSSTArea = road[iroad].hdmdes[k].Z_LFillSSTArea ;Note->MidFillSSTArea=road[iroad].hdmdes[k].MidFillSSTArea;Note->Y_RFillSSTArea=road[iroad].hdmdes[k].Y_RFillSSTArea;//填渗水土面积
		Note->Z_LQBTArea = road[iroad].hdmdes[k].Z_LQBTArea; Note->MidQBTArea = road[iroad].hdmdes[k].MidQBTArea; Note->Y_RQBTArea = road[iroad].hdmdes[k].Y_RQBTArea;
		//	Note->Z_LFillBetterSoilArea=road[iroad].hdmdes[k].Z_LFillBetterSoilArea ; Note->MidFillGLTArea=road[iroad].hdmdes[k].MidFillGLTArea ;Note->Y_RFillBetterSoilArea=road[iroad].hdmdes[k].Y_RFillBetterSoilArea;
		//	Note->Z_LHJarea=road[iroad].hdmdes[k].Z_LHJarea ;Note->MidHJarea=road[iroad].hdmdes[k].MidHJarea ;Note->Y_RHJarea=road[iroad].hdmdes[k].Y_RHJarea;
		Note->Z_LSGJQarea = road[iroad].hdmdes[k].Z_LSGJQarea; Note->MidGouJQarea = road[iroad].hdmdes[k].MidGouJQarea; Note->Y_RSGJQarea = road[iroad].hdmdes[k].Y_RSGJQarea;
		Note->Z_LDQlength = road[iroad].hdmdes[k].Z_LDQlength; Note->MidDQlength = road[iroad].hdmdes[k].MidDQlength; Note->Y_RDQlength = road[iroad].hdmdes[k].Y_RDQlength;//挡墙坡长
		Note->Z_LGrasslength = road[iroad].hdmdes[k].Z_LGrasslength; Note->MidGrasslength = road[iroad].hdmdes[k].MidGrasslength; Note->Y_RGrasslength = road[iroad].hdmdes[k].Y_RGrasslength;//铺草坡长
		Note->Z_LGouTarea = road[iroad].hdmdes[k].Z_LGouTarea; Note->Y_RGouTarea = road[iroad].hdmdes[k].Y_RGouTarea;
		Note->Z_LGouWarea = road[iroad].hdmdes[k].Z_LGouWarea; Note->Y_RGouWarea = road[iroad].hdmdes[k].Y_RGouWarea;

	}
	return Adesk::kTrue;
}

//双路面戴帽子，几统计面积
//void HdmDes::SDM_DoubleLMAutoDesign(int iroad,int j,DesignLine *designline,LTGOU *LTGou,JSGOU* JSGou,EarthLine * l_earthline,EarthLine * r_earthline,HdmText *Note)
//{
//	int i;
//	double *L_EarPtList,*R_EarPtList;
//	int L_EarPtSum,R_EarPtSum;
//	double NewYd,NewLearpt[400],NewRearpt[400];
//    int newNumL,newNumR;
//	double cml,TWH;
//	double offsetX,YoffsetX,EarH,DorS;
//    int ZorY; 
//    //双路面
//	int Z_Lnpt,Y_Rnpt;
//	double Z_LDesPoint[50],Y_RDesPoint[50];
//	//面积
//	double Z_LFillArea,Z_LCutArea,Y_RFillArea,Y_RCutArea;
//	double Z_LFillBetterSoilArea,Z_LFillSSTArea,Z_LQBTArea,Z_LGouTarea,Z_LGouWarea,Z_LJSgou[20],Z_LHJarea,Z_LSGJQarea,Z_LDQlength,Z_LGrasslength;
//	double Y_RFillBetterSoilArea,Y_RFillSSTArea,Y_RQBTArea,Y_RGouTarea,Y_RGouWarea,Y_RJSgou[20],Y_RHJarea,Y_RSGJQarea,Y_RDQlength,Y_RGrasslength;
//	double Z_LGouH,Z_LGouX,Y_RGouH,Y_RGouX;
//	double Z_TWH,Y_TWH;
//	int Z_LGouProperty,Z_LGouPtNum,Z_LJSGouPtNum;
//	int Y_RGouProperty,Y_RGouPtNum,Y_RJSGouPtNum;
//	double Z_Lgou[14],Y_Rgou[14];
//	//填挖信息
//	double ZX_TW[2],YX_TW[2];
//	double Z_LZDK,Y_RZDK;
//	double LNewYd,RNewYd;
//	double Z_NewLearpt[400],Z_NewRearpt[400],Y_NewLearpt[400],Y_NewRearpt[400];
//	int Z_NewNumL,Z_NewNumR,Y_NewNumL,Y_NewNumR,j;
//	double xori,yori;
//	double RHF[8];
//   AcGePoint3d pt;
//	//地面线实体的是相对与左线路基中心线坐标
//	L_EarPtSum=l_earthline->m_EarthPointNum;
//	//if(L_EarPtList) {delete []L_EarPtList;L_EarPtList=NULL;}
//	L_EarPtList = new double[(l_earthline->m_EarthPointNum +1)*2];
//	xori = l_earthline->m_OriPoint.x;
//	yori = l_earthline->m_OriPoint.y;
//	for(i=0; i<l_earthline->m_EarthPointNum; i++)
//	{
//		L_EarPtList[i*2] = fabs(l_earthline->m_EarthPoints[i].x-xori)/Sfactor;//x为正
//		L_EarPtList[i*2+1] = (l_earthline->m_EarthPoints[i].y-yori)/Sfactor+Crs[ii].Ymin-designline->LnewYd;
//
//	}
//	//ads_printf(L"\n$$$ymin=%lf",Crs[ii].Ymin);
//	R_EarPtSum=r_earthline->m_EarthPointNum;
////	if(R_EarPtList) {delete []R_EarPtList;R_EarPtList=NULL;}
//	R_EarPtList = new double[(r_earthline->m_EarthPointNum +1)*2];
//	xori = r_earthline->m_OriPoint.x;
//	yori = r_earthline->m_OriPoint.y;
//	for(i=0; i<r_earthline->m_EarthPointNum; i++)
//	{
//		R_EarPtList[i*2] = fabs(r_earthline->m_EarthPoints[i].x-xori)/Sfactor;//x为正
//		R_EarPtList[i*2+1] = (r_earthline->m_EarthPoints[i].y-yori)/Sfactor+Crs[ii].Ymin-designline->LnewYd;
//	}
//	cml=l_earthline->m_cml;
//	offsetX=fabs(Note->offsetX);
//	YoffsetX=Note->YoffsetX;
//	DorS=Note->DorS;
//    EarH=Note->EarH;
//	ZorY=designline->m_ZorY;
//	//2、由Note的offsetX调用calNewZB();得到新的地面线坐标
//	//CalNewZB(offsetX,EarH,L_EarPtList,L_EarPtSum,R_EarPtList,R_EarPtSum,
//		//LNewYd,Z_NewLearpt,Z_NewNumL,Z_NewRearpt,Z_NewNumR);
//	CalNewZB(YoffsetX+offsetX,designline->LnewYd,L_EarPtList,L_EarPtSum,R_EarPtList,R_EarPtSum,
//		RNewYd,Y_NewLearpt,Y_NewNumL,Y_NewRearpt,Y_NewNumR);//右线右侧相对于路基中心线的地面线坐标////
//	//3、CrosNew();自动代帽子由地面线、路面点	
//	double ZJ=1000;
////	ClearSZ(ii,Crs);//清空数组
//	if(ZorY==-1)//左线左侧
//	{
//		if(road[iroad].hdmdes[j].ZDMXZ==3||road[iroad].hdmdes[j].ZDMXZ==4)
//			return;
//
//		for(i=0; i<designline->m_nLTBPJS; i++)
//		{
//			nLTBPJS=designline->m_nLTBPJS;
//			TM[i] = designline->m_TM[i];
//			TH[i] = designline->m_TH[i];
//			
//			TPTW[i] = designline->m_TPTW[i];
//			TPTI[i] = designline->m_TPTI[i];		
//		}
//		for(i=0; i<designline->m_nLZBPJS; i++)
//		{
//			nLZBPJS=designline->m_nLZBPJS;
//			WM[i] = designline->m_WM[i];
//			PH[i] = designline->m_PH[i];
//			ZPTW[i] = designline->m_ZPTW[i];
//			ZPTI[i] = designline->m_ZPTI[i];	
//		}
//
//		SDM_CrosNew(//输入
//					iroad,//道路号
//					-1,cml,designline->LnewYd,L_EarPtSum,L_EarPtList,
//					designline->RHF,
//					nLTBPJS,TM,TH,TPTW,TPTI,
//					nLZBPJS,WM,PH,ZPTW,ZPTI,
//					//输出
//					lmhd,
//					road[iroad].hdmdes[j].Zt,road[iroad].hdmdes[j].ZHc,Lnpt,LDesPoint,
//				    LFillArea,LFillBetterSoilArea,LQBTArea,LCutArea,
//				    road[iroad].hdmdes[j].LZDK,
//				    road[iroad].hdmdes[j].LGouProperty,road[iroad].hdmdes[j].LGouPtNum,road[iroad].hdmdes[j].Lgou,LGouH,LGouX,LGouTarea,LGouWarea,
//				    road[iroad].hdmdes[j].LJSGouPtNum, road[iroad].hdmdes[j].LJSgou,
//				    LSGJQarea,LDQlength,LGrasslength);					
//
////		  SDM_CrosNew(-1,cml,ZJ,designline->LnewYd,L_EarPtSum,L_EarPtList,designline->RHF,designline,
////			  ZX_TW[0],Z_TWH,Z_Lnpt,Z_LDesPoint,
////		Z_LFillArea,Z_LFillBetterSoilArea,Z_LFillSSTArea,Z_LQBTArea,Z_LCutArea,
////		Z_LZDK,
////		Z_LGouProperty,Z_LGouPtNum,Z_Lgou,Z_LGouH,Z_LGouX,Z_LGouTarea,Z_LGouWarea,
////		Z_LJSGouPtNum, Z_LJSgou,
////		Z_LHJarea,Z_LSGJQarea,Z_LDQlength,Z_LGrasslength);
//
//		road[iroad].hdmdes[j].FillArea = Z_LFillArea + Note->MidFillArea +  Note->Y_RFillArea;
//		road[iroad].hdmdes[j].CutArea = Z_LCutArea +  Note->MidCutArea +  Note->Y_RCutArea;
//		road[iroad].hdmdes[j].FillSSTArea = Z_LFillSSTArea +  Note->Y_RFillSSTArea;//填渗水土面积
//		road[iroad].hdmdes[j].QBTArea = Z_LQBTArea +  Note->MidQBTArea +  Note->Y_RQBTArea;
//		road[iroad].hdmdes[j].FillBetterSoilArea = Z_LFillBetterSoilArea +  Note->MidFillGLTArea + Note-> Y_RFillBetterSoilArea;
//		road[iroad].hdmdes[j].HJarea = Z_LHJarea +  Note->MidHJarea +  Note->Y_RHJarea;
//		road[iroad].hdmdes[j].SGJQarea = Z_LSGJQarea +  Note->MidGouJQarea +  Note->Y_RSGJQarea;
//		road[iroad].hdmdes[j].DQlength = Z_LDQlength +  Note->MidDQlength + Note->Y_RDQlength;//挡墙坡长
//		road[iroad].hdmdes[j].Grasslength = Z_LGrasslength +  Note->MidGrasslength+ Note->Y_RGrasslength;//铺草坡长
//		road[iroad].hdmdes[j].GouTarea = Z_LGouTarea +  Note->Y_RGouTarea;
//		road[iroad].hdmdes[j].GouWarea = Z_LGouWarea +  Note->Y_RGouWarea;
//
//		road[iroad].hdmdes[j].Z_LFillArea =Z_LFillArea ;//填面积
//		road[iroad].hdmdes[j].Z_LCutArea = Z_LCutArea ; //挖面积
//		road[iroad].hdmdes[j].Z_LFillBetterSoilArea = Z_LFillBetterSoilArea;//填改良土面积
//		road[iroad].hdmdes[j].Z_LFillSSTArea = Z_LFillSSTArea;//填渗水土面积
//		road[iroad].hdmdes[j].Z_LQBTArea = Z_LQBTArea ;//清表土面积
//		road[iroad].hdmdes[j].Z_LGouTarea = Z_LGouTarea ;//水沟填面积
//		road[iroad].hdmdes[j].Z_LGouWarea = Z_LGouWarea ;//水沟挖面积
//		road[iroad].hdmdes[j].Z_LHJarea =  Z_LHJarea ;//护肩面积
//		road[iroad].hdmdes[j].Z_LSGJQarea = Z_LSGJQarea ;//浆砌面积
//		road[iroad].hdmdes[j].Z_LDQlength = Z_LDQlength ;//挡墙坡长
//		road[iroad].hdmdes[j].Z_LGrasslength = Z_LGrasslength ;//铺草坡长
//
//		road[iroad].hdmdes[j].at = road[iroad].hdmdes[j].FillArea;
//		road[iroad].hdmdes[j].aw = road[iroad].hdmdes[j].CutArea;
//
//		//左线左侧
//		road[iroad].hdmdes[j].Lnpt = Z_Lnpt;
//		for(j=0; j<Z_Lnpt; j++)
//		{ 
//			pt.x = -1.0*Z_LDesPoint[j*2];
//			pt.y =  Z_LDesPoint[j*2+1];
//			road[iroad].hdmdes[j].RPTL.append(pt);
//		}
//		road[iroad].hdmdes[j].Ljdnum = Z_Lnpt-1;
//		//左线左侧水沟
//		
//		road[iroad].hdmdes[j].LGouProperty = Z_LGouProperty;
//		road[iroad].hdmdes[j].LGouPtNum = Z_LGouPtNum;
//		for(int kk=0; kk<road[iroad].hdmdes[j].LGouPtNum; kk++)
//		{
//			road[iroad].hdmdes[j].Lgou[kk*2] = -1*Z_Lgou[kk*2];
//			road[iroad].hdmdes[j].Lgou[kk*2+1] = Z_Lgou[kk*2+1];
//		}
//		road[iroad].hdmdes[j].LJSGouPtNum = Z_LJSGouPtNum;
//		for(j=0; j<Z_LJSGouPtNum; j++)
//		{
//			road[iroad].hdmdes[j].LJSgou[j*2]=-1*Z_LJSgou[j*2];
//			road[iroad].hdmdes[j].LJSgou[j*2+1]=Z_LJSgou[j*2+1];
//		}
//		road[iroad].hdmdes[j].LZDK = Z_LZDK;
//		road[iroad].hdmdes[j].Zt=ZX_TW[0];
//		SDM_L_setCROSSAutoDesignData(ii,designline->LnewYd,designline,LTGou,JSGou,l_earthline,r_earthline,Note);
//		
//	}
//	if(ZorY==2)//右线右侧
//	{
//		for(int mm=0;mm<4;mm++)
//		{
//			RHF[mm*2]=designline->RHF[mm*2]-YoffsetX+offsetX;
//			RHF[mm*2+1]=designline->RHF[mm*2+1];
//		}
//		SDM_CrosNew(1,cml,ZJ,RNewYd,Y_NewNumR,Y_NewRearpt,RHF,designline,YX_TW[1],Y_TWH,
//		Y_Rnpt,Y_RDesPoint,Y_RFillArea,Y_RFillBetterSoilArea,Y_RFillSSTArea,Y_RQBTArea,Y_RCutArea,
//		Y_RZDK,Y_RGouProperty,Y_RGouPtNum,Y_Rgou,Y_RGouH,Y_RGouX,Y_RGouTarea,Y_RGouWarea,
//		Y_RJSGouPtNum, Y_RJSgou,Y_RHJarea,Y_RSGJQarea,Y_RDQlength,Y_RGrasslength);
//
//		road[iroad].hdmdes[j].FillArea = Note->Z_LFillArea + Note->MidFillArea +  Y_RFillArea;
//		road[iroad].hdmdes[j].CutArea = Note->Z_LCutArea + Note->MidCutArea +  Y_RCutArea;
//		road[iroad].hdmdes[j].FillSSTArea =  Note->Z_LFillSSTArea + Y_RFillSSTArea;//填渗水土面积
//		road[iroad].hdmdes[j].QBTArea =Note->Z_LQBTArea + Note->MidQBTArea +  Y_RQBTArea;
//		road[iroad].hdmdes[j].FillBetterSoilArea = Note->Z_LFillBetterSoilArea +  Note->MidFillGLTArea + Y_RFillBetterSoilArea;
//		road[iroad].hdmdes[j].HJarea = Note->Z_LHJarea +  Note->MidHJarea +  Y_RHJarea;
//		road[iroad].hdmdes[j].SGJQarea = Note->Z_LSGJQarea +  Note->MidGouJQarea +  Y_RSGJQarea;
//		road[iroad].hdmdes[j].DQlength = Note->Z_LDQlength +  Note->MidDQlength + Y_RDQlength;//挡墙坡长
//		road[iroad].hdmdes[j].Grasslength = Note->Z_LGrasslength +  Note->MidGrasslength+ Y_RGrasslength;//铺草坡长
//		road[iroad].hdmdes[j].GouTarea =Note->Z_LGouTarea +  Y_RGouTarea;
//		road[iroad].hdmdes[j].GouWarea = Note->Z_LGouWarea +  Y_RGouWarea;
//
//		road[iroad].hdmdes[j].Y_RFillArea =  Y_RFillArea;//填面积
//		road[iroad].hdmdes[j].Y_RCutArea = Y_RCutArea; //挖面积
//		road[iroad].hdmdes[j].Y_RFillBetterSoilArea = Y_RFillBetterSoilArea;//填改良土面积
//		road[iroad].hdmdes[j].Y_RFillSSTArea =  Y_RFillSSTArea;//填渗水土面积
//		road[iroad].hdmdes[j].Y_RQBTArea = Y_RQBTArea;//清表土面积
//		road[iroad].hdmdes[j].Y_RGouTarea =  Y_RGouTarea;//水沟填面积
//		road[iroad].hdmdes[j].Y_RGouWarea =  Y_RGouWarea;//水沟挖面积
//		road[iroad].hdmdes[j].Y_RHJarea =   Y_RHJarea;//护肩面积
//		road[iroad].hdmdes[j].Y_RSGJQarea =  Y_RSGJQarea;//浆砌面积
//		road[iroad].hdmdes[j].Y_RDQlength =  Y_RDQlength;//挡墙坡长
//		road[iroad].hdmdes[j].Y_RGrasslength = Y_RGrasslength;//铺草坡长
//
//		road[iroad].hdmdes[j].at = road[iroad].hdmdes[j].FillArea;
//		road[iroad].hdmdes[j].aw = road[iroad].hdmdes[j].CutArea;
//
//		//右线右侧
//		road[iroad].hdmdes[j].Y_Rnpt = Y_Rnpt;
//		for(j=0; j<Y_Rnpt; j++)
//		{ 
//			pt.x = Y_RDesPoint[j*2];
//			pt.y = Y_RDesPoint[j*2+1];
//			road[iroad].hdmdes[j].Y_RPTR.append(pt);
//		}
//		road[iroad].hdmdes[j].Y_Rjdnum = Y_Rnpt-1;
//		//左线左侧水沟
//		
//		//右线右侧
//		road[iroad].hdmdes[j].Y_RGouProperty = Y_RGouProperty;
//		//road[iroad].hdmdes[j].Y_LGouProperty = 1;
//		road[iroad].hdmdes[j].Y_RGouPtNum = Y_RGouPtNum;
//		for(int kk=0; kk<road[iroad].hdmdes[j].Y_RGouPtNum; kk++)
//		{
//			road[iroad].hdmdes[j].Y_Rgou[kk*2] = Y_Rgou[kk*2];
//			road[iroad].hdmdes[j].Y_Rgou[kk*2+1] = Y_Rgou[kk*2+1];
//		}
//		road[iroad].hdmdes[j].Y_RJSGouPtNum = Y_RJSGouPtNum;
//		for(j=0; j<Y_RJSGouPtNum; j++)
//		{
//			road[iroad].hdmdes[j].Y_RJSgou[j*2]=Y_RJSgou[j*2];
//			road[iroad].hdmdes[j].Y_RJSgou[j*2+1]=Y_RJSgou[j*2+1];
//		}
//		road[iroad].hdmdes[j].RZDK = Y_RZDK;
//		road[iroad].hdmdes[j].Y_Yt=YX_TW[1];
//		SDM_YR_setCROSSAutoDesignData(ii,RNewYd,designline,LTGou,JSGou,l_earthline,r_earthline,Note);	  
//		
//	}
// 
//}
//
//
void  HdmDes::DRAWHDMT()
{

	CreateLayer(L"清表土");
	//读文件		
	if (!ReadFile(false))//横断面标准
		return;

	ReadBDFile();

	//从鼻端文件中读取左右关联道路，若道路总数>0按互通处理，否则按分离式处理
	CString xl1;
	xl1.Format(L"%s,%s", road[0].pm->mdbname, road[0].roadname);

	//	SetHdmLm();//求路面

	FindAndReadLinkRoad_for3d(xl1);

	ads_printf(L"读数据库OK!\n");

	ads_printf(L"roadsum=%d\n", RoadSum);
	//横断面成果
	for (int i = 0; i < RoadSum; i++)
	{

		if (!ReadHdmResultFile(i))
			return;

		if (!ReadHdmAreaFile(i))
			return;
	}
	HDMTdlg dlg;

	if (dlg.DoModal() == IDOK)//输入设计参数
	{
		int iroad;

		iroad = GetIRoadByName(dlg.roadname);
		double sml, eml;
		sml = road[iroad].pm->TYLC(dlg.CKSml);
		eml = road[iroad].pm->TYLC(dlg.CKEml);

		int lnum;//列数
		lnum = dlg.lnum;
		double zk, yk;
		zk = dlg.m_ZK;
		yk = dlg.m_YK;
		StartX = dlg.m_SX;
		StartY = dlg.m_SY;   // 获取绘制起点
		CString TKname;
		TKname = dlg.m_TKNAME;
		CurRoad = iroad;
		int spage;
		spage = dlg.m_startpage;
		Ifpage = dlg.m_IfBZ;
		if (_wtof(dlg.m_scale) > 0.0001)
			Sfactor = 1000.0 / _wtof(dlg.m_scale);
		else
			Sfactor = 1000.0 / 200.0;

		DrawHdmMap(iroad, sml, eml, zk, yk, TKname, lnum, spage, Ifpage);
	}

	BAS_DRAW_FUN::SetLayerColor(L"图框", 7);	//20190805
}

void  HdmDes::DrawHdmMap(int iroad, double sml, double eml, double zk, double yk, CString TKname, int lnum, int spage, bool IfPage, bool IsShowGuide,double TabTextH,double NoteTextH)
{
	MAP = new HdmDes::Maplist[road[iroad].NCRS];

	//CreateMapList(iroad,sml,eml,zk,yk,lnum);    
	CalMapList(iroad, sml, eml, zk, yk, lnum);

	ads_point INSPT; double CENX, CENY; ACHAR s_ckml[256], e_ckml[256];
	for (int i = 0; i < MAPSUM; i++)
	{

		if (MAP[i].ncrs > 0)
			ads_printf(L"\n共%d幅图, 正在输出第%d幅图(%s - %s)......",
				MAPSUM, i, road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml,
				road[iroad].hdmdes[MAP[i].HDMNO[MAP[i].ncrs - 1]].ckml);
		else
			ads_printf(L"共%d幅图, 正在输出第%d幅图(%s - %s)......",
				MAPSUM, i, road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml,
				road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml);

		DrawAHdmMap(iroad, i, MAP, zk, yk, TabTextH, NoteTextH);//绘横断面图

		CENX = MAP[i].SX + m_FrameWid / 2.0;
		CENY = MAP[i].SY + m_FrameHeight / 2.0 - 100 / 2.0;
		_tcscpy(s_ckml, road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml);
		_tcscpy(e_ckml, road[iroad].hdmdes[MAP[i].HDMNO[MAP[i].ncrs - 1]].ckml);
		if (m_Isbuju_HDm == 1)
			DrawHDMOutput(CENX, CENY, s_ckml, e_ckml, TKname);

		CFileFind fd;
		if (fd.FindFile(TKname))
		{
			INSPT[X] = MAP[i].SX + m_FrameWid / 2.0, INSPT[Y] = MAP[i].SY + m_FrameHeight / 2.0 - 100 / 2.0 * 0.1 * Sfactor;		//20190821	修改横断面绘图位置，如需修改需要和CreateMapList计算绘图原点处联合修改

			ACHAR str[256];
			_stprintf(str, L"%s", TKname);
			AcDbVoidPtrArray entitySet;
			AcDbObjectId pBlockId = BAS_DRAW_FUN::CreateBlockFromDwgFile(str, m_FrameBlockName);
			if (pBlockId > 0)
			{
				AcGePoint3d InsertPt(INSPT[X], INSPT[Y], 0.0);
				AcDbBlockReference* pBkRr = new AcDbBlockReference(InsertPt, pBlockId);
				pBkRr->setScaleFactors(AcGeScale3d(1, 1, 1));
				pBkRr->setLayer(L"图框");
				pBkRr->setColorIndex(0);
				BAS_DRAW_FUN::AddEntityToDbs(pBkRr);
			}
		}
		AcGePoint3d pt;
		ACHAR str[180];
		//标注页码
		if (IfPage)
		{
			pt.x = MAP[i].SX + 780 - 45;
			pt.y = MAP[i].SY + 554 - 10;
			_stprintf(str, L"%d", spage + i);
			maketext(pt, str, 0.0, 4.0, 7, 2);
			pt.x = MAP[i].SX + 780 - 15;
			_stprintf(str, L"%d", MAPSUM);
			maketext(pt, str, 0.0, 4.0, 7, 2);
		}
		pt.x = MAP[i].SX + 380 - 30;
		pt.y = MAP[i].SY + 277 - 5.5;

		//if(MAP[i].ncrs>0)
		//	_stprintf(str,L"%s-%s",road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml,road[iroad].hdmdes[MAP[i].HDMNO[MAP[i].ncrs-1]].ckml);
		//else
		//	_stprintf(str,L"%s-%s",road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml,road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml);
		//maketext(pt,str,0.0,4.0,7,2);		//不绘制	20190805
		ads_printf(L"OK!");
	}
	if (MAPSUM > 0 && IsShowGuide)
	{
		if (daohang) delete daohang;
		daohang = NULL;
		daohang = new CHdmDaoHang;
		daohang->Create(IDD_GENZHONG, acedGetAcadFrame());
		daohang->ShowWindow(SW_SHOW);
	}
}

/*------------------------------------------------------------------*/
//计算出横断面图数，每个图中的断面总数及各断面排版
//
void HdmDes::CreateMapList(int iroad, double sml, double eml, double zk, double yk, int lnum)
{
	//设置参数
	double wmax = 0;
	int i, j;
	int sj;
	/*double BoxH=267,BoxW=380;*/
	double BoxH = 554.0 - 40.0, BoxW = 780.0;

	//寻找起始断面
	j = 0;
	while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < sml - 0.001)
		j++;
	sj = j;

	//计算每个断面的高度和宽度
	while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < eml + 1.0)
	{
		//切断地面线
		TrimEarthLine(iroad, j, zk, yk);
		//计算出每个断面的hi,wi(高度，宽度)
		Calhiwi(iroad, j, road[iroad].hdmdes[j].hi, road[iroad].hdmdes[j].wi, road[iroad].hdmdes[j].Ymin, road[iroad].hdmdes[j].Ymax);//计算出每个断面的高和宽

		j++;
	}


	//排版
	int imap = 0;
	j = sj;
	MAP[imap].SX = StartX;
	MAP[imap].SY = StartY + 100 / 2.0;	//20190821	修改横断面绘图位置，如需修改需要和DrawHdmMap绘制图框处联合修改
	while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < eml + 0.001)
	{
		//计算出每幅图第一列的断面数count,断面数ncrs
		double DY;
		double H, Xcol, BH;
		int count, ncrs;
		bool IfBri;
		IfBri = false;
		ncrs = 0;

		DY = 0;

		for (int icol = 0; icol < lnum; icol++)
		{
			//Xcol = MAP[imap].SX + 0.5*(icol+1)*BoxW/lnum;
			Xcol = MAP[imap].SX + (icol * 2 + 1) * BoxW / (lnum * 2) + 50;	//暂时设置
			if (j < road[iroad].NCRS)
				H = road[iroad].hdmdes[j].hi;
			else
				break;
			count = 0;

			while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < eml + 1.0 && (count == 0 || H < BoxH - 0))
			{
				if (road[iroad].hdmdes[j].Lnpt > 0 || road[iroad].hdmdes[j].Rnpt > 0 ||
					road[iroad].hdmdes[j].Y_Lnpt > 0 || road[iroad].hdmdes[j].Y_Rnpt > 0)
					IfBri = false;
				else
					IfBri = true;

				if (road[iroad].hdmdes[j].IsInsertHdm > 0)//增加断面,2007.9.28.puhao
				{
					ads_printf(L"%lf %d\n", road[iroad].hdmdes[j].cml, road[iroad].hdmdes[j].IsInsertHdm);

					IfBri = true;
				}

				if (!IfBri)
				{
					MAP[imap].HDMNO[ncrs] = j;//记录断面号
					count++;
					ncrs++;
				}
				j++;
				if (j < road[iroad].NCRS && !IfBri)
					H += road[iroad].hdmdes[j].hi;
			}
			//count为断面数
			//重新计算纵向间隔
			int hdmno;
			double Wmax, ZWmax, YWmax;
			BH = 0;
			Wmax = -1000000.0;
			ZWmax = 0.0;
			YWmax = 0.0;
			for (i = 0; i < count; i++)
			{
				hdmno = MAP[imap].HDMNO[ncrs - count + i];
				BH += road[iroad].hdmdes[hdmno].hi;
				Wmax = Wmax > road[iroad].hdmdes[hdmno].wi ? Wmax : road[iroad].hdmdes[hdmno].wi;
				if (road[iroad].hdmdes[hdmno].RPTL.length() > 0)
					ZWmax = ZWmax > fabs(road[iroad].hdmdes[hdmno].RPTL[road[iroad].hdmdes[hdmno].RPTL.length() - 1].x) ? ZWmax : fabs(road[iroad].hdmdes[hdmno].RPTL[road[iroad].hdmdes[hdmno].RPTL.length() - 1].x);
				if (road[iroad].hdmdes[hdmno].RPTR.length() > 0)
					YWmax = YWmax > fabs(road[iroad].hdmdes[hdmno].RPTR[road[iroad].hdmdes[hdmno].RPTR.length() - 1].x) ? YWmax : fabs(road[iroad].hdmdes[hdmno].RPTR[road[iroad].hdmdes[hdmno].RPTR.length() - 1].x);
			}

			if (icol == 0 && count > 0)
				DY = (BoxH - BH) / (count + 1);	//纵向间隔   
			if (DY < 0)
				DY = 0;

			Xcol = Xcol + 0.5 * (ZWmax - YWmax);
			//计算各个断面中心坐标
			double ty;

			ty = MAP[imap].SY + DY;
			for (i = 0; i < count; i++)
			{
				hdmno = MAP[imap].HDMNO[ncrs - count + i];
				road[iroad].hdmdes[hdmno].Xo = Xcol;
				road[iroad].hdmdes[hdmno].Yo = ty;
				road[iroad].hdmdes[hdmno].DX = Xcol - 0.5 * BoxW / lnum + 18;
				ty = ty + DY + road[iroad].hdmdes[hdmno].hi;
			}
		}

		MAP[imap].ncrs = ncrs;
		//列满

		if (j < road[iroad].NCRS)
		{
			imap++;//增加一幅图
			MAP[imap].SX = MAP[imap - 1].SX + 1000.0;
			MAP[imap].SY = MAP[imap - 1].SY;
			MAP[imap].ncrs = 0;
		}

		//		j++;
	}

	MAPSUM = imap + 1;
}
//不考虑标注，只有断面的宽和高
void HdmDes::Calhiwi(int iroad, int j, double& hi, double& wi, double& Ymin, double& Ymax)
{
	double Yllev, Ymlev, Yrlev, YY, Xmin, Xmax;
	double ZYmin, YYmin, ZYmax, YYmax;

	if (road[iroad].hdmdes[j].DorS == 1)
	{
		Xmin = Ymin = 100000000000.0;
		Xmax = Ymax = -100000000000.0;

		Yllev = road[iroad].hdmdes[j].RHFL[9];//左侧路肩高程
		Yrlev = road[iroad].hdmdes[j].RHFR[9];//右侧路肩高程
		Ymin = Yllev < Yrlev ? Yllev : Yrlev;

		Ymlev = road[iroad].hdmdes[j].RHFL[1] > road[iroad].hdmdes[j].RHFR[1] ? road[iroad].hdmdes[j].RHFL[1] : road[iroad].hdmdes[j].RHFR[1];
		Ymax = Yllev > Ymlev ? Yllev : Ymlev;
		Ymax = Ymax < Yrlev ? Ymax : Yrlev;

		int k;
		for (k = 0; k < road[iroad].hdmdmx[j].ZEarPtNum; k++)
		{
			YY = road[iroad].hdmdmx[j].ZEarPtAry[k].y + road[iroad].hdmdmx[j].EarH;
			Ymax = YY > Ymax ? YY : Ymax;
			Ymin = YY < Ymin ? YY : Ymin;
		}

		Xmin = fabs(road[iroad].hdmdmx[j].ZEarPtAry[road[iroad].hdmdmx[j].ZEarPtNum - 1].x);

		for (k = 0; k < road[iroad].hdmdmx[j].YEarPtNum; k++)
		{
			YY = road[iroad].hdmdmx[j].YEarPtAry[k].y + road[iroad].hdmdmx[j].EarH;
			Ymax = YY > Ymax ? YY : Ymax;
			Ymin = YY < Ymin ? YY : Ymin;
		}
		Xmax = road[iroad].hdmdmx[j].YEarPtAry[k - 1].x;
	}
	else if (road[iroad].hdmdes[j].DorS == 2)
	{
		Xmin = Ymin = 100000000000.0;
		Xmax = Ymax = -100000000000.0;

		Yllev = road[iroad].hdmdes[j].RHFL[9];//左侧路肩高程
		Yrlev = road[iroad].hdmdes[j].RHFR[9];//右侧路肩高程
		ZYmin = Yllev < Yrlev ? Yllev : Yrlev;

		Yllev = road[iroad].hdmdes[j].Y_RHFL[9];//左侧路肩高程
		Yrlev = road[iroad].hdmdes[j].Y_RHFR[9];//右侧路肩高程
		YYmin = Yllev < Yrlev ? Yllev : Yrlev;
		Ymin = ZYmin < YYmin ? ZYmin : YYmin;


		Yllev = road[iroad].hdmdes[j].RHFL[9];//左侧路肩高程
		Yrlev = road[iroad].hdmdes[j].RHFR[9];//右侧路肩高程
		Ymlev = road[iroad].hdmdes[j].RHFL[1] > road[iroad].hdmdes[j].RHFR[1] ? road[iroad].hdmdes[j].RHFL[1] : road[iroad].hdmdes[j].RHFR[1];
		ZYmax = Yllev > Ymlev ? Yllev : Ymlev;
		ZYmax = ZYmax > Yrlev ? ZYmax : Yrlev;


		Yllev = road[iroad].hdmdes[j].Y_RHFL[9];//左侧路肩高程
		Yrlev = road[iroad].hdmdes[j].Y_RHFR[9];//右侧路肩高程
		Ymlev = road[iroad].hdmdes[j].Y_RHFL[1] > road[iroad].hdmdes[j].Y_RHFR[1] ? road[iroad].hdmdes[j].Y_RHFL[1] : road[iroad].hdmdes[j].Y_RHFR[1];
		YYmax = Yllev > Ymlev ? Yllev : Ymlev;
		YYmax = YYmax > Yrlev ? YYmax : Yrlev;

		Ymax = ZYmax > YYmax ? ZYmax : YYmax;

		int k;
		for (k = 0; k < road[iroad].hdmdmx[j].ZEarPtNum; k++)
		{
			YY = road[iroad].hdmdmx[j].ZEarPtAry[k].y + road[iroad].hdmdmx[j].EarH;
			Ymax = YY > Ymax ? YY : Ymax;
			Ymin = YY < Ymin ? YY : Ymin;
		}

		Xmin = fabs(road[iroad].hdmdmx[j].ZEarPtAry[road[iroad].hdmdmx[j].ZEarPtNum - 1].x);

		for (k = 0; k < road[iroad].hdmdmx[j].YEarPtNum; k++)
		{
			YY = road[iroad].hdmdmx[j].YEarPtAry[k].y + road[iroad].hdmdmx[j].EarH;
			Ymax = YY > Ymax ? YY : Ymax;
			Ymin = YY < Ymin ? YY : Ymin;
		}

		Xmax = road[iroad].hdmdmx[j].YEarPtAry[road[iroad].hdmdmx[j].YEarPtNum - 1].x;
	}

	//为应对网格线，整数化处理	20190903增加
	Xmin = ceil(Xmin);
	Xmax = ceil(Xmax);
	Ymax = ceil(Ymax);
	Ymin = floor(Ymin);
	//Xmin = ((int)(Xmin / 2.0) + 1) * 2.0;
	//Xmax = ((int)(Xmax / 2.0) + 1) * 2.0;
	//Ymax = ((int)(fabs(Ymax) / 2.0) + 1) * 2.0 * (fabs(Ymax) / Ymax);
	//Ymin = ((int)(fabs(Ymin) / 2.0) + 1) * 2.0 * (fabs(Ymin) / Ymin);

	hi = Sfactor * (Ymax - Ymin) + 2 * Sfactor;

	if (hi < 8 * Sfactor)
		hi = 8 * Sfactor;
	/*
		if (hi < 80)
			hi = 80;*/
	wi = Sfactor * (Xmax + Xmin);
	/*
		if (wi < 120)
			wi = 120;*/


	road[iroad].hdmdes[j].Xmin = Xmin;	//20190903增加记录Xmin
	road[iroad].hdmdes[j].Xmax = Xmax;

	if (road[iroad].hdmdes[j].IsInsertHdm > 0)//后期增加断面，不出图
	{
		hi = 0;
		wi = 0;
		Ymin = 0;
		Ymax = 0;
	}
}

//--------------------------------------------------------------------------------------------------------
//保留ZK---YK范围内的内容
//20190917修改	因为修改后侧沟也存储在沟数组里，可能导致左右侧最大X计算错误，这里取最大值
//--------------------------------------------------------------------------------------------------------
void HdmDes::TrimEarthLine(int iroad, int j, double ZK, double YK)
{
	int i;
	double zk, yk;
	double Earpt[400][2];
	double tempWid = 0;

	if (road[iroad].hdmdes[j].DorS == 1)
	{
		//zk给初值
		if (road[iroad].hdmdes[j].Lnpt > 0)
		{
			zk = fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x) + ZK;
			if (road[iroad].hdmdes[j].LGouPtNum > 0)
				//zk = fabs(road[iroad].hdmdes[j].Lgou[(road[iroad].hdmdes[j].LGouPtNum-1)*2])+ZK;
				tempWid = fabs(road[iroad].hdmdes[j].Lgou[(road[iroad].hdmdes[j].LGouPtNum - 1) * 2]) + ZK;

			zk = max(zk, tempWid);

		}
		else
			zk = fabs(road[iroad].hdmdes[j].RHFL[8]) + ZK;


		if (road[iroad].hdmdes[j].xjj > -0.0001)//有左关联
		{
			int glroad = GetIRoadByName(road[iroad].hdmdes[j].glRoadName);
			int jcross = FindIDM(glroad, road[iroad].hdmdes[j].glcml);
			if (glroad > 0 && jcross >= 0 && road[glroad].hdmdes[jcross].Lnpt > 0)
			{
				double zxhmdk;

				double zk1, zk2;

				if (road[iroad].hdmdes[j].Lnpt > 0)
					zk1 = fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x);
				else
					zk1 = fabs(road[iroad].hdmdes[j].RHFL[8]);

				if (road[glroad].hdmdes[jcross].Lnpt > 0)
					zk2 = fabs(road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].x);
				else
					zk2 = fabs(road[glroad].hdmdes[jcross].RHFL[8]);

				zk = zk1 + zk2 + fabs(road[iroad].hdmdes[j].xjj) + ZK;
				if (road[glroad].hdmdes[jcross].LGouPtNum > 0)
					//zk = zk1+fabs(road[glroad].hdmdes[jcross].Lgou[(road[glroad].hdmdes[jcross].LGouPtNum-1)*2])+ZK;	
					tempWid = zk1 + fabs(road[glroad].hdmdes[jcross].Lgou[(road[glroad].hdmdes[jcross].LGouPtNum - 1) * 2]) + ZK;

				zk = max(zk, tempWid);
			}
		}

		//yk赋初值
		if (road[iroad].hdmdes[j].Rnpt > 0)
		{
			yk = fabs(road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x) + YK;
			if (road[iroad].hdmdes[j].RGouPtNum > 0)
				//yk = fabs(road[iroad].hdmdes[j].Rgou[(road[iroad].hdmdes[j].RGouPtNum-1)*2])+YK;
				tempWid = fabs(road[iroad].hdmdes[j].Rgou[(road[iroad].hdmdes[j].RGouPtNum - 1) * 2]) + YK;

			yk = max(yk, tempWid);
		}
		else
			yk = road[iroad].hdmdes[j].RHFR[8] + YK;

		if (road[iroad].hdmdes[j].xjj < 0.0001)//if(road[iroad].hdmdes[j].ylink)//有右关联
		{
			int glroad = GetIRoadByName(road[iroad].hdmdes[j].glRoadName);
			int jcross = FindIDM(glroad, road[iroad].hdmdes[j].glcml);
			if (glroad > 0 && jcross >= 0 && road[glroad].hdmdes[jcross].Rnpt > 0)
			{
				double yk1, yk2;

				if (road[iroad].hdmdes[j].Rnpt > 0)
					yk1 = fabs(road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x);
				else
					yk1 = fabs(road[iroad].hdmdes[j].RHFR[8]);

				if (road[glroad].hdmdes[jcross].Rnpt > 0)
					yk2 = fabs(road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].x);
				else
					yk2 = fabs(road[glroad].hdmdes[jcross].RHFR[8]);

				yk = yk1 + yk2 + fabs(road[iroad].hdmdes[j].xjj) + YK;

				if (road[glroad].hdmdes[jcross].RGouPtNum > 0)
					//yk = yk1+fabs(road[glroad].hdmdes[jcross].Rgou[(road[glroad].hdmdes[jcross].RGouPtNum-1)*2])+YK;
					tempWid = yk1 + fabs(road[glroad].hdmdes[jcross].Rgou[(road[glroad].hdmdes[jcross].RGouPtNum - 1) * 2]) + YK;

				yk = max(yk, tempWid);
			}
		}
	}
	else
	{
		if (road[iroad].hdmdes[j].xjj < -0.0001)//左线分离
		{
			if (road[iroad].hdmdes[j].Lnpt > 0)
				zk = fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x) + fabs(road[iroad].hdmdes[j].xjj) + ZK;
			else
				zk = fabs(road[iroad].hdmdes[j].RHFL[8]) + fabs(road[iroad].hdmdes[j].xjj) + ZK;

			if (road[iroad].hdmdes[j].Y_Rnpt > 0)
				yk = fabs(road[iroad].hdmdes[j].Y_RPTR[road[iroad].hdmdes[j].Y_Rnpt - 1].x) + YK;
			else
				yk = road[iroad].hdmdes[j].Y_RHFR[8] + YK;
		}
		else
		{
			if (road[iroad].hdmdes[j].Lnpt > 0)
				zk = fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x) + ZK;
			else
				zk = fabs(road[iroad].hdmdes[j].RHFL[6]) + ZK;

			if (road[iroad].hdmdes[j].Y_Rnpt > 0)
				yk = fabs(road[iroad].hdmdes[j].Y_RPTR[road[iroad].hdmdes[j].Y_Rnpt - 1].x) + fabs(road[iroad].hdmdes[j].xjj) + YK;
			else
				yk = road[iroad].hdmdes[j].Y_RHFR[6] + road[iroad].hdmdes[j].xjj + YK;

		}
	}
	//ads_printf(L"iroad=%d ml=%lf xjj=%lf zk=%lf yk=%lf\n",iroad,road[iroad].hdmdes[j].dml,road[iroad].hdmdes[j].xjj,zk,yk);

	if (road[iroad].hdmdmx[j].ZEarPtNum > 0 && road[iroad].hdmdmx[j].ZEarPtAry[road[iroad].hdmdmx[j].ZEarPtNum - 1].x > zk)//左侧有超界点
	{
		i = 0;
		while (i < road[iroad].hdmdmx[j].ZEarPtNum && fabs(road[iroad].hdmdmx[j].ZEarPtAry[i].x) < zk)
		{
			Earpt[i][0] = road[iroad].hdmdmx[j].ZEarPtAry[i].x;
			Earpt[i][1] = road[iroad].hdmdmx[j].ZEarPtAry[i].y;
			i++;
		}
		if (i > 0)
		{
			Earpt[i][0] = zk;
			Earpt[i][1] = Earpt[i - 1][1] + (zk - road[iroad].hdmdmx[j].ZEarPtAry[i - 1].x)*(road[iroad].hdmdmx[j].ZEarPtAry[i].y - road[iroad].hdmdmx[j].ZEarPtAry[i - 1].y) / (road[iroad].hdmdmx[j].ZEarPtAry[i].x - road[iroad].hdmdmx[j].ZEarPtAry[i - 1].x);

			road[iroad].hdmdmx[j].ZEarPtNum = i + 1;
			road[iroad].hdmdmx[j].ZEarPtAry.RemoveAll();
			Point pt;
			for (i = 0; i < road[iroad].hdmdmx[j].ZEarPtNum; i++)
			{
				pt.x = Earpt[i][0];
				pt.y = Earpt[i][1];
				road[iroad].hdmdmx[j].ZEarPtAry.Add(pt);
			}
		}
	}

	if (road[iroad].hdmdmx[j].YEarPtNum > 0 && road[iroad].hdmdmx[j].YEarPtAry[road[iroad].hdmdmx[j].YEarPtNum - 1].x > yk)//左侧有超界点
	{
		i = 0;
		while (i < road[iroad].hdmdmx[j].YEarPtNum && road[iroad].hdmdmx[j].YEarPtAry[i].x < yk)
		{
			Earpt[i][0] = road[iroad].hdmdmx[j].YEarPtAry[i].x;
			Earpt[i][1] = road[iroad].hdmdmx[j].YEarPtAry[i].y;
			i++;
		}
		if (i > 0)
		{
			Earpt[i][0] = yk;
			Earpt[i][1] = Earpt[i - 1][1] + (yk - road[iroad].hdmdmx[j].YEarPtAry[i - 1].x)*(road[iroad].hdmdmx[j].YEarPtAry[i].y - road[iroad].hdmdmx[j].YEarPtAry[i - 1].y) / (road[iroad].hdmdmx[j].YEarPtAry[i].x - road[iroad].hdmdmx[j].YEarPtAry[i - 1].x);

			road[iroad].hdmdmx[j].YEarPtNum = i + 1;
			road[iroad].hdmdmx[j].YEarPtAry.RemoveAll();
			Point pt;
			for (i = 0; i < road[iroad].hdmdmx[j].YEarPtNum; i++)
			{
				pt.x = Earpt[i][0];
				pt.y = Earpt[i][1];
				road[iroad].hdmdmx[j].YEarPtAry.Add(pt);
			}
		}
	}
}

void HdmDes::DrawAHdmMap(int iroad, int ipage, Maplist MAP[], double zk, double yk, double TabTextH,double NoteTextH)//绘横断面图
{
	int j;
	double Learpt[400], Rearpt[400];
	double LBenchPt[400], RBenchPt[400];
	double ZX_LearptOnLJZX[400], ZX_RearptOnLJZX[400];
	double FLX_LearptOnLJZX[400], FLX_RearptOnLJZX[400];
	double ZX_LBenchPtOnLJZX[400], ZX_RBenchPtOnLJZX[400];
	double ZX_EarHOnLJZX, FLX_EarHOnLJZX;
	double ZX_EarHOnXLZX, FLX_EarHOnXLZX;

	int NumLearpt, NumRearpt;
	int OffsetNumLearpt, OffsetNumRearpt;
	int Y_NewNumL;
	//int  DorS;
	AcGePoint3d pt;
	CROSS pCross;
	CROSS GLCross;


	for (int i = 0; i < MAP[ipage].ncrs; i++)//一线
	{

		j = MAP[ipage].HDMNO[i];

		if (road[iroad].hdmdes[j].DorS == 1)//单路面
		{

			int k;
			for (k = 0; k < road[iroad].hdmdmx[j].ZEarPtNum; k++)
			{
				Learpt[k * 2] = road[iroad].hdmdmx[j].ZEarPtAry[k].x;
				Learpt[k * 2 + 1] = road[iroad].hdmdmx[j].ZEarPtAry[k].y;
			}

			for (k = 0; k < road[iroad].hdmdmx[j].YEarPtNum; k++)
			{
				Rearpt[k * 2] = road[iroad].hdmdmx[j].YEarPtAry[k].x;
				Rearpt[k * 2 + 1] = road[iroad].hdmdmx[j].YEarPtAry[k].y;
			}

			//////////////////////////////////////////////////////////////////////////
			double LimitZ, LimitR;
			int iLim = 0;
			LimitZ = fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x) + zk;
			LimitR = fabs(road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x) + yk;
			for (k = 0; k < road[iroad].hdmBench[j].ZEarPtNum; k++)
			{
				if (road[iroad].hdmBench[j].ZEarPtAry[k].x < LimitZ)
				{
					LBenchPt[k * 2] = road[iroad].hdmBench[j].ZEarPtAry[k].x;
					LBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].ZEarPtAry[k].y;
					iLim++;
				}
				else
				{
					LBenchPt[k * 2] = road[iroad].hdmBench[j].ZEarPtAry[iLim].x;
					LBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].ZEarPtAry[iLim].y;
				}
			}

			for (k = 0; k < road[iroad].hdmBench[j].YEarPtNum; k++)
			{
				if (road[iroad].hdmBench[j].YEarPtAry[k].x < LimitR)
				{
					RBenchPt[k * 2] = road[iroad].hdmBench[j].YEarPtAry[k].x;
					RBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].YEarPtAry[k].y;
					iLim++;
				}
				else
				{
					RBenchPt[k * 2] = road[iroad].hdmBench[j].YEarPtAry[iLim].x;
					RBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].YEarPtAry[iLim].y;
				}
			}
			//////////////////////////////////////////////////////////////////////////
			//考虑路基中线与线路中线不重合，将相对于线路中线的地面点数据平移到路基中线（修改）
			ZX_EarHOnXLZX = road[iroad].hdmdmx[j].EarH;//线路中线处的地面标高
			NumLearpt = road[iroad].hdmdmx[j].ZEarPtNum;
			NumRearpt = road[iroad].hdmdmx[j].YEarPtNum;
			CalNewZB(road[iroad].hdmdes[j].OffsetByXLZX, ZX_EarHOnXLZX, Learpt, NumLearpt, Rearpt, NumRearpt,
				ZX_EarHOnLJZX, ZX_LearptOnLJZX, OffsetNumLearpt, ZX_RearptOnLJZX, OffsetNumRearpt);
			//////////////////////////////////////////////////////////////////////////
			road[iroad].hdmdes[j].newLYd = road[iroad].hdmdes[j].newRYd = road[iroad].hdmdmx[j].EarH;
			//左右都是桥
			if (road[iroad].hdmdes[j].ZDMXZ == 3 && road[iroad].hdmdes[j].YDMXZ == 3)
				continue;
			//左右都是隧
			if (road[iroad].hdmdes[j].ZDMXZ == 4 && road[iroad].hdmdes[j].YDMXZ == 4)
				continue;

			//				if(road[0].hdmdes[j].ZDMXZ==-1 || road[0].hdmdes[j].ZDMXZ==-2
			//				   ||road[0].hdmdes[j].YDMXZ==-1 || road[0].hdmdes[j].YDMXZ==-2)
			//				{
			//						pt.x=road[0].hdmdes[i].tX0;//桥隧处标注点
			//						pt.y=road[0].hdmdes[i].tY0;
			//						BiaoZhuQS(0,road[0].hdmdes[i].cml,pt); //标注桥隧位置
			//				}

			pCross.m_OriPoint.x = road[iroad].hdmdes[j].Xo;
			pCross.m_OriPoint.y = road[iroad].hdmdes[j].Yo;	//每个断面的绘图原点
			pCross.m_BTinf = road[iroad].hdmdes[j].ZDMXZ;
			//	road[0].hdmdes[i].xlxz=0;road[0].hdmdes[i].r_bh=-1;//一线，用于交互设计

			setCROSSAutoDesignData(pCross, iroad, j, ZX_EarHOnLJZX, ZX_LearptOnLJZX, OffsetNumLearpt, ZX_RearptOnLJZX, OffsetNumRearpt,
				LBenchPt, road[iroad].hdmBench[j].ZEarPtNum, RBenchPt, road[iroad].hdmBench[j].YEarPtNum);
			pCross.DorS = road[iroad].hdmdes[j].DorS;
			pCross.offset = road[iroad].hdmdes[j].offsetX;//一线中心线相对与新的地面线的移动量

		}
		if (road[iroad].hdmdes[j].DorS == 2)//双路面
		{
			//ads_printf(L"cmlzx=%lf %lf xjj=%lf\n",road[0].hdmdes[i].cml,road[0].hdmdes[i].FLDcml,road[0].hdmdes[i].xjj);				
			double ZX_Yd, ZX_Learpt[400], ZX_Rearpt[400];
			int ZX_NumL, ZX_NumR;
			double YX_Yd, YX_Learpt[400], YX_Rearpt[400];
			int YX_NumL, YX_NumR;

			double ZX_LBenchPt[400], ZX_RBenchPt[400];
			int ZX_BenchNumL, ZX_BenchNumR;
			double YX_LBenchPt[400], YX_RBenchPt[400];
			int YX_BenchNumL, YX_BenchNumR;

			if (road[iroad].hdmdes[j].xjj < -0.00001)//左线分离
			{
				YX_Yd = road[iroad].hdmdmx[j].EarH;
				YX_NumL = road[iroad].hdmdmx[j].ZEarPtNum;
				int k;
				for (k = 0; k < YX_NumL; k++)
				{
					YX_Learpt[k * 2] = road[iroad].hdmdmx[j].ZEarPtAry[k].x;
					YX_Learpt[k * 2 + 1] = road[iroad].hdmdmx[j].ZEarPtAry[k].y;
				}
				YX_NumR = road[iroad].hdmdmx[j].YEarPtNum;
				for (k = 0; k < YX_NumR; k++)
				{
					YX_Rearpt[k * 2] = road[iroad].hdmdmx[j].YEarPtAry[k].x;
					YX_Rearpt[k * 2 + 1] = road[iroad].hdmdmx[j].YEarPtAry[k].y;
				}
				//移轴
				CalNewZB(road[iroad].hdmdes[j].xjj, YX_Yd, YX_Learpt, YX_NumL, YX_Rearpt, YX_NumR,
					ZX_Yd, ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR);

				//////////////////////////////////////////////////////////////////////////
				YX_BenchNumL = road[iroad].hdmBench[j].ZEarPtNum;
				for (k = 0; k < YX_BenchNumL; k++)
				{
					YX_LBenchPt[k * 2] = road[iroad].hdmBench[j].ZEarPtAry[k].x;
					YX_LBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].ZEarPtAry[k].y;
				}
				YX_BenchNumR = road[iroad].hdmBench[j].YEarPtNum;
				for (k = 0; k < YX_BenchNumR; k++)
				{
					YX_RBenchPt[k * 2] = road[iroad].hdmBench[j].YEarPtAry[k].x;
					YX_RBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].YEarPtAry[k].y;
				}
				//移轴
				CalNewZB(road[iroad].hdmdes[j].xjj, YX_Yd, YX_LBenchPt, YX_BenchNumL, YX_RBenchPt, YX_BenchNumR,
					ZX_Yd, ZX_LBenchPt, ZX_BenchNumL, ZX_RBenchPt, ZX_BenchNumR);
				//////////////////////////////////////////////////////////////////////////
			}
			else
			{
				ZX_Yd = road[iroad].hdmdmx[j].EarH;
				ZX_NumL = road[iroad].hdmdmx[j].ZEarPtNum;
				int k;
				for (k = 0; k < ZX_NumL; k++)
				{
					ZX_Learpt[k * 2] = road[iroad].hdmdmx[j].ZEarPtAry[k].x;
					ZX_Learpt[k * 2 + 1] = road[iroad].hdmdmx[j].ZEarPtAry[k].y;
				}
				ZX_NumR = road[iroad].hdmdmx[j].YEarPtNum;
				for (k = 0; k < ZX_NumR; k++)
				{
					ZX_Rearpt[k * 2] = road[iroad].hdmdmx[j].YEarPtAry[k].x;
					ZX_Rearpt[k * 2 + 1] = road[iroad].hdmdmx[j].YEarPtAry[k].y;
				}
				//移轴
				CalNewZB(road[iroad].hdmdes[j].xjj, ZX_Yd, ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR,
					YX_Yd, YX_Learpt, YX_NumL, YX_Rearpt, YX_NumR);

				//////////////////////////////////////////////////////////////////////////
				ZX_BenchNumL = road[iroad].hdmBench[j].ZEarPtNum;
				for (k = 0; k < ZX_BenchNumL; k++)
				{
					ZX_LBenchPt[k * 2] = road[iroad].hdmBench[j].ZEarPtAry[k].x;
					ZX_LBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].ZEarPtAry[k].y;
				}
				ZX_BenchNumR = road[iroad].hdmBench[j].YEarPtNum;
				for (k = 0; k < ZX_BenchNumR; k++)
				{
					ZX_RBenchPt[k * 2] = road[iroad].hdmBench[j].YEarPtAry[k].x;
					ZX_RBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].YEarPtAry[k].y;
				}
				//移轴
				CalNewZB(road[iroad].hdmdes[j].xjj, ZX_Yd, ZX_LBenchPt, ZX_BenchNumL, ZX_RBenchPt, ZX_BenchNumR,
					YX_Yd, YX_LBenchPt, YX_BenchNumL, YX_RBenchPt, YX_BenchNumR);
				//////////////////////////////////////////////////////////////////////////
			}

			if (road[iroad].hdmdes[j].ZDMXZ == 3 && road[iroad].hdmdes[j].YDMXZ == 3
				&&
				road[iroad].hdmdes[j].Y_ZDMXZ == 3 && road[iroad].hdmdes[j].Y_YDMXZ == 3)
				continue;
			//左右都是隧
			if (road[iroad].hdmdes[j].ZDMXZ == 4 && road[iroad].hdmdes[j].YDMXZ == 4
				&&
				road[iroad].hdmdes[j].Y_ZDMXZ == 4 && road[iroad].hdmdes[j].Y_YDMXZ == 4)
				continue;
			//				
			//				if(road[iroad].hdmdes[j].ZDMXZ == -1  ||
			//					road[iroad].hdmdes[j].YDMXZ == -1  ||
			//					road[iroad].hdmdes[j].ZDMXZ == -2  ||
			//					road[iroad].hdmdes[j].YDMXZ == -2 ||
			//					road[iroad].hdmdes[j].Y_ZDMXZ == -1  ||
			//					road[iroad].hdmdes[j].Y_YDMXZ == -1  ||
			//					road[iroad].hdmdes[j].Y_ZDMXZ == -2  ||
			//					road[iroad].hdmdes[j].Y_YDMXZ == -2 )//桥隧起始里程
			//					{
			//				    	pt.x=road[iroad].hdmdes[j].tX0;//桥隧处标注点
			//						pt.y=road[iroad].hdmdes[j].tY0;
			//						BiaoZhuQS(0,road[iroad].hdmdes[j].cml,pt); //标注桥隧位置
			//					}
			pCross.m_OriPoint.x = road[iroad].hdmdes[j].Xo;	//每个断面的绘图原点
			pCross.m_OriPoint.y = road[iroad].hdmdes[j].Yo;
			pCross.m_BTinf = road[iroad].hdmdes[j].ZDMXZ;

			//road[iroad].hdmdes[j].ckml,road[iroad].hdmdes[j].DorS,road[iroad].hdmdes[j].ZDMXZ,road[iroad].hdmdes[j].YDMXZ,road[iroad].hdmdes[j].Y_ZDMXZ,road[iroad].hdmdes[j].Y_YDMXZ);

			//				road[iroad].hdmdes[j].xlxz=0;road[iroad].hdmdes[j].r_bh=-1;//一线，用于交互设计
			//               
			//			    if(!((road[iroad].hdmdes[j].ZDMXZ==3 && road[iroad].hdmdes[j].YDMXZ==3)
			//					|| 
			//				     (road[iroad].hdmdes[j].ZDMXZ==4 && road[iroad].hdmdes[j].YDMXZ==4)
			//				   )
			//				  )
			//			     
			//				{
			//		ads_printf(L"2:%s %d %d %d %d %d\n",
			//			road[iroad].hdmdes[j].ckml,road[iroad].hdmdes[j].DorS,road[iroad].hdmdes[j].ZDMXZ,road[iroad].hdmdes[j].YDMXZ,road[iroad].hdmdes[j].Y_ZDMXZ,road[iroad].hdmdes[j].Y_YDMXZ);
			setCROSSAutoDesignData(pCross, iroad, j, ZX_Yd,
				ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR,
				ZX_LBenchPt, ZX_BenchNumL, ZX_RBenchPt, ZX_BenchNumR);//左线

			//		}
			//setCROSSAutoDesignData(pCross,i,ZX_Yd,ZX_Learpt,ZX_NumL,ZX_Rearpt,ZX_NumR);//左线
			pCross.m_YBTinf = road[iroad].hdmdes[j].Y_YDMXZ;

			//    if(road[iroad].hdmdes[j].Y_ZDMXZ==0 || road[iroad].hdmdes[j].Y_YDMXZ==0)
			if (!((road[iroad].hdmdes[j].Y_ZDMXZ == 3 && road[iroad].hdmdes[j].Y_YDMXZ == 3)
				||
				(road[iroad].hdmdes[j].Y_ZDMXZ == 4 && road[iroad].hdmdes[j].Y_YDMXZ == 4)
				)
				)
			{
				Y_setCROSSAutoDesignData(pCross, j, YX_Yd);

			}

			pCross.DorS = road[iroad].hdmdes[j].DorS;
			//	pCross.offset=0.0;//一线中心线相对与新的地面线的移动量
			//	pCross.Yoffset=0.0;
		}

		//20190815新增计算超高坡度
		double tempSlopePara = 0.0;
		CalSup(road[iroad].hdmdes[j].cml, road[iroad].ZcgNm, road[iroad].Zcg, pCross.m_SuphRate_L, tempSlopePara);
		CalSup(road[iroad].hdmdes[j].cml, road[iroad].YcgNm, road[iroad].Ycg, pCross.m_SuphRate_R, tempSlopePara);


		pCross.IsLinkHdm = false;
		pCross.m_Scale = Sfactor;
		pCross.m_LeftZdk = road[iroad].hdmdes[j].LZDK;
		pCross.m_RightZdk = road[iroad].hdmdes[j].RZDK;
		_tcscpy(pCross.m_GutterBlockName, m_GutterBlockName);


		//绘制网格
		DrawCrossNet(road[iroad].hdmdes[j].RHFL[1], road[iroad].hdmdes[j].Xmin, road[iroad].hdmdes[j].Xmax,
			road[iroad].hdmdes[j].Ymin, road[iroad].hdmdes[j].Ymax, pCross.LeftDesignLinePart->m_DesignPoints, pCross.m_NetCenterY);
		pCross.m_IsDrawCrossEarthPile = m_IsDrawCrossEarthPile;
		//绘制断面的信息表格，但是必须绘制网格处的坐标计算之后，才能绘制信息表格


		//20190915	再次赋值	cad2010版本 32位下X数据会变成0，因调试困难，尚未找到原因
		pCross.m_OriPoint.x = road[iroad].hdmdes[j].Xo;	//每个断面的绘图原点
		pCross.m_OriPoint.y = road[iroad].hdmdes[j].Yo;

		pCross.OutDraw(TabTextH, NoteTextH);

		if (road[iroad].hdmdes[j].glcml > -0.0001)//有关联断面,绘关联
		{
			int glroad = GetIRoadByName(road[iroad].hdmdes[j].glRoadName);
			int jcross = FindIDM(glroad, road[iroad].hdmdes[j].glcml);
			TrimEarthLine(glroad, jcross, 3.0, 3.0);

			int k;
			for (k = 0; k < road[glroad].hdmdmx[jcross].ZEarPtNum; k++)
			{
				Learpt[k * 2] = road[glroad].hdmdmx[jcross].ZEarPtAry[k].x;
				Learpt[k * 2 + 1] = road[glroad].hdmdmx[jcross].ZEarPtAry[k].y;
			}
			for (k = 0; k < road[glroad].hdmdmx[jcross].YEarPtNum; k++)
			{
				Rearpt[k * 2] = road[glroad].hdmdmx[jcross].YEarPtAry[k].x;
				Rearpt[k * 2 + 1] = road[glroad].hdmdmx[jcross].YEarPtAry[k].y;
			}

			//////////////////////////////////////////////////////////////////////////
			for (k = 0; k < road[glroad].hdmBench[jcross].ZEarPtNum; k++)
			{
				LBenchPt[k * 2] = road[glroad].hdmBench[jcross].ZEarPtAry[k].x;
				LBenchPt[k * 2 + 1] = road[glroad].hdmBench[jcross].ZEarPtAry[k].y;
			}
			for (k = 0; k < road[glroad].hdmBench[jcross].YEarPtNum; k++)
			{
				RBenchPt[k * 2] = road[glroad].hdmBench[jcross].YEarPtAry[k].x;
				RBenchPt[k * 2 + 1] = road[glroad].hdmBench[jcross].YEarPtAry[k].y;
			}

			//////////////////////////////////////////////////////////////////////////
			FLX_EarHOnXLZX = road[glroad].hdmdmx[jcross].EarH;//线路中线处的地面标高
			NumLearpt = road[glroad].hdmdmx[jcross].ZEarPtNum;
			NumRearpt = road[glroad].hdmdmx[jcross].YEarPtNum;
			CalNewZB(road[glroad].hdmdes[jcross].OffsetByXLZX, FLX_EarHOnXLZX, Learpt, NumLearpt, Rearpt, NumRearpt,
				FLX_EarHOnLJZX, FLX_LearptOnLJZX, OffsetNumLearpt, FLX_RearptOnLJZX, OffsetNumRearpt);
			//					road[glroad].hdmdes[jcross].newLYd = road[glroad].hdmdes[jcross].newRYd = road[glroad].hdmdmx[jcross].EarH;

			if (iroad == 0 && road[glroad].ZxOrYx > -0.001 || iroad > 0 && road[iroad].ZxOrYx < 0)//右线分离
			{
				if (road[glroad].hdmdes[jcross].Lnpt > 0)
				{
					if (iroad == 0 && (road[glroad].hdmdes[jcross].LGouPtNum == 6 || road[glroad].hdmdes[jcross].LGouPtNum == 16))//有线间沟
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x - road[glroad].hdmdes[jcross].Lgou[2 * (road[glroad].hdmdes[jcross].LGouPtNum - 1)])*Sfactor;
						road[glroad].hdmdes[jcross].Lgou[2 * (road[glroad].hdmdes[jcross].LGouPtNum - 1) + 1] = road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}
					else if (iroad > 0 && (road[iroad].hdmdes[j].RGouPtNum == 6 || road[iroad].hdmdes[j].RGouPtNum == 16))
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[iroad].hdmdes[j].Rgou[2 * (road[iroad].hdmdes[j].RGouPtNum - 1)] - road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].x)*Sfactor;
						road[iroad].hdmdes[j].Rgou[2 * (road[iroad].hdmdes[j].RGouPtNum - 1) + 1] = -road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}
					else
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x - road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].x)*Sfactor;
						road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].y = road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}

					GLCross.DX = GLCross.m_OriPoint.x + 20 * Sfactor;
					road[glroad].hdmdes[jcross].DX = GLCross.m_OriPoint.x + 30 * Sfactor;
					//		ads_printf(L"DX1=%lf\n",GLCross.DX);
				}
				//	dy1 = road[iroad].hdmdes[i].RPTR[road[iroad].hdmdes[i].Rnpt-1].y+road[iroad].hdmdmx[i].EarH-road[iroad].hdmdes[i].RHFR[1];
				//	dy2 = road[iroad].hdmdes[jcross].RHFL[1] - (road[iroad].hdmdes[jcross].RPTL[road[iroad].hdmdes[jcross].Lnpt-1].y+road[iroad].hdmdmx[jcross].EarH);
				GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[iroad].hdmdes[jcross].RHFL[1]-road[iroad].hdmdes[i].RHFR[1])*Sfactor;	//每个断面的绘图原点

			}
			else
			{
				if (road[glroad].hdmdes[jcross].Rnpt > 0)
				{
					if (iroad == 0 && (road[glroad].hdmdes[jcross].RGouPtNum == 6 || road[glroad].hdmdes[jcross].RGouPtNum == 16))
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x - road[glroad].hdmdes[jcross].Rgou[2 * (road[glroad].hdmdes[jcross].RGouPtNum - 1)])*Sfactor;
						road[glroad].hdmdes[jcross].Rgou[2 * (road[glroad].hdmdes[jcross].RGouPtNum - 1) + 1] = road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}
					else if (iroad > 0 && (road[iroad].hdmdes[j].LGouPtNum == 6 || road[iroad].hdmdes[j].LGouPtNum == 16))
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[iroad].hdmdes[j].Lgou[2 * (road[iroad].hdmdes[j].LGouPtNum - 1)] - road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].x)*Sfactor;
						road[iroad].hdmdes[j].Lgou[2 * (road[iroad].hdmdes[j].LGouPtNum - 1) + 1] = -road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}
					else
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x - road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].x)*Sfactor;
						road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].y = road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}

					GLCross.DX = GLCross.m_OriPoint.x - 20 * Sfactor;
					road[glroad].hdmdes[jcross].DX = GLCross.m_OriPoint.x - 30 * Sfactor;

				}
				GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[glroad].hdmdes[jcross].RHFR[1]-road[iroad].hdmdes[i].RHFL[1])*Sfactor;	//每个断面的绘图原点

			}
			road[glroad].hdmdes[jcross].Ymin = road[iroad].hdmdes[j].Ymin;

			setCROSSAutoDesignData(GLCross, glroad, jcross, FLX_EarHOnLJZX, FLX_LearptOnLJZX, OffsetNumLearpt, FLX_RearptOnLJZX, OffsetNumRearpt,
				LBenchPt, road[glroad].hdmBench[jcross].ZEarPtNum, RBenchPt, road[glroad].hdmBench[jcross].YEarPtNum);

			GLCross.DorS = road[glroad].hdmdes[jcross].DorS;
			GLCross.offset = road[glroad].hdmdes[jcross].offsetX;//一线中心线相对与新的地面线的移动量
			GLCross.IsLinkHdm = true;
			if (fabs(road[iroad].hdmdes[j].xjj) < 3)
				GLCross.BzTWInf = -1;
			//					ads_printf(L"dml=%lf\n",road[glroad].hdmdes[jcross].dml);
			GLCross.OutDraw();
		}
		if (road[iroad].hdmdes[j].IfHasZlink)//有关联断面,绘关联
		{
			for (int iroad = 0; iroad < ZRoadSum; iroad++)
			{
				if (Zroad[iroad].roadname == road[iroad].hdmdes[j].zlink->glRoadName)
					break;
			}

			int jcross = FindIDM(Zroad[iroad], road[iroad].hdmdes[j].zlink->cml);

			int k;
			for (k = 0; k < Zroad[iroad].hdmdmx[jcross].ZEarPtNum; k++)
			{
				Learpt[k * 2] = Zroad[iroad].hdmdmx[jcross].ZEarPtAry[k].x;
				Learpt[k * 2 + 1] = Zroad[iroad].hdmdmx[jcross].ZEarPtAry[k].y;
			}

			for (k = 0; k < Zroad[iroad].hdmdmx[jcross].YEarPtNum; k++)
			{
				Rearpt[k * 2] = Zroad[iroad].hdmdmx[jcross].YEarPtAry[k].x;
				Rearpt[k * 2 + 1] = Zroad[iroad].hdmdmx[jcross].YEarPtAry[k].y;
			}

			if (road[iroad].hdmdes[j].zlink->Rnpt > 0)
				GLCross.m_OriPoint.x = pCross.m_OriPoint.x -
				fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x - road[iroad].hdmdes[j].zlink->RPTR[road[iroad].hdmdes[j].zlink->Rnpt - 1].x)*Sfactor;
			GLCross.m_OriPoint.y = pCross.m_OriPoint.y;//+ (road[iroad].hdmdes[j].RHFR[1]-road[iroad].hdmdes[j].RHFL[1])*Sfactor;	//每个断面的绘图原点
			//}
			road[iroad].hdmdes[j].zlink->Ymin = road[iroad].hdmdes[j].Ymin;
			setCROSSAutoDesignData(GLCross, Zroad[iroad], jcross, road[iroad].hdmdes[j].zlink,
				Zroad[iroad].hdmdmx[jcross].EarH, Learpt, Zroad[iroad].hdmdmx[jcross].ZEarPtNum,
				Rearpt, Zroad[iroad].hdmdmx[jcross].YEarPtNum);

			GLCross.DorS = Zroad[iroad].hdmdes[j].DorS;
			GLCross.offset = Zroad[iroad].hdmdes[j].offsetX;//一线中心线相对与新的地面线的移动量
			GLCross.IsLinkHdm = true;
			if (fabs(road[iroad].hdmdes[j].xjj) < 3)
				GLCross.BzTWInf = -1;

			GLCross.OutDraw();

		}
		if (road[iroad].hdmdes[j].IfHasYlink)//有关联断面,绘关联
		{
			//				    ads_printf(L"dml=%lf\n",road[iroad].hdmdes[j].dml);
			for (int iroad = 0; iroad < YRoadSum; iroad++)
			{
				if (Yroad[iroad].roadname == road[iroad].hdmdes[j].ylink->glRoadName)
					break;
			}
			int jcross = FindIDM(Yroad[iroad], road[iroad].hdmdes[j].ylink->cml);
			int k;
			for (k = 0; k < Yroad[iroad].hdmdmx[jcross].ZEarPtNum; k++)
			{
				Learpt[k * 2] = Yroad[iroad].hdmdmx[jcross].ZEarPtAry[k].x;
				Learpt[k * 2 + 1] = Yroad[iroad].hdmdmx[jcross].ZEarPtAry[k].y;
			}

			for (k = 0; k < Yroad[iroad].hdmdmx[jcross].YEarPtNum; k++)
			{
				Rearpt[k * 2] = Yroad[iroad].hdmdmx[jcross].YEarPtAry[k].x;
				Rearpt[k * 2 + 1] = Yroad[iroad].hdmdmx[jcross].YEarPtAry[k].y;
			}

			if (road[iroad].hdmdes[j].ylink->Lnpt > 0)
				GLCross.m_OriPoint.x = pCross.m_OriPoint.x +
				(fabs(road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x) + fabs(road[iroad].hdmdes[j].ylink->RPTL[road[iroad].hdmdes[j].ylink->Lnpt - 1].x))*Sfactor;
			GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[iroad].hdmdes[j].RHFL[1]-road[iroad].hdmdes[j].RHFR[1])*Sfactor;	//每个断面的绘图原点
			//}
			road[iroad].hdmdes[j].ylink->Ymin = road[iroad].hdmdes[j].Ymin;

			setCROSSAutoDesignData(GLCross, Yroad[iroad], jcross, road[iroad].hdmdes[j].ylink,
				Yroad[iroad].hdmdmx[jcross].EarH, Learpt, Yroad[iroad].hdmdmx[jcross].ZEarPtNum,
				Rearpt, Yroad[iroad].hdmdmx[jcross].YEarPtNum);

			GLCross.DorS = Yroad[iroad].hdmdes[j].DorS;
			GLCross.offset = Yroad[iroad].hdmdes[j].offsetX;//一线中心线相对与新的地面线的移动量
			GLCross.IsLinkHdm = true;
			if (fabs(road[iroad].hdmdes[j].xjj) < 3)
				GLCross.BzTWInf = -1;
			GLCross.OutDraw();
		}

	}

}

// This is command 'WRFILE'
void HdmDes::OutDwgFile()
{
	// TODO: Implement the command
	if (MAPSUM > 0)
	{
		ads_point basept, pt[2];
		ACHAR bkname[256], filename[256];
		double startml, endml;
		for (int i = 0; i < MAPSUM; i++)
		{
			basept[X] = MAP[i].SX - 30, basept[Y] = MAP[i].SY - 10;
			//    	   pt[0][X] = MAP[i].SX - 90 , pt[0][Y] = MAP[i].SY - 100;
			//		   pt[1][X] = MAP[i].SX + 420 + 80 , pt[0][Y] = MAP[i].SY + 500;

			pt[0][X] = MAP[i].SX - 120, pt[0][Y] = MAP[i].SY - 120;
			pt[1][X] = MAP[i].SX + 420 + 80, pt[1][Y] = MAP[i].SY + 600;
			//		   acedCommandS(RTSTR,L"line",RTPOINT,pt[0],RTPOINT,pt[1],RTSTR,L"",0);
			if (MAP[i].ncrs > 0)
			{
				CString filepath = Cworkdir + "\\result" + "\\";
				filepath += Pro;
				startml = road[CurRoad].hdmdes[MAP[i].HDMNO[0]].dml;
				endml = road[CurRoad].hdmdes[MAP[i].HDMNO[MAP[i].ncrs - 1]].dml;
				_stprintf(bkname, L"ss%0.0lf-%0.0lf", startml, endml);

#ifdef VERSION_CAD2016
				acedCommandS(RTSTR, L"block", RTSTR, bkname, RTPOINT, basept, RTSTR, L"W", RTPOINT, pt[0],
					RTPOINT, pt[1], RTSTR, L"", 0);
				acedCommandS(0);
#endif // VERSION_CAD2016
#ifdef VERSION_CAD2010
				ads_command(RTSTR, L"block", RTSTR, bkname, RTPOINT, basept, RTSTR, L"W", RTPOINT, pt[0],
					RTPOINT, pt[1], RTSTR, L"", 0);
				ads_command(0);
#endif // VERSION_CAD2010

				_stprintf(filename, L"%s\\result\\%s\\Hdm%0.0lf-%0.0lf", Cworkdir, Pro, startml, endml);
				//filepath=filename;
				::_wmkdir(filepath);
#ifdef VERSION_CAD2016
				acedCommandS(RTSTR, L"wblock", RTSTR, filename, RTSTR, bkname, RTPOINT, basept, 0);
				acedCommandS(0);
#endif // VERSION_CAD2016
#ifdef VERSION_CAD2010
				ads_command(RTSTR, L"wblock", RTSTR, filename, RTSTR, bkname, RTPOINT, basept, 0);
				ads_command(0);
#endif // VERSION_CAD2010

				//filepath+=Pro;
				//ads_printf(filepath);
				ads_printf(L"\n共%d幅图, 已输出第%d幅图%s文件!\n", MAPSUM, i, filename);
			}

		}
	}
	else
	{
		ads_printf(L"横断面图总数为0!\n");
	}

}

void HdmDes::WriteHdmZdkFile(int iroad, int jcross, FILE* fpw)
{

	fwprintf(fpw, L"\n%0.3lf %0.3lf %d %0.3lf %0.3lf",
		road[iroad].hdmdes[jcross].cml,
		road[iroad].hdmdes[jcross].dml,
		//	road[iroad].hdmdes[jcross].DorS,
		road[iroad].hdmdes[jcross].IsInsertHdm,
		fabs(-1.0*road[iroad].hdmdes[jcross].LZDK + road[iroad].hdmdes[jcross].OffsetByXLZX),
		fabs(road[iroad].hdmdes[jcross].RZDK + road[iroad].hdmdes[jcross].OffsetByXLZX)
	);
}


void HdmDes::WriteHdmQBTFile(int iroad, int jcross, FILE* fpw)
{

	fwprintf(fpw, L"\n%0.3lf %0.3lf %0.3lf %0.3lf %0.3lf %0.3lf",
		road[iroad].hdmdes[jcross].cml,
		road[iroad].hdmdes[jcross].dml,
		road[iroad].hdmdes[jcross].ZHTHD,
		road[iroad].hdmdes[jcross].YHTHD,
		road[iroad].hdmdes[jcross].QBTArea,
		road[iroad].hdmdes[jcross].WYNArea

	);
}

void  HdmDes::FindWFFL(double cml, JD_CENTER *pm, int nwffl, WFFLdata wffl[], double wfsj[6])
{
	int i, j;
	double eml;

	for (j = 0; j < 6; j++)
		wfsj[j] = 0.0;
	wfsj[2] = 100;
	for (i = 0; i < nwffl; i++)
	{
		eml = pm->TYLC(wffl[i].dml);
		if (cml < eml + 0.001)
		{
			for (j = 0; j < 6; j++)
				wfsj[j] = wffl[i].sj[j];
			break;
		}
	}
}

void HdmDes::FindGLDMLZ(double cml, JD_CENTER *pm, int ngldmlz, GLDMLZdata gldmlz[], double& dX, double& dH)
{
	dX = 100.0;
	dH = 100.0;
	double Scml, Ecml;
	for (int i = 0; i < ngldmlz; i++)
	{
		Scml = pm->TYLC(gldmlz[i].Sdml);
		Ecml = pm->TYLC(gldmlz[i].Edml);

		if (cml<Ecml + 0.001 && cml>Scml - 0.001)
		{
			dX = gldmlz[i].dX;
			dH = gldmlz[i].dH;
			break;
		}
	}
}

void HdmDes::FindGLDMLQBPTP(double cml, JD_CENTER *pm, int ngldmlqbptp, GLDMLQBPTPdata gldmlqbptp[], double& dX)
{
	dX = 100.0;
	double Scml, Ecml;
	for (int i = 0; i < ngldmlqbptp; i++)
	{
		Scml = pm->TYLC(gldmlqbptp[i].Sdml);
		Ecml = pm->TYLC(gldmlqbptp[i].Edml);

		if (cml<Ecml + 0.001 && cml>Scml - 0.001)
		{
			dX = gldmlqbptp[i].dX;
			break;
		}
	}
}

void  HdmDes::FindGLDMXJG(double cml, JD_CENTER *pm, int ngldmxjg, GLDMXJGdata gldmxjg[],
	double& GouWide, double& GouHigh, double& NBP, double& WBP, double& JQHD, double& GDR)
{
	GouWide = 0.0;
	GouHigh = 0.0;
	NBP = 0.0;
	WBP = 0.0;
	JQHD = 0.0;
	GDR = 0.0;
	double Scml, Ecml;
	int i;
	for (i = 0; i < ngldmxjg; i++)
	{
		Scml = pm->TYLC(gldmxjg[i].Sdml);
		Ecml = pm->TYLC(gldmxjg[i].Edml);

		if (cml<Ecml + 0.001 && cml>Scml - 0.001)
		{
			GouWide = gldmxjg[i].GouWide;
			GouHigh = gldmxjg[i].GouHigh;
			NBP = gldmxjg[i].NBP;
			WBP = gldmxjg[i].WBP;
			JQHD = gldmxjg[i].JQHD;
			GDR = gldmxjg[i].GDR;
			break;
		}
	}

	if (i == ngldmxjg)
		ads_printf(L"\n无法获取连续里程=%lf处线间沟数据，请检查！");
}

//////////////////////////////////////////////////////////////////////////判断是否低填路堤推平
bool HdmDes::FindIsAutoLDTP(double cml, JD_CENTER *pm, int nLDTP, LDTPData LDTP[])
{
	bool IsLDTP = false;
	double Scml, Ecml;
	for (int i = 0; i < nLDTP; i++)
	{
		Scml = pm->TYLC(LDTP[i].sdml);
		Ecml = pm->TYLC(LDTP[i].edml);

		if (cml<Ecml + 0.001 && cml>Scml - 0.001)
		{
			IsLDTP = true;
			break;
		}
	}
	return IsLDTP;
}

//////////////////////////////////////////////////////////////////////////判读是否低挖路堑自动填平
bool HdmDes::FindIsAutoLQTP(double cml, JD_CENTER *pm, int nLQTP, LQTPData LQTP[])
{
	bool IsLQTP = false;
	double Scml, Ecml;
	for (int i = 0; i < nLQTP; i++)
	{
		Scml = pm->TYLC(LQTP[i].sdml);
		Ecml = pm->TYLC(LQTP[i].edml);

		if (cml<Ecml + 0.001 && cml>Scml - 0.001)
		{
			IsLQTP = true;
			break;
		}
	}
	return IsLQTP;
}

//////////////////////////////////////////////////////////////////////////判读是否低填路堤自动加宽土路肩
bool HdmDes::FindIsAutoJKTLJ(double cml, JD_CENTER *pm, int nJKTLJ, TLJJKData JKTLJ[])
{
	bool IsJKTLJ = false;
	double Scml, Ecml;
	for (int i = 0; i < nJKTLJ; i++)
	{
		Scml = pm->TYLC(JKTLJ[i].sdml);
		Ecml = pm->TYLC(JKTLJ[i].edml);

		if (cml<Ecml + 0.001 && cml>Scml - 0.001)
		{
			IsJKTLJ = true;
			break;
		}
	}
	return IsJKTLJ;
}


int  HdmDes::FindLTTL(double cml, JD_CENTER *pm, int nldtl, LDTLdata ldtl[])
{
	double eml;

	for (int i = 0; i < nldtl; i++)
	{
		eml = pm->TYLC(ldtl[i].dml);
		if (cml < eml + 0.001)
			return ldtl[i].type;

	}
	return 0;

}
//------------------------------------------------------------------------
int HdmDes::FindGouBotH(double cml, JD_CENTER *pm, int NGouPD, GouPDdata GouPD[], double &GouBotH)
{
	int i;
	double x, y;
	double sml, eml;
	int IfSetGouPD;

	IfSetGouPD = 0;



	for (i = 0; i < NGouPD; i++)
	{
		sml = pm->TYLC(GouPD[i].Sdml);//分段终里程
		eml = pm->TYLC(GouPD[i].Edml);//分段终里程
		if (cml <= eml && cml >= sml)
		{
			IfSetGouPD = 1;
			break;
		}
	}

	GouBotH = 0.0;
	if (IfSetGouPD)
	{
		x = cml - sml;
		y = eml - cml;
		if (x + y > 0.001)
			GouBotH = (GouPD[i].SH*y + GouPD[i].EH*x) / (x + y);//挡水堰宽
	}

	return IfSetGouPD;
}


//修改一段里程断面的边坡参数,当前选种的边坡单独处理
void HdmDes::ModifySomeSG(CString roadname, double Sdml, double Edml, int ZorY, double SGouH, double EGouH)
{
	int j;
	AcDbObjectId gouId, desId;
	AcDbObject* pObj = NULL;
	AcDbEntity * pEnt = NULL;
	LTGOU_ROAD *LTgou = NULL;
	int iroad;
	double cml, x, y, gouh;
	double Scml, Ecml;

	//搜索指定起终里程的断面
	iroad = GetIRoadByName(roadname);

	Scml = road[iroad].pm->TYLC(Sdml);
	Ecml = road[iroad].pm->TYLC(Edml);

	for (j = 0; j < road[iroad].NCRS; j++)
	{
		if (road[iroad].hdmdes[j].cml < Scml - 0.001)
			continue;
		if (road[iroad].hdmdes[j].cml > Ecml + 0.001)
			break;
		if (ZorY == -1)
		{
			if (road[iroad].hdmdes[j].LGouPtNum < 1)
				continue;
			gouId = road[iroad].hdmdes[j].LgouId;
		}
		else
		{
			if (road[iroad].hdmdes[j].RGouPtNum < 1)
				continue;
			gouId = road[iroad].hdmdes[j].RgouId;
		}
		if (acdbOpenObject(pObj, gouId, AcDb::kForRead) != Acad::eOk)
			return;
		pObj->close();
		if (pObj->isKindOf(LTGOU_ROAD::desc()))
		{
			if (acdbOpenObject(pObj, gouId, AcDb::kForWrite) == Acad::eOk)
			{
				LTgou = LTGOU_ROAD::cast(pObj);
				LTgou->assertWriteEnabled();//加响应器修改实体时，不可少
				LTgou->m_IfSetBotH = 1;

				LTgou->m_GouBotH = SGouH;
				cml = LTgou->m_cml;
				x = cml - Scml;
				y = Ecml - cml;
				gouh = (SGouH*y + EGouH * x) / (x + y);//挡水堰宽

				LTgou->m_GouBotH = gouh;
				LTgou->close();
			}
		}
	}
}


//计算鼻端圆心位置,路面分离点
void HdmDes::CalNoseCen(JD_CENTER *pm1, JD_CENTER *pm2, double sml1, int QorH, int iroad1, int iroad2, double Rnose,
	double &CmlonZX, double &CmlOnYX, double NosePt[2])
{
	//1.计算1线偏离点pt;
	double pt[2], pt2[2];
	xlpoint PZ, PZ2;
	double cml1, cml2, dis, cmlonyx, predis;
	double Offset1, Offset2;
	double half_fgdk, lydk, cxdk, yljk, tljk, tljhp;
	int bkmode, sjbgmode;

	cml1 = sml1;
	cml2 = sml1 + QorH * 10.0;
	dis = 0.0;
	Offset2 = 100;
	//先搜索区间cml1,cml2
	while (cml2 < pm1->XLLength&&dis < (Offset2 + Rnose))
	{
		PZ.lc = cml2;
		pm1->xlpoint_pz(&PZ);
		int LorR = pm1->Judge2XLorR(PZ, pm2->XYArray, pm2->XYNum);

		if (LorR > 0)//取右路面宽
			CalLMK_JK(cml2, road[iroad1].NYLMK, road[iroad1].YLMK,
				road[iroad1].YcgNm, road[iroad1].Ycg,
				road[iroad1].YjkNm, road[iroad1].Yjk,
				half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		else
			CalLMK_JK(cml2, road[iroad1].NZLMK, road[iroad1].ZLMK,
				road[iroad1].ZcgNm, road[iroad1].Zcg,
				road[iroad1].ZjkNm, road[iroad1].Zjk,
				half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		CalLMKbyFile(cml2, LorR, road[iroad1].pm, road[iroad1].pBXArr, road[iroad1].BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
		Offset1 = half_fgdk + lydk + cxdk + yljk + tljk;

		pt[0] = PZ.x + (Offset1 + Rnose) * cos(PZ.a + LorR * 0.5*pi);
		pt[1] = PZ.y + (Offset1 + Rnose) * sin(PZ.a + LorR * 0.5*pi);
		//2.计算pt到pm2的距离;
		cmlonyx = pm2->PROJ_ML(pt[0], pt[1]);

		if (LorR > 0)//取左路面宽
			CalLMK_JK(cmlonyx, road[iroad2].NZLMK, road[iroad2].ZLMK,
				road[iroad2].ZcgNm, road[iroad2].Zcg,
				road[iroad2].ZjkNm, road[iroad2].Zjk,
				half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		else
			CalLMK_JK(cmlonyx, road[iroad2].NYLMK, road[iroad2].YLMK,
				road[iroad2].YcgNm, road[iroad2].Ycg,
				road[iroad2].YjkNm, road[iroad2].Yjk,
				half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		CalLMKbyFile(cmlonyx, LorR, road[iroad2].pm, road[iroad2].pBXArr, road[iroad2].BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
		Offset2 = half_fgdk + lydk + cxdk + yljk + tljk;

		PZ2.lc = cmlonyx;
		pm2->xlpoint_pz(&PZ2);
		pt2[0] = PZ2.x, pt2[1] = PZ2.y;
		predis = dis;
		dis = sqrt((pt2[0] - pt[0])*(pt2[0] - pt[0]) + (pt2[1] - pt[1])*(pt2[1] - pt[1]));
		//ads_printf(L"cmlonzx=%lf cmlonyx=%lf %lf %lf %lf %lf\n",PZ.lc,cmlonyx,pt[0],pt[1],pt2[0],pt2[1]);			
		if (dis > Offset2 + Rnose)
			break;
		else
		{
			cml1 = cml2;
			cml2 += QorH * 10.0;
		}
	}
	CString GH;
	//ads_printf(L"#########cml1=%lf cml2=%lf pdis=%lf dis=%lf %lf\n",pm1->XLC(cml1,GH),pm2->XLC(cmlonyx,GH),predis,dis,Offset2+Rnose);
	while (fabs(cml2 - cml1) > 0.001&&fabs(dis - Offset2 - Rnose) > 0.0001)
	{
		PZ.lc = 0.5*(cml1 + cml2);
		pm1->xlpoint_pz(&PZ);
		int LorR = pm1->Judge2XLorR(PZ, pm2->XYArray, pm2->XYNum);

		if (LorR > 0)//取右路面宽
			CalLMK_JK(PZ.lc, road[iroad1].NYLMK, road[iroad1].YLMK,
				road[iroad1].YcgNm, road[iroad1].Ycg,
				road[iroad1].YjkNm, road[iroad1].Yjk,
				half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		else
			CalLMK_JK(PZ.lc, road[iroad1].NZLMK, road[iroad1].ZLMK,
				road[iroad1].ZcgNm, road[iroad1].Zcg,
				road[iroad1].ZjkNm, road[iroad1].Zjk,
				half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		CalLMKbyFile(PZ.lc, LorR, road[iroad1].pm, road[iroad1].pBXArr, road[iroad1].BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
		Offset1 = half_fgdk + lydk + cxdk + yljk + tljk;

		pt[0] = PZ.x + (Offset1 + Rnose) * cos(PZ.a + LorR * 0.5*pi);
		pt[1] = PZ.y + (Offset1 + Rnose) * sin(PZ.a + LorR * 0.5*pi);
		//2.计算pt到pm2的距离;
		cmlonyx = pm2->PROJ_ML(pt[0], pt[1]);
		if (LorR > 0)//取右路面宽
			CalLMK_JK(cmlonyx, road[iroad2].NZLMK, road[iroad2].ZLMK,
				road[iroad2].ZcgNm, road[iroad2].Zcg,
				road[iroad2].ZjkNm, road[iroad2].Zjk,
				half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		else
			CalLMK_JK(cmlonyx, road[iroad2].NYLMK, road[iroad2].YLMK,
				road[iroad2].YcgNm, road[iroad2].Ycg,
				road[iroad2].YjkNm, road[iroad2].Yjk,
				half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		CalLMKbyFile(cmlonyx, LorR, road[iroad2].pm, road[iroad2].pBXArr, road[iroad2].BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
		Offset2 = half_fgdk + lydk + cxdk + yljk + tljk;

		PZ2.lc = cmlonyx;
		pm2->xlpoint_pz(&PZ2);
		pt2[0] = PZ2.x, pt2[1] = PZ2.y;
		dis = sqrt((pt2[0] - pt[0])*(pt2[0] - pt[0]) + (pt2[1] - pt[1])*(pt2[1] - pt[1]));
		if (dis > Offset2 + Rnose)
			cml2 = PZ.lc;
		else
			cml1 = PZ.lc;
		// ads_printf(L"####%lf  %lf %lf\n",PZ.lc,dis,Offset2+Rnose);
	}


	if (fabs(dis - Offset2 - Rnose) < 0.0001)
	{
		CmlonZX = 0.5*(cml1 + cml2);
		PZ.lc = CmlonZX;
		pm1->xlpoint_pz(&PZ);
		int LorR = pm1->Judge2XLorR(PZ, pm2->XYArray, pm2->XYNum);
		pt[0] = PZ.x + (Offset1 + Rnose) * cos(PZ.a + LorR * 0.5*pi);
		pt[1] = PZ.y + (Offset1 + Rnose) * sin(PZ.a + LorR * 0.5*pi);
		//2.计算pt到pm2的距离;
		CmlOnYX = pm2->PROJ_ML(pt[0], pt[1]);
		//    ads_printf(L"***zxcml=%0.3lf ymcml%0.3lf\n",CmlonZX,CmlOnYX);
		NosePt[0] = pt[0];
		NosePt[1] = pt[1];
	}
	else
		CmlOnYX = -1;
}
//计算主线双路面中间部分
void HdmDes::DesZXHdm_ON_doubleLM(double XJJ, RoadHdmdata &ZDroad,
	double cml, double projml,
	double Z_RHFR[], double Y_RHFL[],
	double LNewYd, int Z_NewNumR, double Z_NewRearpt[],
	double RNewYd, int Y_NewNumL, double Y_NewLearpt[],
	double &Z_RTW, double &Y_LTW,
	double Z_Rlmhd[3], double Y_Llmhd[3],
	int &Z_Rnpt, double Z_RDesPoint[],
	int &Y_Lnpt, double Y_LDesPoint[],
	double &MidFillArea, double &MidCutArea,
	double &MidQBTArea, double &MidFillGLTArea, double &MidHJarea,
	double &MidGouJQarea,
	double &MidDQLength, double &MidCrassLength, bool &IfXJGou
)//设计左填至右填
{
	//左线右侧单独设计,得左线边坡点
	double Z_RStartDesPt[2], Y_LStartDesPt[2];
	double Z_RTM[30], Z_RTH[30], Z_RTPTW[30], Z_RTPTI[30];
	double Y_LTM[30], Y_LTH[30], Y_LTPTW[30], Y_LTPTI[30];
	int Z_RLTBPJS, Y_LLTBPJS;
	double Z_RZJ, Y_LZJ, XJGK;
	int Z_RBPptSum, Y_LBPptSum;
	double Z_RDQLength, Z_RGrassLength, Y_LDQLength, Y_LGrassLength;
	double zssthd, zglthd, zhjwid, zhthd;
	double yssthd, yglthd, yhjwid, yhthd;
	double Z_RFillArea, Z_RCutArea, Y_LFillArea, Y_LCutArea;
	double Z_RQBTArea, Z_RFillGLTArea, Z_RHJarea;
	double Y_LQBTArea, Y_LFillGLTArea, Y_LHJarea;
	double Z_Rhthd, Y_Lhthd;
	double ljdis;

	int j;
	for (j = 0; j < 2; j++)
		Z_RStartDesPt[j] = Y_LStartDesPt[j] = 0.0;
	for (j = 0; j < 30; j++)
	{
		Z_RTM[j] = Z_RTH[j] = Z_RTPTW[j] = Z_RTPTI[j] = 0.0;
		Y_LTM[j] = Y_LTH[j] = Y_LTPTW[j] = Y_LTPTI[j] = 0.0;
	}
	Z_RLTBPJS = Y_LLTBPJS = 0;
	Z_RZJ = Y_LZJ = XJGK = 1000.0;
	Z_RBPptSum = Y_LBPptSum = 0;
	Z_RDQLength = Z_RGrassLength = Y_LDQLength = Y_LGrassLength = 0;
	zssthd = zglthd = zhjwid = zhthd = 0;
	yssthd = yglthd = yhjwid = yhthd = 0;
	Z_RFillArea = Z_RCutArea = Y_LFillArea = Y_LCutArea = 0;
	Z_RQBTArea = Z_RFillGLTArea = Z_RHJarea = 0;
	Y_LQBTArea = Y_LFillGLTArea = Y_LHJarea = 0;
	Z_Rhthd = Y_Lhthd = 0;


	Z_RStartDesPt[0] = Z_RHFR[4 * 2];//以左线为Y轴
	Z_RStartDesPt[1] = Z_RHFR[4 * 2 + 1] - LNewYd;//地面标高为原点	
	if (XJJ < 0.0001)//左线为绕行，一线为右线
	{
		//取出左线右侧参数
		Z_RLTBPJS = FindWichBP(projml, ZDroad.pm, ZDroad.hdmbz.NYLDBP, ZDroad.hdmbz.YLDBP, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI);//左路堤边坡
		//清表土厚度
		Z_Rhthd = FindWichHTHD(projml, ZDroad.pm, ZDroad.hdmbz.NYHTHD, ZDroad.hdmbz.YHTHD);
		Z_RZJ = FindWichDQ(projml, ZDroad.pm, ZDroad.hdmbz.NYDQ, ZDroad.hdmbz.YDQ);
		//路面厚
		FindWichHD(projml, ZDroad.pm, ZDroad.hdmbz.NYLMHD, ZDroad.hdmbz.YLMHD, Z_Rlmhd);

		Y_LLTBPJS = FindWichBP(cml, road[0].pm, road[0].hdmbz.NZLDBP, road[0].hdmbz.ZLDBP, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI);//左路堤边坡
		//清表土厚度
		Y_Lhthd = FindWichHTHD(cml, road[0].pm, road[0].hdmbz.NZHTHD, road[0].hdmbz.ZHTHD);
		Y_LZJ = FindWichDQ(cml, road[0].pm, road[0].hdmbz.NZDQ, road[0].hdmbz.ZDQ);
		//路面厚
		FindWichHD(cml, road[0].pm, road[0].hdmbz.NZLMHD, road[0].hdmbz.ZLMHD, Y_Llmhd);
	}
	else
	{
		//取出左线(主线)右侧参数
		Z_RLTBPJS = FindWichBP(cml, road[0].pm, road[0].hdmbz.NYLDBP, road[0].hdmbz.YLDBP, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI);//左路堤边坡
		//清表土厚度
		Z_Rhthd = FindWichHTHD(cml, road[0].pm, road[0].hdmbz.NYHTHD, road[0].hdmbz.YHTHD);
		Z_RZJ = FindWichDQ(cml, road[0].pm, road[0].hdmbz.NYDQ, road[0].hdmbz.YDQ);
		//路面厚
		FindWichHD(cml, road[0].pm, road[0].hdmbz.NYLMHD, road[0].hdmbz.YLMHD, Z_Rlmhd);

		Y_LLTBPJS = FindWichBP(projml, ZDroad.pm, ZDroad.hdmbz.NZLDBP, ZDroad.hdmbz.ZLDBP, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI);//左路堤边坡
		//清表土厚度
		Y_Lhthd = FindWichHTHD(projml, ZDroad.pm, ZDroad.hdmbz.NZHTHD, ZDroad.hdmbz.ZHTHD);
		Y_LZJ = FindWichDQ(projml, ZDroad.pm, ZDroad.hdmbz.NZDQ, ZDroad.hdmbz.ZDQ);
		//路面厚
		FindWichHD(projml, ZDroad.pm, ZDroad.hdmbz.NZLMHD, ZDroad.hdmbz.ZLMHD, Y_Llmhd);
	}

	ljdis = fabs(XJJ) - Z_RHFR[8] - Y_RHFL[8];
	Z_Rnpt = 5;

	for (j = 0; j < 5; j++)
	{
		Z_RDesPoint[j * 2] = Z_RHFR[j * 2];
		Z_RDesPoint[j * 2 + 1] = Z_RHFR[j * 2 + 1] - LNewYd;
	}

	Y_Lnpt = 5;
	for (j = 0; j < 5; j++)
	{
		Y_LDesPoint[j * 2] = Y_RHFL[j * 2];
		Y_LDesPoint[j * 2 + 1] = Y_RHFL[j * 2 + 1] - RNewYd;
	}

	//-------------------------------------------------------------------------------------------------------------	
	Z_RDesPoint[Z_Rnpt * 2] = Z_RHFR[4 * 2] + ljdis;
	Z_RDesPoint[Z_Rnpt * 2 + 1] = Y_RHFL[4 * 2 + 1] - LNewYd;
	Z_Rnpt++;


	//计算断面积
	CalDesAllArea(Z_Rnpt, Z_RDesPoint, Z_NewNumR, Z_NewRearpt, Z_Rlmhd, Z_Rhthd, zglthd, 0.0, Z_RZJ, -1,
		Z_RStartDesPt, Z_RTM, Z_RTH, Z_RTPTW, Z_RTPTI, Z_RLTBPJS,
		Z_RFillArea, Z_RCutArea, Z_RQBTArea, Z_RFillGLTArea, Z_RHJarea);

	CalDesAllArea(Y_Lnpt, Y_LDesPoint, Y_NewNumL, Y_NewLearpt, Y_Llmhd, Y_Lhthd, yglthd, 0.0, Y_LZJ, -1,
		Y_LStartDesPt, Y_LTM, Y_LTH, Y_LTPTW, Y_LTPTI, Y_LLTBPJS,
		Y_LFillArea, Y_LCutArea, Y_LQBTArea, Y_LFillGLTArea, Y_LHJarea);

	//计算右侧面积 //统计面积
	MidQBTArea = Z_RQBTArea + Y_LQBTArea;
	MidFillArea = Z_RFillArea + Y_LFillArea;
	MidCutArea = Z_RCutArea + Y_LCutArea;
	MidFillGLTArea = Z_RFillGLTArea + Y_LFillGLTArea;
	MidHJarea = 0.0;
	MidGouJQarea = 0.0;
	MidDQLength = 0.0;
	MidCrassLength = 0.0;
}

//设计关联横断面
//////////////////////////////////////////////////////////////////////////
//设计road[i].hdmdes[j]的横断面；ZxOrYx=-1 相对于当前线路左线分离，ZxOrYx=1 相对于当前线路右线分离
//
//////////////////////////////////////////////////////////////////////////
void HdmDes::DesLinkCross(int i, int j, int ZxOrYx)
{
	int ZIfBTinf, YIfBTinf;
	double LDesPoint[500], RDesPoint[500], LFillArea, LCutArea, RFillArea, RCutArea, FillArea, CutArea;
	double LGouH, LGouX, RGouH, RGouX;
	double LFillBetterSoilArea, LFillSSTArea, LQBTArea, LGouTarea, LGouWarea, LHJarea, LSGJQarea, LDQlength, LGrasslength;
	double RFillBetterSoilArea, RFillSSTArea, RQBTArea, RGouTarea, RGouWarea, RHJarea, RSGJQarea, RDQlength, RGrasslength;
	int Lnpt, Rnpt;
	//double LgouTarea,LgouWarea,RgouTarea,RgouWarea;
	double cml;
	double NewYd, NewLearpt[400], NewRearpt[400];
	int newNumL, newNumR;
	double NewYdOffset, NewLearptOffset[400], NewRearptOffset[400];
	int newNumLOffset, newNumROffset;
	//	double OffsetByXLZX;
	int iroad, jcross;
	double ZJ2;
	double glcml;

	ZIfBTinf = 0;
	YIfBTinf = 0;

	LFillBetterSoilArea = LFillSSTArea = LQBTArea = LGouTarea = LGouWarea = LHJarea = LSGJQarea = LDQlength = LGrasslength = 0.0;
	RFillBetterSoilArea = RFillSSTArea = RQBTArea = RGouTarea = RGouWarea = RHJarea = RSGJQarea = RDQlength = RGrasslength = 0.0;
	Lnpt = Rnpt = 0;
	LFillArea = RFillArea = FillArea = LCutArea = RCutArea = CutArea = 0.0;

	cml = road[i].hdmdes[j].cml;
	road[i].hdmdes[j].DorS = 1;
	road[i].hdmdes[j].newLYd = road[i].hdmdes[j].newRYd = road[i].hdmdmx[j].EarH;

	if (road[i].hdmdes[j].ZDMXZ == 3)//桥中
	{
		road[i].hdmdes[j].LZDK = road[i].hdmdes[j].RHFL[8] + road[i].hdmdes[j].BriZZDK;//桥梁用地
		if (road[i].NCRS == 1)
			ads_alert(L"指定里程位于桥梁范围内!");
		ZIfBTinf = 1;
	}

	if (road[i].hdmdes[j].ZDMXZ == 4)//隧中
	{
		//	road[i].hdmdes[j].LZDK=road[i].hdmdes[j].RHFL[8]+road[i].hdmdes[j].TunZZDK;//桥梁用地
		road[i].hdmdes[j].LZDK = 0.0;
		if (road[i].NCRS == 1)
			ads_alert(L"指定里程位于隧道范围内!");
		ZIfBTinf = 1;
	}
	if (road[i].hdmdes[j].YDMXZ == 3)//桥中
	{
		road[i].hdmdes[j].RZDK = road[i].hdmdes[j].RHFR[8] + road[i].hdmdes[j].BriYZDK;//桥梁用地
		if (road[i].NCRS == 1)
			ads_alert(L"指定里程位于桥梁范围内!");
		YIfBTinf = 1;
	}

	if (road[i].hdmdes[j].YDMXZ == 4)//隧中
	{
		//	road[i].hdmdes[j].RZDK=road[i].hdmdes[j].RHFR[8]+road[i].hdmdes[j].TunYZDK;//桥梁用地
		road[i].hdmdes[j].RZDK = 0.0;
		if (road[i].NCRS == 1)
			ads_alert(L"指定里程位于隧道范围内!");
		YIfBTinf = 1;
	}


	xlpoint PZ;
	PZ.lc = cml;
	road[i].pm->xlpoint_pz(&PZ);
	//	road[i].hdmdes[j].fwj = PZ.a;//记录断面中心切线方位角

	if (!ZIfBTinf)//左幅非桥非隧
	{
		//////////////////////////////////////////////////////////////////////////
		//路基中线和线路中线不一致：地面点需要平移(修改)
		NewYd = road[i].hdmdmx[j].EarH;
		newNumL = road[i].hdmdmx[j].ZEarPtNum;
		int k;
		for (k = 0; k < newNumL; k++)
		{
			NewLearpt[k * 2] = road[i].hdmdmx[j].ZEarPtAry[k].x;
			NewLearpt[k * 2 + 1] = road[i].hdmdmx[j].ZEarPtAry[k].y;
		}
		newNumR = road[i].hdmdmx[j].YEarPtNum;
		for (k = 0; k < newNumR; k++)
		{
			NewRearpt[k * 2] = road[i].hdmdmx[j].YEarPtAry[k].x;
			NewRearpt[k * 2 + 1] = road[i].hdmdmx[j].YEarPtAry[k].y;
		}
		//		OffsetByXLZX = 0.0;
		//		CalOffsetByXLZX(cml,road[i].NZLMK,road[i].ZLMK,OffsetByXLZX);
		CalNewZB(road[i].hdmdes[j].OffsetByXLZX, NewYd, NewLearpt, newNumL, NewRearpt, newNumR,
			NewYdOffset, NewLearptOffset, newNumLOffset, NewRearptOffset, newNumROffset);
		//////////////////////////////////////////////////////////////////////////
		CrosNew(i, -1, j, NewYdOffset, newNumLOffset, NewLearptOffset, road[i].hdmdes[j].RHFL, road[i].hdmdes[j].zlmhd, road[i].hdmdes[j].ZZJ, road[i].hdmdes[j].ZPJPT,
			road[i].hdmdes[j].Ldeltah, road[i].hdmdes[j].Zt, road[i].hdmdes[j].ZHc, Lnpt, LDesPoint,
			LFillArea, LFillBetterSoilArea, LQBTArea, LCutArea,
			road[i].hdmdes[j].LZDK,
			road[i].hdmdes[j].LIfSetGouH, road[i].hdmdes[j].LGouH, road[i].hdmdes[j].LGouProperty, road[i].hdmdes[j].LGouPtNum, road[i].hdmdes[j].Lgou, road[i].hdmdes[j].LGouH, LGouX, LGouTarea, LGouWarea,
			road[i].hdmdes[j].LJSGouPtNum, road[i].hdmdes[j].LJSgou,
			LSGJQarea, LDQlength, LGrasslength, road[i].hdmdes[j].ZCG_GDR);

		//	if(road[i].hdmdes[j].xjj<0.0001)//左线分离

		if (ZxOrYx < 0.0001)//左线分离
		{
			//1.计算左线对应里程段落
			double ept[2];

			iroad = GetIRoadByName(road[i].hdmdes[j].FLDname);
			//计算是否有关联断面
			CalLinkHdmSENo(i, j, -1, Lnpt, LDesPoint, iroad, glcml, road[i].hdmdes[j].ZZJ, ZJ2);

			//			CalLinkHdmSENo(i,road[i].hdmdes[j].cml,fabs(LDesPoint[(Lnpt-1)*2]),-1,iroad,SnoOnFld,EnoOnFld);
			if (glcml > -0.0001)//有关联断面
			{
				//对于主线需要按ZJ1重新设计
				if (ZJ2 + 10000.0<0.01 && ZJ2 + 10000.0>-0.01)
				{
					jcross = InsertHdm(i, j, iroad, 1, ZJ2, glcml);
					CalLinkHdm_TWPJD(i, j, -1, iroad, jcross);
				}

				CrosNew(i, -1, j, NewYdOffset, newNumLOffset, NewLearptOffset, road[i].hdmdes[j].RHFL, road[i].hdmdes[j].zlmhd, road[i].hdmdes[j].ZZJ, road[i].hdmdes[j].ZPJPT,
					road[i].hdmdes[j].Ldeltah, road[i].hdmdes[j].Zt, road[i].hdmdes[j].ZHc, Lnpt, LDesPoint,
					LFillArea, LFillBetterSoilArea, LQBTArea, LCutArea,
					road[i].hdmdes[j].LZDK,
					road[i].hdmdes[j].LIfSetGouH, road[i].hdmdes[j].LGouH, road[i].hdmdes[j].LGouProperty, road[i].hdmdes[j].LGouPtNum, road[i].hdmdes[j].Lgou, road[i].hdmdes[j].LGouH, LGouX, LGouTarea, LGouWarea,
					road[i].hdmdes[j].LJSGouPtNum, road[i].hdmdes[j].LJSgou,
					LSGJQarea, LDQlength, LGrasslength, road[i].hdmdes[j].ZCG_GDR);

				road[i].hdmdes[j].glcml = glcml;
				road[i].hdmdes[j].glRoadName = road[iroad].roadname;
				road[i].hdmdes[j].LIfSetGouH = 0;
				road[i].hdmdes[j].LJSGouPtNum = 0;
				if (i == 0)//主线不设线间沟
				{
					road[i].hdmdes[j].LGouProperty = -1;
					road[i].hdmdes[j].LGouPtNum = 0;
				}
				road[i].hdmdes[j].LZDK = 0;
				LGouH = LGouX = LGouTarea = LGouWarea = 0.0;
				//对于分离线需要插入该断面
				//ads_printf(L"iroad=%d ZJ2=%lf\n",iroad,ZJ2);
				jcross = InsertHdm(i, j, iroad, 1, ZJ2, glcml);
				road[iroad].hdmdes[jcross].RZDK = 0;

			}

		}
		//判别右侧是否为桥隧
	}

	if (!YIfBTinf)
	{
		NewYd = road[i].hdmdmx[j].EarH;
		newNumR = road[i].hdmdmx[j].YEarPtNum;
		int k;
		for (k = 0; k < newNumR; k++)
		{
			NewRearpt[k * 2] = road[i].hdmdmx[j].YEarPtAry[k].x;
			NewRearpt[k * 2 + 1] = road[i].hdmdmx[j].YEarPtAry[k].y;
		}
		newNumL = road[i].hdmdmx[j].ZEarPtNum;
		for (k = 0; k < newNumL; k++)
		{
			NewLearpt[k * 2] = road[i].hdmdmx[j].ZEarPtAry[k].x;
			NewLearpt[k * 2 + 1] = road[i].hdmdmx[j].ZEarPtAry[k].y;
		}
		//		CalOffsetByXLZX(cml,road[i].NYLMK,road[i].YLMK,OffsetByXLZX);
		CalNewZB(road[i].hdmdes[j].OffsetByXLZX, NewYd, NewLearpt, newNumL, NewRearpt, newNumR,
			NewYdOffset, NewLearptOffset, newNumLOffset, NewRearptOffset, newNumROffset);

		CrosNew(i, 1, j, NewYdOffset, newNumROffset, NewRearptOffset, road[i].hdmdes[j].RHFR, road[i].hdmdes[j].ylmhd, road[i].hdmdes[j].YZJ, road[i].hdmdes[j].YPJPT,
			road[i].hdmdes[j].Rdeltah, road[i].hdmdes[j].Yt, road[i].hdmdes[j].YHc, Rnpt, RDesPoint,
			RFillArea, RFillBetterSoilArea, RQBTArea, RCutArea,
			road[i].hdmdes[j].RZDK,
			road[i].hdmdes[j].RIfSetGouH, road[i].hdmdes[j].RGouH, road[i].hdmdes[j].RGouProperty, road[i].hdmdes[j].RGouPtNum, road[i].hdmdes[j].Rgou, road[i].hdmdes[j].RGouH, RGouX, RGouTarea, RGouWarea,
			road[i].hdmdes[j].RJSGouPtNum, road[i].hdmdes[j].RJSgou,
			RSGJQarea, RDQlength, RGrasslength, road[i].hdmdes[j].YCG_GDR);

		//	if(road[i].hdmdes[j].xjj>0.0001)//右线分离
		if (ZxOrYx > 0.0001)//右线分离
		{
			//1.计算右线对应里程段落
			double spt[2];
			int SnoOnFld, EnoOnFld;

			iroad = GetIRoadByName(road[i].hdmdes[j].FLDname);
			//计算是否有关联断面
			CalLinkHdmSENo(i, j, 1, Rnpt, RDesPoint, iroad, glcml, road[i].hdmdes[j].YZJ, ZJ2);



			if (glcml > -0.0001)//有关联断面
			{
				//			   ads_printf(L"dml=%lf glcml=%lf %lf zj2=%lf\n",road[i].hdmdes[j].dml,glcml,road[i].hdmdes[j].YZJ,ZJ2);
				if (ZJ2 + 10000.0<0.01 && ZJ2 + 10000.0>-0.01)
				{
					jcross = InsertHdm(i, j, iroad, -1, ZJ2, glcml);
					CalLinkHdm_TWPJD(i, j, 1, iroad, jcross);
				}


				//				 ads_printf(L"####%lf\n", road[i].hdmdes[j].dml);
				//对于主线需要按ZJ1重新设计
				CrosNew(i, 1, j, NewYdOffset, newNumROffset, NewRearptOffset, road[i].hdmdes[j].RHFR, road[i].hdmdes[j].ylmhd, road[i].hdmdes[j].YZJ, road[i].hdmdes[j].YPJPT,
					road[i].hdmdes[j].Rdeltah, road[i].hdmdes[j].Yt, road[i].hdmdes[j].YHc, Rnpt, RDesPoint,
					RFillArea, RFillBetterSoilArea, RQBTArea, RCutArea,
					road[i].hdmdes[j].RZDK,
					road[i].hdmdes[j].RIfSetGouH, road[i].hdmdes[j].RGouH, road[i].hdmdes[j].RGouProperty, road[i].hdmdes[j].RGouPtNum, road[i].hdmdes[j].Rgou, road[i].hdmdes[j].RGouH, RGouX, RGouTarea, RGouWarea,
					road[i].hdmdes[j].RJSGouPtNum, road[i].hdmdes[j].RJSgou,
					RSGJQarea, RDQlength, RGrasslength, road[i].hdmdes[j].YCG_GDR);
				road[i].hdmdes[j].glcml = glcml;
				road[i].hdmdes[j].glRoadName = road[iroad].roadname;


				road[i].hdmdes[j].RIfSetGouH = 0;
				road[i].hdmdes[j].RGouH = 0.0;
				if (i == 0)
				{
					road[i].hdmdes[j].RGouProperty = -1;
					road[i].hdmdes[j].RGouPtNum = 0;
				}
				RGouH = RGouX = RGouTarea = RGouWarea = 0.0;
				road[i].hdmdes[j].RJSGouPtNum = 0;
				RSGJQarea = RDQlength = RGrasslength = 0.0;
				road[i].hdmdes[j].RZDK = 0;
				//对于分离线需要插入该断面
				jcross = InsertHdm(i, j, iroad, -1, ZJ2, glcml);
				road[iroad].hdmdes[jcross].LZDK = 0;
			}
			//////////////////////////////////////////////////////////////////////////
			//为什么只有右线分离的时候有这些？
			// 			else
			// 			{
			// 				if(i>0&&fabs(road[i].hdmdes[j].xjj)<0.001)//对分离段起始断面
			// 				{
			// 					road[i].hdmdes[j].ZZJ =0.0;
			// 				    CrosNew(i,-1,j,NewYd,newNumL,NewLearpt,road[i].hdmdes[j].RHFL,road[i].hdmdes[j].zlmhd,road[i].hdmdes[j].ZZJ,road[i].hdmdes[j].ZPJPT,
			// 					road[i].hdmdes[j].Ldeltah,road[i].hdmdes[j].Zt,road[i].hdmdes[j].ZHc,Lnpt,LDesPoint,
			// 					LFillArea,LFillBetterSoilArea,LQBTArea,LCutArea,
			// 					road[i].hdmdes[j].LZDK,
			// 					road[i].hdmdes[j].LIfSetGouH,road[i].hdmdes[j].LGouH,road[i].hdmdes[j].LGouProperty,road[i].hdmdes[j].LGouPtNum,road[i].hdmdes[j].Lgou,road[i].hdmdes[j].LGouH,LGouX,LGouTarea,LGouWarea,
			// 					road[i].hdmdes[j].LJSGouPtNum, road[i].hdmdes[j].LJSgou,
			// 					LSGJQarea,LDQlength,LGrasslength, road[i].hdmdes[j].ZCG_GDR);
			// 				}
			// 			}

		}

	}
	//计算左右两侧面积		
	//判别本断面清表土和挖淤泥面积数量
	FindWichHTHD(road[i].hdmdes[j].cml, road[i].pm, road[i].hdmbz.NZHTHD, road[i].hdmbz.ZHTHD, road[i].hdmdes[j].ZHTHD, road[i].hdmdes[j].ZHTXZ);
	if (road[i].hdmdes[j].ZHTXZ == 0)//清表土
		road[i].hdmdes[j].QBTArea = LQBTArea;
	else
		road[i].hdmdes[j].WYNArea = LQBTArea;
	FindWichHTHD(road[i].hdmdes[j].cml, road[i].pm, road[i].hdmbz.NYHTHD, road[i].hdmbz.YHTHD, road[i].hdmdes[j].YHTHD, road[i].hdmdes[j].YHTXZ);
	if (road[i].hdmdes[j].YHTXZ == 0)//清表土
		road[i].hdmdes[j].QBTArea += RQBTArea;
	else
		road[i].hdmdes[j].WYNArea += RQBTArea;

	//	road[i].hdmdes[j].QBTArea = LQBTArea + RQBTArea;//清表土面积
	road[i].hdmdes[j].GouTarea = LGouTarea + RGouTarea;//水沟填面积
	road[i].hdmdes[j].GouWarea = LGouWarea + RGouWarea;//水沟挖面积
	road[i].hdmdes[j].FillArea = LFillArea + RFillArea + road[i].hdmdes[j].GouTarea;//填面积



	road[i].hdmdes[j].CutArea = LCutArea + RCutArea + road[i].hdmdes[j].GouWarea; //挖面积
	road[i].hdmdes[j].aw = road[i].hdmdes[j].CutArea;
	road[i].hdmdes[j].at = road[i].hdmdes[j].FillArea;
	road[i].hdmdes[j].FillBetterSoilArea = LFillBetterSoilArea + RFillBetterSoilArea;//填改良土面积
	road[i].hdmdes[j].HJarea = LHJarea + RHJarea;//护肩面积
	road[i].hdmdes[j].SGJQarea = LSGJQarea + RSGJQarea;//浆砌面积
	road[i].hdmdes[j].DQlength = LDQlength + RDQlength;//挡墙坡长
	road[i].hdmdes[j].Grasslength = LGrasslength + RGrasslength;//铺草坡长
	//用于交互设计
	road[i].hdmdes[j].Z_LFillArea = LFillArea; road[i].hdmdes[j].MidFillArea = 0.0; road[i].hdmdes[j].Y_RFillArea = RFillArea;
	road[i].hdmdes[j].Z_LCutArea = LCutArea; road[i].hdmdes[j].MidCutArea = 0.0; road[i].hdmdes[j].Y_RCutArea = RCutArea;
	road[i].hdmdes[j].Z_LFillSSTArea = LFillSSTArea; road[i].hdmdes[j].MidFillSSTArea = 0.0; road[i].hdmdes[j].Y_RFillSSTArea = RFillSSTArea;//填渗水土面积
	road[i].hdmdes[j].Z_LQBTArea = LQBTArea; road[i].hdmdes[j].MidQBTArea = 0.0; road[i].hdmdes[j].Y_RQBTArea = RQBTArea;
	road[i].hdmdes[j].Z_LFillBetterSoilArea = LFillBetterSoilArea; road[i].hdmdes[j].MidFillGLTArea = 0.0; road[i].hdmdes[j].Y_RFillBetterSoilArea = RFillBetterSoilArea;
	road[i].hdmdes[j].Z_LHJarea = LHJarea; road[i].hdmdes[j].MidHJarea = 0.0; road[i].hdmdes[j].Y_RHJarea = RHJarea;
	road[i].hdmdes[j].Z_LSGJQarea = LSGJQarea; road[i].hdmdes[j].MidGouJQarea = 0.0; road[i].hdmdes[j].Y_RSGJQarea = RSGJQarea;
	road[i].hdmdes[j].Z_LDQlength = LDQlength; road[i].hdmdes[j].MidDQlength = 0.0; road[i].hdmdes[j].Y_RDQlength = RDQlength;//挡墙坡长
	road[i].hdmdes[j].Z_LGrasslength = LGrasslength; road[i].hdmdes[j].MidGrasslength = 0.0; road[i].hdmdes[j].Y_RGrasslength = RGrasslength;//铺草坡长
	road[i].hdmdes[j].Z_LGouTarea = LGouTarea; road[i].hdmdes[j].Y_RGouTarea = RGouTarea;
	road[i].hdmdes[j].Z_LGouWarea = LGouWarea; road[i].hdmdes[j].Y_RGouWarea = RGouWarea;

	//////////////////////////////////////////////////////////////////////////
	road[i].hdmdes[j].Lnpt = Lnpt;
	if (road[i].hdmdes[j].RPTL.length() > 0)
		road[i].hdmdes[j].RPTL.removeSubArray(0, road[i].hdmdes[j].RPTL.length() - 1);

	AcGePoint3d pt;
	int k;
	for (k = 0; k < Lnpt; k++)
	{
		pt.x = -1.0*LDesPoint[k * 2];
		pt.y = LDesPoint[k * 2 + 1];
		road[i].hdmdes[j].RPTL.append(pt);

	}


	road[i].hdmdes[j].Rnpt = Rnpt;
	if (road[i].hdmdes[j].RPTR.length() > 0)
		road[i].hdmdes[j].RPTR.removeSubArray(0, road[i].hdmdes[j].RPTR.length() - 1);

	for (k = 0; k < Rnpt; k++)
	{
		pt.x = RDesPoint[k * 2];
		pt.y = RDesPoint[k * 2 + 1];
		road[i].hdmdes[j].RPTR.append(pt);
	}

	if (road[i].hdmdes[j].Lnpt > 0)
		road[i].hdmdes[j].Ljdnum = road[i].hdmdes[j].Lnpt - 1;
	if (road[i].hdmdes[j].Rnpt > 0)
		road[i].hdmdes[j].Rjdnum = road[i].hdmdes[j].Rnpt - 1;

	//////////////////////////////////////////////////////////////////////////
	//为什么只有左侧,只给X坐标赋值？
	for (k = 0; k < road[i].hdmdes[j].LJSGouPtNum; k++)
		road[i].hdmdes[j].LJSgou[k * 2] = -1 * road[i].hdmdes[j].LJSgou[k * 2];
	for (int kk = 0; kk < road[i].hdmdes[j].LGouPtNum; kk++)
		road[i].hdmdes[j].Lgou[kk * 2] = -1 * road[i].hdmdes[j].Lgou[kk * 2];
	//////////////////////////////////////////////////////////////////////////

}

int HdmDes::FindIDM(int iroad, double glcml)
{
	int i;
	for (i = 0; i < road[iroad].NCRS; i++)
	{
		if (road[iroad].hdmdes[i].cml > glcml)
			break;

	}

	if (i < road[iroad].NCRS && i>0)
	{
		if (fabs(glcml - road[iroad].hdmdes[i].cml) < 0.001)
			return i;
		else
			return i - 1;
	}
	else if (i == 0)
		return 0;

	return road[iroad].NCRS - 1;
}

int HdmDes::FindIDM(RoadHdmdata &ZDroad, double glcml)
{
	int i;
	for (i = 0; i < ZDroad.NCRS; i++)
	{
		if (ZDroad.hdmdes[i].cml > glcml)
			break;
	}

	if (i < ZDroad.NCRS && i>0)
	{
		if (fabs(glcml - ZDroad.hdmdes[i].cml) < 0.001)
			return i;
		else
			return i - 1;
	}
	else if (i == 0)
		return 0;
	return ZDroad.NCRS - 1;
}

//计算相关断面交点
int HdmDes::CalLinkHdmJd(int i, double cml1, double bpc1, int LorR1, int iroad, double cml2, double bpc2, int LorR2, double &ZJ1, double &ZJ2)
{
	int IfHasJd = 0;

	double SptZX[2], EptZX[2], SptFLD[2], EptFLD[2], IntPt[2];
	xlpoint PZ;

	PZ.lc = cml1;
	road[i].pm->xlpoint_pz(&PZ);
	SptZX[0] = PZ.x, SptZX[1] = PZ.y;
	EptZX[0] = PZ.x + bpc1 * cos(PZ.a + LorR1 * 0.5*pi);
	EptZX[1] = PZ.y + bpc1 * sin(PZ.a + LorR1 * 0.5*pi);

	PZ.lc = cml2;
	road[iroad].pm->xlpoint_pz(&PZ);
	SptFLD[0] = PZ.x, SptFLD[1] = PZ.y;
	EptFLD[0] = PZ.x + bpc2 * cos(PZ.a + LorR2 * 0.5*pi);
	EptFLD[1] = PZ.y + bpc2 * sin(PZ.a + LorR2 * 0.5*pi);

	if (INTERS(&IntPt[0], &IntPt[1], SptZX[0], SptZX[1], EptZX[0], EptZX[1], SptFLD[0], SptFLD[1], EptFLD[0], EptFLD[1]) == 0)
	{
		IfHasJd = 1;//有交点
		//求支距
		ZJ1 = sqrt((IntPt[0] - SptZX[0])*(IntPt[0] - SptZX[0]) + (IntPt[1] - SptZX[1])*(IntPt[1] - SptZX[1]));
		ZJ2 = sqrt((IntPt[0] - SptFLD[0])*(IntPt[0] - SptFLD[0]) + (IntPt[1] - SptFLD[1])*(IntPt[1] - SptFLD[1]));
	}

	return IfHasJd;
}

/*
void HdmDes::DesZXLinkHdm_ZTtoYW(int i,int j,int iroad,int jcross,
double ZX_lmhd[3],
double &ZX_TW,double &ZX_TWH,
int &ZX_npt,double ZX_DesPoint[],
double &MidFillArea,double &MidCutArea,double &ZX_ZDK
)//设计左挖至右挖

{
//左线右侧单独设计,得左线边坡点
double Z_RStartDesPt[2],Y_LStartDesPt[2];
double Z_RTM[30],Z_RTH[30],Z_RTPTW[30],Z_RTPTI[30];
double Y_LTM[30],Y_LTH[30],Y_LTPTW[30],Y_LTPTI[30];
int Z_RLTBPJS,Y_LLTBPJS;
double Z_RZJ,Y_LZJ,XJGK;
double MidQBTArea,MidFillGLTArea,MidHJarea;

double zssthd,zglthd,zhjwid,zhthd;
double yssthd,yglthd,yhjwid,yhthd;
double Z_RFillArea,Z_RCutArea,Y_LFillArea,Y_LCutArea;
double Z_RQBTArea,Z_RFillGLTArea,Z_RHJarea;
double Y_LQBTArea,Y_LFillGLTArea,Y_LHJarea;
double ZD,ZGK,ZGS,ZGP1,ZGP2,ZCG_JQHD;
double YD,YGK,YGS,YGP1,YGP2,YCG_JQHD;
double ZDesBG,YDesBG;
double LNewYd, Z_NewRearpt[200];
int Z_NewNumR;
double RNewYd;
int Y_NewNumL;
double Y_NewLearpt[200];
int TorW;
int k;
double Z_Rhthd,Y_Lhthd;
int Z_Rnpt;
double Z_RDesPoint[100];
int Y_Lnpt;
double Y_LDesPoint[100];
double XJJ;

XJJ = road[i].hdmdes[j].xjj;
double cml;
cml = road[i].hdmdes[j].cml;
double projml;
projml = road[i].hdmdes[j].glcml;
double Z_RHFR[8],ZWW[2];
double Y_RHFL[8],YWW[2];

zssthd=zglthd=zhjwid=zhthd=0;
yssthd=yglthd=yhjwid=yhthd=0;
Z_RFillArea=Z_RCutArea=Y_LFillArea=Y_LCutArea=0;
Z_RQBTArea=Z_RFillGLTArea=Z_RHJarea=0;
Y_LQBTArea=Y_LFillGLTArea=Y_LHJarea=0;
ZD=ZGK=ZGS=ZGP1=ZGP2=ZCG_JQHD=0;
YD=YGK=YGS=YGP1=YGP2=YCG_JQHD=0;
ZDesBG=YDesBG=0;
Z_Rhthd=Y_Lhthd=0;

Z_RFillArea=Z_RCutArea=Y_LFillArea=Y_LCutArea=0.0;
Z_RQBTArea=Z_RFillGLTArea=Z_RHJarea=0.0;
Y_LQBTArea=Y_LFillGLTArea=Y_LHJarea=0.0;

TorW=1;//挖
double ljdis;
if(XJJ<-0.0001)//左线为绕行,右线为主线
{
//取出左线右侧参数
Cal_D(projml,road[iroad].pm,road[iroad].hdmbz.NZLQSG,road[iroad].hdmbz.ZLQSG,
&ZD,&ZGK,&ZGS,&ZGP1,&ZGP2,&ZCG_JQHD);//路堑边沟宽度

for(k=0; k<8; k++)
{
Z_RHFR[k] = road[iroad].hdmdes[jcross].RHFR[k];
Y_RHFL[k] = road[i].hdmdes[j].RHFL[k];
}
LNewYd=road[iroad].hdmdmx[jcross].EarH;
Z_NewNumR=road[iroad].hdmdmx[jcross].YEarPtNum;
for(k=0; k<Z_NewNumR; k++)
{
Z_NewRearpt[k*2] = road[iroad].hdmdmx[jcross].YEarPtAry[k].x;
Z_NewRearpt[k*2+1] = road[iroad].hdmdmx[jcross].YEarPtAry[k].y;
}

RNewYd=road[i].hdmdmx[j].EarH;
Y_NewNumL=road[i].hdmdmx[j].ZEarPtNum;
for(k=0; k<Y_NewNumL; k++)
{
Y_NewLearpt[k*2] = road[i].hdmdmx[j].ZEarPtAry[k].x;
Y_NewLearpt[k*2+1] = road[i].hdmdmx[j].ZEarPtAry[k].y;
}

Z_RStartDesPt[0]=Z_RHFR[3*2];//以左线为Y轴
Z_RStartDesPt[1]=Z_RHFR[3*2+1]-LNewYd;//地面标高为原点

Z_Rnpt = 5;
Z_RDesPoint[0] = 0.0;
Z_RDesPoint[1] = Z_RHFR[1] - LNewYd;
for(k=0; k<4; k++)
{
Z_RDesPoint[(k+1)*2] = Z_RHFR[k*2];
Z_RDesPoint[(k+1)*2+1] = Z_RHFR[k*2+1] - LNewYd;
}

Y_Lnpt = 5;
Y_LDesPoint[0] = 0.0;
Y_LDesPoint[1] = Y_RHFL[1] - RNewYd;
for(k=0; k<4; k++)
{
Y_LDesPoint[(k+1)*2] = Y_RHFL[k*2];
Y_LDesPoint[(k+1)*2+1] = Y_RHFL[k*2+1] - RNewYd;
}

ZDesBG = Z_RHFR[7],YDesBG=Y_RHFL[7];
FindIljjk(cml,road[i].pm,road[i].hdmbz.NZPWD,road[i].hdmbz.ZPWD,ZWW[0],ZWW[1]);//右侧占地加宽

//清表土厚度
Z_Rhthd = FindWichHTHD(projml,road[iroad].pm,road[iroad].hdmbz.NYHTHD,road[iroad].hdmbz.YHTHD);

Z_RZJ =   FindWichDQ(projml,road[iroad].pm,road[iroad].hdmbz.NYDQ,road[iroad].hdmbz.YDQ);    //路面厚


Y_LLTBPJS=FindWichBP(cml,road[i].pm,road[i].hdmbz.NZLQBP,
road[i].hdmbz.ZLQBP,Y_LTM,Y_LTH,Y_LTPTW,Y_LTPTI);//左路堤边坡

Cal_D(cml,road[i].pm,road[i].hdmbz.NZLQSG,road[i].hdmbz.ZLQSG,
&YD,&YGK,&YGS,&YGP1,&YGP2,&YCG_JQHD);//路堑边沟宽度

//清表土厚度
Y_Lhthd = FindWichHTHD(cml,road[i].pm,road[i].hdmbz.NZHTHD,road[i].hdmbz.ZHTHD);

Y_LZJ = FindWichDQ(cml,road[i].pm,road[i].hdmbz.NZDQ,road[i].hdmbz.ZDQ);

//路面厚
FindWichHD(cml,road[i].pm,road[i].hdmbz.NZLMHD,road[i].hdmbz.ZLMHD,ZX_lmhd);

double zw,yw,deltax,deltah;
deltah = ZDesBG - YDesBG;

ZX_DesPoint[0] = 0.0;
ZX_DesPoint[1] = Y_RHFL[1] - RNewYd;
for(k=0; k<4; k++)
{
ZX_DesPoint[(k+1)*2] = Y_RHFL[k*2];
ZX_DesPoint[(k+1)*2+1] = Y_RHFL[k*2+1] - RNewYd;
}
ZX_npt = Y_Lnpt;

double ljpt1[2],ljpt2[2];
xlpoint PZ;
PZ.lc = cml;

road[i].pm->xlpoint_pz(&PZ);

ljpt1[0] = PZ.x + Y_RHFL[6]*cos(PZ.a-0.5*pi);
ljpt1[1] = PZ.y + Y_RHFL[6]*sin(PZ.a-0.5*pi);
PZ.lc = projml;

road[iroad].pm->xlpoint_pz(&PZ);

ljpt2[0] = PZ.x + Z_RHFR[6]*cos(PZ.a+0.5*pi);
ljpt2[1] = PZ.y + Z_RHFR[6]*sin(PZ.a+0.5*pi);

ljdis = sqrt((ljpt1[0]-ljpt2[0])*(ljpt1[0]-ljpt2[0])+(ljpt1[1]-ljpt2[1])*(ljpt1[1]-ljpt2[1]));
//	if(deltah<0.0)//右线比左线高
//	{
ZX_TWH = Y_RHFL[1] - RNewYd;
ZX_TW=0.0;
ZX_DesPoint[ZX_npt*2] = Y_RHFL[3*2] + ljdis;
ZX_DesPoint[ZX_npt*2+1] = Z_RHFR[3*2+1] - RNewYd;
ZX_npt++;

if(deltah<0.0)//主线为路堤
ZX_ZDK = ZX_DesPoint[ZX_npt*2] + ZWW[0];
else
ZX_ZDK = ZX_DesPoint[ZX_npt*2] + ZWW[1];

//	}
//	else////左线比右线高,设计路堑
//		{
//			ZX_TW=1.0;
//			ZX_DesPoint[ZX_npt*2] = Y_RHFL[3*2] + YGS*YGP1;
//			ZX_DesPoint[ZX_npt*2+1] = Y_RHFL[3*2+1] - YGS;
//			ZX_npt++;
//			ZX_DesPoint[ZX_npt*2] = ZX_DesPoint[(ZX_npt-1)*2] + YGK;
//			ZX_DesPoint[ZX_npt*2+1] = ZX_DesPoint[(ZX_npt-1)*2+1];
//			ZX_npt++;
//			ZX_DesPoint[ZX_npt*2] = ZX_DesPoint[(ZX_npt-1)*2] + YGS*YGP2;
//			ZX_DesPoint[ZX_npt*2+1] = ZX_DesPoint[(ZX_npt-1)*2+1]+YGS;
//			ZX_npt++;
//			ZX_DesPoint[ZX_npt*2] = ZX_DesPoint[(ZX_npt-1)*2] + Y_LTPTW[0];
//			ZX_DesPoint[ZX_npt*2+1] = ZX_DesPoint[(ZX_npt-1)*2+1];
//			ZX_npt++;
//			ZX_DesPoint[ZX_npt*2] = ZX_DesPoint[(ZX_npt-1)*2] + ljdis;
//			ZX_DesPoint[ZX_npt*2+1] = Z_RHFR[3*2+1] - RNewYd;
//			ZX_npt++;
//		}
//计算挖方面积

CalDesAllArea(ZX_npt,ZX_DesPoint,Y_NewNumL,Y_NewLearpt,ZX_lmhd,Y_Lhthd,yglthd,0.0,Y_LZJ,-1,
Y_LStartDesPt,Y_LTM,Y_LTH,Y_LTPTW,Y_LTPTI,Y_LLTBPJS,
MidFillArea,MidCutArea,MidQBTArea,MidFillGLTArea,MidHJarea);
}
else//右线为绕行,左线为主线
{
for(k=0; k<8; k++)
{
Z_RHFR[k] = road[i].hdmdes[j].RHFR[k];
Y_RHFL[k] = road[iroad].hdmdes[jcross].RHFL[k];
}
LNewYd=road[i].hdmdmx[j].EarH;
Z_NewNumR=road[i].hdmdmx[j].YEarPtNum;
for(k=0; k<Z_NewNumR; k++)
{
Z_NewRearpt[k*2] = road[i].hdmdmx[j].YEarPtAry[k].x;
Z_NewRearpt[k*2+1] = road[i].hdmdmx[j].YEarPtAry[k].y;
}

RNewYd=road[iroad].hdmdmx[jcross].EarH;
Y_NewNumL=road[iroad].hdmdmx[jcross].ZEarPtNum;
for(int k=0; k<Y_NewNumL; k++)
{
Y_NewLearpt[k*2] = road[iroad].hdmdmx[jcross].ZEarPtAry[k].x;
Y_NewLearpt[k*2+1] = road[iroad].hdmdmx[jcross].ZEarPtAry[k].y;
}

Z_RStartDesPt[0]=Z_RHFR[3*2];//以左线为Y轴
Z_RStartDesPt[1]=Z_RHFR[3*2+1]-LNewYd;//地面标高为原点

Z_Rnpt = 5;
Z_RDesPoint[0] = 0.0;
Z_RDesPoint[1] = Z_RHFR[1] - LNewYd;
for(k=0; k<4; k++)
{
Z_RDesPoint[(k+1)*2] = Z_RHFR[k*2];
Z_RDesPoint[(k+1)*2+1] = Z_RHFR[k*2+1] - LNewYd;
}

Y_Lnpt = 5;
Y_LDesPoint[0] = 0.0;
Y_LDesPoint[1] = Y_RHFL[1] - RNewYd;
for(k=0; k<4; k++)
{
Y_LDesPoint[(k+1)*2] = Y_RHFL[k*2];
Y_LDesPoint[(k+1)*2+1] = Y_RHFL[k*2+1] - RNewYd;
}

//取出左线右侧参数
Z_RLTBPJS=FindWichBP(cml,road[i].pm,road[i].hdmbz.NYLQBP,
road[i].hdmbz.YLQBP,Z_RTM,Z_RTH,Z_RTPTW,Z_RTPTI);//左路堑边坡
Cal_D(cml,road[i].pm,road[i].hdmbz.NZLQSG,road[i].hdmbz.ZLQSG,
&ZD,&ZGK,&ZGS,&ZGP1,&ZGP2,&ZCG_JQHD);//路堑边沟宽度
FindIljjk(cml,road[i].pm,road[i].hdmbz.NYPWD,road[i].hdmbz.YPWD,YWW[0],YWW[1]);//右侧占地加宽
//清表土厚度
Z_Rhthd = FindWichHTHD(cml,road[i].pm,road[i].hdmbz.NYHTHD,road[i].hdmbz.YHTHD);
Z_RZJ =   FindWichDQ(cml,road[i].pm,road[i].hdmbz.NYDQ,road[i].hdmbz.YDQ);
//路面厚
FindWichHD(cml,road[i].pm,road[i].hdmbz.NYLMHD,road[i].hdmbz.YLMHD,ZX_lmhd);

Y_LLTBPJS=FindWichBP(projml,road[iroad].pm,road[iroad].hdmbz.NZLQBP,
road[iroad].hdmbz.ZLQBP,Y_LTM,Y_LTH,Y_LTPTW,Y_LTPTI);//左路堤边坡
Cal_D(projml,road[iroad].pm,road[iroad].hdmbz.NZLQSG,road[iroad].hdmbz.ZLQSG,
&YD,&YGK,&YGS,&YGP1,&YGP2,&YCG_JQHD);//路堑边沟宽度
//清表土厚度
Y_Lhthd = FindWichHTHD(projml,road[iroad].pm,road[iroad].hdmbz.NZHTHD,road[iroad].hdmbz.ZHTHD);
Y_LZJ = FindWichDQ(projml,road[iroad].pm,road[iroad].hdmbz.NZDQ,road[iroad].hdmbz.ZDQ);
//路面厚

double zw,yw,deltax,deltah;
deltah = ZDesBG - YDesBG;

ZX_DesPoint[0] = 0.0;
ZX_DesPoint[1] = Z_RHFR[1] - LNewYd;
for(k=0; k<4; k++)
{
ZX_DesPoint[(k+1)*2] = Z_RHFR[k*2];
ZX_DesPoint[(k+1)*2+1] = Z_RHFR[k*2+1] - LNewYd;
}
ZX_npt = 5;

double ljpt1[2],ljpt2[2];
xlpoint PZ,PZ1;
PZ.lc = cml;
road[i].pm->xlpoint_pz(&PZ);

ljpt1[0] = PZ.x + Z_RHFR[6]*cos(PZ.a+0.5*pi);
ljpt1[1] = PZ.y + Z_RHFR[6]*sin(PZ.a+0.5*pi);

PZ1.lc = projml;
road[iroad].pm->xlpoint_pz(&PZ1);
ljpt2[0] = PZ1.x + Y_RHFL[6]*cos(PZ.a-0.5*pi);
ljpt2[1] = PZ1.y + Y_RHFL[6]*sin(PZ.a-0.5*pi);

ljdis = sqrt((ljpt1[0]-ljpt2[0])*(ljpt1[0]-ljpt2[0])+(ljpt1[1]-ljpt2[1])*(ljpt1[1]-ljpt2[1]));

//	if(deltah>0.0)//右线比左线低
//	{
ZX_TWH = Z_RHFR[1] - RNewYd;
ZX_TW=0.0;
ZX_DesPoint[ZX_npt*2] = Z_RHFR[3*2] + ljdis;

ZX_DesPoint[ZX_npt*2+1] = Y_RHFL[3*2+1] - LNewYd;
ZX_npt++;
if(deltah>0.0)//主线为路堤
ZX_ZDK = ZX_DesPoint[ZX_npt*2] + YWW[0];
else
ZX_ZDK = ZX_DesPoint[ZX_npt*2] + YWW[1];

//	}
//		else////左线比右线低,设计路堑
//		{
//			ZX_TW=1.0;
//			ZX_DesPoint[ZX_npt*2] = Z_RHFR[3*2] + ZGS*ZGP1;
//			ZX_DesPoint[ZX_npt*2+1] = Z_RHFR[3*2+1] - ZGS;
//			ZX_npt++;
//			ZX_DesPoint[ZX_npt*2] = ZX_DesPoint[(ZX_npt-1)*2] + ZGK;
//			ZX_DesPoint[ZX_npt*2+1] = ZX_DesPoint[(ZX_npt-1)*2+1];
//			ZX_npt++;
//			ZX_DesPoint[ZX_npt*2] = ZX_DesPoint[(ZX_npt-1)*2] + ZGS*ZGP2;
//			ZX_DesPoint[ZX_npt*2+1] = ZX_DesPoint[(ZX_npt-1)*2+1]+ZGS;
//			ZX_npt++;
//			ZX_DesPoint[ZX_npt*2] = ZX_DesPoint[(ZX_npt-1)*2] + Z_RTPTW[0];
//			ZX_DesPoint[ZX_npt*2+1] = ZX_DesPoint[(ZX_npt-1)*2+1];
//			ZX_npt++;
//			ZX_DesPoint[ZX_npt*2] = ZX_DesPoint[(ZX_npt-1)*2] + ljdis;
//			ZX_DesPoint[ZX_npt*2+1] = Y_RHFL[3*2+1] - LNewYd;
//			ZX_npt++;
//		}
//计算挖方面积
CalDesAllArea(ZX_npt,ZX_DesPoint,Z_NewNumR,Z_NewRearpt,ZX_lmhd,Z_Rhthd,zglthd,0.0,Z_RZJ,-1,
Z_RStartDesPt,Z_RTM,Z_RTH,Z_RTPTW,Z_RTPTI,Z_RLTBPJS,
MidFillArea,MidCutArea,MidQBTArea,MidFillGLTArea,MidHJarea);
}
}*/

//bool IfPrint=false;
//////////////////////////////////////////////////////////////////////////
//计算road[i].hdmdes[jcross]横断面的关联断面
//LorR 关联线路相对于当前线路的左右侧
//desptsum，DesPt[] road[i].hdmdes[jcross]横断面关联侧的设计点（未考虑关联）
//iroad		分离线编号
//glcml		关联断面分离线上的里程
//ZJ1，ZJ2	当前断面和关联断面的支距。为正值时表示正常支距；ZJ2=-10000表示路肩直接拉直；此外ZJ1，ZJ2为负值表示有线间沟，或路堑边坡推平，其绝对值表示真实的支距；
//设置初值
//判断关联断面的路肩距离和高差是否满足拉直的要求
//获取线间沟，路堑边坡拉直参数
//确定搜索关联断面的范围
//三维边坡求交得到得到关联断面
//如果关联断面线间两侧的填挖性质不同判断是否是分离路基，如果不是则赋值ZJ2=-10000.0
//////////////////////////////////////////////////////////////////////////
void HdmDes::CalLinkHdmSENo(int i, int jcross, int LorR, int desptsum, double DesPt[], int iroad, double &glcml, double &ZJ1, double &ZJ2)
{
	double SptZX[2], EptZX[2];
	xlpoint PZ, FLX_PZ;
	int ZIfBTinf, YIfBTinf;
	double NewYd, NewLearpt[400], NewRearpt[400];//以线路中线为坐标系的地面点数组
	int newNumL, newNumR;
	double NewYdOffset1, NewYdOffset2, NewLearptOffset[400], NewRearptOffset[400];//以路基中线为坐标系的地面点数组
	int newNumLOffset, newNumROffset;
	int Rnpt1, Rnpt2;
	double RDesPoint1[500], RDesPoint2[500], Yt1, Yt2;
	int Lnpt1, Lnpt2;
	double LDesPoint1[500], LDesPoint2[500], Zt1, Zt2;
	int SnoOnFld, EnoOnFld, k;
	double ZX_TW;
	double ZPJPT[2], YPJPT[2];
	//	double dh,zx_desh,flx_desh;
	//	double RHF[10];
	ZPJPT[0] = YPJPT[0] = ZPJPT[1] = YPJPT[1] = -1;
	ZIfBTinf = 0;
	YIfBTinf = 0;

	double cml;

	glcml = -1;//无关]

	ZJ1 = ZJ2 = 1000;
	cml = road[i].hdmdes[jcross].cml;


	if (fabs(road[i].hdmdes[jcross].xjj) > 80.0)
		return;

	PZ.lc = cml;
	road[i].pm->xlpoint_pz(&PZ);
	PZ.x = PZ.x + road[i].hdmdes[jcross].OffsetByXLZX * cos(PZ.a + 0.5*pi);
	PZ.y = PZ.y + road[i].hdmdes[jcross].OffsetByXLZX * sin(PZ.a + 0.5*pi);
	//	double xjj;
	//	xjj = fabs(road[i].hdmdes[jcross].xjj);
	//	double zx_OffsetByXLZX,flx_OffsetByXLZX;//当前线路，分离线路基中线相对于线路中线的偏移量
	//	zx_OffsetByXLZX = flx_OffsetByXLZX = 0.0;
	//	double LJJ = xjj;//路基中线间距（含义同线间距类似）

	//	double zxwid,yxwid,yxcml;
	//	double half_fgdk,lydk,cxdk,yljk,tljk,tljhp;
	int bkmode, sjbgmode;

	//路基中线和线路中线不一致：计算路肩点的水平距离和高差需通过新的计算路面点函数来确定
	// 	if(LorR<0)//iroad右侧带帽子
	// 	{
	// 		zxwid = road[i].hdmdes[jcross].RHFL[8];
	// 		yxcml = road[iroad].pm->PROJ_ML(PZ.x,PZ.y);
	//     
	// 		CalLMK_JK(yxcml,road[iroad].NYLMK,road[iroad].YLMK,
	//             road[iroad].YcgNm,road[iroad].Ycg,
	// 			road[iroad].YjkNm,road[iroad].Yjk,
	// 			half_fgdk,lydk,cxdk,yljk,tljk,tljhp,bkmode,sjbgmode);
	// 		zx_desh = CalDesH(cml,road[i].ZZM,road[i].AllZM);
	// 		flx_desh = CalDesH(yxcml,road[iroad].YZM,road[iroad].AllZM);
	// 		dh = fabs(zx_desh-flx_desh);//两线高差
	// //		yxwid = half_fgdk+lydk+cxdk+yljk+tljk;
	// 	}
	// 	else
	// 	{
	// 		zxwid = road[i].hdmdes[jcross].RHFR[8];
	// 		yxcml = road[iroad].pm->PROJ_ML(PZ.x,PZ.y);
	// 			
	// 		CalLMK_JK(yxcml,road[iroad].NZLMK,road[iroad].ZLMK,
	// 			road[iroad].ZcgNm,road[iroad].Zcg,
	// 			road[iroad].ZjkNm,road[iroad].Zjk,
	// 			half_fgdk,lydk,cxdk,yljk,tljk,tljhp,bkmode,sjbgmode);
	// 
	// 		zx_desh = CalDesH(cml,road[i].YZM,road[i].AllZM);
	// 		flx_desh = CalDesH(yxcml,road[iroad].ZZM,road[iroad].AllZM);
	// 		dh = fabs(zx_desh-flx_desh);//两线高差
	// //		yxwid = half_fgdk+lydk+cxdk+yljk+tljk;
	// 	}	
	//    CalLMKbyFile(yxcml,LorR,road[iroad].pm,road[iroad].pBXArr,road[iroad].BxNum,half_fgdk,lydk,cxdk,yljk,tljk);	
	//    yxwid = half_fgdk+lydk+cxdk+yljk+tljk;

	//////////////////////////////////////////////////////////////////////////
	double dXGLDMLZ = 100.0;
	double dHGLDMLZ = 100.0;
	double GouWideXJG = 0.0;
	double GouHighXJG = 0.0;
	double NBPXJG = 0.0;
	double WBPXJG = 0.0;
	double JQHDXJG = 0.0;
	double GDRXJG = 0.0;
	double TopWideXJG = 0.0;
	double dXGLDMLQBPTP = 100.0;
	double XJDist = 0.0;//线间沟或路堑边坡边坡推平距离
	double dXLJPt = 1e6;//路肩点之间的水平距离
	double dHLJPt = 1e6;//路肩点之间的高差
	int ZX_BpStartIndex = 4;//当前主线边坡起点在设计点数组中的下标号(默认为路堤)
	int FLX_BpStartIndex1 = 4;//当前分离线边坡起点在设计点数组中的下标号
	int FLX_BpStartIndex2 = 4;//当前分离线边坡起点在设计点数组中的下标号
	double ZX_LenBPStartToLJ = 0.0;//当前主线边坡起点到路肩点的距离
	double FLX_LenBPStartToLJ1 = 0.0;//分离线边坡起点到路肩点的距离
	double FLX_LenBPStartToLJ2 = 0.0;//分离线边坡起点到路肩点的距离

	/////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////
	//计算当前断面与其投影断面的路肩点的水平距离和高差
	double EarHonLJCen = road[i].hdmdes[jcross].RHFL[1] - DesPt[1];//当前线路路基中线上的地面标高
	AcGePoint3d ZX_LJPt, FLX_LJPT;//主线和分离段的路肩点
	double FLX_RHFL[10], FLX_RHFR[10];//分离线的左右路面点
	ZX_LJPt.x = PZ.x + fabs(DesPt[4 * 2]) * cos(PZ.a + LorR * 0.5*pi);
	ZX_LJPt.y = PZ.y + fabs(DesPt[4 * 2]) * sin(PZ.a + LorR * 0.5*pi);
	ZX_LJPt.z = DesPt[4 * 2 + 1] + EarHonLJCen;

	FLX_PZ.lc = road[iroad].pm->PROJ_ML(PZ.x, PZ.y);
	double FLX_Cml = FLX_PZ.lc;
	road[iroad].pm->xlpoint_pz(&FLX_PZ);
	CalHDmLm(iroad, FLX_Cml, FLX_RHFL, FLX_RHFR);
	double OffsetByXLZX = 0.0;

	if (LorR > 0)//分离线在主线右侧
	{
		CalOffsetByXLZX(FLX_PZ.lc, road[iroad].NZLMK, road[iroad].ZLMK, OffsetByXLZX);
		FLX_PZ.x = FLX_PZ.x + OffsetByXLZX * cos(FLX_PZ.a + 0.5*pi);
		FLX_PZ.y = FLX_PZ.y + OffsetByXLZX * sin(FLX_PZ.a + 0.5*pi);
		FLX_LJPT.x = FLX_PZ.x + FLX_RHFL[8] * cos(FLX_PZ.a - 0.5*pi);
		FLX_LJPT.y = FLX_PZ.y + FLX_RHFL[8] * sin(FLX_PZ.a - 0.5*pi);
		FLX_LJPT.z = FLX_RHFL[9];
	}
	else
	{
		CalOffsetByXLZX(FLX_PZ.lc, road[iroad].NYLMK, road[iroad].YLMK, OffsetByXLZX);
		FLX_PZ.x = FLX_PZ.x + OffsetByXLZX * cos(FLX_PZ.a + 0.5*pi);
		FLX_PZ.y = FLX_PZ.y + OffsetByXLZX * sin(FLX_PZ.a + 0.5*pi);
		FLX_LJPT.x = FLX_PZ.x + FLX_RHFR[8] * cos(FLX_PZ.a + 0.5*pi);
		FLX_LJPT.y = FLX_PZ.y + FLX_RHFR[8] * sin(FLX_PZ.a + 0.5*pi);
		FLX_LJPT.z = FLX_RHFR[9];
	}

	dXLJPt = sqrt((ZX_LJPt.x - FLX_LJPT.x)*(ZX_LJPt.x - FLX_LJPT.x) + (ZX_LJPt.y - FLX_LJPT.y)*(ZX_LJPt.y - FLX_LJPT.y));
	dHLJPt = fabs(ZX_LJPt.z - FLX_LJPT.z);
	if (i != 0)
	{
		FindGLDMLZ(cml, road[i].pm, road[i].hdmbz.NGLDMLZ, road[i].hdmbz.GLDMLZ, dXGLDMLZ, dHGLDMLZ);
	}
	else
	{
		FindGLDMLZ(FLX_Cml, road[iroad].pm, road[iroad].hdmbz.NGLDMLZ, road[iroad].hdmbz.GLDMLZ, dXGLDMLZ, dHGLDMLZ);
	}
	if (dXLJPt <= dXGLDMLZ && dHLJPt <= dHGLDMLZ)//关联,边坡拉直
	{
		glcml = FLX_Cml;
		ZJ2 = -10000.0;
		return;
	}


	//////////////////////////////////////////////////////////////////////////

	// 	if(fabs(zxwid+yxwid-fabs(xjj))<=m_ljdist && dh <= m_ljdh)//|| xjj<1.0)//关联,边坡拉直
	// 	{
	//        glcml = yxcml;
	//      //  ZJ1 = zxwid;
	// 	 //  ZJ2 = yxwid;
	// 	   ZJ2 = -100;
	// 		return ;
	// 	}

	//通过当前线路和线路中线点在关联线路上的投影确定搜索关联断面号的范围
	double pjdx = fabs(DesPt[(desptsum - 1) * 2]);

	SptZX[0] = PZ.x, SptZX[1] = PZ.y;
	EptZX[0] = PZ.x + fabs(pjdx)*cos(PZ.a + LorR * 0.5*pi);
	EptZX[1] = PZ.y + fabs(pjdx)*sin(PZ.a + LorR * 0.5*pi);
	//	EptZX[0] =PZ.x + (LorR * pjdx + road[i].hdmdes[jcross].OffsetByXLZX) * cos(PZ.a+0.5*pi);//考虑路基中线与线路中线不重合(修改)
	//	EptZX[1] =PZ.y + (LorR * pjdx + road[i].hdmdes[jcross].OffsetByXLZX) * sin(PZ.a+0.5*pi);

	double sml, eml, lcmin, lcmax;
	sml = road[iroad].pm->PROJ_ML(SptZX[0], SptZX[1]);
	eml = road[iroad].pm->PROJ_ML(EptZX[0], EptZX[1]);
	lcmin = sml < eml ? sml : eml;
	lcmax = sml > eml ? sml : eml;

	lcmin -= 1.0;
	lcmax += 1.0;
	int j = 0;
	while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < lcmin - 0.001)
		j++;
	SnoOnFld = j - 1 < 0 ? 0 : j - 1;
	j = 0;
	while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < lcmax + 0.001)
		j++;
	EnoOnFld = j + 1 > road[iroad].NCRS - 1 ? road[iroad].NCRS - 1 : j + 1;

	if (LorR < 0)//iroad右侧带帽子
	{
		ZX_TW = road[i].hdmdes[jcross].Zt;
		if (ZX_TW > 0.9)//路堑或者有路肩沟
			ZX_BpStartIndex = 8;
		else//路堤
			ZX_BpStartIndex = 4;

		for (j = SnoOnFld; j < EnoOnFld; j++)
		{
			if (road[iroad].hdmdes[j].YDMXZ != 3 && road[iroad].hdmdes[j].YDMXZ != 4)
			{
				//////////////////////////////////////////////////////////////////////////
				//考虑路基中线与线路中线不重合，地面点需要平移(修改)
				NewYd = road[iroad].hdmdmx[j].EarH;
				newNumR = road[iroad].hdmdmx[j].YEarPtNum;
				for (int k = 0; k < newNumR; k++)
				{
					NewRearpt[k * 2] = road[iroad].hdmdmx[j].YEarPtAry[k].x;
					NewRearpt[k * 2 + 1] = road[iroad].hdmdmx[j].YEarPtAry[k].y;
				}
				newNumL = road[iroad].hdmdmx[j].ZEarPtNum;
				for (k = 0; k < newNumL; k++)
				{
					NewLearpt[k * 2] = road[iroad].hdmdmx[j].ZEarPtAry[k].x;
					NewLearpt[k * 2 + 1] = road[iroad].hdmdmx[j].ZEarPtAry[k].y;
				}
				CalNewZB(road[iroad].hdmdes[j].OffsetByXLZX, NewYd, NewLearpt, newNumL, NewRearpt, newNumR,
					NewYdOffset1, NewLearptOffset, newNumLOffset, NewRearptOffset, newNumROffset);

				double tmp[20], gou[36], jsg[36];
				int itmp[10];
				CrosNew(iroad, 1, j, NewYdOffset1, newNumROffset, NewRearptOffset, road[iroad].hdmdes[j].RHFR, road[iroad].hdmdes[j].ylmhd, 1000, YPJPT,
					road[iroad].hdmdes[j].Rdeltah, Yt1, road[iroad].hdmdes[j].YHc, Rnpt1, RDesPoint1,
					tmp[0], tmp[1], tmp[2], tmp[3],
					tmp[4],
					itmp[0], tmp[5], itmp[1], itmp[2], gou, tmp[6], tmp[7], tmp[8], tmp[9],
					itmp[3], jsg,
					tmp[10], tmp[11], tmp[12], tmp[13]);
				if (Yt1 > 0.9)
					FLX_BpStartIndex1 = 8;
				else
					FLX_BpStartIndex1 = 4;

				if (i != 0)
				{
					FindGLDMLZ(road[i].hdmdes[jcross].cml, road[i].pm, road[i].hdmbz.NGLDMLZ, road[i].hdmbz.GLDMLZ, dXGLDMLZ, dHGLDMLZ);
					FindGLDMLQBPTP(road[i].hdmdes[jcross].cml, road[i].pm, road[i].hdmbz.NGLDMLQBPTP, road[i].hdmbz.GLDMLQBPTP, dXGLDMLQBPTP);
					FindGLDMXJG(road[i].hdmdes[jcross].cml, road[i].pm, road[i].hdmbz.NGLDMXJG, road[i].hdmbz.GLDMXJG,
						GouWideXJG, GouHighXJG, NBPXJG, WBPXJG, JQHDXJG, GDRXJG);
					TopWideXJG = GouWideXJG + GouHighXJG * (NBPXJG + WBPXJG);
				}
				else
				{
					FindGLDMLZ(road[iroad].hdmdes[j].cml, road[iroad].pm, road[iroad].hdmbz.NGLDMLZ, road[iroad].hdmbz.GLDMLZ, dXGLDMLZ, dHGLDMLZ);
					FindGLDMLQBPTP(road[iroad].hdmdes[j].cml, road[iroad].pm, road[iroad].hdmbz.NGLDMLQBPTP, road[iroad].hdmbz.GLDMLQBPTP, dXGLDMLQBPTP);
					FindGLDMXJG(road[iroad].hdmdes[j].cml, road[iroad].pm, road[iroad].hdmbz.NGLDMXJG, road[iroad].hdmbz.GLDMXJG,
						GouWideXJG, GouHighXJG, NBPXJG, WBPXJG, JQHDXJG, GDRXJG);
					TopWideXJG = GouWideXJG + GouHighXJG * (NBPXJG + WBPXJG);
				}
			}
			else
				continue;

			if (road[iroad].hdmdes[j + 1].YDMXZ != 3 && road[iroad].hdmdes[j + 1].YDMXZ != 4)
			{
				NewYd = road[iroad].hdmdmx[j + 1].EarH;
				newNumR = road[iroad].hdmdmx[j + 1].YEarPtNum;
				for (int k = 0; k < newNumR; k++)
				{
					NewRearpt[k * 2] = road[iroad].hdmdmx[j + 1].YEarPtAry[k].x;
					NewRearpt[k * 2 + 1] = road[iroad].hdmdmx[j + 1].YEarPtAry[k].y;
				}
				newNumL = road[iroad].hdmdmx[j + 1].ZEarPtNum;
				for (k = 0; k < newNumL; k++)
				{
					NewLearpt[k * 2] = road[iroad].hdmdmx[j + 1].ZEarPtAry[k].x;
					NewLearpt[k * 2 + 1] = road[iroad].hdmdmx[j + 1].ZEarPtAry[k].y;
				}
				CalNewZB(road[iroad].hdmdes[j + 1].OffsetByXLZX, NewYd, NewLearpt, newNumL, NewRearpt, newNumR,
					NewYdOffset2, NewLearptOffset, newNumLOffset, NewRearptOffset, newNumROffset);
				double tmp[20], gou[36], jsg[36];
				int itmp[10];
				CrosNew(iroad, 1, j + 1, NewYdOffset2, newNumROffset, NewRearptOffset, road[iroad].hdmdes[j + 1].RHFR, road[iroad].hdmdes[j + 1].ylmhd, 1000, YPJPT,
					road[iroad].hdmdes[j + 1].Rdeltah, Yt2, road[iroad].hdmdes[j + 1].YHc, Rnpt2, RDesPoint2,
					tmp[0], tmp[1], tmp[2], tmp[3],
					tmp[4],
					itmp[0], tmp[5], itmp[1], itmp[2], gou, tmp[6], tmp[7], tmp[8], tmp[9],
					itmp[3], jsg,
					tmp[10], tmp[11], tmp[12], tmp[13]);
				if (Yt2 > 0.9)
					FLX_BpStartIndex2 = 8;
				else
					FLX_BpStartIndex2 = 4;
			}
			else
				continue;

			if ((Yt1 < 0.1&&Yt2 < 0.1) || (Yt1 > 0.9&&Yt2 > 0.9))
			{
				if ((ZX_TW < 0.1&&Yt1 < 0.1) || (ZX_TW > 0.9&&Yt1 > 0.9))
				{
					//////////////////////////////////////////////////////////////////////////
					//计算三维边坡线
					if (ZX_TW < 0.1&&Yt1 < 0.1)//路堤，考虑线间沟
						XJDist = TopWideXJG;
					else//路堑，考虑推平
						XJDist = dXGLDMLQBPTP;
					AcGePoint3d Pt, ZX_LJPt, FLX_LJPt;
					AcGePoint3dArray PtArr;
					double EarHonLJCen = road[i].hdmdes[jcross].RHFL[1] - DesPt[1];//当前线路路基中线上的地面标高
					for (k = 0; k < desptsum; k++)
					{
						Pt.x = PZ.x + fabs(DesPt[k * 2] + XJDist) * cos(PZ.a + LorR * 0.5*pi);
						Pt.y = PZ.y + fabs(DesPt[k * 2] + XJDist) * sin(PZ.a + LorR * 0.5*pi);
						//					Pt.z = DesPt[k*2+1] + road[i].hdmdmx[jcross].EarH;
						// 					Pt.x = PZ.x + (LorR * (DesPt[k*2]+XJDist) + road[i].hdmdes[jcross].OffsetByXLZX) * cos(PZ.a + 0.5*pi);//考虑路基中线与线路中线不重合(修改)
						// 					Pt.y = PZ.y + (LorR * (DesPt[k*2]+XJDist) + road[i].hdmdes[jcross].OffsetByXLZX) * sin(PZ.a + 0.5*pi);
						Pt.z = DesPt[k * 2 + 1] + EarHonLJCen;
						PtArr.append(Pt);
					}
					//				ZX_LJPt.x = PZ.x + (LorR * (DesPt[4*2]) + road[i].hdmdes[jcross].OffsetByXLZX) * cos(PZ.a + 0.5*pi);//考虑路基中线与线路中线不重合(修改)
					//				ZX_LJPt.y = PZ.y + (LorR * (DesPt[4*2]) + road[i].hdmdes[jcross].OffsetByXLZX) * sin(PZ.a + 0.5*pi);
					ZX_LJPt.x = PZ.x + fabs(DesPt[4 * 2]) * cos(PZ.a + LorR * 0.5*pi);
					ZX_LJPt.y = PZ.y + fabs(DesPt[4 * 2]) * sin(PZ.a + LorR * 0.5*pi);
					ZX_LJPt.z = DesPt[4 * 2 + 1] + EarHonLJCen;
					ZX_LenBPStartToLJ = DesPt[ZX_BpStartIndex * 2] - DesPt[4 * 2];
					AcDb3dPolyline *zxbp;
					//形成路面
					//					if(fabs(road[i].hdmdes[jcross].dml-208130.35)<0.1)
					//									{
					//										zxbp = new AcDb3dPolyline(AcDb::k3dSimplePoly,PtArr);		
					//										AddEntityToDbs(zxbp);
					//									}
					xlpoint PZ1;
					AcGePoint3dArray PtArr1;
					PZ1.lc = road[iroad].hdmdes[j].cml;
					road[iroad].pm->xlpoint_pz(&PZ1);
					PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
					PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
					for (k = 0; k < Rnpt1; k++)
					{
						Pt.x = PZ1.x + fabs(RDesPoint1[k * 2]) * cos(PZ1.a - LorR * 0.5*pi);
						Pt.y = PZ1.y + fabs(RDesPoint1[k * 2]) * sin(PZ1.a - LorR * 0.5*pi);
						// 					Pt.z = RDesPoint1[k*2+1] + road[iroad].hdmdmx[j].EarH;
						//					Pt.x = PZ1.x + (-1.0 * LorR * RDesPoint1[k*2] + road[iroad].hdmdes[j].OffsetByXLZX) * cos(PZ1.a + 0.5*pi);//考虑路基中线与线路中线不重合(修改)
						//					Pt.y = PZ1.y + (-1.0 * LorR * RDesPoint1[k*2] + road[iroad].hdmdes[j].OffsetByXLZX) * sin(PZ1.a + 0.5*pi);
						Pt.z = RDesPoint1[k * 2 + 1] + NewYdOffset1;
						PtArr1.append(Pt);
					}
					FLX_LJPt = PtArr1[4];
					FLX_LenBPStartToLJ1 = RDesPoint1[FLX_BpStartIndex1 * 2] - RDesPoint1[4 * 2];
					dXLJPt = sqrt((ZX_LJPt.x - FLX_LJPt.x)*(ZX_LJPt.x - FLX_LJPt.x) + (ZX_LJPt.y - FLX_LJPt.y)*(ZX_LJPt.y - FLX_LJPt.y));
					dHLJPt = fabs(ZX_LJPt.z - FLX_LJPt.z);
					if (dXLJPt <= dXGLDMLZ + ZX_LenBPStartToLJ + FLX_LenBPStartToLJ1 && dHLJPt <= dHGLDMLZ)//关联,边坡拉直
					{
						glcml = road[iroad].hdmdes[j].cml;
						ZJ2 = -10000.0;
						return;
					}

					if (dXLJPt <= dXGLDMLQBPTP && ZX_TW > 0.9 && Yt1 > 0.9)//设置的推平距离过大，路肩直接拉直
					{
						glcml = road[iroad].hdmdes[j].cml;
						ZJ2 = -10000.0;
						return;
					}
					if (dXLJPt < ZX_LenBPStartToLJ + FLX_LenBPStartToLJ1)//路肩点之间的距离无法容纳两个路堑沟
					{
						glcml = road[iroad].hdmdes[j].cml;
						ZJ2 = -10000.0;
						return;
					}
					AcGePoint3dArray PtArr2;
					PZ1.lc = road[iroad].hdmdes[j + 1].cml;
					road[iroad].pm->xlpoint_pz(&PZ1);
					PZ1.x = PZ1.x + road[iroad].hdmdes[j + 1].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
					PZ1.y = PZ1.y + road[iroad].hdmdes[j + 1].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
					for (k = 0; k < Rnpt2; k++)
					{
						Pt.x = PZ1.x + fabs(RDesPoint2[k * 2]) * cos(PZ1.a - LorR * 0.5*pi);
						Pt.y = PZ1.y + fabs(RDesPoint2[k * 2]) * sin(PZ1.a - LorR * 0.5*pi);
						//					Pt.z = RDesPoint2[k*2+1] + road[iroad].hdmdmx[j+1].EarH;
						// 					Pt.x = PZ1.x + (-1.0 * LorR * RDesPoint2[k*2] + road[iroad].hdmdes[j+1].OffsetByXLZX) * cos(PZ1.a + 0.5*pi);
						// 					Pt.y = PZ1.y + (-1.0 * LorR * RDesPoint2[k*2] + road[iroad].hdmdes[j+1].OffsetByXLZX) * sin(PZ1.a + 0.5*pi);
						Pt.z = RDesPoint2[k * 2 + 1] + NewYdOffset2;
						PtArr2.append(Pt);
					}
					FLX_LJPt = PtArr2[4];
					FLX_LenBPStartToLJ2 = RDesPoint2[FLX_BpStartIndex2 * 2] - RDesPoint2[4 * 2];
					dXLJPt = sqrt((ZX_LJPt.x - FLX_LJPt.x)*(ZX_LJPt.x - FLX_LJPt.x) + (ZX_LJPt.y - FLX_LJPt.y)*(ZX_LJPt.y - FLX_LJPt.y));
					dHLJPt = fabs(ZX_LJPt.z - FLX_LJPt.z);
					if (dXLJPt <= dXGLDMLZ + ZX_LenBPStartToLJ + FLX_LenBPStartToLJ2 && dHLJPt <= dHGLDMLZ)//关联,边坡拉直
					{
						glcml = road[iroad].hdmdes[j + 1].cml;
						ZJ2 = -10000.0;
						return;
					}

					if (dXLJPt <= dXGLDMLQBPTP && ZX_TW > 0.9 && Yt2 > 0.9)//设置的推平距离过大，路肩直接拉直
					{
						glcml = road[iroad].hdmdes[j + 1].cml;
						ZJ2 = -10000.0;
						return;
					}
					if (dXLJPt < ZX_LenBPStartToLJ + FLX_LenBPStartToLJ2)//路肩点之间的距离无法容纳两个路堑沟
					{
						glcml = road[iroad].hdmdes[j + 1].cml;
						ZJ2 = -10000.0;
						return;
					}
					for (int n = ZX_BpStartIndex; n < desptsum - 1; n++)
					{
						AcGeLine3d zxline(PtArr[n], PtArr[n + 1]);
						int npt;
						npt = Rnpt1 < Rnpt2 ? Rnpt1 : Rnpt2;
						AcGePoint3d InterPt1;
						for (k = FLX_BpStartIndex1; k < npt - 1; k++)
						{
							AcDbFace face(PtArr1[k], PtArr1[k + 1], PtArr2[k + 1], PtArr2[k]);
							AcGePlane prj(PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]);
							/*
							if(fabs(road[i].hdmdes[jcross].dml-208130.35)<0.1)
							{
							AcDbFace *face1;
							face1 = new AcDbFace(PtArr1[k],PtArr1[k+1],PtArr2[k+1]);
							AddEntityToDbs(face1);
							bool res;
							res = prj.intersectWith(zxline,InterPt1);
							ads_point pt;
							pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
							acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
							//	IfPrint=true;
							ads_printf(L"zx=%lf %lf %lf 1:%lf %lf %lf 2:%lf %lf %lf\n",InterPt1.x,InterPt1.y,InterPt1.z,PtArr[n].x,PtArr[n].y,PtArr[n].z,PtArr[n+1].x,PtArr[n+1].y,PtArr[n+1].z);
							ads_printf(L"in=%d zx=%d tri=%d\n",res,CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr1[k+1],PtArr2[k+1]));
							//		IfPrint=false;
							}*/


							if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
								&& CheckPtInTri(InterPt1, PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]))//有交点
							{
								//投影到iroad线路上计算里程
								glcml = road[iroad].pm->PROJ_ML(InterPt1.x, InterPt1.y);
								//计算支距ZJ1,ZJ2,
								ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
								//						ZJ1 = fabs(LorR * sqrt((PZ.x-InterPt1.x)*(PZ.x-InterPt1.x)+(PZ.y-InterPt1.y)*(PZ.y-InterPt1.y)) - road[i].hdmdes[jcross].OffsetByXLZX);//考虑路基中线与线路中线不重合
								PZ1.lc = glcml;
								road[iroad].pm->xlpoint_pz(&PZ1);
								PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
								PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
								ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
								//						ZJ2 = fabs(-1.0 * LorR * sqrt((PZ1.x-InterPt1.x)*(PZ1.x-InterPt1.x)+(PZ1.y-InterPt1.y)*(PZ1.y-InterPt1.y)) - road[iroad].hdmdes[j].OffsetByXLZX);
								if (XJDist > 0.01)//有线间沟
								{

									ZJ1 = -(ZJ1 - XJDist);//将支距改成负值，以标记该处有线间沟，并减去线间沟的宽度
									ZJ2 = -ZJ2;
								}
								//						ads_printf(L"0: %lf\n",InterPt1.z);
								return;
							}

							AcGePlane prj1(PtArr1[k], PtArr2[k + 1], PtArr2[k]);
							/*
							AcDbFace *face3;
							if(fabs(road[i].hdmdes[jcross].dml-208130.35)<0.1)
							{
							face3 = new AcDbFace(PtArr1[k],PtArr2[k+1],PtArr2[k]);
							AddEntityToDbs(face3);
							bool res;
							res = prj1.intersectWith(zxline,InterPt1);
							ads_point pt;
							pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
							acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
							//	IfPrint=true;
							ads_printf(L"zx=%lf %lf %lf 1:%lf %lf %lf 2:%lf %lf %lf\n",InterPt1.x,InterPt1.y,InterPt1.z,PtArr[n].x,PtArr[n].y,PtArr[n].z,PtArr[n+1].x,PtArr[n+1].y,PtArr[n+1].z);
							ads_printf(L"re=%d zx=%d tri=%d\n",res,CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr2[k+1],PtArr2[k]));
							//	IfPrint=false;
							}	*/


							if (prj1.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
								&& CheckPtInTri(InterPt1, PtArr1[k], PtArr2[k + 1], PtArr2[k]))//有交点
							{
								//投影到iroad线路上计算里程
								glcml = road[iroad].pm->PROJ_ML(InterPt1.x, InterPt1.y);
								//计算支距ZJ1,ZJ2,
								ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
								//	                    ZJ1 = fabs(LorR * sqrt((PZ.x-InterPt1.x)*(PZ.x-InterPt1.x)+(PZ.y-InterPt1.y)*(PZ.y-InterPt1.y)) - road[i].hdmdes[jcross].OffsetByXLZX);//考虑路基中线与线路中线不重合
								PZ1.lc = glcml;
								road[iroad].pm->xlpoint_pz(&PZ1);
								PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
								PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
								ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
								//						ZJ2 = fabs(-1.0 * LorR * sqrt((PZ1.x-InterPt1.x)*(PZ1.x-InterPt1.x)+(PZ1.y-InterPt1.y)*(PZ1.y-InterPt1.y)) - road[iroad].hdmdes[j].OffsetByXLZX);
								if (XJDist > 0.01)//有线间沟
								{
									ZJ1 = -(ZJ1 - XJDist);//将支距改成负值，以标记该处有线间沟，并减去线间沟的宽度（线间沟看成绕线段部分的路肩沟）
									ZJ2 = -ZJ2;
								}
								//						ads_printf(L"0: %lf\n",InterPt1.z);
								return;
							}
						}

						if (Rnpt1 > npt)
						{
							for (k = npt - 1; k < Rnpt1 - 1; k++)
							{
								AcDbFace face(PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1], PtArr2[npt - 1]);
								AcGePlane prj(PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1]);
								if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
									&& CheckPtInTri(InterPt1, PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1]))//有交点
								{
									//投影到iroad线路上计算里程
									glcml = road[iroad].pm->PROJ_ML(InterPt1.x, InterPt1.y);
									//计算支距ZJ1,ZJ2,
									ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
									//							ZJ1 = fabs(LorR * sqrt((PZ.x-InterPt1.x)*(PZ.x-InterPt1.x)+(PZ.y-InterPt1.y)*(PZ.y-InterPt1.y)) - road[i].hdmdes[jcross].OffsetByXLZX);
									PZ1.lc = glcml;
									road[iroad].pm->xlpoint_pz(&PZ1);
									PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
									PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
									ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
									//							ZJ2 = fabs(-1.0 * LorR * sqrt((PZ1.x-InterPt1.x)*(PZ1.x-InterPt1.x)+(PZ1.y-InterPt1.y)*(PZ1.y-InterPt1.y)) - road[iroad].hdmdes[j].OffsetByXLZX);
									if (XJDist > 0.01)//有线间沟
									{
										ZJ1 = -(ZJ1 - XJDist);//将支距改成负值，以标记该处有线间沟，并减去线间沟的宽度（线间沟看成绕线段部分的路肩沟）
										ZJ2 = -ZJ2;
									}
									//							ads_printf(L"0: %lf\n",InterPt1.z);
									return;
								}
							}
						}

						if (Rnpt2 > npt)
						{
							for (k = npt - 1; k < Rnpt2 - 1; k++)
							{
								AcDbFace face(PtArr1[npt - 1], PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]);
								AcGePlane prj(PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]);
								if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
									&& CheckPtInTri(InterPt1, PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]))//有交点
								{
									//投影到iroad线路上计算里程
									glcml = road[iroad].pm->PROJ_ML(InterPt1.x, InterPt1.y);
									//计算支距ZJ1,ZJ2,
									ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
									//							ZJ1 = fabs(LorR * sqrt((PZ.x-InterPt1.x)*(PZ.x-InterPt1.x)+(PZ.y-InterPt1.y)*(PZ.y-InterPt1.y)) - road[i].hdmdes[jcross].OffsetByXLZX);
									PZ1.lc = glcml;
									road[iroad].pm->xlpoint_pz(&PZ1);
									PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
									PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
									ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
									//							ZJ2 = fabs(-1.0 * LorR * sqrt((PZ1.x-InterPt1.x)*(PZ1.x-InterPt1.x)+(PZ1.y-InterPt1.y)*(PZ1.y-InterPt1.y)) - road[iroad].hdmdes[j].OffsetByXLZX);
									if (XJDist > 0.01)//有线间沟
									{
										ZJ1 = -(ZJ1 - XJDist);//将支距改成负值，以标记该处有线间沟，并减去线间沟的宽度（线间沟看成绕线段部分的路肩沟）
										ZJ2 = -ZJ2;
									}
									//							ads_printf(L"0: %lf\n",InterPt1.z);
									return;
								}
							}
						}
					}
				}
				//左右线性质相同
				else
				{
					//1.计算坡脚点到主线中心的距离bpc
					double bpc = fabs(DesPt[(desptsum - 1) * 2]);
					//2.计算当前线路法线与二线交点的长度xjj
					double spt[2], fwj, PtOnFld[2], FLDcml;
					xlpoint PZ;
					PZ.lc = road[i].hdmdes[jcross].cml;
					road[i].pm->xlpoint_pz(&PZ);
					PZ.x = PZ.x + road[i].hdmdes[jcross].OffsetByXLZX * cos(PZ.a + 0.5*pi);
					PZ.y = PZ.y + road[i].hdmdes[jcross].OffsetByXLZX * sin(PZ.a + 0.5*pi);
					spt[0] = PZ.x, spt[1] = PZ.y;
					fwj = PZ.a;
					road[iroad].pm->CalJD_ZX_XL(spt, fwj - 0.5*pi, PtOnFld, FLDcml);
					double xjj = -sqrt((spt[0] - PtOnFld[0])*(spt[0] - PtOnFld[0]) + (spt[1] - PtOnFld[1])*(spt[1] - PtOnFld[1]));//相关道路上的投影里程
					double TmpOffsetByXLZX = 0.0;
					CalOffsetByXLZX(FLDcml, road[iroad].NYLMK, road[iroad].YLMK, TmpOffsetByXLZX);
					double ljj = fabs(xjj + TmpOffsetByXLZX);//路基中线间距(添加)
					//3.if(bpc>xjj) 
					//				if(bpc>xjj)//设置关联
					if (bpc > ljj)//设置关联,考虑路基中线与线路中线不重合
					{
						glcml = FLDcml;
						ZJ2 = -10000.0;//特殊关联标志
						return;
					}
					else
					{
						spt[0] = PZ.x + bpc * cos(fwj - 0.5*pi);
						spt[1] = PZ.y + bpc * sin(fwj - 0.5*pi);
						//					spt[0] = PZ.x + (LorR * bpc + road[i].hdmdes[jcross].OffsetByXLZX) * cos(fwj+0.5*pi);//考虑路基中线与线路中线不重合(修改)
						//					spt[1] = PZ.y + (LorR * bpc + road[i].hdmdes[jcross].OffsetByXLZX) * sin(fwj+0.5*pi);
						//4.else 求坡脚点到二线的长度len,及投影里程prjml
						double prjml = road[iroad].pm->PROJ_ML(spt[0], spt[1]);
						//5.计算二线prjml处坡脚点长度bpc1;
						if (prjml > road[iroad].hdmdes[j + 1].cml + 0.001 || prjml < road[iroad].hdmdes[j].cml - 0.001)
							continue;
						else
						{
							double bpc1;
							if (fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) < 0.0001)
								bpc1 = RDesPoint1[(Rnpt1 - 1) * 2];
							else
								bpc1 = RDesPoint1[(Rnpt1 - 1) * 2] + (prjml - road[iroad].hdmdes[j].cml)*(RDesPoint2[(Rnpt2 - 1) * 2] - RDesPoint1[(Rnpt1 - 1) * 2]) / (road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml);
							bpc1 = fabs(bpc1);
							//6.if(len1>bpc1) 无关联
							PZ.lc = prjml;
							road[iroad].pm->xlpoint_pz(&PZ);
							CalOffsetByXLZX(prjml, road[iroad].NYLMK, road[iroad].YLMK, TmpOffsetByXLZX);
							PZ.x = PZ.x + TmpOffsetByXLZX * cos(PZ.a + 0.5*pi);
							PZ.y = PZ.y + TmpOffsetByXLZX * sin(PZ.a + 0.5*pi);
							double len1 = sqrt((PZ.x - spt[0])*(PZ.x - spt[0]) + (PZ.y - spt[1])*(PZ.y - spt[1]));
							//					   double len1 = fabs(-1.0 * LorR * sqrt((PZ.x-spt[0])*(PZ.x-spt[0])+(PZ.y-spt[1])*(PZ.y-spt[1])) - TmpOffsetByXLZX);//考虑路基中线与线路中线不重合(修改)

							if (len1 < bpc1)
							{
								//7 else 设置关联
								glcml = prjml;
								ZJ2 = -10000.0;//特殊关联标志
								return;
							}

						}
					}
				}
			}

		}
	}
	else
	{
		ZX_TW = road[i].hdmdes[jcross].Yt;
		for (j = SnoOnFld; j < EnoOnFld; j++)
		{
			if (road[iroad].hdmdes[j].ZDMXZ != 3 && road[iroad].hdmdes[j].ZDMXZ != 4)
			{
				NewYd = road[iroad].hdmdmx[j].EarH;
				newNumL = road[iroad].hdmdmx[j].ZEarPtNum;
				for (int k = 0; k < newNumL; k++)
				{
					NewLearpt[k * 2] = road[iroad].hdmdmx[j].ZEarPtAry[k].x;
					NewLearpt[k * 2 + 1] = road[iroad].hdmdmx[j].ZEarPtAry[k].y;
				}
				newNumR = road[iroad].hdmdmx[j].YEarPtNum;
				for (k = 0; k < newNumR; k++)
				{
					NewRearpt[k * 2] = road[iroad].hdmdmx[j].YEarPtAry[k].x;
					NewRearpt[k * 2 + 1] = road[iroad].hdmdmx[j].YEarPtAry[k].y;
				}
				CalNewZB(road[iroad].hdmdes[j].OffsetByXLZX, NewYd, NewLearpt, newNumL, NewRearpt, newNumR,
					NewYdOffset1, NewLearptOffset, newNumLOffset, NewRearptOffset, newNumROffset);
				double tmp[20], gou[36], jsg[36];
				int itmp[10];
				CrosNew(iroad, -1, j, NewYdOffset1, newNumLOffset, NewLearptOffset, road[iroad].hdmdes[j].RHFL, road[iroad].hdmdes[j].zlmhd, 1000, ZPJPT,
					road[iroad].hdmdes[j].Ldeltah, Zt1, road[iroad].hdmdes[j].ZHc, Lnpt1, LDesPoint1,
					tmp[0], tmp[1], tmp[2], tmp[3],
					tmp[4],
					itmp[0], tmp[5], itmp[1], itmp[2], gou, tmp[6], tmp[7], tmp[8], tmp[9],
					itmp[3], jsg,
					tmp[10], tmp[11], tmp[12], tmp[13]);
				if (Zt1 > 0.9)
					FLX_BpStartIndex1 = 8;
				else
					FLX_BpStartIndex1 = 4;
				if (i != 0)
				{
					FindGLDMLZ(road[i].hdmdes[jcross].cml, road[i].pm, road[i].hdmbz.NGLDMLZ, road[i].hdmbz.GLDMLZ, dXGLDMLZ, dHGLDMLZ);
					FindGLDMLQBPTP(road[i].hdmdes[jcross].cml, road[i].pm, road[i].hdmbz.NGLDMLQBPTP, road[i].hdmbz.GLDMLQBPTP, dXGLDMLQBPTP);
					FindGLDMXJG(road[i].hdmdes[jcross].cml, road[i].pm, road[i].hdmbz.NGLDMXJG, road[i].hdmbz.GLDMXJG,
						GouWideXJG, GouHighXJG, NBPXJG, WBPXJG, JQHDXJG, GDRXJG);
					TopWideXJG = GouWideXJG + GouHighXJG * (NBPXJG + WBPXJG);
				}
				else
				{
					FindGLDMLZ(road[iroad].hdmdes[j].cml, road[iroad].pm, road[iroad].hdmbz.NGLDMLZ, road[iroad].hdmbz.GLDMLZ, dXGLDMLZ, dHGLDMLZ);
					FindGLDMLQBPTP(road[iroad].hdmdes[j].cml, road[iroad].pm, road[iroad].hdmbz.NGLDMLQBPTP, road[iroad].hdmbz.GLDMLQBPTP, dXGLDMLQBPTP);
					FindGLDMXJG(road[iroad].hdmdes[j].cml, road[iroad].pm, road[iroad].hdmbz.NGLDMXJG, road[iroad].hdmbz.GLDMXJG,
						GouWideXJG, GouHighXJG, NBPXJG, WBPXJG, JQHDXJG, GDRXJG);
					TopWideXJG = GouWideXJG + GouHighXJG * (NBPXJG + WBPXJG);
				}

			}
			else
				continue;

			if (road[iroad].hdmdes[j + 1].ZDMXZ != 3 && road[iroad].hdmdes[j + 1].ZDMXZ != 4)
			{
				NewYd = road[iroad].hdmdmx[j + 1].EarH;
				newNumL = road[iroad].hdmdmx[j + 1].ZEarPtNum;
				for (int k = 0; k < newNumL; k++)
				{
					NewLearpt[k * 2] = road[iroad].hdmdmx[j + 1].ZEarPtAry[k].x;
					NewLearpt[k * 2 + 1] = road[iroad].hdmdmx[j + 1].ZEarPtAry[k].y;
				}
				newNumR = road[iroad].hdmdmx[j + 1].YEarPtNum;
				for (k = 0; k < newNumR; k++)
				{
					NewRearpt[k * 2] = road[iroad].hdmdmx[j + 1].YEarPtAry[k].x;
					NewRearpt[k * 2 + 1] = road[iroad].hdmdmx[j + 1].YEarPtAry[k].y;
				}
				CalNewZB(road[iroad].hdmdes[j + 1].OffsetByXLZX, NewYd, NewLearpt, newNumL, NewRearpt, newNumR,
					NewYdOffset2, NewLearptOffset, newNumLOffset, NewRearptOffset, newNumROffset);
				double tmp[20], gou[36], jsg[36];
				int itmp[10];
				CrosNew(iroad, -1, j + 1, NewYdOffset2, newNumLOffset, NewLearptOffset, road[iroad].hdmdes[j + 1].RHFL, road[iroad].hdmdes[j + 1].zlmhd, 1000, ZPJPT,
					road[iroad].hdmdes[j + 1].Ldeltah, Zt2, road[iroad].hdmdes[j + 1].ZHc, Lnpt2, LDesPoint2,
					tmp[0], tmp[1], tmp[2], tmp[3],
					tmp[4],
					itmp[0], tmp[5], itmp[1], itmp[2], gou, tmp[6], tmp[7], tmp[8], tmp[9],
					itmp[3], jsg,
					tmp[10], tmp[11], tmp[12], tmp[13]);
				if (Zt2 > 0.9)
					FLX_BpStartIndex2 = 8;
				else
					FLX_BpStartIndex2 = 4;
			}
			else
				continue;

			if ((Zt1 < 0.1&&Zt2 < 0.1) || (Zt1 > 0.9&&Zt2 > 0.9))
			{
				if ((ZX_TW < 0.1&&Zt1 < 0.1) || (ZX_TW > 0.9&&Zt1 > 0.9))
				{
					//计算三维边坡线
					if (ZX_TW < 0.1&&Zt1 < 0.1)
						XJDist = TopWideXJG;
					else
						XJDist = dXGLDMLQBPTP;
					AcGePoint3d Pt;
					AcGePoint3d ZX_LJPt, FLX_LJPt;
					AcGePoint3dArray PtArr;
					double EarHonLJCen = road[i].hdmdes[jcross].RHFR[1] - DesPt[1];//当前线路路基中线上的地面标高
					for (k = 0; k < desptsum; k++)
					{
						Pt.x = PZ.x + fabs(DesPt[k * 2] + XJDist) * cos(PZ.a + LorR * 0.5*pi);
						Pt.y = PZ.y + fabs(DesPt[k * 2] + XJDist) * sin(PZ.a + LorR * 0.5*pi);
						// 						Pt.z = DesPt[k*2+1] + road[i].hdmdmx[jcross].EarH;
						//						Pt.x = PZ.x + (LorR * fabs(DesPt[k*2]+XJDist) + road[i].hdmdes[jcross].OffsetByXLZX) * cos(PZ.a + 0.5*pi);//考虑路基中线与线路中线不重合(修改)
						//						Pt.y = PZ.y + (LorR * fabs(DesPt[k*2]+XJDist) + road[i].hdmdes[jcross].OffsetByXLZX) * sin(PZ.a + 0.5*pi);
						Pt.z = DesPt[k * 2 + 1] + EarHonLJCen;
						PtArr.append(Pt);
					}
					// 					ZX_LJPt.x = PZ.x + (LorR * fabs(DesPt[4*2]) + road[i].hdmdes[jcross].OffsetByXLZX) * cos(PZ.a + 0.5*pi);//考虑路基中线与线路中线不重合(修改)
					// 					ZX_LJPt.y = PZ.y + (LorR * fabs(DesPt[4*2]) + road[i].hdmdes[jcross].OffsetByXLZX) * sin(PZ.a + 0.5*pi);
					Pt.x = PZ.x + fabs(DesPt[4 * 2]) * cos(PZ.a + LorR * 0.5*pi);
					Pt.y = PZ.y + fabs(DesPt[4 * 2]) * sin(PZ.a + LorR * 0.5*pi);
					ZX_LJPt.z = DesPt[4 * 2 + 1] + EarHonLJCen;
					ZX_LenBPStartToLJ = DesPt[ZX_BpStartIndex * 2] - DesPt[4 * 2];
					//形成路面
					xlpoint PZ1;
					AcGePoint3dArray PtArr1;
					PZ1.lc = road[iroad].hdmdes[j].cml;
					road[iroad].pm->xlpoint_pz(&PZ1);
					PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
					PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
					for (k = 0; k < Lnpt1; k++)
					{
						Pt.x = PZ1.x + fabs(LDesPoint1[k * 2]) * cos(PZ1.a - LorR * 0.5*pi);
						Pt.y = PZ1.y + fabs(LDesPoint1[k * 2]) * sin(PZ1.a - LorR * 0.5*pi);
						// 						Pt.z = LDesPoint1[k*2+1] + road[iroad].hdmdmx[j].EarH;
						//						Pt.x = PZ1.x + (-1.0 * LorR * fabs(LDesPoint1[k*2]) + road[iroad].hdmdes[j].OffsetByXLZX) * cos(PZ1.a + 0.5*pi);//考虑路基中线与线路中线不重合(修改)
						//						Pt.y = PZ1.y + (-1.0 * LorR * fabs(LDesPoint1[k*2]) + road[iroad].hdmdes[j].OffsetByXLZX) * sin(PZ1.a + 0.5*pi);
						Pt.z = LDesPoint1[k * 2 + 1] + NewYdOffset1;
						PtArr1.append(Pt);
					}
					FLX_LJPt = PtArr1[4];
					FLX_LenBPStartToLJ1 = LDesPoint1[FLX_BpStartIndex1 * 2] - LDesPoint1[4 * 2];
					dXLJPt = sqrt((ZX_LJPt.x - FLX_LJPt.x)*(ZX_LJPt.x - FLX_LJPt.x) + (ZX_LJPt.y - FLX_LJPt.y)*(ZX_LJPt.y - FLX_LJPt.y));
					dHLJPt = fabs(ZX_LJPt.z - FLX_LJPt.z);
					if (dXLJPt <= dXGLDMLZ + ZX_LenBPStartToLJ + FLX_LenBPStartToLJ1 && dHLJPt <= dHGLDMLZ)//关联,边坡拉直
					{
						glcml = road[iroad].hdmdes[j].cml;
						ZJ2 = -10000.0;
						return;
					}

					if (dXLJPt <= dXGLDMLQBPTP && ZX_TW > 0.9 && Zt1 > 0.9)//设置的推平距离过大，路肩直接拉直
					{
						glcml = road[iroad].hdmdes[j].cml;
						ZJ2 = -10000.0;
						return;
					}
					if (dXLJPt <= ZX_LenBPStartToLJ + FLX_LenBPStartToLJ1)
					{
						glcml = road[iroad].hdmdes[j].cml;
						ZJ2 = -10000.0;
						return;
					}
					AcGePoint3dArray PtArr2;
					PZ1.lc = road[iroad].hdmdes[j + 1].cml;
					road[iroad].pm->xlpoint_pz(&PZ1);
					PZ1.x = PZ1.x + road[iroad].hdmdes[j + 1].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
					PZ1.y = PZ1.y + road[iroad].hdmdes[j + 1].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
					for (k = 0; k < Lnpt2; k++)
					{
						Pt.x = PZ1.x + fabs(LDesPoint2[k * 2]) * cos(PZ1.a - LorR * 0.5*pi);
						Pt.y = PZ1.y + fabs(LDesPoint2[k * 2]) * sin(PZ1.a - LorR * 0.5*pi);
						//						Pt.x = PZ1.x + (-1.0 * LorR * fabs(LDesPoint2[k*2]) + road[iroad].hdmdes[j+1].OffsetByXLZX) * cos(PZ1.a + 0.5*pi);
						//						Pt.y = PZ1.y + (-1.0 * LorR * fabs(LDesPoint2[k*2]) + road[iroad].hdmdes[j+1].OffsetByXLZX) * sin(PZ1.a + 0.5*pi);
						Pt.z = LDesPoint2[k * 2 + 1] + NewYdOffset2;
						PtArr2.append(Pt);
					}
					FLX_LJPt = PtArr2[4];
					dXLJPt = sqrt((ZX_LJPt.x - FLX_LJPt.x)*(ZX_LJPt.x - FLX_LJPt.x) + (ZX_LJPt.y - FLX_LJPt.y)*(ZX_LJPt.y - FLX_LJPt.y));
					dHLJPt = fabs(ZX_LJPt.z - FLX_LJPt.z);
					FLX_LenBPStartToLJ2 = LDesPoint2[FLX_BpStartIndex2 * 2] - LDesPoint2[4 * 2];
					if (dXLJPt <= dXGLDMLZ + ZX_LenBPStartToLJ + FLX_LenBPStartToLJ2 && dHLJPt <= dHGLDMLZ)//关联,边坡拉直
					{
						glcml = road[iroad].hdmdes[j + 1].cml;
						ZJ2 = -10000.0;
						return;
					}

					if (dXLJPt <= dXGLDMLQBPTP && ZX_TW > 0.9 && Zt1 > 0.9)//设置的推平距离过大，路肩直接拉直
					{
						glcml = road[iroad].hdmdes[j + 1].cml;
						ZJ2 = -10000.0;
						return;
					}
					if (dXLJPt < ZX_LenBPStartToLJ + FLX_LenBPStartToLJ2)
					{
						glcml = road[iroad].hdmdes[j + 1].cml;
						ZJ2 = -10000.0;
						return;
					}
					int npt;
					npt = Lnpt1 < Lnpt2 ? Lnpt1 : Lnpt2;
					//				AcGePoint3dArray InterPt;
					AcGePoint3d InterPt1;
					//	AcGePlane plane(AcGePoint3d(0,0,0),AcGeVector3d(0,0,1));
					//	if(fabs(road[i].hdmdes[jcross].dml-193600)<0.1)
					//					{
					//						dline = new AcDb3dPolyline(AcDb::k3dSimplePoly,PtArr);		
					//						AddEntityToDbs(dline);
					//					}

					for (int n = ZX_BpStartIndex; n < desptsum - 1; n++)
					{
						//AcDbLine zxline(PtArr[n],PtArr[n+1]);
						AcGeLine3d zxline(PtArr[n], PtArr[n + 1]);
						for (k = FLX_BpStartIndex1; k < npt - 1; k++)
						{
							//					  AcDbFace face(PtArr1[k],PtArr1[k+1],PtArr2[k+1],PtArr2[k]);
							AcDbFace face(PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]);
							//					  AcGePlane prj(PtArr1[k],PtArr1[k+1],PtArr2[k+1]);
							AcGePlane prj(PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]);
							AcGePlane plane(AcGePoint3d(0, 0, 0), AcGeVector3d(0, 0, 1));
							/*
							if(fabs(road[i].hdmdes[jcross].dml-208130.35)<0.1)
							{
							AcDbFace *face1;
							face1 = new AcDbFace(PtArr1[k],PtArr1[k+1],PtArr2[k+1]);
							AddEntityToDbs(face1);
							prj.intersectWith(zxline,InterPt1);
							ads_point pt;
							pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
							acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
							//	IfPrint=true;
							ads_printf(L"zx=%lf %lf %lf 1:%lf %lf %lf 2:%lf %lf %lf\n",InterPt1.x,InterPt1.y,InterPt1.z,PtArr[n].x,PtArr[n].y,PtArr[n].z,PtArr[n+1].x,PtArr[n+1].y,PtArr[n+1].z);
							ads_printf(L"zx=%d tri=%d\n",CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr1[k+1],PtArr2[k+1]));
							//		IfPrint=false;
							}*/



							//					makeline(PtArr1[k],PtArr1[k+1],1,0);
							//					makeline(PtArr1[k+1],PtArr2[k+1],1,0);
							//					makeline(PtArr2[k+1],PtArr2[k],1,0);
							//					makeline(PtArr2[k],PtArr1[k],1,0);
							//					zxbp.intersectWith(&face,AcDb::kOnBothOperands,InterPt);
							if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
								&& CheckPtInTri(InterPt1, PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]))//有交点
							{
								//投影到iroad线路上计算里程
								glcml = road[iroad].pm->PROJ_ML(InterPt1.x, InterPt1.y);
								//计算支距ZJ1,ZJ2,
								ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
								//								ZJ1 = fabs(LorR * sqrt((PZ.x-InterPt1.x)*(PZ.x-InterPt1.x)+(PZ.y-InterPt1.y)*(PZ.y-InterPt1.y)) - road[i].hdmdes[jcross].OffsetByXLZX);
								PZ1.lc = glcml;
								road[iroad].pm->xlpoint_pz(&PZ1);
								PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
								PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
								ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
								//								ZJ2 = fabs(-1.0 * LorR * sqrt((PZ1.x-InterPt1.x)*(PZ1.x-InterPt1.x)+(PZ1.y-InterPt1.y)*(PZ1.y-InterPt1.y)) - road[iroad].hdmdes[j].OffsetByXLZX);
								if (XJDist > 0.01)//有线间沟
								{
									ZJ1 = -(ZJ1 - XJDist);//将支距改成负值，以标记该处有线间沟，并减去线间沟的宽度（线间沟看成绕线段部分的路肩沟）
									ZJ2 = -ZJ2;
								}
								//								ads_printf(L"0: %lf\n",InterPt1.z);
								//								ads_point pt;
								//								pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
								//								acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
								//							ads_alert(L"1");
								return;
							}

							AcDbFace face2(PtArr1[k], PtArr2[k + 1], PtArr2[k]);
							AcGePlane prj1(PtArr1[k], PtArr2[k + 1], PtArr2[k]);

							/*
							AcDbFace *face3;
							if(fabs(road[i].hdmdes[jcross].dml-208130.35)<0.1)
							{
							face3 = new AcDbFace(PtArr1[k],PtArr2[k+1],PtArr2[k]);
							AddEntityToDbs(face3);
							prj.intersectWith(zxline,InterPt1);
							ads_point pt;
							pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
							acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
							//	IfPrint=true;
							ads_printf(L"zx=%lf %lf %lf 1:%lf %lf %lf 2:%lf %lf %lf\n",InterPt1.x,InterPt1.y,InterPt1.z,PtArr[n].x,PtArr[n].y,PtArr[n].z,PtArr[n+1].x,PtArr[n+1].y,PtArr[n+1].z);
							ads_printf(L"zx=%d tri=%d\n",CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr2[k+1],PtArr2[k]));
							//	IfPrint=false;
							}*/

							//					makeline(PtArr1[k],PtArr1[k+1],1,0);
							//					makeline(PtArr1[k+1],PtArr2[k+1],1,0);
							//					makeline(PtArr2[k+1],PtArr2[k],1,0);
							//					makeline(PtArr2[k],PtArr1[k],1,0);
							//					zxbp.intersectWith(&face,AcDb::kOnBothOperands,InterPt);
							if (prj1.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
								&& CheckPtInTri(InterPt1, PtArr1[k], PtArr2[k + 1], PtArr2[k]))//有交点
							{
								//投影到iroad线路上计算里程
								glcml = road[iroad].pm->PROJ_ML(InterPt1.x, InterPt1.y);
								//计算支距ZJ1,ZJ2,
								ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
								//								ZJ1 = fabs(LorR * sqrt((PZ.x-InterPt1.x)*(PZ.x-InterPt1.x)+(PZ.y-InterPt1.y)*(PZ.y-InterPt1.y)) - road[i].hdmdes[jcross].OffsetByXLZX);
								PZ1.lc = glcml;
								road[iroad].pm->xlpoint_pz(&PZ1);
								PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
								PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
								ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
								//								ZJ2 = fabs(-1.0 * LorR * sqrt((PZ1.x-InterPt1.x)*(PZ1.x-InterPt1.x)+(PZ1.y-InterPt1.y)*(PZ1.y-InterPt1.y)) - road[iroad].hdmdes[j].OffsetByXLZX);
								if (XJDist > 0.01)//有线间沟
								{
									ZJ1 = -(ZJ1 - XJDist);//将支距改成负值，以标记该处有线间沟，并减去线间沟的宽度（线间沟看成绕线段部分的路肩沟）
									ZJ2 = -ZJ2;
								}
								//								ads_printf(L"0: %lf\n",InterPt1.z);
								//								ads_point pt;
								//								pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
								//								acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
								return;
							}
						}

						if (Lnpt1 > npt)
						{
							for (k = npt - 1; k < Lnpt1 - 1; k++)
							{
								AcDbFace face(PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1], PtArr2[npt - 1]);
								AcGePlane prj(PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1]);

								//						face.intersectWith(zxbp,AcDb::kOnBothOperands,)
								if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
									&& CheckPtInTri(InterPt1, PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1]))//有交点
								{
									//投影到iroad线路上计算里程
									glcml = road[iroad].pm->PROJ_ML(InterPt1.x, InterPt1.y);
									//计算支距ZJ1,ZJ2,
									ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
									//									ZJ1 = fabs(LorR * sqrt((PZ.x-InterPt1.x)*(PZ.x-InterPt1.x)+(PZ.y-InterPt1.y)*(PZ.y-InterPt1.y)) - road[i].hdmdes[jcross].OffsetByXLZX);
									PZ1.lc = glcml;
									road[iroad].pm->xlpoint_pz(&PZ1);
									PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
									PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
									ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
									//									ZJ2 = fabs(-1.0 * LorR * sqrt((PZ1.x-InterPt1.x)*(PZ1.x-InterPt1.x)+(PZ1.y-InterPt1.y)*(PZ1.y-InterPt1.y) - road[iroad].hdmdes[j].OffsetByXLZX));
									if (XJDist > 0.01)//有线间沟
									{
										ZJ1 = -(ZJ1 - XJDist);//将支距改成负值，以标记该处有线间沟，并减去线间沟的宽度（线间沟看成绕线段部分的路肩沟）
										ZJ2 = -ZJ2;
									}
									//									ads_printf(L"0: %lf\n",InterPt1.z);
									//									ads_point pt;
									//									pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
									//							acedCommandS(RTSTR,L"donut",RTREAL,0.0,RTREAL,1.0,RTPOINT,pt,RTSTR,L"",0);
									return;
								}
							}
						}

						if (Lnpt2 > npt)
						{
							for (k = npt - 1; k < Lnpt2 - 1; k++)
							{
								AcDbFace face(PtArr1[npt - 1], PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]);
								AcGePlane prj(PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]);
								if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
									&& CheckPtInTri(InterPt1, PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]))//有交点
								{
									//投影到iroad线路上计算里程
									glcml = road[iroad].pm->PROJ_ML(InterPt1.x, InterPt1.y);
									//计算支距ZJ1,ZJ2,
									ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
									//									ZJ1 = fabs(LorR * sqrt((PZ.x-InterPt1.x)*(PZ.x-InterPt1.x)+(PZ.y-InterPt1.y)*(PZ.y-InterPt1.y)) - road[i].hdmdes[jcross].OffsetByXLZX);
									PZ1.lc = glcml;
									road[iroad].pm->xlpoint_pz(&PZ1);
									PZ1.x = PZ1.x + road[iroad].hdmdes[j].OffsetByXLZX * cos(PZ1.a + 0.5*pi);
									PZ1.y = PZ1.y + road[iroad].hdmdes[j].OffsetByXLZX * sin(PZ1.a + 0.5*pi);
									ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
									//									ZJ2 = fabs(-1.0 * LorR * sqrt((PZ1.x-InterPt1.x)*(PZ1.x-InterPt1.x)+(PZ1.y-InterPt1.y)*(PZ1.y-InterPt1.y)) - road[iroad].hdmdes[j].OffsetByXLZX);
									if (XJDist > 0.01)//有线间沟
									{
										ZJ1 = -(ZJ1 - XJDist);//将支距改成负值，以标记该处有线间沟，并减去线间沟的宽度（线间沟看成绕线段部分的路肩沟）
										ZJ2 = -ZJ2;
									}
									//									ads_printf(L"0: %lf\n",InterPt1.z);
									//									ads_point pt;
									//									pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
									//							acedCommandS(RTSTR,L"donut",RTREAL,0.0,RTREAL,1.0,RTPOINT,pt,RTSTR,L"",0);
									return;
								}
							}
						}
					}

				}//左右线性质相同
				else
				{
					//1.计算坡脚点到主线中心的距离bpc
					double bpc = fabs(DesPt[(desptsum - 1) * 2]);
					//2.计算当前线路法线与二线交点的长度xjj
					double spt[2], fwj, PtOnFld[2], FLDcml;
					xlpoint PZ;
					PZ.lc = road[i].hdmdes[jcross].cml;
					road[i].pm->xlpoint_pz(&PZ);
					PZ.x = PZ.x + road[i].hdmdes[jcross].OffsetByXLZX * cos(PZ.a + 0.5*pi);
					PZ.y = PZ.y + road[i].hdmdes[jcross].OffsetByXLZX * sin(PZ.a + 0.5*pi);
					spt[0] = PZ.x, spt[1] = PZ.y;
					fwj = PZ.a;
					road[iroad].pm->CalJD_ZX_XL(spt, fwj + 0.5*pi, PtOnFld, FLDcml);
					double xjj = sqrt((spt[0] - PtOnFld[0])*(spt[0] - PtOnFld[0]) + (spt[1] - PtOnFld[1])*(spt[1] - PtOnFld[1]));//相关道路上的投影里程	
					double TmpOffsetByXLZX = 0.0;
					CalOffsetByXLZX(FLDcml, road[iroad].NZLMK, road[iroad].ZLMK, TmpOffsetByXLZX);
					double LJJ = fabs(xjj + TmpOffsetByXLZX);//(添加)
					//3.if(bpc>xjj) 
					//				if(bpc>xjj)//设置关联
					if (bpc > LJJ)//(修改)
					{
						glcml = FLDcml;
						ZJ2 = -10000.0;//特殊关联标志
						return;
					}
					else
					{
						spt[0] = PZ.x + bpc * cos(fwj + 0.5*pi);
						spt[1] = PZ.y + bpc * sin(fwj + 0.5*pi);
						//					spt[0] = PZ.x + (LorR * bpc + road[i].hdmdes[jcross].OffsetByXLZX) * cos(fwj+0.5*pi);//（修改）
						//					spt[1] = PZ.y + (LorR * bpc + road[i].hdmdes[jcross].OffsetByXLZX) * sin(fwj+0.5*pi);
						//4.else 求坡脚点到二线的长度len,及投影里程prjml
						double prjml = road[iroad].pm->PROJ_ML(spt[0], spt[1]);
						//5.计算二线prjml处坡脚点长度bpc1;
						if (prjml > road[iroad].hdmdes[j + 1].cml + 0.001 || prjml < road[iroad].hdmdes[j].cml - 0.001)
							continue;
						else
						{
							double bpc1;
							if (fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) < 0.0001)
								bpc1 = LDesPoint1[(Lnpt1 - 1) * 2];
							else
								bpc1 = LDesPoint1[(Lnpt1 - 1) * 2] + (prjml - road[iroad].hdmdes[j].cml)*(LDesPoint2[(Lnpt2 - 1) * 2] - LDesPoint1[(Lnpt1 - 1) * 2]) / (road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml);
							bpc1 = fabs(bpc1);
							//6.if(len1>bpc1) 无关联
							PZ.lc = prjml;
							road[iroad].pm->xlpoint_pz(&PZ);
							CalOffsetByXLZX(prjml, road[iroad].NZLMK, road[iroad].ZLMK, TmpOffsetByXLZX);
							PZ.x = PZ.x + TmpOffsetByXLZX * cos(PZ.a + 0.5*pi);
							PZ.y = PZ.y + TmpOffsetByXLZX * sin(PZ.a + 0.5*pi);
							double len1 = sqrt((PZ.x - spt[0])*(PZ.x - spt[0]) + (PZ.y - spt[1])*(PZ.y - spt[1]));
							//					   double len1 = fabs(-1.0 * LorR * sqrt((PZ.x-spt[0])*(PZ.x-spt[0])+(PZ.y-spt[1])*(PZ.y-spt[1])) - TmpOffsetByXLZX);//(修改)
							if (len1 < bpc1)
							{
								//7 else 设置关联
								glcml = prjml;
								ZJ2 = -10000.0;//特殊关联标志
								return;
							}

						}
					}

				}
			}

		}
	}
}

int HdmDes::InsertHdm(int izx, int jcross, int iroad, int LorR, double ZJ2, double glcml)
{
	//找到位置

	int j;
	j = 0;
	while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < glcml + 0.001)
		j++;
	//补充地面线
	j = j - 1 < 0 ? 0 : j - 1;
	if (fabs(glcml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml) < 0.1)
		j = road[iroad].NCRS - 1;
	//   ads_printf(L"dml=%lf\n",road[iroad].hdmdes[j].dml);
	if (fabs(road[iroad].hdmdes[j].cml - glcml) < 1)//有一样的里程
	{

		if (LorR < 0)//左侧
		{
			if (fabs(ZJ2 + 10000.0) > 0.01)
				road[iroad].hdmdes[j].ZZJ = ZJ2;
			//else
			// road[iroad].hdmdes[j].ZZJ = fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt-1].x);

		}
		else
		{
			if (fabs(ZJ2 + 10000.0) > 0.01)
				road[iroad].hdmdes[j].YZJ = ZJ2;
			//		  else
			//			 road[iroad].hdmdes[j].YZJ = fabs(road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt-1].x);
		}
		//	  ads_printf(L"ZZJ1=%lf\n",road[iroad].hdmdes[j].ZZJ);
		DesACrossOnSingleLine(iroad, j);
		road[iroad].hdmdes[j].glRoadName = road[izx].roadname;
		road[iroad].hdmdes[j].glcml = road[izx].hdmdes[jcross].cml;
		road[izx].hdmdes[jcross].glcml = road[iroad].hdmdes[j].cml;
		road[iroad].hdmdes[j].IfHasDes = true;

		return j;
	}
	//没有该里程，插入
	int k;
	for (k = road[iroad].NCRS; k > j + 1; k--)
	{
		SetDmxData(road[iroad].hdmdmx[k], road[iroad].hdmdmx[k - 1]);
		SetDmxData(road[iroad].hdmBench[k], road[iroad].hdmBench[k - 1]);
		//      road[iroad].hdmdmx[k] =  road[iroad].hdmdmx[k-1];
		road[iroad].hdmdes[k] = road[iroad].hdmdes[k - 1];
	}
	//设置地面线
	double cml1, cml, cml2, dml, Ydesh, Zdesh;
	CString GH;
	cml = glcml;
	dml = road[iroad].pm->XLC(glcml, GH);
	cml1 = road[iroad].pm->TYLC(road[iroad].hdmdmx[j].lc);
	//  if(j<road[iroad].NCRS-2)
	cml2 = road[iroad].pm->TYLC(road[iroad].hdmdmx[j + 2].lc);
	//  else
	//	 cml2 = road[iroad].pm->TYLC(road[iroad].hdmdmx[road[iroad].NCRS-1].lc);

	//////////////////////////////////////////////////////////////////////////
	bool IsInsertByDTM = true;//默认采用数模内插
	IsInsertByDTM = InsertHdmDmxByDTM(iroad, j + 1, cml);
	if (IsInsertByDTM)//数模内插成功
	{
		if (cml - cml1 > cml2 - cml)
		{
			road[iroad].hdmdmx[j + 1].BTxz = road[iroad].hdmdmx[j + 2].BTxz;
			_tcscpy(road[iroad].hdmdmx[j + 1].flag, road[iroad].hdmdmx[j + 2].flag);
		}
		else
		{
			road[iroad].hdmdmx[j + 1].BTxz = road[iroad].hdmdmx[j].BTxz;
			_tcscpy(road[iroad].hdmdmx[j + 1].flag, road[iroad].hdmdmx[j].flag);
		}
	}

	else
	{
		if (cml - cml1 > cml2 - cml)
			SetDmxData(road[iroad].hdmdmx[j + 1], road[iroad].hdmdmx[j + 2]);
		else
			SetDmxData(road[iroad].hdmdmx[j + 1], road[iroad].hdmdmx[j]);
	}
	//////////////////////////////////////////////////////////////////////////

	road[iroad].hdmdmx[j + 1].lc = dml;
	//设置路面信息

	InitHdmData(iroad, j + 1);//设置初值
	road[iroad].hdmdes[j + 1].cml = cml;
	road[iroad].hdmdes[j + 1].dml = dml;
	road[iroad].hdmdes[j + 1].glRoadName = road[izx].roadname;
	road[iroad].hdmdes[j + 1].glcml = road[izx].hdmdes[jcross].cml;
	road[izx].hdmdes[jcross].glcml = road[iroad].hdmdes[j + 1].cml;
	road[iroad].hdmdes[j + 1].xjj = -road[izx].hdmdes[jcross].xjj;//初始值

	_tcscpy(road[iroad].hdmdes[j + 1].ckml, road[iroad].pm->LCchr(GH, dml, 3));

	//计算路面标高
	//1.计算左幅右幅设计标高	

	// 	   Zdesh = CalDesH(cml,road[iroad].ZZM,road[iroad].AllZM);
	// 	   if(road[iroad].ZcgNm>0)
	// 		   CalLMPT(cml,Zdesh,road[iroad].ZcgNm,road[iroad].Zcg,road[iroad].ZjkNm,
	// 		   road[iroad].Zjk,road[iroad].NZLMK,road[iroad].ZLMK,road[iroad].hdmdes[j+1].RHFL,
	// 		   -1,road[iroad].BxNum,road[iroad].pBXArr,road[iroad].pm);
	CalOffsetByXLZX(cml, road[iroad].NZLMK, road[iroad].ZLMK, road[iroad].hdmdes[j + 1].OffsetByXLZX);
	CalFGDBYDesH(cml, iroad, Zdesh, -1);//考虑道路中线与线路中线不重合(修改)
	CalLMPT(cml, Zdesh, road[iroad].ZcgNm, road[iroad].Zcg, road[iroad].ZjkNm,
		road[iroad].Zjk, road[iroad].NZLMK, road[iroad].ZLMK, road[iroad].hdmdes[j + 1].RHFL,
		-1, road[iroad].BxNum, road[iroad].pBXArr, road[iroad].pm);

	//计算断面属性       			  
	road[iroad].hdmdes[j + 1].ZDMXZ = SetDmProperty(cml, road[iroad].pm, road[iroad].NZBri, road[iroad].ZBri,
		road[iroad].NAllBri, road[iroad].AllBri,
		road[iroad].NZTun, road[iroad].ZTun,
		road[iroad].NAllTun, road[iroad].AllTun, -1, road[iroad].hdmdes[j + 1].BriZZDK, road[iroad].hdmdes[j].ZDMXZ);

	// 	   Ydesh = CalDesH(cml,road[iroad].YZM,road[iroad].AllZM);
	// 	   if(road[iroad].YcgNm>0)
	// 		   CalLMPT(cml,Ydesh,road[iroad].YcgNm,road[iroad].Ycg,road[iroad].YjkNm,
	// 		   road[iroad].Yjk,road[iroad].NYLMK,road[iroad].YLMK,road[iroad].hdmdes[j+1].RHFR,
	// 		   1,road[iroad].BxNum,road[iroad].pBXArr,road[iroad].pm);
	CalFGDBYDesH(cml, iroad, Ydesh, 1);//考虑道路中线与线路中线不重合(修改)
	CalLMPT(cml, Ydesh, road[iroad].YcgNm, road[iroad].Ycg, road[iroad].YjkNm,
		road[iroad].Yjk, road[iroad].NYLMK, road[iroad].YLMK, road[iroad].hdmdes[j + 1].RHFR,
		1, road[iroad].BxNum, road[iroad].pBXArr, road[iroad].pm);

	road[iroad].hdmdes[j + 1].YDMXZ = SetDmProperty(cml, road[iroad].pm, road[iroad].NYBri, road[iroad].YBri,
		road[iroad].NAllBri, road[iroad].AllBri,
		road[iroad].NYTun, road[iroad].YTun,
		road[iroad].NAllTun, road[iroad].AllTun, 1, road[iroad].hdmdes[j + 1].BriYZDK, road[iroad].hdmdes[j].YDMXZ);



	double fgdhp, fgdk;

	if (road[iroad].hdmdes[j + 1].RHFL[8]<0.001 && road[iroad].hdmdes[j + 1].RHFR[8]>0.01)
	{
		//修正
		Zdesh = road[iroad].hdmdes[j + 1].RHFR[1];
		for (k = 0; k < 5; k++)
			road[iroad].hdmdes[j + 1].RHFL[k * 2 + 1] = Zdesh;
	}
	if (road[iroad].hdmdes[j + 1].RHFR[8]<0.001 && road[iroad].hdmdes[j + 1].RHFL[8]>0.01)
	{
		//修正
		Ydesh = road[iroad].hdmdes[j + 1].RHFL[1];
		for (k = 0; k < 5; k++)
			road[iroad].hdmdes[j + 1].RHFR[k * 2 + 1] = Ydesh;
	}



	if (LorR < 0)//左侧
	{
		if (fabs(ZJ2 + 10000.0) > 0.01)
			road[iroad].hdmdes[j + 1].ZZJ = ZJ2;
		//		  else
		//			 road[iroad].hdmdes[j+1].ZZJ = fabs(road[iroad].hdmdes[j+1].RPTL[road[iroad].hdmdes[j+1].Lnpt-1].x);

	}
	else
	{
		if (fabs(ZJ2 + 10000.0) > 0.01)
			road[iroad].hdmdes[j + 1].YZJ = ZJ2;
		//		  else
		//			 road[iroad].hdmdes[j+1].YZJ =fabs(road[iroad].hdmdes[j+1].RPTR[road[iroad].hdmdes[j+1].Rnpt-1].x);
	}
	//	  ads_printf(L"ZZJ=%lf\n",road[iroad].hdmdes[j+1].ZZJ);
	DesACrossOnSingleLine(iroad, j + 1);
	road[iroad].hdmdes[j + 1].xjj = -road[izx].hdmdes[jcross].xjj;//初始值
	road[iroad].hdmdes[j + 1].IfHasDes = true;
	road[iroad].hdmdes[j + 1].IsInsertHdm = 1;
	road[iroad].NCRS++;
	return j + 1;
}


int HdmDes::InsertHdm(int izx, int jcross, RoadHdmdata &ZDroad, int LorR, double ZJ2, double glcml)
{
	//找到位置
	int j;
	j = 0;

	while (j < ZDroad.NCRS && ZDroad.hdmdes[j].cml < glcml + 0.001)
		j++;
	//补充地面线
	j = j - 1 < 0 ? 0 : j - 1;
	//   ads_printf(L"dml=%lf\n",ZDroad.hdmdes[j].dml);

	if (fabs(ZDroad.hdmdes[j].cml - glcml) < 1)//有一样的里程
	{

		if (LorR < 0)//左侧
		{
			if (fabs(ZJ2 + 10000.0) > 0.01)
				ZDroad.hdmdes[j].ZZJ = ZJ2;
			//else
			// ZDroad.hdmdes[j].ZZJ = fabs(ZDroad.hdmdes[j].RPTL[ZDroad.hdmdes[j].Lnpt-1].x);

		}
		else
		{
			if (fabs(ZJ2 + 10000.0) > 0.01)
				ZDroad.hdmdes[j].YZJ = ZJ2;
			//		  else
			//			 ZDroad.hdmdes[j].YZJ = fabs(ZDroad.hdmdes[j].RPTR[ZDroad.hdmdes[j].Rnpt-1].x);
		}
		//	  ads_printf(L"ZZJ1=%lf\n",ZDroad.hdmdes[j].ZZJ);

		DesACrossOnSingleLine(ZDroad, j);

		ZDroad.hdmdes[j].glRoadName = road[izx].roadname;
		ZDroad.hdmdes[j].glcml = road[izx].hdmdes[jcross].cml;
		ZDroad.hdmdes[j].IfHasDes = true;

		return j;
	}
	//没有该里程，插入
	int k;
	for (k = ZDroad.NCRS; k > j + 1; k--)
	{
		SetDmxData(ZDroad.hdmdmx[k], ZDroad.hdmdmx[k - 1]);
		SetDmxData(ZDroad.hdmBench[k], ZDroad.hdmBench[k - 1]);
		//      ZDroad.hdmdmx[k] =  ZDroad.hdmdmx[k-1];
		ZDroad.hdmdes[k] = ZDroad.hdmdes[k - 1];
	}
	//设置地面线

	double cml1, cml, cml2, dml, Ydesh;
	CString GH;
	cml = glcml;
	dml = ZDroad.pm->XLC(glcml, GH);
	cml1 = ZDroad.pm->TYLC(ZDroad.hdmdmx[j].lc);
	cml2 = ZDroad.pm->TYLC(ZDroad.hdmdmx[j + 2].lc);

	//////////////////////////////////////////////////////////////////////////
	bool IsInsertByDTM = true;//默认采用数模内插
	IsInsertByDTM = InsertHdmDmxByDTM(ZDroad, j + 1, cml);
	if (IsInsertByDTM)//数模内插成功
	{
		if (cml - cml1 > cml2 - cml)
		{
			ZDroad.hdmdmx[j + 1].BTxz = ZDroad.hdmdmx[j + 2].BTxz;
			_tcscpy(ZDroad.hdmdmx[j + 1].flag, ZDroad.hdmdmx[j + 2].flag);
		}
		else
		{
			ZDroad.hdmdmx[j + 1].BTxz = ZDroad.hdmdmx[j].BTxz;
			_tcscpy(ZDroad.hdmdmx[j + 1].flag, ZDroad.hdmdmx[j].flag);
		}
	}

	else
	{
		if (cml - cml1 > cml2 - cml)
			SetDmxData(ZDroad.hdmdmx[j + 1], ZDroad.hdmdmx[j + 2]);
		else
			SetDmxData(ZDroad.hdmdmx[j + 1], ZDroad.hdmdmx[j]);
	}
	//////////////////////////////////////////////////////////////////////////

	ZDroad.hdmdmx[j + 1].lc = dml;
	//设置路面信息

	InitHdmData(ZDroad.hdmdes[j + 1]);//设置初值
	ZDroad.hdmdes[j + 1].cml = cml;
	ZDroad.hdmdes[j + 1].dml = dml;
	ZDroad.hdmdes[j + 1].glRoadName = road[izx].roadname;
	ZDroad.hdmdes[j + 1].glcml = road[izx].hdmdes[jcross].cml;
	ZDroad.hdmdes[j + 1].xjj = -road[izx].hdmdes[jcross].xjj;//初始值

	_tcscpy(ZDroad.hdmdes[j + 1].ckml, ZDroad.pm->LCchr(GH, dml, 3));

	//计算路面标高
	//1.计算左幅右幅设计标高			  

	double Zdesh = CalDesH(cml, ZDroad.ZZM, ZDroad.AllZM);
	if (ZDroad.ZcgNm > 0)
		CalLMPT(cml, Zdesh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm,
			ZDroad.Zjk, ZDroad.NZLMK, ZDroad.ZLMK, ZDroad.hdmdes[j + 1].RHFL,
			-1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

	//计算断面属性       			  
	ZDroad.hdmdes[j + 1].ZDMXZ = SetDmProperty(cml, ZDroad.pm, ZDroad.NZBri, ZDroad.ZBri,
		ZDroad.NAllBri, ZDroad.AllBri,
		ZDroad.NZTun, ZDroad.ZTun,
		ZDroad.NAllTun, ZDroad.AllTun, -1, ZDroad.hdmdes[j + 1].BriZZDK, ZDroad.hdmdes[j].ZDMXZ);

	Ydesh = CalDesH(cml, ZDroad.YZM, ZDroad.AllZM);
	if (ZDroad.YcgNm > 0)
		CalLMPT(cml, Ydesh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm,
			ZDroad.Yjk, ZDroad.NYLMK, ZDroad.YLMK, ZDroad.hdmdes[j + 1].RHFR,
			1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

	ZDroad.hdmdes[j + 1].YDMXZ = SetDmProperty(cml, ZDroad.pm, ZDroad.NYBri, ZDroad.YBri,
		ZDroad.NAllBri, ZDroad.AllBri,
		ZDroad.NYTun, ZDroad.YTun,
		ZDroad.NAllTun, ZDroad.AllTun, 1, ZDroad.hdmdes[j + 1].BriYZDK, ZDroad.hdmdes[j].YDMXZ);

	double fgdhp, fgdk;
	if (ZDroad.hdmdes[j + 1].RHFL[8]<0.001 && ZDroad.hdmdes[j + 1].RHFR[8]>0.01)
	{
		//修正
		Zdesh = ZDroad.hdmdes[j + 1].RHFR[1];
		for (k = 0; k < 5; k++)
			ZDroad.hdmdes[j + 1].RHFL[k * 2 + 1] = Zdesh;
	}
	if (ZDroad.hdmdes[j + 1].RHFR[8]<0.001 && ZDroad.hdmdes[j + 1].RHFL[8]>0.01)
	{
		//修正
		Ydesh = ZDroad.hdmdes[j + 1].RHFL[1];
		for (k = 0; k < 5; k++)
			ZDroad.hdmdes[j + 1].RHFR[k * 2 + 1] = Ydesh;
	}


	if (LorR < 0)//左侧
	{
		if (fabs(ZJ2 + 10000.0) > 0.01)
			ZDroad.hdmdes[j + 1].ZZJ = ZJ2;
		//		  else
		//			 ZDroad.hdmdes[j+1].ZZJ = fabs(ZDroad.hdmdes[j+1].RPTL[ZDroad.hdmdes[j+1].Lnpt-1].x);

	}
	else
	{
		if (fabs(ZJ2 + 10000.0) > 0.01)
			ZDroad.hdmdes[j + 1].YZJ = ZJ2;
		//		  else
		//			 ZDroad.hdmdes[j+1].YZJ =fabs(ZDroad.hdmdes[j+1].RPTR[ZDroad.hdmdes[j+1].Rnpt-1].x);
	}
	//	  ads_printf(L"ZZJ=%lf\n",ZDroad.hdmdes[j+1].ZZJ);

	DesACrossOnSingleLine(ZDroad, j + 1);

	ZDroad.hdmdes[j + 1].xjj = -road[izx].hdmdes[jcross].xjj;//初始值
	ZDroad.hdmdes[j + 1].IfHasDes = true;
	ZDroad.hdmdes[j + 1].IsInsertHdm = 1;
	ZDroad.NCRS++;
	return j + 1;
}

void HdmDes::SetDmxData(HDMDMXdata &dmx1, HDMDMXdata &dmx2)
{
	dmx1.lc = dmx2.lc;
	dmx1.BTxz = dmx2.BTxz;
	dmx1.EarH = dmx2.EarH;
	dmx1.lcflag = dmx2.lcflag;
	dmx1.YEarPtNum = dmx2.YEarPtNum;
	int i;

	if (dmx1.YEarPtAry.GetSize() > 0)
		dmx1.YEarPtAry.RemoveAll();
	for (i = 0; i < dmx2.YEarPtNum; i++)
		dmx1.YEarPtAry.Add(dmx2.YEarPtAry[i]);

	if (dmx1.ZEarPtAry.GetSize() > 0)
		dmx1.ZEarPtAry.RemoveAll();
	dmx1.ZEarPtNum = dmx2.ZEarPtNum;
	for (i = 0; i < dmx2.ZEarPtNum; i++)
		dmx1.ZEarPtAry.Add(dmx2.ZEarPtAry[i]);
}

bool HdmDes::CheckPtOnZX(AcGePoint3d InterPt1, AcGePoint3d Spt, AcGePoint3d Ept)
{
	double xmin, xmax, ymin, ymax, zmin, zmax;
	xmin = Spt.x < Ept.x ? Spt.x : Ept.x;
	xmax = Spt.x > Ept.x ? Spt.x : Ept.x;
	ymin = Spt.y < Ept.y ? Spt.y : Ept.y;
	ymax = Spt.y > Ept.y ? Spt.y : Ept.y;
	zmin = Spt.z < Ept.z ? Spt.z : Ept.z;
	zmax = Spt.z > Ept.z ? Spt.z : Ept.z;
	//   if(IfPrint)
	//ads_printf(L"###### x=%lf %lf %lf y=%lf %lf %lf z=%lf %lf %lf\n",
	//		   InterPt1.x,xmin,xmax,
	//		   InterPt1.y,ymin,ymax,
	//		   InterPt1.z,zmin,zmax);

	if (InterPt1.x<xmax + 0.0001 && InterPt1.x>xmin - 0.0001
		&& InterPt1.y<ymax + 0.0001 && InterPt1.y>ymin - 0.0001
		&& InterPt1.z<zmax + 0.0001 && InterPt1.z>zmin - 0.0001
		)
		return true;

	return false;
}

void HdmDes::CalLinkHdm_TWPJD(int i, int j, int LorR1, int iroad, int jcross)//设计左挖至右挖
{
	double z1, z2, z, dis1, dis2;
	double ljpt1[2], ljpt2[2], mpt[2];
	if (LorR1 < 0)//i线左侧
	{
		//1.计算i设计标高,iroad设计标高

		z1 = road[i].hdmdes[j].RHFL[9];
		z2 = road[iroad].hdmdes[jcross].RHFR[9];
		z = 0.5*(z1 + z2);
		//2.计算路肩点大地坐标,
		// 		xlpoint PZ;
		// 		PZ.lc = road[i].hdmdes[j].cml;
		// 		road[i].pm->xlpoint_pz(&PZ);
		// 		mpt[0]=PZ.x,mpt[1]=PZ.y;
		// 		ljpt1[0] = mpt[0] + road[i].hdmdes[j].RHFL[8] * cos(PZ.a-0.5*pi);
		// 		ljpt1[1] = mpt[1] + road[i].hdmdes[j].RHFL[8] * sin(PZ.a-0.5*pi);
		// 		
		// 		PZ.lc = road[iroad].hdmdes[jcross].cml;
		// 		road[iroad].pm->xlpoint_pz(&PZ);
		// 		mpt[0]=PZ.x,mpt[1]=PZ.y;
		// 		ljpt2[0] = mpt[0] + road[iroad].hdmdes[jcross].RHFR[8] * cos(PZ.a+0.5*pi);
		// 		ljpt2[1] = mpt[1] + road[iroad].hdmdes[jcross].RHFR[8] * sin(PZ.a+0.5*pi);
		// 		//3.计算中点大地坐标,
		// 		mpt[0] = 0.5*(ljpt1[0]+ljpt2[0]);
		// 		mpt[1] = 0.5*(ljpt1[1]+ljpt2[1]);
		// 		//4.计算中点到两侧路肩点距离
		//         dis1 = sqrt((mpt[0]-ljpt1[0])*(mpt[0]-ljpt1[0])+(mpt[1]-ljpt1[1])*(mpt[1]-ljpt1[1]));
		// 		dis2 = sqrt((mpt[0]-ljpt2[0])*(mpt[0]-ljpt2[0])+(mpt[1]-ljpt2[1])*(mpt[1]-ljpt2[1]));
		// 		//5. PJPT付值
		// 		if(road[i].hdmdes[j].xjj>-1.0e-6)
		// 		{
		// 			dis1=dis2=0.0;
		// 		}

		//////////////////////////////////////////////////////////////////////////
		//考虑路基中线与线路中线不重合(修改)
		xlpoint PZ;
		PZ.lc = road[i].hdmdes[j].cml;
		road[i].pm->xlpoint_pz(&PZ);
		mpt[0] = PZ.x, mpt[1] = PZ.y;
		//		CalOffsetByXLZX(PZ.lc,road[i].NZLMK,road[i].ZLMK,OffsetByXLZX);

		ljpt1[0] = mpt[0] + (-1.0 * road[i].hdmdes[j].RHFL[8] + road[i].hdmdes[j].OffsetByXLZX) * cos(PZ.a + 0.5*pi);
		ljpt1[1] = mpt[1] + (-1.0 * road[i].hdmdes[j].RHFL[8] + road[i].hdmdes[j].OffsetByXLZX) * sin(PZ.a + 0.5*pi);

		PZ.lc = road[iroad].hdmdes[jcross].cml;
		road[iroad].pm->xlpoint_pz(&PZ);
		mpt[0] = PZ.x, mpt[1] = PZ.y;
		ljpt2[0] = mpt[0] + (road[iroad].hdmdes[jcross].RHFR[8] + road[iroad].hdmdes[jcross].OffsetByXLZX) * cos(PZ.a + 0.5*pi);
		ljpt2[1] = mpt[1] + (road[iroad].hdmdes[jcross].RHFR[8] + road[iroad].hdmdes[jcross].OffsetByXLZX) * sin(PZ.a + 0.5*pi);
		//3.计算中点大地坐标,
		mpt[0] = 0.5*(ljpt1[0] + ljpt2[0]);
		mpt[1] = 0.5*(ljpt1[1] + ljpt2[1]);
		//4.计算中点到两侧路肩点距离
		dis1 = sqrt((mpt[0] - ljpt1[0])*(mpt[0] - ljpt1[0]) + (mpt[1] - ljpt1[1])*(mpt[1] - ljpt1[1]));
		dis2 = sqrt((mpt[0] - ljpt2[0])*(mpt[0] - ljpt2[0]) + (mpt[1] - ljpt2[1])*(mpt[1] - ljpt2[1]));
		//5. PJPT付值
		if (road[i].hdmdes[j].xjj > -1.0e-6)
		{
			dis1 = dis2 = 0.0;
		}

		road[i].hdmdes[j].ZPJPT[0] = road[i].hdmdes[j].RHFL[8] + dis1;
		road[i].hdmdes[j].ZPJPT[1] = z;
		road[iroad].hdmdes[jcross].YPJPT[0] = road[iroad].hdmdes[jcross].RHFR[8] + dis2;
		road[iroad].hdmdes[jcross].YPJPT[1] = z;

	}
	else
	{
		//1.计算i设计标高,iroad设计标高
		z1 = road[i].hdmdes[j].RHFR[7];
		z2 = road[iroad].hdmdes[jcross].RHFL[9];
		z = 0.5*(z1 + z2);
		//2.计算路肩点大地坐标,
		// 		xlpoint PZ;
		// 		PZ.lc = road[i].hdmdes[j].cml;
		// 		road[i].pm->xlpoint_pz(&PZ);
		// 		mpt[0]=PZ.x,mpt[1]=PZ.y;
		// 		ljpt1[0] = mpt[0] + road[i].hdmdes[j].RHFR[8] * cos(PZ.a+0.5*pi);
		// 		ljpt1[1] = mpt[1] + road[i].hdmdes[j].RHFR[8] * sin(PZ.a+0.5*pi);
		// 		
		// 		PZ.lc = road[iroad].hdmdes[jcross].cml;
		// 		road[iroad].pm->xlpoint_pz(&PZ);
		// 		mpt[0]=PZ.x,mpt[1]=PZ.y;
		// 		ljpt2[0] = mpt[0] + road[iroad].hdmdes[jcross].RHFL[8] * cos(PZ.a-0.5*pi);
		// 		ljpt2[1] = mpt[1] + road[iroad].hdmdes[jcross].RHFL[8] * sin(PZ.a-0.5*pi);
		// 		//3.计算中点大地坐标,
		// 		mpt[0] = 0.5*(ljpt1[0]+ljpt2[0]);
		// 		mpt[1] = 0.5*(ljpt1[1]+ljpt2[1]);
		// 		//4.计算中点到两侧路肩点距离
		//         dis1 = sqrt((mpt[0]-ljpt1[0])*(mpt[0]-ljpt1[0])+(mpt[1]-ljpt1[1])*(mpt[1]-ljpt1[1]));
		// 		dis2 = sqrt((mpt[0]-ljpt2[0])*(mpt[0]-ljpt2[0])+(mpt[1]-ljpt2[1])*(mpt[1]-ljpt2[1]));
		// 		//5. PJPT付值
		// 		if(road[i].hdmdes[j].xjj<1.0e-6)
		// 		{
		// 			dis1=dis2=0.0;
		// 		}

		//////////////////////////////////////////////////////////////////////////
		//考虑路基中线与线路中线不重合(修改)
		xlpoint PZ;
		PZ.lc = road[i].hdmdes[j].cml;
		road[i].pm->xlpoint_pz(&PZ);
		mpt[0] = PZ.x, mpt[1] = PZ.y;
		//		CalOffsetByXLZX(PZ.lc,road[i].NYLMK,road[i].YLMK,OffsetByXLZX);
		ljpt1[0] = mpt[0] + (road[i].hdmdes[j].RHFR[8] + road[i].hdmdes[j].OffsetByXLZX) * cos(PZ.a + 0.5*pi);
		ljpt1[1] = mpt[1] + (road[i].hdmdes[j].RHFR[8] + road[i].hdmdes[j].OffsetByXLZX) * sin(PZ.a + 0.5*pi);

		PZ.lc = road[iroad].hdmdes[jcross].cml;
		road[iroad].pm->xlpoint_pz(&PZ);
		mpt[0] = PZ.x, mpt[1] = PZ.y;
		ljpt2[0] = mpt[0] + (-1.0 * road[iroad].hdmdes[jcross].RHFL[8] + road[iroad].hdmdes[jcross].OffsetByXLZX) * cos(PZ.a + 0.5*pi);
		ljpt2[1] = mpt[1] + (-1.0 * road[iroad].hdmdes[jcross].RHFL[8] + road[iroad].hdmdes[jcross].OffsetByXLZX) * sin(PZ.a + 0.5*pi);
		//3.计算中点大地坐标,
		mpt[0] = 0.5*(ljpt1[0] + ljpt2[0]);
		mpt[1] = 0.5*(ljpt1[1] + ljpt2[1]);
		//4.计算中点到两侧路肩点距离
		dis1 = sqrt((mpt[0] - ljpt1[0])*(mpt[0] - ljpt1[0]) + (mpt[1] - ljpt1[1])*(mpt[1] - ljpt1[1]));
		dis2 = sqrt((mpt[0] - ljpt2[0])*(mpt[0] - ljpt2[0]) + (mpt[1] - ljpt2[1])*(mpt[1] - ljpt2[1]));
		//5. PJPT付值
		if (road[i].hdmdes[j].xjj < 1.0e-6)
		{
			dis1 = dis2 = 0.0;
		}
		road[i].hdmdes[j].YPJPT[0] = road[i].hdmdes[j].RHFR[6] + dis1;
		road[i].hdmdes[j].YPJPT[1] = z;
		road[iroad].hdmdes[jcross].ZPJPT[0] = road[iroad].hdmdes[jcross].RHFL[8] + dis2;
		road[iroad].hdmdes[jcross].ZPJPT[1] = z;

	}
}

void HdmDes::CalLinkHdm_TWPJD(int i, int j, int LorR1, RoadHdmdata &ZDroad, int jcross)//设计左挖至右挖
{
	double z1, z2, z, dis1, dis2;
	double ljpt1[2], ljpt2[2], mpt[2];
	if (LorR1 < 0)//i线左侧
	{
		//1.计算i设计标高,iroad设计标高
		z1 = road[i].hdmdes[j].RHFL[9];
		z2 = ZDroad.hdmdes[jcross].RHFR[9];
		z = 0.5*(z1 + z2);
		//2.计算路肩点大地坐标,
		xlpoint PZ;
		PZ.lc = road[i].hdmdes[j].cml;
		road[i].pm->xlpoint_pz(&PZ);
		mpt[0] = PZ.x, mpt[1] = PZ.y;
		ljpt1[0] = mpt[0] + road[i].hdmdes[j].RHFL[8] * cos(PZ.a - 0.5*pi);
		ljpt1[1] = mpt[1] + road[i].hdmdes[j].RHFL[8] * sin(PZ.a - 0.5*pi);

		PZ.lc = ZDroad.hdmdes[jcross].cml;
		ZDroad.pm->xlpoint_pz(&PZ);
		mpt[0] = PZ.x, mpt[1] = PZ.y;
		ljpt2[0] = mpt[0] + ZDroad.hdmdes[jcross].RHFR[8] * cos(PZ.a + 0.5*pi);
		ljpt2[1] = mpt[1] + ZDroad.hdmdes[jcross].RHFR[8] * sin(PZ.a + 0.5*pi);
		//3.计算中点大地坐标,
		mpt[0] = 0.5*(ljpt1[0] + ljpt2[0]);
		mpt[1] = 0.5*(ljpt1[1] + ljpt2[1]);
		//4.计算中点到两侧路肩点距离
		dis1 = sqrt((mpt[0] - ljpt1[0])*(mpt[0] - ljpt1[0]) + (mpt[1] - ljpt1[1])*(mpt[1] - ljpt1[1]));
		dis2 = sqrt((mpt[0] - ljpt2[0])*(mpt[0] - ljpt2[0]) + (mpt[1] - ljpt2[1])*(mpt[1] - ljpt2[1]));
		//5. PJPT付值
		road[i].hdmdes[j].ZPJPT[0] = road[i].hdmdes[j].RHFL[8] + dis1;
		road[i].hdmdes[j].ZPJPT[1] = z;
		ZDroad.hdmdes[jcross].YPJPT[0] = ZDroad.hdmdes[jcross].RHFR[8] + dis2;
		ZDroad.hdmdes[jcross].YPJPT[1] = z;

	}
	else
	{
		//1.计算i设计标高,iroad设计标高
		z1 = road[i].hdmdes[j].RHFR[9];
		z2 = ZDroad.hdmdes[jcross].RHFL[9];
		z = 0.5*(z1 + z2);
		//2.计算路肩点大地坐标,
		xlpoint PZ;
		PZ.lc = road[i].hdmdes[j].cml;
		road[i].pm->xlpoint_pz(&PZ);
		mpt[0] = PZ.x, mpt[1] = PZ.y;
		ljpt1[0] = mpt[0] + road[i].hdmdes[j].RHFR[8] * cos(PZ.a + 0.5*pi);
		ljpt1[1] = mpt[1] + road[i].hdmdes[j].RHFR[8] * sin(PZ.a + 0.5*pi);

		PZ.lc = ZDroad.hdmdes[jcross].cml;
		ZDroad.pm->xlpoint_pz(&PZ);
		mpt[0] = PZ.x, mpt[1] = PZ.y;
		ljpt2[0] = mpt[0] + ZDroad.hdmdes[jcross].RHFL[8] * cos(PZ.a - 0.5*pi);
		ljpt2[1] = mpt[1] + ZDroad.hdmdes[jcross].RHFL[8] * sin(PZ.a - 0.5*pi);
		//3.计算中点大地坐标,
		mpt[0] = 0.5*(ljpt1[0] + ljpt2[0]);
		mpt[1] = 0.5*(ljpt1[1] + ljpt2[1]);
		//4.计算中点到两侧路肩点距离
		dis1 = sqrt((mpt[0] - ljpt1[0])*(mpt[0] - ljpt1[0]) + (mpt[1] - ljpt1[1])*(mpt[1] - ljpt1[1]));
		dis2 = sqrt((mpt[0] - ljpt2[0])*(mpt[0] - ljpt2[0]) + (mpt[1] - ljpt2[1])*(mpt[1] - ljpt2[1]));
		//5. PJPT付值
		road[i].hdmdes[j].YPJPT[0] = road[i].hdmdes[j].RHFR[8] + dis1;
		road[i].hdmdes[j].YPJPT[1] = z;
		ZDroad.hdmdes[jcross].ZPJPT[0] = ZDroad.hdmdes[jcross].RHFL[8] + dis2;
		ZDroad.hdmdes[jcross].ZPJPT[1] = z;
	}
}

//计算匝道的路面标高，以及与主线的连接点
void HdmDes::CalBDZDDesH(RoadHdmdata &ZXroad, double zxcml, double &CmlOnFLD, double xjj, RoadHdmdata &ZDroad, double RHFL[10], double RHFR[10], double ZX_RHFL[10], double ZX_RHFR[10])
{
	//1.判别是分流还是汇流
	CString xl1, xl2;
	int qorh;
	double YljNose, zxhp, zxdesh, dtmp, fldcmlonzd, flddmlonzd, bddmlonzd;
	int TorF;
	double dis;
	xlpoint PZ;
	double pt[2];
	double newpt[2], newwd, newml;
	double LinkPt[2];
	PZ.lc = zxcml;
	ZXroad.pm->xlpoint_pz(&PZ);

	xl1.Format(L"%s,%s", ZXroad.pm->mdbname, ZXroad.pm->RoadName);
	xl2.Format(L"%s,%s", ZDroad.pm->mdbname, ZDroad.pm->RoadName);

	if (FindWichNoseAndProperty(xl1, xl2, CmlOnFLD, ZDroad.pm, qorh, YljNose, TorF, flddmlonzd, bddmlonzd))
	{
		if (xjj > 0.0001)//右线分离
		{
			//1.计算主线标高及横坡
			zxdesh = CalDesH(zxcml, ZXroad.YZM, ZXroad.AllZM);
			CalLMHP(zxcml, ZXroad.YcgNm, ZXroad.Ycg, zxhp, dtmp);
		}
		else
		{
			//1.计算主线标高及横坡
			zxdesh = CalDesH(zxcml, ZXroad.ZZM, ZXroad.AllZM);
			CalLMHP(zxcml, ZXroad.ZcgNm, ZXroad.Zcg, zxhp, dtmp);
		}
		if (TorF < 0)
		{
			//计算出同坡向反坡变化的里程
			fldcmlonzd = CalTPtoFPML(bddmlonzd, qorh, ZDroad, xjj);
			if (fldcmlonzd < 0)
				fldcmlonzd = ZDroad.pm->TYLC(flddmlonzd);
			if (qorh == 0 && CmlOnFLD<fldcmlonzd + 0.001 || qorh == 1 && CmlOnFLD>fldcmlonzd - 0.001)//分流鼻
				TorF = 1;
		}

		if (TorF > 0)//同坡
		{
			//依据xjj,计算路面点标高
			if (xjj > -0.001)//匝道在右侧,主线右侧路面延伸到匝道中心，匝道左侧路面计算到匝道中线
			{
				//匝道左侧路面计算到中线
				CalLMPT(CmlOnFLD, zxdesh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm,
					ZDroad.Zjk, ZDroad.NZLMK, ZDroad.ZLMK, RHFL,
					-1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);
				int j;
				for (j = 0; j < 5; j++)
				{
					RHFL[j * 2] = 0.0;
					RHFL[j * 2 + 1] = zxdesh + zxhp * 0.01*fabs(xjj);
				}

				//匝道右侧路面计算到中线
				CalLMPT(CmlOnFLD, zxdesh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm,
					ZDroad.Yjk, ZDroad.NYLMK, ZDroad.YLMK, RHFR,
					1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);
				//计算直线与右侧各路面线的交点,修正宽度
				for (j = 0; j < 5; j++)
				{
					if (ZDroad.pm->CalPXXJD(CmlOnFLD, PZ.a + 0.5*PI, RHFR[j * 2], newpt, newml, newwd))
						RHFR[j * 2] = newwd;
					RHFR[j * 2 + 1] = zxdesh + zxhp * 0.01*(fabs(xjj) + RHFR[j * 2]);
				}

				double tljhp;
				int itmp;
				CalLMK_JK(CmlOnFLD, ZDroad.NYLMK, ZDroad.YLMK, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm, ZDroad.Yjk, dtmp, dtmp, dtmp, dtmp, dtmp, tljhp, itmp, itmp);
				RHFR[4 * 2 + 1] = RHFR[3 * 2 + 1] - tljhp * 0.01*fabs(RHFR[4 * 2] - RHFR[3 * 2]);
				//与主线的连接点
				xlpoint PZ;
				PZ.lc = CmlOnFLD;
				ZDroad.pm->xlpoint_pz(&PZ);
				LinkPt[0] = PZ.x;
				LinkPt[1] = PZ.y;

				//修正主线右侧路面点
				PZ.lc = zxcml;
				ZXroad.pm->xlpoint_pz(&PZ);
				double wd;
				wd = sqrt((PZ.x - LinkPt[0])*(PZ.x - LinkPt[0]) + (PZ.y - LinkPt[1])*(PZ.y - LinkPt[1]));
				ZX_RHFR[4 * 2] = wd;
				ZX_RHFR[4 * 2 + 1] = RHFL[1];
				ZX_RHFR[3 * 2] = wd;
				ZX_RHFR[3 * 2 + 1] = RHFL[1];
				if (ZX_RHFR[2 * 2] > wd)
				{
					ZX_RHFR[2 * 2] = wd;
					ZX_RHFR[2 * 2 + 1] = RHFL[1];
				}
			}
			else
			{
				//匝道右侧路面计算到中线
				CalLMPT(CmlOnFLD, zxdesh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm,
					ZDroad.Yjk, ZDroad.NYLMK, ZDroad.YLMK, RHFR,
					-1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);
				int j;
				for (j = 0; j < 5; j++)
				{
					RHFR[j * 2] = 0.0;
					RHFR[j * 2 + 1] = zxdesh + zxhp * 0.01*fabs(xjj);
				}

				CalLMPT(CmlOnFLD, zxdesh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm,
					ZDroad.Zjk, ZDroad.NZLMK, ZDroad.ZLMK, RHFL,
					1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

				for (j = 0; j < 5; j++)
				{
					//计算直线与左侧各路面线的交点,并依据主线方位角修正宽度
					if (ZDroad.pm->CalPXXJD(CmlOnFLD, PZ.a - 0.5*PI, RHFL[j * 2], newpt, newml, newwd))
						RHFL[j * 2] = newwd;
					RHFL[j * 2 + 1] = zxdesh + zxhp * 0.01*(fabs(xjj) + RHFL[j * 2]);
				}


				double tljhp;
				int itmp;
				CalLMK_JK(CmlOnFLD, ZDroad.NZLMK, ZDroad.ZLMK, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm, ZDroad.Zjk, dtmp, dtmp, dtmp, dtmp, dtmp, tljhp, itmp, itmp);
				RHFL[4 * 2 + 1] = RHFL[3 * 2 + 1] - tljhp * 0.01*fabs(RHFL[4 * 2] - RHFL[3 * 2]);

				xlpoint PZ;
				PZ.lc = CmlOnFLD;
				ZDroad.pm->xlpoint_pz(&PZ);
				LinkPt[0] = PZ.x;
				LinkPt[1] = PZ.y;


				//修正主线左侧路面点
				PZ.lc = zxcml;
				ZXroad.pm->xlpoint_pz(&PZ);
				double wd;
				wd = sqrt((PZ.x - LinkPt[0])*(PZ.x - LinkPt[0]) + (PZ.y - LinkPt[1])*(PZ.y - LinkPt[1]));
				ZX_RHFL[4 * 2] = wd;
				ZX_RHFL[4 * 2 + 1] = RHFR[1];
				ZX_RHFL[3 * 2] = wd;
				ZX_RHFL[3 * 2 + 1] = RHFR[1];
				if (ZX_RHFL[2 * 2] > wd)//车道超过wd才修正
				{
					ZX_RHFL[2 * 2] = wd;
					ZX_RHFL[2 * 2 + 1] = RHFR[1];
				}

			}
		}
		else//若与主线反坡,各自垂直于自身中线
		{
			//以匝道行车道边线为界,取各自横坡
			CalLMPT(CmlOnFLD, zxdesh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm,
				ZDroad.Zjk, ZDroad.NZLMK, ZDroad.ZLMK, RHFL,
				-1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

			CalLMPT(CmlOnFLD, zxdesh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm,
				ZDroad.Yjk, ZDroad.NYLMK, ZDroad.YLMK, RHFR,
				-1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

			if (xjj > -0.001)//匝道在右侧,主线右侧路面延伸到匝道左侧行车道边线
			{
				//计算左侧主线 与 匝道分界点newpt
				if (ZDroad.pm->CalPXXJD(CmlOnFLD, PZ.a + 1.5*PI, RHFL[2 * 2], newpt, newml, newwd))
				{
					LinkPt[0] = newpt[0], LinkPt[1] = newpt[1];
					//计算匝道投影里程,并修正里程
					CmlOnFLD = ZDroad.pm->PROJ_ML(LinkPt[0], LinkPt[1]);
					//修正左侧路面宽度 
					RHFL[3 * 2] = RHFL[4 * 2] = RHFL[2 * 2];

					CalLMPT(CmlOnFLD, zxdesh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm,
						ZDroad.Yjk, ZDroad.NYLMK, ZDroad.YLMK, RHFR,
						-1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

					//修正主线右侧路面点
					PZ.lc = zxcml;
					ZXroad.pm->xlpoint_pz(&PZ);
					double wd;
					wd = sqrt((PZ.x - LinkPt[0])*(PZ.x - LinkPt[0]) + (PZ.y - LinkPt[1])*(PZ.y - LinkPt[1]));
					ZX_RHFR[4 * 2] = wd;
					ZX_RHFR[4 * 2 + 1] = zxdesh + 0.01*zxhp*wd;
					ZX_RHFR[3 * 2] = wd;
					ZX_RHFR[3 * 2 + 1] = zxdesh + 0.01*zxhp*wd;
					if (ZX_RHFR[2 * 2] > wd)
					{
						ZX_RHFR[2 * 2] = wd;
						ZX_RHFR[2 * 2 + 1] = zxdesh + 0.01*zxhp*wd;
					}

				}
			}
			else
			{
				//计算右侧主线 与 匝道分界点newpt
				if (ZDroad.pm->CalPXXJD(CmlOnFLD, PZ.a + 0.5*PI, RHFR[2 * 2], newpt, newml, newwd))
				{
					LinkPt[0] = newpt[0], LinkPt[1] = newpt[1];
					//计算匝道投影里程,并修正里程
					CmlOnFLD = ZDroad.pm->PROJ_ML(LinkPt[0], LinkPt[1]);
					//修正左侧路面宽度 标高
					RHFR[3 * 2] = RHFR[4 * 2] = RHFR[2 * 2];

					CalLMPT(CmlOnFLD, zxdesh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm,
						ZDroad.Zjk, ZDroad.NZLMK, ZDroad.ZLMK, RHFL,
						-1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);

					//修正主线左侧路面点
					PZ.lc = zxcml;
					ZXroad.pm->xlpoint_pz(&PZ);
					double wd;
					wd = sqrt((PZ.x - LinkPt[0])*(PZ.x - LinkPt[0]) + (PZ.y - LinkPt[1])*(PZ.y - LinkPt[1]));
					ZX_RHFL[4 * 2] = wd;
					ZX_RHFL[4 * 2 + 1] = zxdesh + 0.01*zxhp*wd;
					ZX_RHFL[3 * 2] = wd;
					ZX_RHFL[3 * 2 + 1] = zxdesh + 0.01*zxhp*wd;
					if (ZX_RHFL[2 * 2] > wd)
					{
						ZX_RHFL[2 * 2] = wd;
						ZX_RHFL[2 * 2 + 1] = zxdesh + 0.01*zxhp*wd;
					}

				}


			}

			//计算路面标高	
			PZ.lc = CmlOnFLD;
			ZDroad.pm->xlpoint_pz(&PZ);
			for (int j = 0; j < 5; j++)
			{
				pt[0] = PZ.x + RHFL[j * 2] * cos(PZ.a - 0.5*PI);
				pt[1] = PZ.y + RHFL[j * 2] * sin(PZ.a - 0.5*PI);
				RHFL[j * 2 + 1] = CalZDFPDesH(pt[0], pt[1], ZDroad, 0);

				pt[0] = PZ.x + RHFR[j * 2] * cos(PZ.a + 0.5*PI);
				pt[1] = PZ.y + RHFR[j * 2] * sin(PZ.a + 0.5*PI);
				RHFR[j * 2 + 1] = CalZDFPDesH(pt[0], pt[1], ZDroad, 0);
			}
		}
	}
	else
	{
		ads_printf(L"请先计算%s-%s鼻端里程!\n", xl1, xl2);
		//按照纵坡左右路面点计算
	}

}
//给出主线pm,里程，线间距，匝道左右路面边侧,匝道pm,计算匝道中心线与主线路面线的交点pt
void HdmDes::CalZDLMX_JD(JD_CENTER *zxpm, double cmlonzx, JD_CENTER *zdpm, double cmlonzd, double xjj, int LorR, double dis, double pt[2], double &wd)
{
	//1计算直线
	double spt[2], ept[2], dis1, dis2, mdis, xpt[2], mpt[2];
	xlpoint PZ;
	double projml;
	int ZYinf;

	ZYinf = 1;
	if (xjj > 0.0001)//匝道在主线右侧
	{
		if (LorR < 0)//求左侧路面
			ZYinf = 1;
		else
			ZYinf = -1;
	}
	else
	{
		if (LorR > 0)//求左侧路面
			ZYinf = 1;
		else
			ZYinf = -1;
	}
	if (ZYinf > 0)
	{
		//先计算匝道左侧
		PZ.lc = cmlonzx;
		zxpm->xlpoint_pz(&PZ);
		ept[0] = PZ.x, ept[1] = PZ.y;
		projml = zdpm->PROJ_ML(ept[0], ept[1]);
		PZ.lc = projml;
		zdpm->xlpoint_pz(&PZ);
		xpt[0] = PZ.x, xpt[1] = PZ.y;
		dis2 = sqrt((xpt[0] - ept[0])*(xpt[0] - ept[0]) + (xpt[1] - ept[1])*(xpt[1] - ept[1]));

		dis1 = 0.0;
		PZ.lc = cmlonzd;
		zdpm->xlpoint_pz(&PZ);
		spt[0] = PZ.x, spt[1] = PZ.y;
	}
	else//求异侧路面
	{

		//先计算匝道左侧
		PZ.lc = cmlonzd;
		zdpm->xlpoint_pz(&PZ);
		spt[0] = PZ.x, spt[1] = PZ.y;
		dis1 = 0.0;

		xlpoint PZ1;
		PZ1.lc = cmlonzx;
		zxpm->xlpoint_pz(&PZ1);
		if (LorR > 0)
		{
			ept[0] = spt[0] + 100.0*cos(PZ1.a + 0.5*pi);
			ept[1] = spt[1] + 100.0*sin(PZ1.a + 0.5*pi);
		}
		else
		{
			ept[0] = spt[0] + 100.0*cos(PZ1.a - 0.5*pi);
			ept[1] = spt[1] + 100.0*sin(PZ1.a - 0.5*pi);
		}

		//		projml=zdpm->PROJ_ML(ept[0],ept[1]);
		//		PZ.lc = projml;
		//		zdpm->xlpoint_pz(&PZ);
		//		xpt[0]=PZ.x,xpt[1]=PZ.y;
		//		dis2 = sqrt((xpt[0]-ept[0])*(xpt[0]-ept[0])+(xpt[1]-ept[1])*(xpt[1]-ept[1]));
		//		sml = projml;
	}
	mpt[0] = 0.5*(spt[0] + ept[0]);
	mpt[1] = 0.5*(spt[1] + ept[1]);
	projml = zdpm->PROJ_ML(mpt[0], mpt[1]);
	PZ.lc = projml;
	zdpm->xlpoint_pz(&PZ);
	xpt[0] = PZ.x, xpt[1] = PZ.y;
	mdis = sqrt((xpt[0] - mpt[0])*(xpt[0] - mpt[0]) + (xpt[1] - mpt[1])*(xpt[1] - mpt[1]));

	double xdis = 50.0;

	while (fabs(mdis - dis) > 0.0001 && xdis > 0.0001)
	{
		if (mdis > dis)
			ept[0] = mpt[0], ept[1] = mpt[1];
		else
			spt[0] = mpt[0], spt[1] = mpt[1];
		mpt[0] = 0.5*(spt[0] + ept[0]);
		mpt[1] = 0.5*(spt[1] + ept[1]);
		projml = zdpm->PROJ_ML(mpt[0], mpt[1]);
		PZ.lc = projml;
		zdpm->xlpoint_pz(&PZ);
		xpt[0] = PZ.x, xpt[1] = PZ.y;
		mdis = sqrt((xpt[0] - mpt[0])*(xpt[0] - mpt[0]) + (xpt[1] - mpt[1])*(xpt[1] - mpt[1]));
		xdis = sqrt((spt[0] - ept[0])*(spt[0] - ept[0]) + (spt[1] - ept[1])*(spt[1] - ept[1]));

	}

	if (fabs(mdis - dis) < 0.001)
	{
		pt[0] = mpt[0], pt[1] = mpt[1];
		PZ.lc = cmlonzd;
		zdpm->xlpoint_pz(&PZ);
		spt[0] = PZ.x, spt[1] = PZ.y;
		wd = sqrt((spt[0] - pt[0])*(spt[0] - pt[0]) + (spt[1] - pt[1])*(spt[1] - pt[1]));
	}
	else
	{
		wd = dis;
		PZ.lc = cmlonzd;
		zdpm->xlpoint_pz(&PZ);
		pt[0] = PZ.x + wd * cos(PZ.a + LorR * 0.5*pi);
		pt[1] = PZ.y + wd * sin(PZ.a + LorR * 0.5*pi);
	}

	//	ads_printf(L"mdis=%lf dis=%lf xdis=%lf pt=%lf %lf spt=%lf %lf %lf\n",mdis,dis,xdis,pt[0],pt[1],spt[0],spt[1],wd);
}
//给定匝道里程,求出拱顶点，主线对应里程
void HdmDes::CalGDPt(double cmlonzd, RoadHdmdata &ZDroad, int izx, double xjj, double pt[2], double &zxcml)
{
	xlpoint PZ, zdPZ;
	JD_CENTER *zxpm, *zdpm;
	zxpm = road[izx].pm;
	zdpm = ZDroad.pm;

	zdPZ.lc = cmlonzd;
	zdpm->xlpoint_pz(&zdPZ);
	double spt[2], ept[2], mpt[2], fwj;
	spt[0] = zdPZ.x, spt[1] = zdPZ.y, fwj = zdPZ.a;
	double desh = 0;
	double ZX_RHF[10], ZD_RHF[10];
	double zxlmk, zdlmk;
	double dis1, dis2, cmlonzx;
	double wd;
	double xdis = 1;

	if (fabs(xjj) < 0.001)
	{
		pt[0] = spt[0], pt[1] = spt[1];
		zxcml = road[izx].pm->PROJ_ML(pt[0], pt[1]);
		return;
	}

	if (xjj > 0.0001)//匝道在右侧
	{
		CalLMPT(cmlonzd, desh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm,
			ZDroad.Zjk, ZDroad.NZLMK, ZDroad.ZLMK, ZD_RHF,
			-1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);
		zdlmk = ZD_RHF[8];

		ZDroad.pm->CalJD_ZX_XL(spt, fwj - 0.5*pi, ept, cmlonzx);
		CalLMPT(cmlonzx, desh, road[izx].YcgNm, road[izx].Ycg, road[izx].YjkNm,
			road[izx].Yjk, road[izx].NYLMK, road[izx].YLMK, ZX_RHF,
			1, road[izx].BxNum, road[izx].pBXArr, road[izx].pm);
		CalZDLMX_JD(ZDroad.pm, cmlonzd, road[izx].pm, cmlonzx, -xjj, 1, ZX_RHF[8], ept, wd);
		dis1 = sqrt((zdPZ.x - ept[0])*(zdPZ.x - ept[0]) + (zdPZ.y - ept[1])*(zdPZ.y - ept[1])) - zdlmk;

		zxcml = zxpm->PROJ_ML(ept[0], ept[1]);
		CalLMPT(zxcml, desh, road[izx].YcgNm, road[izx].Ycg, road[izx].YjkNm,
			road[izx].Yjk, road[izx].NYLMK, road[izx].YLMK, ZX_RHF,
			1, road[izx].BxNum, road[izx].pBXArr, road[izx].pm);
		zxlmk = ZX_RHF[8];
		PZ.lc = zxcml;
		zxpm->xlpoint_pz(&PZ);
		dis2 = sqrt((PZ.x - ept[0])*(PZ.x - ept[0]) + (PZ.y - ept[1])*(PZ.y - ept[1])) - zxlmk;
		double xdis = 1;
		while (fabs(dis1 - dis2) > 0.0001 && xdis > 0.0001)
		{
			mpt[0] = 0.5*(spt[0] + ept[0]), mpt[1] = 0.5*(spt[1] + ept[1]);
			dis1 = sqrt((zdPZ.x - mpt[0])*(zdPZ.x - mpt[0]) + (zdPZ.y - mpt[1])*(zdPZ.y - mpt[1])) - zdlmk;

			zxcml = zxpm->PROJ_ML(mpt[0], mpt[1]);
			CalLMPT(zxcml, desh, road[izx].YcgNm, road[izx].Ycg, road[izx].YjkNm,
				road[izx].Yjk, road[izx].NYLMK, road[izx].YLMK, ZX_RHF,
				1, road[izx].BxNum, road[izx].pBXArr, road[izx].pm);
			zxlmk = ZX_RHF[8];
			PZ.lc = zxcml;
			zxpm->xlpoint_pz(&PZ);
			dis2 = sqrt((PZ.x - mpt[0])*(PZ.x - mpt[0]) + (PZ.y - mpt[1])*(PZ.y - mpt[1])) - zxlmk;

			if (dis1 > dis2)
			{
				ept[0] = mpt[0], ept[1] = mpt[1];
			}
			else
			{
				spt[0] = mpt[0], spt[1] = mpt[1];
			}
			xdis = sqrt((spt[0] - ept[0])*(spt[0] - ept[0]) + (spt[1] - ept[1])*(spt[1] - ept[1]));
		}
	}
	else
	{
		CalLMPT(cmlonzd, desh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm,
			ZDroad.Yjk, ZDroad.NYLMK, ZDroad.YLMK, ZD_RHF,
			1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);
		zdlmk = ZD_RHF[8];

		ZDroad.pm->CalJD_ZX_XL(spt, fwj + 0.5*pi, ept, cmlonzx);
		CalLMPT(cmlonzx, desh, road[izx].ZcgNm, road[izx].Zcg, road[izx].ZjkNm,
			road[izx].Zjk, road[izx].NZLMK, road[izx].ZLMK, ZX_RHF,
			-1, road[izx].BxNum, road[izx].pBXArr, road[izx].pm);
		CalZDLMX_JD(ZDroad.pm, cmlonzd, road[izx].pm, cmlonzx, -xjj, -1, ZX_RHF[8], ept, wd);
		dis1 = sqrt((zdPZ.x - ept[0])*(zdPZ.x - ept[0]) + (zdPZ.y - ept[1])*(zdPZ.y - ept[1])) - zdlmk;

		zxcml = zxpm->PROJ_ML(ept[0], ept[1]);
		CalLMPT(zxcml, desh, road[izx].ZcgNm, road[izx].Zcg, road[izx].ZjkNm,
			road[izx].Zjk, road[izx].NZLMK, road[izx].ZLMK, ZX_RHF,
			-1, road[izx].BxNum, road[izx].pBXArr, road[izx].pm);
		zxlmk = ZX_RHF[8];
		PZ.lc = zxcml;
		zxpm->xlpoint_pz(&PZ);
		dis2 = sqrt((PZ.x - ept[0])*(PZ.x - ept[0]) + (PZ.y - ept[1])*(PZ.y - ept[1])) - zxlmk;

		while (fabs(dis1 - dis2) > 0.0001  && xdis > 0.0001)
		{
			mpt[0] = 0.5*(spt[0] + ept[0]), mpt[1] = 0.5*(spt[1] + ept[1]);
			dis1 = sqrt((zdPZ.x - mpt[0])*(zdPZ.x - mpt[0]) + (zdPZ.y - mpt[1])*(zdPZ.y - mpt[1])) - zdlmk;

			zxcml = zxpm->PROJ_ML(mpt[0], mpt[1]);
			CalLMPT(zxcml, desh, road[izx].ZcgNm, road[izx].Zcg, road[izx].ZjkNm,
				road[izx].Zjk, road[izx].NZLMK, road[izx].ZLMK, ZX_RHF,
				-1, road[izx].BxNum, road[izx].pBXArr, road[izx].pm);
			zxlmk = ZX_RHF[8];
			PZ.lc = zxcml;
			zxpm->xlpoint_pz(&PZ);
			dis2 = sqrt((PZ.x - mpt[0])*(PZ.x - mpt[0]) + (PZ.y - mpt[1])*(PZ.y - mpt[1])) - zxlmk;

			if (dis1 > dis2)
			{
				ept[0] = mpt[0], ept[1] = mpt[1];
			}
			else
			{
				spt[0] = mpt[0], spt[1] = mpt[1];
			}
			xdis = sqrt((spt[0] - ept[0])*(spt[0] - ept[0]) + (spt[1] - ept[1])*(spt[1] - ept[1]));
		}
	}
	//ads_printf(L"#### dis1=%lf dis2=%lf xdis=%lf\n",dis1,dis2,xdis);
	//计算出拱顶点
	pt[0] = 0.5*(spt[0] + ept[0]);
	pt[1] = 0.5*(spt[1] + ept[1]);
	zxcml = road[izx].pm->PROJ_ML(pt[0], pt[1]);
}
//检索出鼻端同坡向反坡变化的匝道里程
double  HdmDes::CalTPtoFPML(double bddmlonzd, int qorh, RoadHdmdata &ZDroad, double xjj)
{
	int i;
	double cml, bdcml;

	bdcml = ZDroad.pm->TYLC(bddmlonzd);
	if (xjj > 0.0001)//匝道在右侧,取左幅超高分段
	{
		for (i = 0; i < ZDroad.ZcgNm; i++)
		{
			cml = ZDroad.pm->TYLC(ZDroad.Zcg[i].xlc);
			if (cml > bdcml + 0.001)
				break;
		}
		if (i > 1 && i < ZDroad.ZcgNm)
		{
			if (qorh == 0)//分流鼻
				i = i - 2;
			cml = ZDroad.pm->TYLC(ZDroad.Zcg[i].xlc);
			return cml;
		}
	}
	else
	{
		for (i = 0; i < ZDroad.YcgNm; i++)
		{
			cml = ZDroad.pm->TYLC(ZDroad.Ycg[i].xlc);
			if (cml > bdcml + 0.001)
				break;
		}
		if (i > 1 && i < ZDroad.YcgNm)
		{
			if (qorh == 0)//分流鼻
				i = i - 2;
			cml = ZDroad.pm->TYLC(ZDroad.Ycg[i].xlc);
			return cml;
		}
	}

	return -1.0;
}

//输入鼻端反坡匝道一点x,y,返回标高			
double HdmDes::CalZDFPDesH(double x, double y, RoadHdmdata &ZDroad, int izx)
{
	//计算x,y在匝道上的投影里程
	double zdcml, zxcml, zdhp, dis, desh;
	JD_CENTER *zdpm, *zxpm;
	double RHF[10];
	zdpm = ZDroad.pm;
	zxpm = road[izx].pm;

	zdcml = zdpm->PROJ_ML(x, y);
	xlpoint PZ;
	PZ.lc = zdcml;
	zdpm->xlpoint_pz(&PZ);
	zxcml = zxpm->PROJ_ML(PZ.x, PZ.y);
	double xjj, pt[2], prjml;
	CalXjj(zxcml, zxpm->XYArray, zxpm->XYNum, zdpm->XYArray, zdpm->XYNum, xjj, prjml, pt);

	double GDpt[2], zxdesh, zxhp, dtmp, GDH;
	zxdesh = 0.0;
	//     CalGDPt(zdcml,ZDroad,0,xjj,GDpt,zxcml);
	if (xjj > 0.0001)//匝道在右侧
	{
		//以匝道左路面宽为分界,计算标高
		//计算匝道左侧路面宽
		CalLMPT(zdcml, zxdesh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm,
			ZDroad.Zjk, ZDroad.NZLMK, ZDroad.ZLMK, RHF, -1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);
		//计算分界点坐标
		GDpt[0] = PZ.x + RHF[3 * 2] * cos(PZ.a - 0.5*PI);
		GDpt[1] = PZ.y + RHF[3 * 2] * sin(PZ.a - 0.5*PI);
		//计算主线投影里程
		zxcml = zxpm->PROJ_ML(GDpt[0], GDpt[1]);
		//1.计算主线标高及横坡
		zxdesh = CalDesH(zxcml, road[izx].YZM, road[izx].AllZM);
		CalLMHP(zxcml, road[izx].YcgNm, road[izx].Ycg, zxhp, dtmp);
	}
	else
	{
		//计算匝道右侧路面宽
		CalLMPT(zdcml, zxdesh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm,
			ZDroad.Yjk, ZDroad.NYLMK, ZDroad.YLMK, RHF, 1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);
		//计算分界点坐标
		GDpt[0] = PZ.x + RHF[3 * 2] * cos(PZ.a + 0.5*PI);
		GDpt[1] = PZ.y + RHF[3 * 2] * sin(PZ.a + 0.5*PI);
		//计算主线投影里程
		zxcml = zxpm->PROJ_ML(GDpt[0], GDpt[1]);
		//1.计算主线标高及横坡
		zxdesh = CalDesH(zxcml, road[izx].ZZM, road[izx].AllZM);
		CalLMHP(zxcml, road[izx].ZcgNm, road[izx].Zcg, zxhp, dtmp);
	}

	PZ.lc = zxcml;
	road[izx].pm->xlpoint_pz(&PZ);
	dis = sqrt((PZ.x - GDpt[0])*(PZ.x - GDpt[0]) + (PZ.y - GDpt[1])*(PZ.y - GDpt[1]));
	GDH = zxdesh + zxhp * 0.01*dis;//路拱顶标高

	//由拱顶标高计算匝道中心标高
	PZ.lc = zdcml;
	ZDroad.pm->xlpoint_pz(&PZ);
	dis = sqrt((PZ.x - GDpt[0])*(PZ.x - GDpt[0]) + (PZ.y - GDpt[1])*(PZ.y - GDpt[1]));
	if (xjj > 0.0001)
		CalLMHP(zdcml, ZDroad.ZcgNm, ZDroad.Zcg, zdhp, dtmp);
	else
		CalLMHP(zdcml, ZDroad.YcgNm, ZDroad.Ycg, zdhp, dtmp);

	desh = GDH - zdhp * 0.01*dis;
	//计算x,y点路面标高	
	//计算x,y点在中线左、右侧
	double dist;
	int LorR;
	LorR = JudgePTLorR(x, y, dist, ZDroad.pm->XYArray, ZDroad.pm->XYNum);//距离中线dist
	if (fabs(dist) < 0.0001)
		return desh;

	if (LorR > 0.0)//在右侧
	{
		CalLMPT(zdcml, desh, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm, ZDroad.Yjk,
			ZDroad.NYLMK, ZDroad.YLMK, RHF,
			1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);
		if (dist < RHF[6] + 0.001)//取路面横坡
		{
			CalLMHP(zdcml, ZDroad.YcgNm, ZDroad.Ycg, zdhp, dtmp);
			//			desh = desh + zdhp*0.01*dist;
			desh = RHF[3] + zdhp * 0.01*dist;
		}
		else
		{
			CalLMHP(zdcml, ZDroad.YcgNm, ZDroad.Ycg, zdhp, dtmp);
			//计算硬路肩标高
			//			desh = desh + zdhp*0.01*RHF[6];
			desh = RHF[3] + zdhp * 0.01*dist;
			//计算土路肩横坡
			double half_fgdk, lydk, cxdk, yljk, tljk, tljhp;
			int bkmode, sjbgmode;
			CalLMK_JK(zdcml, ZDroad.NYLMK, ZDroad.YLMK, ZDroad.YcgNm, ZDroad.Ycg, ZDroad.YjkNm, ZDroad.Yjk, half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
			desh = desh - tljhp * 0.01*(dist - RHF[6]);
		}
	}
	else
	{
		dist = fabs(dist);
		CalLMPT(zdcml, desh, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm, ZDroad.Zjk,
			ZDroad.NZLMK, ZDroad.ZLMK, RHF,
			-1, ZDroad.BxNum, ZDroad.pBXArr, ZDroad.pm);
		if (dist < RHF[6] + 0.001)//取路面横坡
		{
			CalLMHP(zdcml, ZDroad.ZcgNm, ZDroad.Zcg, zdhp, dtmp);
			//			desh = desh + zdhp*0.01*dist;
			desh = RHF[3] + zdhp * 0.01*dist;
		}
		else
		{
			CalLMHP(zdcml, ZDroad.ZcgNm, ZDroad.Zcg, zdhp, dtmp);
			//计算硬路肩标高
			//			desh = desh + zdhp*0.01*RHF[6];
			desh = RHF[3] + zdhp * 0.01*dist;
			//计算土路肩横坡
			double half_fgdk, lydk, cxdk, yljk, tljk, tljhp;
			int bkmode, sjbgmode;
			CalLMK_JK(zdcml, ZDroad.NZLMK, ZDroad.ZLMK, ZDroad.ZcgNm, ZDroad.Zcg, ZDroad.ZjkNm, ZDroad.Zjk, half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
			desh = desh - tljhp * 0.01*(dist - RHF[6]);
		}
	}
	return desh;
}
//输入平面，里程段落zxscml-zxeml 找出左右关联道路
bool HdmDes::FindWichGLROAD(JD_CENTER *curpm, double cursml, double cureml, GLROAD &ZGLR, GLROAD &YGLR)
{
	CString XL;
	XL.Format(L"%s,%s", curpm->mdbname, curpm->RoadName);
	XL.MakeUpper();

	double fldcml, nosecml, dis, bdmincml, bdmaxcml;
	int LorR, i;
	JD_CENTER *glpm;

	for (i = 0; i < NBIDUAN; i++)
	{
		if (XL == BDArr[i].XL1)//当前线路为主线
		{
			glpm = GetPm(BDArr[i].XL2);
			if (glpm == NULL)
				continue;

			if (BDArr[i].ZDStOrEd == 0)//匝道起始端
			{
				fldcml = curpm->PROJ_ML(glpm->XYArray[1][8], glpm->XYArray[1][9]);
				nosecml = curpm->TYLC(BDArr[i].Yljdml1);
				bdmincml = fldcml < nosecml ? fldcml : nosecml;
				bdmaxcml = fldcml > nosecml ? fldcml : nosecml;
				if (cursml<bdmaxcml && cureml >bdmincml)
				{
					LorR = JudgePTLorR(BDArr[i].TNosePt[0], BDArr[i].TNosePt[1], dis, curpm->XYArray, curpm->XYNum);
					if (LorR == -1)//关联道路在左侧
					{
						ZGLR.glxl = BDArr[i].XL2;
						ZGLR.torf = BDArr[i].Lmhp;
						ZGLR.qorh = BDArr[i].InOrOut;
						ZGLR.sml = fldcml;
						ZGLR.eml = nosecml;
						ZGLR.glxlxz = 1;

					}
					else//关联道路在右侧
					{
						YGLR.glxl = BDArr[i].XL2;
						YGLR.torf = BDArr[i].Lmhp;
						YGLR.qorh = BDArr[i].InOrOut;
						YGLR.sml = fldcml;
						YGLR.eml = nosecml;
						YGLR.glxlxz = 1;
					}
				}

			}
			else////匝道终端
			{
				fldcml = curpm->PROJ_ML(glpm->XYArray[glpm->XYNum][8], glpm->XYArray[glpm->XYNum][9]);
				nosecml = curpm->TYLC(BDArr[i].Yljdml1);
				bdmincml = fldcml < nosecml ? fldcml : nosecml;
				bdmaxcml = fldcml > nosecml ? fldcml : nosecml;
				if (cursml<bdmaxcml && cureml >bdmincml)
				{
					LorR = JudgePTLorR(BDArr[i].TNosePt[0], BDArr[i].TNosePt[1], dis, curpm->XYArray, curpm->XYNum);
					if (LorR == -1)//关联道路在左侧
					{
						ZGLR.glxl = BDArr[i].XL2;
						ZGLR.torf = BDArr[i].Lmhp;
						ZGLR.qorh = BDArr[i].InOrOut;
						ZGLR.sml = fldcml;
						ZGLR.eml = nosecml;
						ZGLR.glxlxz = 1;

					}
					else//关联道路在右侧
					{
						YGLR.glxl = BDArr[i].XL2;
						YGLR.torf = BDArr[i].Lmhp;
						YGLR.qorh = BDArr[i].InOrOut;
						YGLR.sml = fldcml;
						YGLR.eml = nosecml;
						YGLR.glxlxz = 1;

					}
				}
			}
		}
		else if (XL == BDArr[i].XL2)//当前线路为匝道
		{
			if (BDArr[i].ZDStOrEd == 0)//匝道起始端
			{
				fldcml = curpm->XYArray[1][6];
				nosecml = curpm->TYLC(BDArr[i].Yljdml2);
				bdmincml = fldcml < nosecml ? fldcml : nosecml;
				bdmaxcml = fldcml > nosecml ? fldcml : nosecml;
				if (cursml<bdmaxcml && cureml >bdmincml)
				{
					LorR = JudgePTLorR(BDArr[i].TNosePt[0], BDArr[i].TNosePt[1], dis, curpm->XYArray, curpm->XYNum);
					if (LorR == -1)//关联道路在左侧
					{
						ZGLR.glxl = BDArr[i].XL1;
						ZGLR.torf = BDArr[i].Lmhp;
						ZGLR.qorh = BDArr[i].InOrOut;
						ZGLR.sml = fldcml;
						ZGLR.eml = nosecml;
						ZGLR.glxlxz = 0;
					}
					else//关联道路在右侧
					{
						YGLR.glxl = BDArr[i].XL1;
						YGLR.torf = BDArr[i].Lmhp;
						YGLR.qorh = BDArr[i].InOrOut;
						YGLR.sml = fldcml;
						YGLR.eml = nosecml;
						YGLR.glxlxz = 0;
					}
				}
			}
			else////匝道终端
			{
				fldcml = curpm->XYArray[curpm->XYNum][6];
				nosecml = curpm->TYLC(BDArr[i].Yljdml2);
				bdmincml = fldcml < nosecml ? fldcml : nosecml;
				bdmaxcml = fldcml > nosecml ? fldcml : nosecml;
				if (cursml<bdmaxcml && cureml >bdmincml)
				{
					LorR = JudgePTLorR(BDArr[i].TNosePt[0], BDArr[i].TNosePt[1], dis, curpm->XYArray, curpm->XYNum);
					if (LorR == -1)//关联道路在左侧
					{
						ZGLR.glxl = BDArr[i].XL1;
						ZGLR.torf = BDArr[i].Lmhp;
						ZGLR.qorh = BDArr[i].InOrOut;
						ZGLR.sml = fldcml;
						ZGLR.eml = nosecml;
						ZGLR.glxlxz = 0;
					}
					else//关联道路在右侧
					{
						YGLR.glxl = BDArr[i].XL1;
						YGLR.torf = BDArr[i].Lmhp;
						YGLR.qorh = BDArr[i].InOrOut;
						YGLR.sml = fldcml;
						YGLR.eml = nosecml;
						YGLR.glxlxz = 0;
					}
				}
			}
		}
	}
	return true;
}
//查找与当前线路关联的道路 包括左侧和右侧 并且读取道路横断面相关数据 计算出路肩分离和边坡分离里程
bool HdmDes::FindAndReadLinkRoad(CString CurrXL)
{

	int i, pos, len, LorR;
	double xl1dml, xl2dml;
	CString xl, mdbname, roadname;
	xl1dml = xl2dml = 0;
	RoadHdmdata RoadData;
	xlpoint PZ;
	int j;

	CurrXL.MakeUpper();

	Zroad = new RoadHdmdata[20];
	Yroad = new RoadHdmdata[20];

	for (i = 0; i < NBIDUAN; i++)
	{
		if (CurrXL == BDArr[i].XL1)
		{
			//判别BDArr[i].XL2与CurrXL左关联或右关联
			xl = BDArr[i].XL2;
			pos = BDArr[i].XL2.FindOneOf(L",");
			mdbname = BDArr[i].XL2.Left(pos);
			len = BDArr[i].XL2.GetLength();
			roadname = BDArr[i].XL2.Right(len - pos - 1);
			JD_CENTER *pm = NULL;
			pm = ReadPm(mdbname, roadname);

			if (pm)
			{
				PZ.lc = road[0].pm->TYLC(BDArr[i].Tljdml1);
				road[0].pm->xlpoint_pz(&PZ);
				LorR = road[0].pm->Judge2XLorR(PZ, pm->XYArray, pm->XYNum);
				if (LorR < 0)//关联线路为左线
				{
					if (ReadARoadFile(mdbname, Zroad[ZRoadSum]) == 1)
					{
						if (BDArr[i].ZDStOrEd == 0)//匝道起鼻
						{
							Zroad[ZRoadSum].SmlOnZx = road[0].pm->PROJ_ML(Zroad[ZRoadSum].pm->XYArray[1][8], Zroad[ZRoadSum].pm->XYArray[1][9]);
							Zroad[ZRoadSum].LJFLSmlOnZx = road[0].pm->TYLC(BDArr[i].Yljdml1);
							Zroad[ZRoadSum].LJFLSmlOnFLD = Zroad[ZRoadSum].pm->TYLC(BDArr[i].Yljdml2);
							Zroad[ZRoadSum].XZ = 1;
							Zroad[ZRoadSum].roadname = mdbname;

							if (BDArr[i].InOrOut > 0)//主线里程增加方向
								SearchBPFLml(road[0], Zroad[ZRoadSum], Zroad[ZRoadSum].LJFLSmlOnZx, Zroad[ZRoadSum].LJFLSmlOnZx + 2000, j, true, -1, Zroad[ZRoadSum].BPFLSmlOnFLD, Zroad[ZRoadSum].BPFLSmlOnZx);//true:向前,false:向后
							else
								SearchBPFLml(road[0], Zroad[ZRoadSum], Zroad[ZRoadSum].LJFLSmlOnZx, Zroad[ZRoadSum].LJFLSmlOnZx + 2000, j, false, -1, Zroad[ZRoadSum].BPFLSmlOnFLD, Zroad[ZRoadSum].BPFLSmlOnZx);//true:向前,false:向后


						}
						else
						{
							Zroad[ZRoadSum].EmlOnZx = road[0].pm->PROJ_ML(Zroad[ZRoadSum].pm->XYArray[Zroad[ZRoadSum].pm->XYNum][8], Zroad[ZRoadSum].pm->XYArray[Zroad[ZRoadSum].pm->XYNum][9]);
							Zroad[ZRoadSum].LJFLEmlOnZx = road[0].pm->TYLC(BDArr[i].Yljdml1);
							Zroad[ZRoadSum].LJFLEmlOnFLD = Zroad[ZRoadSum].pm->TYLC(BDArr[i].Yljdml2);
							Zroad[ZRoadSum].XZ = 1;
							Zroad[ZRoadSum].roadname = mdbname;

							if (BDArr[i].InOrOut > 0)//主线里程方向与匝道
								SearchBPFLml(road[0], Zroad[ZRoadSum], Zroad[ZRoadSum].LJFLEmlOnZx, Zroad[ZRoadSum].LJFLEmlOnZx + 2000, j, true, -1, Zroad[ZRoadSum].BPFLEmlOnFLD, Zroad[ZRoadSum].BPFLEmlOnZx);//true:向前,false:向后
							else
								SearchBPFLml(road[0], Zroad[ZRoadSum], Zroad[ZRoadSum].LJFLEmlOnZx, Zroad[ZRoadSum].LJFLEmlOnZx + 2000, j, false, -1, Zroad[ZRoadSum].BPFLEmlOnFLD, Zroad[ZRoadSum].BPFLEmlOnZx);//true:向前,false:向后

						}
						ZRoadSum++;
					}

				}
				else
				{
					if (ReadARoadFile(mdbname, Yroad[YRoadSum]))
					{
						if (BDArr[i].ZDStOrEd == 0)//分流鼻
						{
							Yroad[YRoadSum].SmlOnZx = road[0].pm->PROJ_ML(Yroad[YRoadSum].pm->XYArray[1][8], Yroad[YRoadSum].pm->XYArray[1][9]);
							Yroad[YRoadSum].LJFLSmlOnZx = road[0].pm->TYLC(BDArr[i].Yljdml1);
							Yroad[YRoadSum].LJFLSmlOnFLD = Yroad[YRoadSum].pm->TYLC(BDArr[i].Yljdml2);
							Yroad[YRoadSum].XZ = 1;
							Yroad[YRoadSum].roadname = mdbname;

							if (BDArr[i].InOrOut > 0)//主线里程增加方向
								SearchBPFLml(road[0], Yroad[YRoadSum], Yroad[YRoadSum].LJFLSmlOnZx, Yroad[YRoadSum].LJFLSmlOnZx + 2000, j, true, 1, Yroad[YRoadSum].BPFLSmlOnFLD, Yroad[YRoadSum].BPFLSmlOnZx);//true:向前,false:向后
							else
								SearchBPFLml(road[0], Yroad[YRoadSum], Yroad[YRoadSum].LJFLSmlOnZx, Yroad[YRoadSum].LJFLSmlOnZx + 2000, j, false, 1, Yroad[YRoadSum].BPFLSmlOnFLD, Yroad[YRoadSum].BPFLSmlOnZx);//true:向前,false:向后
						}
						else
						{
							Yroad[YRoadSum].EmlOnZx = road[0].pm->PROJ_ML(Yroad[YRoadSum].pm->XYArray[Yroad[YRoadSum].pm->XYNum][8], Yroad[YRoadSum].pm->XYArray[Yroad[YRoadSum].pm->XYNum][9]);
							Yroad[YRoadSum].LJFLEmlOnZx = road[0].pm->TYLC(BDArr[i].Yljdml1);
							Yroad[YRoadSum].LJFLEmlOnFLD = Yroad[YRoadSum].pm->TYLC(BDArr[i].Yljdml2);
							Yroad[YRoadSum].XZ = 1;
							Yroad[YRoadSum].roadname = mdbname;

							if (BDArr[i].InOrOut > 0)//主线里程增加方向
								SearchBPFLml(road[0], Yroad[YRoadSum], Yroad[YRoadSum].LJFLEmlOnZx, Yroad[YRoadSum].LJFLEmlOnZx + 2000, j, true, 1, Yroad[YRoadSum].BPFLEmlOnFLD, Yroad[YRoadSum].BPFLEmlOnZx);//true:向前,false:向后
							else
								SearchBPFLml(road[0], Yroad[YRoadSum], Yroad[YRoadSum].LJFLEmlOnZx, Yroad[YRoadSum].LJFLEmlOnZx + 2000, j, false, 1, Yroad[YRoadSum].BPFLEmlOnFLD, Yroad[YRoadSum].BPFLEmlOnZx);//true:向前,false:向后
						}

						YRoadSum++;
					}

				}
			}
		}
		else if (CurrXL == BDArr[i].XL2)//当前线路为匝道,关联为主线
		{
			xl = BDArr[i].XL1;
			pos = BDArr[i].XL1.FindOneOf(L",");
			mdbname = BDArr[i].XL1.Left(pos);
			len = BDArr[i].XL1.GetLength();
			roadname = BDArr[i].XL1.Right(len - pos - 1);
			JD_CENTER *pm = NULL;
			pm = ReadPm(mdbname, roadname);
			if (pm)
			{
				PZ.lc = road[0].pm->TYLC(BDArr[i].Tljdml1);
				road[0].pm->xlpoint_pz(&PZ);
				LorR = road[0].pm->Judge2XLorR(PZ, pm->XYArray, pm->XYNum);
				if (LorR < 0)//关联线路为左线
				{
					if (ReadARoadFile(mdbname, Zroad[ZRoadSum]))
					{
						if (BDArr[i].ZDStOrEd == 0)//分流鼻
						{
							road[0].SmlOnZx = Zroad[ZRoadSum].pm->PROJ_ML(road[0].pm->XYArray[1][8], road[0].pm->XYArray[1][9]);
							road[0].LJFLSmlOnZx = Zroad[ZRoadSum].pm->TYLC(BDArr[i].Yljdml1);
							road[0].LJFLSmlOnFLD = road[0].pm->TYLC(BDArr[i].Yljdml2);
							Zroad[ZRoadSum].XZ = 0;
							Zroad[ZRoadSum].roadname = mdbname;

							if (BDArr[i].InOrOut > 0)//汇流鼻
								SearchBPFLml(Zroad[ZRoadSum], road[0], road[0].LJFLSmlOnZx, road[0].LJFLSmlOnZx + 2000, j, true, 1, road[0].BPFLSmlOnFLD, road[0].BPFLSmlOnZx);//true:向前,false:向后
							else
								SearchBPFLml(Zroad[ZRoadSum], road[0], road[0].LJFLSmlOnZx, road[0].LJFLSmlOnZx + 2000, j, false, 1, road[0].BPFLSmlOnFLD, road[0].BPFLSmlOnZx);//true:向前,false:向后
						}
						else
						{
							road[0].EmlOnZx = Zroad[ZRoadSum].pm->PROJ_ML(Zroad[ZRoadSum].pm->XYArray[road[0].pm->XYNum][8], road[0].pm->XYArray[Zroad[ZRoadSum].pm->XYNum][9]);
							road[0].LJFLEmlOnZx = Zroad[ZRoadSum].pm->TYLC(BDArr[i].Yljdml1);
							road[0].LJFLEmlOnFLD = road[0].pm->TYLC(BDArr[i].Yljdml2);
							Zroad[ZRoadSum].XZ = 0;
							Zroad[ZRoadSum].roadname = mdbname;

							if (BDArr[i].InOrOut > 0)//汇流鼻
								SearchBPFLml(Zroad[ZRoadSum], road[0], road[0].LJFLEmlOnZx, road[0].LJFLEmlOnZx + 2000, j, true, 1, road[0].BPFLEmlOnFLD, road[0].BPFLEmlOnZx);//true:向前,false:向后
							else
								SearchBPFLml(Zroad[ZRoadSum], road[0], road[0].LJFLEmlOnZx, road[0].LJFLEmlOnZx + 2000, j, false, 1, road[0].BPFLEmlOnFLD, road[0].BPFLEmlOnZx);//true:向前,false:向后
						}
						ZRoadSum++;
					}
				}
				else
				{
					if (ReadARoadFile(mdbname, Yroad[YRoadSum]))
					{
						if (BDArr[i].ZDStOrEd == 0)//分流鼻
						{
							road[0].SmlOnZx = Yroad[YRoadSum].pm->PROJ_ML(road[0].pm->XYArray[1][8], road[0].pm->XYArray[1][9]);
							road[0].LJFLSmlOnZx = Yroad[YRoadSum].pm->TYLC(BDArr[i].Yljdml1);
							road[0].LJFLSmlOnFLD = road[0].pm->TYLC(BDArr[i].Yljdml2);
							Yroad[YRoadSum].XZ = 0;
							Yroad[YRoadSum].roadname = mdbname;

							if (BDArr[i].InOrOut > 0)//汇流鼻
								SearchBPFLml(Yroad[YRoadSum], road[0], road[0].LJFLSmlOnZx, road[0].LJFLSmlOnZx + 2000, j, true, -1, road[0].BPFLSmlOnFLD, road[0].BPFLSmlOnZx);//true:向前,false:向后
							else
								SearchBPFLml(Yroad[YRoadSum], road[0], road[0].LJFLSmlOnZx, road[0].LJFLSmlOnZx + 2000, j, false, -1, road[0].BPFLSmlOnFLD, road[0].BPFLSmlOnZx);//true:向前,false:向后
						}
						else
						{
							road[0].EmlOnZx = Yroad[YRoadSum].pm->PROJ_ML(Yroad[YRoadSum].pm->XYArray[road[0].pm->XYNum][8], road[0].pm->XYArray[Yroad[YRoadSum].pm->XYNum][9]);
							road[0].LJFLEmlOnZx = Yroad[YRoadSum].pm->TYLC(BDArr[i].Yljdml1);
							road[0].LJFLEmlOnFLD = road[0].pm->TYLC(BDArr[i].Yljdml2);
							Yroad[YRoadSum].XZ = 0;
							Yroad[YRoadSum].roadname = mdbname;

							if (BDArr[i].InOrOut > 0)//汇流鼻
								SearchBPFLml(Yroad[YRoadSum], road[0], road[0].LJFLEmlOnZx, road[0].LJFLEmlOnZx + 2000, j, true, -1, road[0].BPFLEmlOnFLD, road[0].BPFLEmlOnZx);//true:向前,false:向后
							else
								SearchBPFLml(Yroad[YRoadSum], road[0], road[0].LJFLEmlOnZx, road[0].LJFLEmlOnZx + 2000, j, false, -1, road[0].BPFLEmlOnFLD, road[0].BPFLEmlOnZx);//true:向前,false:向后
						}

						YRoadSum++;
					}
				}

			}
		}

	}

	if (ZRoadSum + YRoadSum < 1)
	{
		delete[]Zroad;
		delete[]Yroad;
	}

	return false;

}

//适用于横断面设计完成后的导入横断面\总体图三维
//查找与当前线路关联的道路 包括左侧和右侧 并且读取道路横断面相关数据 计算出路肩分离和边坡分离里程
bool HdmDes::FindAndReadLinkRoad_for3d(CString CurrXL)
{

	int i, pos, len, LorR;
	double xl1dml, xl2dml;
	CString xl, mdbname, roadname;
	xl1dml = xl2dml = 0;
	RoadHdmdata RoadData;
	xlpoint PZ;
	int j;

	CurrXL.MakeUpper();

	Zroad = new RoadHdmdata[20];
	Yroad = new RoadHdmdata[20];

	for (i = 0; i < NBIDUAN; i++)
	{
		if (CurrXL == BDArr[i]./*XL1*/XL2)//lbw改
		{
			//判别BDArr[i].XL2与CurrXL左关联或右关联
			xl = BDArr[i].XL2;
			pos = BDArr[i].XL2.FindOneOf(L",");
			mdbname = BDArr[i].XL2.Left(pos);
			len = BDArr[i].XL2.GetLength();
			roadname = BDArr[i].XL2.Right(len - pos - 1);
			JD_CENTER *pm = NULL;
			pm = ReadPm(mdbname, roadname);

			if (pm)
			{
				PZ.lc = road[0].pm->TYLC(BDArr[i].Tljdml1);
				road[0].pm->xlpoint_pz(&PZ);
				LorR = road[0].pm->Judge2XLorR(PZ, pm->XYArray, pm->XYNum);
				if (LorR < 0)//关联线路为左线
				{
					if (ReadARoadFile(mdbname, Zroad[ZRoadSum]) == 1)
					{
						Zroad[ZRoadSum].XZ = 1;
						Zroad[ZRoadSum].roadname = mdbname;

						ZRoadSum++;
					}

				}
				else
				{
					if (ReadARoadFile(mdbname, Yroad[YRoadSum]))
					{
						Yroad[YRoadSum].XZ = 1;
						Yroad[YRoadSum].roadname = mdbname;

						YRoadSum++;
					}

				}
			}
		}
		else if (CurrXL == BDArr[i]./*XL2*/XL1)//lbw改//当前线路为匝道,关联为主线
		{
			xl = BDArr[i].XL1;
			pos = BDArr[i].XL1.FindOneOf(L",");
			mdbname = BDArr[i].XL1.Left(pos);
			len = BDArr[i].XL1.GetLength();
			roadname = BDArr[i].XL1.Right(len - pos - 1);
			JD_CENTER *pm = NULL;
			pm = ReadPm(mdbname, roadname);
			if (pm)
			{
				PZ.lc = road[0].pm->TYLC(BDArr[i].Tljdml1);
				road[0].pm->xlpoint_pz(&PZ);
				LorR = road[0].pm->Judge2XLorR(PZ, pm->XYArray, pm->XYNum);
				if (LorR < 0)//关联线路为左线
				{
					if (ReadARoadFile(mdbname, Zroad[ZRoadSum]))
					{
						Zroad[ZRoadSum].XZ = 0;
						Zroad[ZRoadSum].roadname = mdbname;

						ZRoadSum++;
					}
				}
				else
				{
					if (ReadARoadFile(mdbname, Yroad[YRoadSum]))
					{
						Yroad[YRoadSum].XZ = 0;
						Yroad[YRoadSum].roadname = mdbname;


						YRoadSum++;
					}
				}

			}
		}

	}

	if (ZRoadSum + YRoadSum < 1)
	{
		delete[]Zroad;
		delete[]Yroad;
	}

	return false;

}

int HdmDes::ReadARoadFile(CString mdbFname, RoadHdmdata &RoadData)
{
	ACHAR pszLabel[256];
	_tcscpy(pszLabel, L"正在读取横断面数据库");
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);

	//读道路总数
	XLDataBase mdb;
	mdb.ReadAllRoadName(mdbFname);//读取线路数据库中断链表的数据
	//对所有道路循环，读取地面线，

	if (mdb.m_RoadSum < 1)
	{
		AfxMessageBox(L"当前道路总数为0，请先指定当前方案名称和道路名!");
		return 0;
	}
	acedSetStatusBarProgressMeterPos(0);
	InitRoadData(RoadData);
	RoadData.roadname = mdb.Road[0].RoadName;//左绕行段线路性质为-1
	ads_printf(L"\n正在读取%s横断面数据....", road[0].roadname);
	//读平面
	RoadData.pm = ReadPm(mdbFname, RoadData.roadname);
	if (!RoadData.pm)
	{
		ads_printf(L"读%s平面失败!\n", mdbFname);
		return 0;
	}
	acedSetStatusBarProgressMeterPos(10);

	//读纵面
	ReadZm(mdbFname, RoadData.roadname, L"全幅", RoadData);
	ReadZm(mdbFname, RoadData.roadname, L"左幅", RoadData);
	ReadZm(mdbFname, RoadData.roadname, L"右幅", RoadData);

	if (!RoadData.AllZM && !RoadData.ZZM && !RoadData.YZM)
	{
		ads_printf(L"读%s纵面失败!\n", mdbFname);
		return 0;
	}
	acedSetStatusBarProgressMeterPos(30);
	//读桥梁
	ReadBri(mdbFname, RoadData.roadname, L"全幅", RoadData);
	ReadBri(mdbFname, RoadData.roadname, L"左幅", RoadData);
	ReadBri(mdbFname, RoadData.roadname, L"右幅", RoadData);
	acedSetStatusBarProgressMeterPos(50);
	//读隧道
	ReadTun(mdbFname, RoadData.roadname, L"全幅", RoadData);
	ReadTun(mdbFname, RoadData.roadname, L"左幅", RoadData);
	ReadTun(mdbFname, RoadData.roadname, L"右幅", RoadData);
	acedSetStatusBarProgressMeterPos(70);

	//读超高
	ReadCG(mdbFname, RoadData.roadname, L"左超高分段表", RoadData);
	ReadCG(mdbFname, RoadData.roadname, L"右超高分段表", RoadData);
	if (RoadData.ZcgNm < 1 && RoadData.YcgNm < 1)
	{
		ads_printf(L"读%s超高失败!\n", mdbFname);
		return 0;
	}

	//读加宽
	ReadJK(mdbFname, RoadData.roadname, L"左加宽分段表", RoadData);
	ReadJK(mdbFname, RoadData.roadname, L"右加宽分段表", RoadData);
	acedSetStatusBarProgressMeterPos(80);

	//读地面线
	ReadHdmdmx(RoadData.roadname, mdbFname, RoadData);
	if (RoadData.NCRS < 1)
	{
		ACHAR mes[256];
		_stprintf(mes, L"请先计算%s横断面地面线!", mdbFname);
		ads_alert(mes);
		return 0;
	}
	acedSetStatusBarProgressMeterPos(90);
	//读横断面标准
	RoadData.hdmbz.Read_AllHdmDataFromDbs(mdbFname, RoadData.roadname);
	acedSetStatusBarProgressMeterPos(100);
	//acedSetStatusBarProgressMeterPos(10 + 80*i*1.0/mdb.m_RoadSum);    			   
	//读横断面路面宽分段
	ReadLMK(mdbFname, RoadData.roadname, L"左路面宽分段表", RoadData);
	ReadLMK(mdbFname, RoadData.roadname, L"右路面宽分段表", RoadData);
	if (RoadData.NZLMK < 1 && RoadData.NYLMK < 1)
	{
		ads_printf(L"读%s路面宽失败!\n", mdbFname);
		return 0;
	}

	SetHdmLm(RoadData);

	acedSetStatusBarProgressMeterPos(100);
	ads_printf(L"\nOK!");

	acedSetStatusBarProgressMeterPos(100);
	acedRestoreStatusBar();
	return 1;
}

void HdmDes::InitRoadData(RoadHdmdata &RoadData)
{
	RoadData.roadname = "";//道路名
	RoadData.pm = NULL;
	RoadData.AllZM = NULL;
	RoadData.ZZM = NULL;
	RoadData.YZM = NULL;//整幅纵面,左幅纵面,右幅纵面
	RoadData.NAllBri = RoadData.NZBri = RoadData.NYBri = 0;
	RoadData.AllBri = NULL;
	RoadData.ZBri = NULL;
	RoadData.YBri = NULL;//整幅桥,左幅桥,右幅桥
	RoadData.AllTun = NULL;
	RoadData.NAllTun = RoadData.NZTun = RoadData.NYTun = 0;
	RoadData.ZTun = NULL;
	RoadData.YTun = NULL;//整幅隧,左幅隧,右幅隧
	RoadData.ZcgNm = 0;
	RoadData.YcgNm = 0;
	RoadData.ZjkNm = 0;
	RoadData.YjkNm = 0;//超高加宽
	RoadData.Zcg = NULL;
	RoadData.Ycg = NULL;
	RoadData.Zjk = NULL;
	RoadData.Yjk = NULL;
	RoadData.LorR = 1;

	RoadData.NCRS = 0;
	RoadData.hdmdmx = NULL;

	RoadData.NZLMK = 0;
	RoadData.NYLMK = 0;
	RoadData.ZLMK = NULL;
	RoadData.YLMK = NULL;
	RoadData.SmlOnZx = RoadData.EmlOnZx = -1;
	RoadData.XZ = 0;
	//起终路肩分离点在主线上的投影里程
	RoadData.LJFLSmlOnZx = RoadData.LJFLEmlOnZx = RoadData.LJFLSmlOnFLD = RoadData.LJFLEmlOnFLD = -1;
	//起终边坡分离点在主线上的投影里程
	RoadData.BPFLSmlOnZx = RoadData.BPFLEmlOnZx = RoadData.BPFLSmlOnFLD = RoadData.BPFLEmlOnFLD = -1;
}


void HdmDes::Design_ZD_Hdm()
{
	ACHAR pszLabel[256];
	int i, NCRS, iroad;
	double cml;
	int inf;
	i = 0;

	_stprintf(pszLabel, L"%s横断面自动设计", road[i].roadname);
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);

	NCRS = road[i].NCRS;

	for (int j = 0; j < NCRS; j++)
	{

		//计算左幅
		cml = road[i].hdmdes[j].cml;
		xlpoint PZ;
		PZ.lc = cml;
		road[i].pm->xlpoint_pz(&PZ);

		//		road[i].hdmdes[j].fwj = PZ.a;//记录断面中心切线方位			

		//设计左侧
		//1.判别断面性质，是否存在关联道路

		inf = CalLinkRoadInf(cml, -1, iroad);

		//2.无关联，按普通断面设计
		if (inf == 0)
			DesACrossOnSingleLine(i, j, -1);
		else if (inf == -1)
			continue;//匝道双路面地段 横段面在主线考虑
		else if (inf == 1)
			DesZXCrossOnDoubleLM(j, Zroad[iroad], -1);
		else
			DesZXHdmLinkZD(0, j, -1, Zroad[iroad]);

		//1.判别断面性质，是否存在关联道路
		inf = CalLinkRoadInf(cml, 1, iroad);
		//2.无关联，按普通断面设计
		if (inf == 0)
			DesACrossOnSingleLine(i, j, 1);
		else if (inf == -1)
			continue;//匝道双路面地段 横段面在主线考虑
		else if (inf == 1)
			DesZXCrossOnDoubleLM(j, Yroad[iroad], 1);
		else
			DesZXHdmLinkZD(0, j, 1, Yroad[iroad]);
		road[0].hdmdes[j].FillArea = road[0].hdmdes[j].Z_LFillArea + road[0].hdmdes[j].Y_RFillArea;//填面积
		road[0].hdmdes[j].CutArea = road[0].hdmdes[j].Z_LCutArea + road[0].hdmdes[j].Y_RCutArea;//填面积
		road[0].hdmdes[j].QBTArea = road[0].hdmdes[j].Z_LQBTArea + road[0].hdmdes[j].Y_RQBTArea;//清表土面积
		road[0].hdmdes[j].GouTarea = road[0].hdmdes[j].Z_LGouTarea + road[0].hdmdes[j].Y_RGouTarea;//水沟填面积
		road[0].hdmdes[j].GouWarea = road[0].hdmdes[j].Z_LGouWarea + road[0].hdmdes[j].Y_RGouWarea;//水沟挖面积
		road[0].hdmdes[j].aw = road[0].hdmdes[j].CutArea;
		road[0].hdmdes[j].at = road[0].hdmdes[j].FillArea;
		road[0].hdmdes[j].SGJQarea = road[0].hdmdes[j].Z_LSGJQarea + road[0].hdmdes[j].Y_RSGJQarea;//浆砌面积
		road[0].hdmdes[j].DQlength = road[0].hdmdes[j].Z_LDQlength + road[0].hdmdes[j].Y_RDQlength;//挡墙坡长
		road[0].hdmdes[j].Grasslength = road[0].hdmdes[j].Z_LGrasslength + road[0].hdmdes[j].Y_RGrasslength;//铺草坡长*/

		//分情况设计
		//还需考虑桥隧相连的情况
		int Pos = (int)(j*100.0 / road[i].NCRS);
		acedSetStatusBarProgressMeterPos(Pos);
	}
	road[0].NCRS = NCRS;

	acedSetStatusBarProgressMeterPos(100);
	acedRestoreStatusBar();

}


//计算出与当前道路关联的道路信息 传入当前道路里程 左右侧 返回 
//inf 0 独立断面 1主线双路面 2关联断面 -1匝道双路面无需做横断面设计
int HdmDes::CalLinkRoadInf(double cml, int zory, int &iroad)
{
	int inf;
	inf = 0;//独立断面设计

	if (zory < 0)
	{
		for (int i = 0; i < ZRoadSum; i++)
		{

			if (Zroad[i].XZ == 0)//关联为主线，当前cml为匝道
			{
				//首先判别cml是否需要横断面设计
				if (cml < road[0].LJFLSmlOnFLD || (road[0].LJFLEmlOnFLD > 0 && cml > road[0].LJFLEmlOnFLD))
					inf = -1;//当前线路为匝道且里程位于鼻断以外 无需做横断面设计 主线考虑	
				else if ((road[0].LJFLSmlOnFLD > 0 && cml > road[0].LJFLSmlOnFLD&&cml < road[0].BPFLSmlOnFLD) ||
					(road[0].LJFLEmlOnFLD > 0 && cml<road[0].LJFLEmlOnFLD&&cml>road[0].BPFLEmlOnFLD))
				{
					inf = 2;//关联断面 
					iroad = i;
				}
			}
			else
			{
				double mincml, maxcml;
				if (Zroad[i].SmlOnZx > 0)
				{
					mincml = Zroad[i].SmlOnZx < Zroad[i].LJFLSmlOnZx ? Zroad[i].SmlOnZx : Zroad[i].LJFLSmlOnZx;
					maxcml = Zroad[i].SmlOnZx > Zroad[i].LJFLSmlOnZx ? Zroad[i].SmlOnZx : Zroad[i].LJFLSmlOnZx;
					if (cml > mincml - 0.001&&cml < maxcml + 0.001)
					{
						inf = 1;//当前线路为主线且里程位于鼻断范围内双路面考虑
						iroad = i;
						return inf;
					}
				}
				if (Zroad[i].LJFLEmlOnZx > 0 && Zroad[i].EmlOnZx > 0)
				{
					mincml = Zroad[i].LJFLEmlOnZx < Zroad[i].EmlOnZx ? Zroad[i].LJFLEmlOnZx : Zroad[i].EmlOnZx;
					maxcml = Zroad[i].LJFLEmlOnZx > Zroad[i].EmlOnZx ? Zroad[i].LJFLEmlOnZx : Zroad[i].EmlOnZx;
					if (cml > mincml - 0.001&&cml < maxcml + 0.001)
					{
						inf = 1;//当前线路为主线且里程位于鼻断范围内双路面考虑
						iroad = i;
						return inf;
					}

				}
				if (Zroad[i].LJFLSmlOnZx > 0 && Zroad[i].BPFLSmlOnZx > 0)
				{
					mincml = Zroad[i].LJFLSmlOnZx < Zroad[i].BPFLSmlOnZx ? Zroad[i].LJFLSmlOnZx : Zroad[i].BPFLSmlOnZx;
					maxcml = Zroad[i].LJFLSmlOnZx > Zroad[i].BPFLSmlOnZx ? Zroad[i].LJFLSmlOnZx : Zroad[i].BPFLSmlOnZx;
					if (cml > mincml - 0.001&&cml < maxcml + 0.001)
					{
						inf = 2;//当前线路为主线且里程位于鼻断范围内双路面考虑
						iroad = i;
						return inf;
					}

				}
				if (Zroad[i].LJFLEmlOnZx > 0 && Zroad[i].BPFLEmlOnZx > 0)
				{
					mincml = Zroad[i].LJFLEmlOnZx < Zroad[i].BPFLEmlOnZx ? Zroad[i].LJFLEmlOnZx : Zroad[i].BPFLEmlOnZx;
					maxcml = Zroad[i].LJFLEmlOnZx > Zroad[i].BPFLEmlOnZx ? Zroad[i].LJFLEmlOnZx : Zroad[i].BPFLEmlOnZx;
					if (cml > mincml - 0.001&&cml < maxcml + 0.001)
					{
						inf = 2;//当前线路为主线且里程位于鼻断范围内双路面考虑
						iroad = i;
						return inf;
					}

				}

			}
		}
	}
	else
	{
		for (int i = 0; i < YRoadSum; i++)
		{
			if (Yroad[i].XZ == 0)//主线，cml为匝道
			{
				//首先判别cml是否需要横断面设计
				if (cml < road[0].LJFLSmlOnFLD || (road[0].LJFLEmlOnFLD > 0 && cml > road[0].LJFLEmlOnFLD))
					inf = -1;//当前线路为匝道且里程位于鼻断以外 无需做横断面设计 主线考虑

				else if ((road[0].LJFLSmlOnFLD > 0 && cml > road[0].LJFLSmlOnFLD&&cml < road[0].BPFLSmlOnFLD) ||
					(road[0].LJFLEmlOnFLD > 0 && cml<road[0].LJFLEmlOnFLD&&cml>road[0].BPFLEmlOnFLD))
				{
					inf = 2;//关联断面 
					iroad = i;
				}
			}
			else
			{
				double mincml, maxcml;
				//ads_printf(L"cml=%lf sml1=%lf sml2=%lf sml3=%lf eml1=%lf eml2=%lf eml3=%lf\n",cml,Yroad[i].SmlOnZx,Yroad[i].LJFLSmlOnZx,Yroad[i].BPFLSmlOnZx,Yroad[i].EmlOnZx,Yroad[i].LJFLEmlOnZx,Yroad[i].BPFLEmlOnZx);
				if (Yroad[i].SmlOnZx > 0)
				{
					mincml = Yroad[i].SmlOnZx < Yroad[i].LJFLSmlOnZx ? Yroad[i].SmlOnZx : Yroad[i].LJFLSmlOnZx;
					maxcml = Yroad[i].SmlOnZx > Yroad[i].LJFLSmlOnZx ? Yroad[i].SmlOnZx : Yroad[i].LJFLSmlOnZx;
					if (cml > mincml - 0.001&&cml < maxcml + 0.001)
					{
						inf = 1;//当前线路为主线且里程位于鼻断范围内双路面考虑
						iroad = i;
						return inf;
					}
				}
				if (Yroad[i].LJFLEmlOnZx > 0 && Yroad[i].EmlOnZx > 0)
				{
					mincml = Yroad[i].LJFLEmlOnZx < Yroad[i].EmlOnZx ? Yroad[i].LJFLEmlOnZx : Yroad[i].EmlOnZx;
					maxcml = Yroad[i].LJFLEmlOnZx > Yroad[i].EmlOnZx ? Yroad[i].LJFLEmlOnZx : Yroad[i].EmlOnZx;
					if (cml > mincml - 0.001&&cml < maxcml + 0.001)
					{
						inf = 1;//当前线路为主线且里程位于鼻断范围内双路面考虑
						iroad = i;
						return inf;
					}

				}

				if (Yroad[i].LJFLSmlOnZx > 0 && Yroad[i].BPFLSmlOnZx > 0)
				{
					mincml = Yroad[i].LJFLSmlOnZx < Yroad[i].BPFLSmlOnZx ? Yroad[i].LJFLSmlOnZx : Yroad[i].BPFLSmlOnZx;
					maxcml = Yroad[i].LJFLSmlOnZx > Yroad[i].BPFLSmlOnZx ? Yroad[i].LJFLSmlOnZx : Yroad[i].BPFLSmlOnZx;
					if (cml > mincml - 0.001&&cml < maxcml + 0.001)
					{
						inf = 2;//当前线路为主线且里程位于鼻断范围内双路面考虑
						iroad = i;
						return inf;
					}

				}

				if (Yroad[i].LJFLEmlOnZx > 0 && Yroad[i].BPFLEmlOnZx > 0)
				{
					mincml = Yroad[i].LJFLEmlOnZx < Yroad[i].BPFLEmlOnZx ? Yroad[i].LJFLEmlOnZx : Yroad[i].BPFLEmlOnZx;
					maxcml = Yroad[i].LJFLEmlOnZx > Yroad[i].BPFLEmlOnZx ? Yroad[i].LJFLEmlOnZx : Yroad[i].BPFLEmlOnZx;
					if (cml > mincml - 0.001&&cml < maxcml + 0.001)
					{
						inf = 2;//当前线路为主线且里程位于鼻断范围内双路面考虑
						iroad = i;
						return inf;
					}

				}
			}
		}


	}
	return inf;
}


int HdmDes::CalZXxjj(double zxcml, JD_CENTER *zxpm, JD_CENTER *zdpm, double &xjj, double &zdcml)
{
	double projml, resPt[2];
	BAS_DRAW_FUN::CalXjj(zxcml, zxpm->XYArray, zxpm->XYNum, zdpm->XYArray, zdpm->XYNum,
		xjj, projml, resPt);
	xlpoint pZ;
	pZ.lc = zxcml;
	zxpm->xlpoint_pz(&pZ);
	double spt[2], fwj, PtOnFld[2];
	spt[0] = pZ.x, spt[1] = pZ.y;
	fwj = pZ.a;
	if (xjj > 0.0000001)
	{
		zdpm->CalJD_ZX_XL(spt, fwj + 0.5*pi, PtOnFld, zdcml);
		xjj = sqrt((spt[0] - PtOnFld[0])*(spt[0] - PtOnFld[0]) + (spt[1] - PtOnFld[1])*(spt[1] - PtOnFld[1]));//相关道路上的投影里程			   
	}
	else if (xjj < -0.0000001)
	{
		zdpm->CalJD_ZX_XL(spt, fwj - 0.5*pi, PtOnFld, zdcml);
		xjj = -sqrt((spt[0] - PtOnFld[0])*(spt[0] - PtOnFld[0]) + (spt[1] - PtOnFld[1])*(spt[1] - PtOnFld[1]));//相关道路上的投影里程			   
		//	   ads_printf(L"%lf %lf\n",road[0].hdmdes[j].cml,road[0].hdmdes[j].xjj);
	}
	else
	{
		xjj = 0.0;
		zdcml = projml;
	}
	return 1;
}


//设计关联横断面
void HdmDes::DesZXHdmLinkZD(int i, int j, int zory, RoadHdmdata &ZDroad)
{
	int ZIfBTinf, YIfBTinf;
	double LDesPoint[500], RDesPoint[500], LFillArea, LCutArea, RFillArea, RCutArea, FillArea, CutArea;
	double LGouH, LGouX, RGouH, RGouX;
	double LFillBetterSoilArea, LFillSSTArea, LQBTArea, LGouTarea, LGouWarea, LHJarea, LSGJQarea, LDQlength, LGrasslength;
	double RFillBetterSoilArea, RFillSSTArea, RQBTArea, RGouTarea, RGouWarea, RHJarea, RSGJQarea, RDQlength, RGrasslength;
	int Lnpt, Rnpt;
	//double LgouTarea,LgouWarea,RgouTarea,RgouWarea;
	double cml;
	double NewYd, NewLearpt[400], NewRearpt[400];
	int newNumL, newNumR;
	int jcross;
	double ZJ2;
	double glcml;

	ZIfBTinf = 0;
	YIfBTinf = 0;

	LFillBetterSoilArea = LFillSSTArea = LQBTArea = LGouTarea = LGouWarea = LHJarea = LSGJQarea = LDQlength = LGrasslength = 0.0;
	RFillBetterSoilArea = RFillSSTArea = RQBTArea = RGouTarea = RGouWarea = RHJarea = RSGJQarea = RDQlength = RGrasslength = 0.0;
	Lnpt = Rnpt = 0;
	LFillArea = RFillArea = FillArea = LCutArea = RCutArea = CutArea = 0.0;

	cml = road[i].hdmdes[j].cml;
	road[i].hdmdes[j].DorS = 1;
	road[i].hdmdes[j].newLYd = road[i].hdmdes[j].newRYd = road[i].hdmdmx[j].EarH;
	if (road[i].hdmdes[j].ZDMXZ == 3)//桥中
	{
		road[i].hdmdes[j].LZDK = road[i].hdmdes[j].RHFL[8] + road[i].hdmdes[j].BriZZDK;//桥梁用地
		if (road[i].NCRS == 1)
			ads_alert(L"指定里程位于桥梁范围内!");
		ZIfBTinf = 1;
	}

	if (road[i].hdmdes[j].ZDMXZ == 4)//隧中
	{
		//		road[i].hdmdes[j].LZDK=road[i].hdmdes[j].RHFL[8]+road[i].hdmdes[j].TunZZDK;//桥梁用地
		road[i].hdmdes[j].LZDK = 0.0;
		if (road[i].NCRS == 1)
			ads_alert(L"指定里程位于隧道范围内!");
		ZIfBTinf = 1;
	}
	if (road[i].hdmdes[j].YDMXZ == 3)//桥中
	{
		road[i].hdmdes[j].RZDK = road[i].hdmdes[j].RHFR[8] + road[i].hdmdes[j].BriYZDK;//桥梁用地
		if (road[i].NCRS == 1)
			ads_alert(L"指定里程位于桥梁范围内!");
		YIfBTinf = 1;
	}

	if (road[i].hdmdes[j].YDMXZ == 4)//隧中
	{
		//	road[i].hdmdes[j].RZDK=road[i].hdmdes[j].RHFR[8]+road[i].hdmdes[j].TunYZDK;//桥梁用地
		road[i].hdmdes[j].RZDK = 0.0;
		if (road[i].NCRS == 1)
			ads_alert(L"指定里程位于隧道范围内!");
		YIfBTinf = 1;
	}

	if (!ZIfBTinf && zory < -0.0001)//左线分离
	{
		NewYd = road[i].hdmdmx[j].EarH;
		newNumL = road[i].hdmdmx[j].ZEarPtNum;
		int k;
		for (k = 0; k < newNumL; k++)
		{
			NewLearpt[k * 2] = road[i].hdmdmx[j].ZEarPtAry[k].x;
			NewLearpt[k * 2 + 1] = road[i].hdmdmx[j].ZEarPtAry[k].y;
		}


		CrosNew(i, -1, j, NewYd, newNumL, NewLearpt, road[i].hdmdes[j].RHFL, road[i].hdmdes[j].zlmhd, road[i].hdmdes[j].ZZJ, road[i].hdmdes[j].ZPJPT,
			road[i].hdmdes[j].Ldeltah, road[i].hdmdes[j].Zt, road[i].hdmdes[j].ZHc, Lnpt, LDesPoint,
			LFillArea, LFillBetterSoilArea, LQBTArea, LCutArea,
			road[i].hdmdes[j].LZDK,
			road[i].hdmdes[j].LIfSetGouH, road[i].hdmdes[j].LGouH, road[i].hdmdes[j].LGouProperty, road[i].hdmdes[j].LGouPtNum, road[i].hdmdes[j].Lgou, LGouH, LGouX, LGouTarea, LGouWarea,
			road[i].hdmdes[j].LJSGouPtNum, road[i].hdmdes[j].LJSgou,
			LSGJQarea, LDQlength, LGrasslength, road[i].hdmdes[j].ZCG_GDR);


		//1.计算左线对应里程段落

		//计算是否有关联断面

		CalLinkZDHdm(i, j, -1, Lnpt, LDesPoint, ZDroad, glcml, road[i].hdmdes[j].ZZJ, ZJ2);
		if (glcml > -0.0001)//有关联断面
		{
			//对于主线需要按ZJ1重新设计
			if (ZJ2 < -0.01)
			{
				jcross = InsertHdm(i, j, ZDroad, 1, ZJ2, glcml);

				CalLinkHdm_TWPJD(i, j, -1, ZDroad, jcross);
			}

			CrosNew(i, -1, j, NewYd, newNumL, NewLearpt, road[i].hdmdes[j].RHFL, road[i].hdmdes[j].zlmhd, road[i].hdmdes[j].ZZJ, road[i].hdmdes[j].ZPJPT,
				road[i].hdmdes[j].Ldeltah, road[i].hdmdes[j].Zt, road[i].hdmdes[j].ZHc, Lnpt, LDesPoint,
				LFillArea, LFillBetterSoilArea, LQBTArea, LCutArea,
				road[i].hdmdes[j].LZDK,
				road[i].hdmdes[j].LIfSetGouH, road[i].hdmdes[j].LGouH, road[i].hdmdes[j].LGouProperty, road[i].hdmdes[j].LGouPtNum, road[i].hdmdes[j].Lgou, LGouH, LGouX, LGouTarea, LGouWarea,
				road[i].hdmdes[j].LJSGouPtNum, road[i].hdmdes[j].LJSgou,
				LSGJQarea, LDQlength, LGrasslength, road[i].hdmdes[j].ZCG_GDR);

			//		road[i].hdmdes[j].glcml = glcml;
			//		road[i].hdmdes[j].glRoadName = ZDroad.roadname;
			road[i].hdmdes[j].LIfSetGouH = 0;
			road[i].hdmdes[j].LJSGouPtNum = 0;
			road[i].hdmdes[j].LGouProperty = -1;
			road[i].hdmdes[j].LGouPtNum = 0;
			road[i].hdmdes[j].LZDK = 0;
			LGouH = LGouX = LGouTarea = LGouWarea = 0.0;
			//对于分离线需要插入该断面,并设置与主线关联
			//ads_printf(L"iroad=%d ZJ2=%lf\n",iroad,ZJ2);
			jcross = InsertHdm(i, j, ZDroad, 1, ZJ2, glcml);
			ZDroad.hdmdes[jcross].RZDK = 0;
			//对road[i].hdmdes[j].zlink付值
			road[i].hdmdes[j].IfHasZlink = 1;

			if (road[i].hdmdes[j].zlink) delete road[i].hdmdes[j].zlink;
			road[i].hdmdes[j].zlink = new CRSDAT;
			SetLinkHdmData(road[i].hdmdes[j].zlink, ZDroad, jcross);
			//road[i].hdmdes[j].zlink = &ZDroad.hdmdes[jcross];
			road[i].hdmdes[j].zlink->cml = glcml;
			road[i].hdmdes[j].zlink->glRoadName = ZDroad.roadname;

		}


		road[i].hdmdes[j].Z_LFillArea = LFillArea + LGouTarea;
		road[i].hdmdes[j].Z_LCutArea = LCutArea + LGouWarea;
		road[i].hdmdes[j].Z_LFillSSTArea = LFillSSTArea;
		road[i].hdmdes[j].Z_LQBTArea = LQBTArea;
		road[i].hdmdes[j].Z_LHJarea = LHJarea;
		road[i].hdmdes[j].Z_LSGJQarea = LSGJQarea;
		road[i].hdmdes[j].Z_LDQlength = LDQlength;
		road[i].hdmdes[j].Z_LGrasslength = LGrasslength;
		road[i].hdmdes[j].Z_LGouTarea = LGouTarea;
		road[i].hdmdes[j].Z_LGouWarea = LGouWarea;

		road[i].hdmdes[j].Lnpt = Lnpt;
		if (road[i].hdmdes[j].RPTL.length() > 0)
			road[i].hdmdes[j].RPTL.removeSubArray(0, road[i].hdmdes[j].RPTL.length() - 1);

		AcGePoint3d pt;
		for (k = 0; k < Lnpt; k++)
		{
			pt.x = -1.0*LDesPoint[k * 2];
			pt.y = LDesPoint[k * 2 + 1];
			road[i].hdmdes[j].RPTL.append(pt);

		}
		if (road[i].hdmdes[j].Lnpt > 0)
			road[i].hdmdes[j].Ljdnum = road[i].hdmdes[j].Lnpt - 1;
		for (k = 0; k < road[i].hdmdes[j].LJSGouPtNum; k++)
			road[i].hdmdes[j].LJSgou[k * 2] = -1 * road[i].hdmdes[j].LJSgou[k * 2];
		for (int kk = 0; kk < road[i].hdmdes[j].LGouPtNum; kk++)
			road[i].hdmdes[j].Lgou[kk * 2] = -1 * road[i].hdmdes[j].Lgou[kk * 2];


	}

	//判别右侧是否为桥隧
	if (!YIfBTinf && zory > 0.0001)
	{
		NewYd = road[i].hdmdmx[j].EarH;
		newNumR = road[i].hdmdmx[j].YEarPtNum;
		int k;
		for (k = 0; k < newNumR; k++)
		{
			NewRearpt[k * 2] = road[i].hdmdmx[j].YEarPtAry[k].x;
			NewRearpt[k * 2 + 1] = road[i].hdmdmx[j].YEarPtAry[k].y;
		}

		CrosNew(i, 1, j, NewYd, newNumR, NewRearpt, road[i].hdmdes[j].RHFR, road[i].hdmdes[j].ylmhd, road[i].hdmdes[j].YZJ, road[i].hdmdes[j].YPJPT,
			road[i].hdmdes[j].Rdeltah, road[i].hdmdes[j].Yt, road[i].hdmdes[j].YHc, Rnpt, RDesPoint,
			RFillArea, RFillBetterSoilArea, RQBTArea, RCutArea,
			road[i].hdmdes[j].RZDK,
			road[i].hdmdes[j].RIfSetGouH, road[i].hdmdes[j].RGouH, road[i].hdmdes[j].RGouProperty, road[i].hdmdes[j].RGouPtNum, road[i].hdmdes[j].Rgou, RGouH, RGouX, RGouTarea, RGouWarea,
			road[i].hdmdes[j].RJSGouPtNum, road[i].hdmdes[j].RJSgou,
			RSGJQarea, RDQlength, RGrasslength, road[i].hdmdes[j].YCG_GDR);

		//1.计算右线对应里程段落
		double spt[2];

		CalLinkZDHdm(i, j, 1, Rnpt, RDesPoint, ZDroad, glcml, road[i].hdmdes[j].YZJ, ZJ2);

		if (glcml > -0.0001)//有关联断面
		{
			//			   ads_printf(L"dml=%lf glcml=%lf %lf zj2=%lf\n",road[i].hdmdes[j].dml,glcml,road[i].hdmdes[j].YZJ,ZJ2);

			if (ZJ2 < -0.01)
			{

				jcross = InsertHdm(i, j, ZDroad, -1, ZJ2, glcml);
				CalLinkHdm_TWPJD(i, j, 1, ZDroad, jcross);
			}


			//				 ads_printf(L"####%lf\n", road[i].hdmdes[j].dml);
			//对于主线需要按ZJ1重新设计
			CrosNew(i, 1, j, NewYd, newNumR, NewRearpt, road[i].hdmdes[j].RHFR, road[i].hdmdes[j].ylmhd, road[i].hdmdes[j].YZJ, road[i].hdmdes[j].YPJPT,
				road[i].hdmdes[j].Rdeltah, road[i].hdmdes[j].Yt, road[i].hdmdes[j].YHc, Rnpt, RDesPoint,
				RFillArea, RFillBetterSoilArea, RQBTArea, RCutArea,
				road[i].hdmdes[j].RZDK,
				road[i].hdmdes[j].RIfSetGouH, road[i].hdmdes[j].RGouH, road[i].hdmdes[j].RGouProperty, road[i].hdmdes[j].RGouPtNum, road[i].hdmdes[j].Rgou, RGouH, RGouX, RGouTarea, RGouWarea,
				road[i].hdmdes[j].RJSGouPtNum, road[i].hdmdes[j].RJSgou,
				RSGJQarea, RDQlength, RGrasslength, road[i].hdmdes[j].YCG_GDR);

			road[i].hdmdes[j].glcml = glcml;
			road[i].hdmdes[j].glRoadName = ZDroad.roadname;
			road[i].hdmdes[j].RIfSetGouH = 0;
			road[i].hdmdes[j].RGouH = 0.0;
			road[i].hdmdes[j].RGouProperty = -1;
			road[i].hdmdes[j].RGouPtNum = 0;
			RGouH = RGouX = RGouTarea = RGouWarea = 0.0;
			road[i].hdmdes[j].RJSGouPtNum = 0;
			RSGJQarea = RDQlength = RGrasslength = 0.0;
			road[i].hdmdes[j].RZDK = 0;
			//对于分离线需要插入该断面
			road[i].hdmdes[j].IfHasYlink = 1;
			jcross = InsertHdm(i, j, ZDroad, -1, ZJ2, glcml);

			ZDroad.hdmdes[jcross].LZDK = 0;
			//	if(road[i].hdmdes[j].ylink) delete road[i].hdmdes[j].ylink;
			road[i].hdmdes[j].ylink = new CRSDAT;

			SetLinkHdmData(road[i].hdmdes[j].ylink, ZDroad, jcross);
			road[i].hdmdes[j].ylink = &ZDroad.hdmdes[jcross];
			road[i].hdmdes[j].ylink->cml = glcml;
			road[i].hdmdes[j].ylink->glRoadName = ZDroad.roadname;

		}

		road[i].hdmdes[j].Y_RFillArea = RFillArea + RGouTarea;
		road[i].hdmdes[j].Y_RCutArea = RCutArea + RGouWarea;
		road[i].hdmdes[j].Y_RFillSSTArea = RFillSSTArea;
		road[i].hdmdes[j].Y_RQBTArea = RQBTArea;
		road[i].hdmdes[j].Y_RHJarea = RHJarea;
		road[i].hdmdes[j].Y_RSGJQarea = RSGJQarea;
		road[i].hdmdes[j].Y_RDQlength = RDQlength;
		road[i].hdmdes[j].Y_RGrasslength = RGrasslength;
		road[i].hdmdes[j].Y_RGouTarea = RGouTarea;
		road[i].hdmdes[j].Y_RGouWarea = RGouWarea;

		road[i].hdmdes[j].Rnpt = Rnpt;
		if (road[i].hdmdes[j].RPTR.length() > 0)
			road[i].hdmdes[j].RPTR.removeSubArray(0, road[i].hdmdes[j].RPTR.length() - 1);

		AcGePoint3d pt;
		for (k = 0; k < Rnpt; k++)
		{
			pt.x = RDesPoint[k * 2];
			pt.y = RDesPoint[k * 2 + 1];
			road[i].hdmdes[j].RPTR.append(pt);

		}
		if (road[i].hdmdes[j].Rnpt > 0)
			road[i].hdmdes[j].Rjdnum = road[i].hdmdes[j].Rnpt - 1;
		for (k = 0; k < road[i].hdmdes[j].RJSGouPtNum; k++)
			road[i].hdmdes[j].RJSgou[k * 2] = road[i].hdmdes[j].RJSgou[k * 2];
		for (int kk = 0; kk < road[i].hdmdes[j].RGouPtNum; kk++)
			road[i].hdmdes[j].Rgou[kk * 2] = road[i].hdmdes[j].Rgou[kk * 2];



	}


	//计算左右两侧面积		 
	/*

	road[i].hdmdes[j].QBTArea = LQBTArea + RQBTArea;//清表土面积
	road[i].hdmdes[j].GouTarea = LGouTarea + RGouTarea;//水沟填面积
	road[i].hdmdes[j].GouWarea = LGouWarea + RGouWarea;//水沟挖面积
	road[i].hdmdes[j].FillArea = LFillArea + RFillArea + road[i].hdmdes[j].GouTarea + road[i].hdmdes[j].QBTArea;//填面积
	road[i].hdmdes[j].CutArea = LCutArea + RCutArea + road[i].hdmdes[j].GouWarea; //挖面积
	road[i].hdmdes[j].aw = road[i].hdmdes[j].CutArea;
	road[i].hdmdes[j].at = road[i].hdmdes[j].FillArea;
	road[i].hdmdes[j].FillBetterSoilArea = LFillBetterSoilArea+RFillBetterSoilArea;//填改良土面积
	road[i].hdmdes[j].HJarea =  LHJarea + RHJarea;//护肩面积
	road[i].hdmdes[j].SGJQarea = LSGJQarea + RSGJQarea;//浆砌面积
	road[i].hdmdes[j].DQlength = LDQlength + RDQlength;//挡墙坡长
	road[i].hdmdes[j].Grasslength = LGrasslength + RGrasslength;//铺草坡长*/

	//用于交互设计
}

void HdmDes::CalLinkZDHdm(int i, int jcross, int LorR, int desptsum, double DesPt[], RoadHdmdata &ZDroad, double &glcml, double &ZJ1, double &ZJ2)
{
	double SptZX[2], EptZX[2];
	xlpoint PZ;
	int ZIfBTinf, YIfBTinf;
	double NewYd, NewLearpt[400], NewRearpt[400];
	int newNumL, newNumR;
	int Rnpt1, Rnpt2;
	double RDesPoint1[500], RDesPoint2[500], Yt1, Yt2;
	int Lnpt1, Lnpt2;
	double LDesPoint1[500], LDesPoint2[500], Zt1, Zt2;
	int SnoOnFld, EnoOnFld, k;
	double ZX_TW;
	double ZPJPT[2], YPJPT[2];

	ZPJPT[0] = YPJPT[0] = ZPJPT[1] = YPJPT[1] = -1;
	ZIfBTinf = 0;
	YIfBTinf = 0;
	double cml;

	glcml = -1;//无关
	ZJ1 = ZJ2 = 1000;
	cml = road[i].hdmdes[jcross].cml;
	double XJJ, CmlOnFLD;
	CalZXxjj(cml, road[i].pm, ZDroad.pm, XJJ, CmlOnFLD);
	road[0].hdmdes[jcross].xjj = XJJ;
	if (fabs(road[i].hdmdes[jcross].xjj) > 80.0)
		return;

	PZ.lc = cml;
	road[i].pm->xlpoint_pz(&PZ);

	//计算两线路肩距离
	double xjj;
	xjj = fabs(road[i].hdmdes[jcross].xjj);

	double zxwid, yxwid, yxcml;
	double half_fgdk, lydk, cxdk, yljk, tljk, tljhp;
	int bkmode, sjbgmode;
	if (LorR < 0)//iroad右侧带帽子
	{
		zxwid = road[i].hdmdes[jcross].RHFL[8];
		yxcml = ZDroad.pm->PROJ_ML(PZ.x, PZ.y);
		CalLMK_JK(yxcml, ZDroad.NYLMK, ZDroad.YLMK,
			ZDroad.YcgNm, ZDroad.Ycg,
			ZDroad.YjkNm, ZDroad.Yjk,
			half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		//		yxwid = half_fgdk+lydk+cxdk+yljk+tljk;
	}
	else
	{
		zxwid = road[i].hdmdes[jcross].RHFR[8];
		yxcml = ZDroad.pm->PROJ_ML(PZ.x, PZ.y);
		CalLMK_JK(yxcml, ZDroad.NZLMK, ZDroad.ZLMK,
			ZDroad.ZcgNm, ZDroad.Zcg,
			ZDroad.ZjkNm, ZDroad.Zjk,
			half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
		//		yxwid = half_fgdk+lydk+cxdk+yljk+tljk;
	}
	CalLMKbyFile(yxcml, LorR, ZDroad.pm, ZDroad.pBXArr, ZDroad.BxNum, half_fgdk, lydk, cxdk, yljk, tljk);
	yxwid = half_fgdk + lydk + cxdk + yljk + tljk;
	/*
	if(fabs(cml-180400)<0.1)
	{
	CString mes;
	mes.Format(L"xjj=%lf",fabs(zxwid+yxwid-fabs(xjj)));
	ads_alert(mes);
	}*/

	if (fabs(zxwid + yxwid - fabs(xjj)) < 5.0)//关联
	{
		glcml = yxcml;
		ZJ2 = -100;
		return;
	}

	double pjdx = fabs(DesPt[(desptsum - 1) * 2]);

	SptZX[0] = PZ.x, SptZX[1] = PZ.y;
	EptZX[0] = PZ.x + fabs(pjdx)*cos(PZ.a + LorR * 0.5*pi);
	EptZX[1] = PZ.y + fabs(pjdx)*sin(PZ.a + LorR * 0.5*pi);
	double sml, eml, lcmin, lcmax;
	sml = ZDroad.pm->PROJ_ML(SptZX[0], SptZX[1]);
	eml = ZDroad.pm->PROJ_ML(EptZX[0], EptZX[1]);
	//判别主线坡脚点ept是否进入匝道路面范围
	//
	//	double dist;
	//	int zy;
	//    zy = ZDroad.pm->JudgePTLorR(EptZX[0],EptZX[1],dist,ZDroad.pm->XYArray,ZDroad.pm->XYNum);
	//ads_printf(L"%lf %d LorR=%d dist=%lf yxwid=%lf sml=%lf eml=%lf\n",cml,zy,LorR,dist,yxwid,sml,eml);
	//	if(zy*LorR<0)//进一步判别点是否位于匝道路面范围内
	//	{
	//		if(dist<yxwid)//主线坡脚深入匝道路面
	//		{
	//			glcml = yxcml;
	//            ZJ2 = -100;
	//			return;
	//		}
	//	}
	//	else
	//	{
	//       glcml = yxcml;
	//       ZJ2 = -100;
	//		return ;
	//	}
	//判别匝道坡脚点ept是否进入主线路面范围

	lcmin = sml < eml ? sml : eml;
	lcmax = sml > eml ? sml : eml;

	lcmin -= 1.0;
	lcmax += 1.0;
	int j = 0;
	while (j < ZDroad.NCRS && ZDroad.hdmdes[j].cml < lcmin - 0.001)
		j++;
	SnoOnFld = j - 1 < 0 ? 0 : j - 1;
	j = 0;
	while (j < ZDroad.NCRS && ZDroad.hdmdes[j].cml < lcmax + 0.001)
		j++;
	EnoOnFld = j + 1 > ZDroad.NCRS - 1 ? ZDroad.NCRS - 1 : j + 1;

	if (LorR < 0)//iroad右侧带帽子
	{
		ZX_TW = road[i].hdmdes[jcross].Zt;
		for (j = SnoOnFld; j < EnoOnFld; j++)
		{
			if (ZDroad.hdmdes[j].YDMXZ != 3 && ZDroad.hdmdes[j].YDMXZ != 4)
			{
				NewYd = ZDroad.hdmdmx[j].EarH;
				newNumR = ZDroad.hdmdmx[j].YEarPtNum;
				for (int k = 0; k < newNumR; k++)
				{
					NewRearpt[k * 2] = ZDroad.hdmdmx[j].YEarPtAry[k].x;
					NewRearpt[k * 2 + 1] = ZDroad.hdmdmx[j].YEarPtAry[k].y;
				}
				double tmp, gou[20], jsg[14];
				int itmp;
				CrosNew1(ZDroad, 1, ZDroad.hdmdes[j].cml, NewYd, newNumR, NewRearpt, ZDroad.hdmdes[j].RHFR, ZDroad.hdmdes[j].ylmhd, 1000, YPJPT,
					ZDroad.hdmdes[j].Rdeltah, Yt1, ZDroad.hdmdes[j].YHc, Rnpt1, RDesPoint1,
					tmp, tmp, tmp, tmp,
					tmp,
					itmp, tmp, itmp, itmp, gou, tmp, tmp, tmp, tmp,
					itmp, jsg,
					tmp, tmp, tmp);
			}
			else
				continue;

			if (ZDroad.hdmdes[j + 1].YDMXZ != 3 && ZDroad.hdmdes[j + 1].YDMXZ != 4)
			{
				NewYd = ZDroad.hdmdmx[j + 1].EarH;
				newNumR = ZDroad.hdmdmx[j + 1].YEarPtNum;
				for (int k = 0; k < newNumR; k++)
				{
					NewRearpt[k * 2] = ZDroad.hdmdmx[j + 1].YEarPtAry[k].x;
					NewRearpt[k * 2 + 1] = ZDroad.hdmdmx[j + 1].YEarPtAry[k].y;
				}
				double tmp, gou[20], jsg[14];
				int itmp;
				CrosNew1(ZDroad, 1, ZDroad.hdmdes[j + 1].cml, NewYd, newNumR, NewRearpt, ZDroad.hdmdes[j + 1].RHFR, ZDroad.hdmdes[j + 1].ylmhd, 1000, YPJPT,
					ZDroad.hdmdes[j + 1].Rdeltah, Yt2, ZDroad.hdmdes[j + 1].YHc, Rnpt2, RDesPoint2,
					tmp, tmp, tmp, tmp,
					tmp,
					itmp, tmp, itmp, itmp, gou, tmp, tmp, tmp, tmp,
					itmp, jsg,
					tmp, tmp, tmp);
			}
			else
				continue;

			//ads_printf(L"Yt1=%lf Yt2=%lf ZX=%lf\n",Yt1,Yt2,ZX_TW);
			if ((Yt1 < 0.1&&Yt2 < 0.1) || (Yt1 > 0.9&&Yt2 > 0.9))
			{
				if ((ZX_TW < 0.1&&Yt1 < 0.1) || (ZX_TW > 0.9&&Yt1 > 0.9))
				{
					//计算三维边坡线
					AcGePoint3d Pt;
					AcGePoint3dArray PtArr;
					for (k = 0; k < desptsum; k++)
					{
						Pt.x = PZ.x + fabs(DesPt[k * 2]) * cos(PZ.a + LorR * 0.5*pi);
						Pt.y = PZ.y + fabs(DesPt[k * 2]) * sin(PZ.a + LorR * 0.5*pi);
						Pt.z = DesPt[k * 2 + 1] + road[i].hdmdmx[jcross].EarH;
						//ads_printf(L"zx: %lf %lf %lf %lf\n",Pt.x,Pt.y,Pt.z,road[i].hdmdmx[jcross].EarH);
						PtArr.append(Pt);
					}
					AcDb3dPolyline *zxbp;
					//形成路面
					xlpoint PZ1;
					AcGePoint3dArray PtArr1;
					PZ1.lc = ZDroad.hdmdes[j].cml;
					ZDroad.pm->xlpoint_pz(&PZ1);
					for (k = 0; k < Rnpt1; k++)
					{
						Pt.x = PZ1.x + fabs(RDesPoint1[k * 2]) * cos(PZ1.a - LorR * 0.5*pi);
						Pt.y = PZ1.y + fabs(RDesPoint1[k * 2]) * sin(PZ1.a - LorR * 0.5*pi);
						Pt.z = RDesPoint1[k * 2 + 1] + ZDroad.hdmdmx[j].EarH;
						//ads_printf(L"zd: %lf %lf %lf %lf\n",Pt.x,Pt.y,Pt.z,ZDroad.hdmdmx[j].EarH);
						PtArr1.append(Pt);
					}

					AcGePoint3dArray PtArr2;
					PZ1.lc = ZDroad.hdmdes[j + 1].cml;
					ZDroad.pm->xlpoint_pz(&PZ1);
					for (k = 0; k < Rnpt2; k++)
					{
						Pt.x = PZ1.x + fabs(RDesPoint2[k * 2]) * cos(PZ1.a - LorR * 0.5*pi);
						Pt.y = PZ1.y + fabs(RDesPoint2[k * 2]) * sin(PZ1.a - LorR * 0.5*pi);
						Pt.z = RDesPoint2[k * 2 + 1] + ZDroad.hdmdmx[j + 1].EarH;
						//ads_printf(L"zd: %lf %lf %lf\n",Pt.x,Pt.y,Pt.z);
						PtArr2.append(Pt);
					}
					for (int n = 0; n < desptsum - 1; n++)
					{
						AcGeLine3d zxline(PtArr[n], PtArr[n + 1]);
						int npt;
						npt = Rnpt1 < Rnpt2 ? Rnpt1 : Rnpt2;
						AcGePoint3d InterPt1;
						for (k = 0; k < npt - 1; k++)
						{
							AcDbFace face(PtArr1[k], PtArr1[k + 1], PtArr2[k + 1], PtArr2[k]);
							AcGePlane prj(PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]);

							////					if(fabs(road[i].hdmdes[jcross].dml-208130.35)<0.1)
							////					{
							//						AcDbFace *face1;
							//						face1 = new AcDbFace(PtArr1[k],PtArr1[k+1],PtArr2[k+1]);		
							//						AddEntityToDbs(face1);
							//						bool res;
							//						res = prj.intersectWith(zxline,InterPt1);	
							//						ads_point pt;
							//						pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
							//						acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
							//						//	IfPrint=true;
							//						ads_printf(L"zx=%lf %lf %lf 1:%lf %lf %lf 2:%lf %lf %lf\n",InterPt1.x,InterPt1.y,InterPt1.z,PtArr[n].x,PtArr[n].y,PtArr[n].z,PtArr[n+1].x,PtArr[n+1].y,PtArr[n+1].z);
							//						ads_printf(L"in=%d zx=%d tri=%d\n",res,CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr1[k+1],PtArr2[k+1]));
							//						//		IfPrint=false;
							////					}*/
							//ads_printf(L"inf1=%d inf2=%d inf3=%d\n",prj.intersectWith(zxline,InterPt1),CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr1[k+1],PtArr2[k+1]));

							if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
								&& CheckPtInTri(InterPt1, PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]))//有交点
							{
								//投影到iroad线路上计算里程
								glcml = ZDroad.pm->PROJ_ML(InterPt1.x, InterPt1.y);
								//计算支距ZJ1,ZJ2,
								ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
								PZ1.lc = glcml;
								ZDroad.pm->xlpoint_pz(&PZ1);
								ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
								//						ads_printf(L"0: %lf\n",InterPt1.z);
								return;
							}

							AcGePlane prj1(PtArr1[k], PtArr2[k + 1], PtArr2[k]);
							/*
							AcDbFace *face3;
							if(fabs(road[i].hdmdes[jcross].dml-208130.35)<0.1)
							{
							face3 = new AcDbFace(PtArr1[k],PtArr2[k+1],PtArr2[k]);
							AddEntityToDbs(face3);
							bool res;
							res = prj1.intersectWith(zxline,InterPt1);
							ads_point pt;
							pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
							acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
							//	IfPrint=true;
							ads_printf(L"zx=%lf %lf %lf 1:%lf %lf %lf 2:%lf %lf %lf\n",InterPt1.x,InterPt1.y,InterPt1.z,PtArr[n].x,PtArr[n].y,PtArr[n].z,PtArr[n+1].x,PtArr[n+1].y,PtArr[n+1].z);
							ads_printf(L"re=%d zx=%d tri=%d\n",res,CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr2[k+1],PtArr2[k]));
							//	IfPrint=false;
							}	*/

							//ads_printf(L"inf1=%d inf2=%d inf3=%d\n",prj.intersectWith(zxline,InterPt1),CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr1[k+1],PtArr2[k]));
							if (prj1.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
								&& CheckPtInTri(InterPt1, PtArr1[k], PtArr2[k + 1], PtArr2[k]))//有交点
							{
								//投影到iroad线路上计算里程
								glcml = ZDroad.pm->PROJ_ML(InterPt1.x, InterPt1.y);
								//计算支距ZJ1,ZJ2,
								ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
								PZ1.lc = glcml;
								ZDroad.pm->xlpoint_pz(&PZ1);
								ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
								//						ads_printf(L"0: %lf\n",InterPt1.z);
								return;
							}
						}

						if (Rnpt1 > npt)
						{
							for (k = npt - 1; k < Rnpt1 - 1; k++)
							{
								AcDbFace face(PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1], PtArr2[npt - 1]);
								AcGePlane prj(PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1]);
								//ads_printf(L"inf1=%d inf2=%d inf3=%d\n",prj.intersectWith(zxline,InterPt1),CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr1[k+1],PtArr2[npt-1]));					   
								if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
									&& CheckPtInTri(InterPt1, PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1]))//有交点
								{
									//投影到iroad线路上计算里程
									glcml = ZDroad.pm->PROJ_ML(InterPt1.x, InterPt1.y);
									//计算支距ZJ1,ZJ2,
									ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
									PZ1.lc = glcml;
									ZDroad.pm->xlpoint_pz(&PZ1);
									ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
									//							ads_printf(L"0: %lf\n",InterPt1.z);
									return;
								}
							}
						}

						if (Rnpt2 > npt)
						{
							for (k = npt - 1; k < Rnpt2 - 1; k++)
							{
								AcDbFace face(PtArr1[npt - 1], PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]);
								AcGePlane prj(PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]);

								if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
									&& CheckPtInTri(InterPt1, PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]))//有交点
								{
									//投影到iroad线路上计算里程
									glcml = ZDroad.pm->PROJ_ML(InterPt1.x, InterPt1.y);
									//计算支距ZJ1,ZJ2,
									ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
									PZ1.lc = glcml;
									ZDroad.pm->xlpoint_pz(&PZ1);
									ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
									//							ads_printf(L"0: %lf\n",InterPt1.z);
									return;
								}
							}
						}
					}
				}
				//左右线性质相同
				else
				{
					//1.计算坡脚点到主线中心的距离bpc
					double bpc = fabs(DesPt[(desptsum - 1) * 2]);
					//2.计算当前线路法线与二线交点的长度xjj
					double spt[2], fwj, PtOnFld[2], FLDcml;
					xlpoint PZ;
					PZ.lc = road[i].hdmdes[jcross].cml;
					road[i].pm->xlpoint_pz(&PZ);
					spt[0] = PZ.x, spt[1] = PZ.y;
					fwj = PZ.a;
					ZDroad.pm->CalJD_ZX_XL(spt, fwj - 0.5*pi, PtOnFld, FLDcml);
					double xjj = sqrt((spt[0] - PtOnFld[0])*(spt[0] - PtOnFld[0]) + (spt[1] - PtOnFld[1])*(spt[1] - PtOnFld[1]));//相关道路上的投影里程			   
					//3.if(bpc>xjj) 
					if (bpc > xjj)//设置关联
					{
						glcml = FLDcml;
						ZJ2 = -100;//特殊关联标志
						return;
					}
					else
					{
						spt[0] = PZ.x + bpc * cos(fwj - 0.5*pi);
						spt[1] = PZ.y + bpc * sin(fwj - 0.5*pi);
						//4.else 求坡脚点到二线的长度len,及投影里程prjml
						double prjml = ZDroad.pm->PROJ_ML(spt[0], spt[1]);
						//5.计算二线prjml处坡脚点长度bpc1;
						if (prjml > ZDroad.hdmdes[j + 1].cml + 0.001 || prjml < ZDroad.hdmdes[j].cml - 0.001)
							continue;
						else
						{
							double bpc1;
							if (fabs(ZDroad.hdmdes[j + 1].cml - ZDroad.hdmdes[j].cml) < 0.0001)
								bpc1 = RDesPoint1[(Rnpt1 - 1) * 2];
							else
								bpc1 = RDesPoint1[(Rnpt1 - 1) * 2] + (prjml - ZDroad.hdmdes[j].cml)*(RDesPoint2[(Rnpt2 - 1) * 2] - RDesPoint1[(Rnpt1 - 1) * 2]) / (ZDroad.hdmdes[j + 1].cml - ZDroad.hdmdes[j].cml);
							bpc1 = fabs(bpc1);
							//6.if(len1>bpc1) 无关联
							PZ.lc = prjml;
							ZDroad.pm->xlpoint_pz(&PZ);
							double len1 = sqrt((PZ.x - spt[0])*(PZ.x - spt[0]) + (PZ.y - spt[1])*(PZ.y - spt[1]));
							if (len1 < bpc1)
							{
								//7 else 设置关联
								glcml = prjml;
								ZJ2 = -100;//特殊关联标志
								return;
							}

						}
					}
				}
			}

		}
	}
	else
	{
		ZX_TW = road[i].hdmdes[jcross].Yt;
		for (j = SnoOnFld; j < EnoOnFld; j++)
		{
			if (ZDroad.hdmdes[j].ZDMXZ != 3 && ZDroad.hdmdes[j].ZDMXZ != 4)
			{
				NewYd = ZDroad.hdmdmx[j].EarH;
				newNumL = ZDroad.hdmdmx[j].ZEarPtNum;
				for (int k = 0; k < newNumL; k++)
				{
					NewLearpt[k * 2] = ZDroad.hdmdmx[j].ZEarPtAry[k].x;
					NewLearpt[k * 2 + 1] = ZDroad.hdmdmx[j].ZEarPtAry[k].y;
				}
				double tmp, gou[20], jsg[14];
				int itmp;
				CrosNew1(ZDroad, -1, ZDroad.hdmdes[j].cml, NewYd, newNumL, NewLearpt, ZDroad.hdmdes[j].RHFL, ZDroad.hdmdes[j].zlmhd, 1000, ZPJPT,
					ZDroad.hdmdes[j].Ldeltah, Zt1, ZDroad.hdmdes[j].ZHc, Lnpt1, LDesPoint1,
					tmp, tmp, tmp, tmp,
					tmp,
					itmp, tmp, itmp, itmp, gou, tmp, tmp, tmp, tmp,
					itmp, jsg,
					tmp, tmp, tmp);
			}
			else
				continue;

			if (ZDroad.hdmdes[j + 1].ZDMXZ != 3 && ZDroad.hdmdes[j + 1].ZDMXZ != 4)
			{
				NewYd = ZDroad.hdmdmx[j + 1].EarH;
				newNumL = ZDroad.hdmdmx[j + 1].ZEarPtNum;
				for (int k = 0; k < newNumL; k++)
				{
					NewLearpt[k * 2] = ZDroad.hdmdmx[j + 1].ZEarPtAry[k].x;
					NewLearpt[k * 2 + 1] = ZDroad.hdmdmx[j + 1].ZEarPtAry[k].y;
				}
				double tmp, gou[20], jsg[14];
				int itmp;
				CrosNew1(ZDroad, -1, ZDroad.hdmdes[j + 1].cml, NewYd, newNumL, NewLearpt, ZDroad.hdmdes[j + 1].RHFL, ZDroad.hdmdes[j + 1].zlmhd, 1000, ZPJPT,
					ZDroad.hdmdes[j + 1].Ldeltah, Zt2, ZDroad.hdmdes[j + 1].ZHc, Lnpt2, LDesPoint2,
					tmp, tmp, tmp, tmp,
					tmp,
					itmp, tmp, itmp, itmp, gou, tmp, tmp, tmp, tmp,
					itmp, jsg,
					tmp, tmp, tmp);
			}
			else
				continue;

			if ((Zt1 < 0.1&&Zt2 < 0.1) || (Zt1 > 0.9&&Zt2 > 0.9))
			{
				if ((ZX_TW < 0.1&&Zt1 < 0.1) || (ZX_TW > 0.9&&Zt1 > 0.9))
				{
					//计算三维边坡线
					AcGePoint3d Pt;
					AcGePoint3dArray PtArr;
					for (k = 0; k < desptsum; k++)
					{
						Pt.x = PZ.x + fabs(DesPt[k * 2]) * cos(PZ.a + LorR * 0.5*pi);
						Pt.y = PZ.y + fabs(DesPt[k * 2]) * sin(PZ.a + LorR * 0.5*pi);
						Pt.z = DesPt[k * 2 + 1] + road[i].hdmdmx[jcross].EarH;

						PtArr.append(Pt);
					}

					//形成路面
					xlpoint PZ1;
					AcGePoint3dArray PtArr1;
					PZ1.lc = ZDroad.hdmdes[j].cml;
					ZDroad.pm->xlpoint_pz(&PZ1);
					for (k = 0; k < Lnpt1; k++)
					{
						Pt.x = PZ1.x + fabs(LDesPoint1[k * 2]) * cos(PZ1.a - LorR * 0.5*pi);
						Pt.y = PZ1.y + fabs(LDesPoint1[k * 2]) * sin(PZ1.a - LorR * 0.5*pi);
						Pt.z = LDesPoint1[k * 2 + 1] + ZDroad.hdmdmx[j].EarH;

						PtArr1.append(Pt);
					}

					AcGePoint3dArray PtArr2;
					PZ1.lc = ZDroad.hdmdes[j + 1].cml;
					ZDroad.pm->xlpoint_pz(&PZ1);
					for (k = 0; k < Lnpt2; k++)
					{
						Pt.x = PZ1.x + fabs(LDesPoint2[k * 2]) * cos(PZ1.a - LorR * 0.5*pi);
						Pt.y = PZ1.y + fabs(LDesPoint2[k * 2]) * sin(PZ1.a - LorR * 0.5*pi);
						Pt.z = LDesPoint2[k * 2 + 1] + ZDroad.hdmdmx[j + 1].EarH;
						PtArr2.append(Pt);
					}

					int npt;
					npt = Lnpt1 < Lnpt2 ? Lnpt1 : Lnpt2;
					//				AcGePoint3dArray InterPt;
					AcGePoint3d InterPt1;
					//	AcGePlane plane(AcGePoint3d(0,0,0),AcGeVector3d(0,0,1));
					//	if(fabs(road[i].hdmdes[jcross].dml-193600)<0.1)
					//					{
					//						dline = new AcDb3dPolyline(AcDb::k3dSimplePoly,PtArr);		
					//						AddEntityToDbs(dline);
					//					}

					for (int n = 0; n < desptsum - 1; n++)
					{
						//AcDbLine zxline(PtArr[n],PtArr[n+1]);
						AcGeLine3d zxline(PtArr[n], PtArr[n + 1]);
						for (k = 0; k < npt - 1; k++)
						{
							//					  AcDbFace face(PtArr1[k],PtArr1[k+1],PtArr2[k+1],PtArr2[k]);
							AcDbFace face(PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]);
							//					  AcGePlane prj(PtArr1[k],PtArr1[k+1],PtArr2[k+1]);
							AcGePlane prj(PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]);
							AcGePlane plane(AcGePoint3d(0, 0, 0), AcGeVector3d(0, 0, 1));
							/*
							if(fabs(road[i].hdmdes[jcross].dml-208130.35)<0.1)
							{
							AcDbFace *face1;
							face1 = new AcDbFace(PtArr1[k],PtArr1[k+1],PtArr2[k+1]);
							AddEntityToDbs(face1);
							prj.intersectWith(zxline,InterPt1);
							ads_point pt;
							pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
							acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
							//	IfPrint=true;
							ads_printf(L"zx=%lf %lf %lf 1:%lf %lf %lf 2:%lf %lf %lf\n",InterPt1.x,InterPt1.y,InterPt1.z,PtArr[n].x,PtArr[n].y,PtArr[n].z,PtArr[n+1].x,PtArr[n+1].y,PtArr[n+1].z);
							ads_printf(L"zx=%d tri=%d\n",CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr1[k+1],PtArr2[k+1]));
							//		IfPrint=false;
							}*/



							//					makeline(PtArr1[k],PtArr1[k+1],1,0);
							//					makeline(PtArr1[k+1],PtArr2[k+1],1,0);
							//					makeline(PtArr2[k+1],PtArr2[k],1,0);
							//					makeline(PtArr2[k],PtArr1[k],1,0);
							//					zxbp.intersectWith(&face,AcDb::kOnBothOperands,InterPt);
							if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
								&& CheckPtInTri(InterPt1, PtArr1[k], PtArr1[k + 1], PtArr2[k + 1]))//有交点
							{
								//投影到iroad线路上计算里程
								glcml = ZDroad.pm->PROJ_ML(InterPt1.x, InterPt1.y);
								//计算支距ZJ1,ZJ2,
								ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
								PZ1.lc = glcml;
								ZDroad.pm->xlpoint_pz(&PZ1);
								ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
								//								ads_printf(L"0: %lf\n",InterPt1.z);
								//								ads_point pt;
								//								pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
								//								acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
								//							ads_alert(L"1");
								return;
							}

							AcDbFace face2(PtArr1[k], PtArr2[k + 1], PtArr2[k]);
							AcGePlane prj1(PtArr1[k], PtArr2[k + 1], PtArr2[k]);

							/*
							AcDbFace *face3;
							if(fabs(road[i].hdmdes[jcross].dml-208130.35)<0.1)
							{
							face3 = new AcDbFace(PtArr1[k],PtArr2[k+1],PtArr2[k]);
							AddEntityToDbs(face3);
							prj.intersectWith(zxline,InterPt1);
							ads_point pt;
							pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
							acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
							//	IfPrint=true;
							ads_printf(L"zx=%lf %lf %lf 1:%lf %lf %lf 2:%lf %lf %lf\n",InterPt1.x,InterPt1.y,InterPt1.z,PtArr[n].x,PtArr[n].y,PtArr[n].z,PtArr[n+1].x,PtArr[n+1].y,PtArr[n+1].z);
							ads_printf(L"zx=%d tri=%d\n",CheckPtOnZX(InterPt1,PtArr[n],PtArr[n+1]),CheckPtInTri(InterPt1,PtArr1[k],PtArr2[k+1],PtArr2[k]));
							//	IfPrint=false;
							}*/

							//					makeline(PtArr1[k],PtArr1[k+1],1,0);
							//					makeline(PtArr1[k+1],PtArr2[k+1],1,0);
							//					makeline(PtArr2[k+1],PtArr2[k],1,0);
							//					makeline(PtArr2[k],PtArr1[k],1,0);
							//					zxbp.intersectWith(&face,AcDb::kOnBothOperands,InterPt);
							if (prj1.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
								&& CheckPtInTri(InterPt1, PtArr1[k], PtArr2[k + 1], PtArr2[k]))//有交点
							{
								//投影到iroad线路上计算里程
								glcml = ZDroad.pm->PROJ_ML(InterPt1.x, InterPt1.y);
								//计算支距ZJ1,ZJ2,
								ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
								PZ1.lc = glcml;
								ZDroad.pm->xlpoint_pz(&PZ1);
								ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
								//								ads_printf(L"0: %lf\n",InterPt1.z);
								//								ads_point pt;
								//								pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
								//								acedCommandS(RTSTR,L"sphere",RT3DPOINT,pt,RTREAL,1.0,0);
								return;
							}
						}

						if (Lnpt1 > npt)
						{
							for (k = npt - 1; k < Lnpt1 - 1; k++)
							{
								AcDbFace face(PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1], PtArr2[npt - 1]);
								AcGePlane prj(PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1]);

								//						face.intersectWith(zxbp,AcDb::kOnBothOperands,)
								if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
									&& CheckPtInTri(InterPt1, PtArr1[k], PtArr1[k + 1], PtArr2[npt - 1]))//有交点
								{
									//投影到iroad线路上计算里程
									glcml = ZDroad.pm->PROJ_ML(InterPt1.x, InterPt1.y);
									//计算支距ZJ1,ZJ2,
									ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
									PZ1.lc = glcml;
									ZDroad.pm->xlpoint_pz(&PZ1);
									ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
									//									ads_printf(L"0: %lf\n",InterPt1.z);
									//									ads_point pt;
									//									pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
									//							acedCommandS(RTSTR,L"donut",RTREAL,0.0,RTREAL,1.0,RTPOINT,pt,RTSTR,L"",0);
									return;
								}
							}
						}

						if (Lnpt2 > npt)
						{
							for (k = npt - 1; k < Lnpt2 - 1; k++)
							{
								AcDbFace face(PtArr1[npt - 1], PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]);
								AcGePlane prj(PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]);
								if (prj.intersectWith(zxline, InterPt1) && CheckPtOnZX(InterPt1, PtArr[n], PtArr[n + 1])
									&& CheckPtInTri(InterPt1, PtArr1[npt - 1], PtArr2[k + 1], PtArr2[k]))//有交点
								{
									//投影到iroad线路上计算里程
									glcml = ZDroad.pm->PROJ_ML(InterPt1.x, InterPt1.y);
									//计算支距ZJ1,ZJ2,
									ZJ1 = sqrt((PZ.x - InterPt1.x)*(PZ.x - InterPt1.x) + (PZ.y - InterPt1.y)*(PZ.y - InterPt1.y));
									PZ1.lc = glcml;
									ZDroad.pm->xlpoint_pz(&PZ1);
									ZJ2 = sqrt((PZ1.x - InterPt1.x)*(PZ1.x - InterPt1.x) + (PZ1.y - InterPt1.y)*(PZ1.y - InterPt1.y));
									//									ads_printf(L"0: %lf\n",InterPt1.z);
									//									ads_point pt;
									//									pt[0]=InterPt1.x,pt[1]=InterPt1.y,pt[2]=InterPt1.z;
									//							acedCommandS(RTSTR,L"donut",RTREAL,0.0,RTREAL,1.0,RTPOINT,pt,RTSTR,L"",0);
									return;
								}
							}
						}
					}

				}//左右线性质相同
				else
				{
					//1.计算坡脚点到主线中心的距离bpc
					double bpc = fabs(DesPt[(desptsum - 1) * 2]);
					//2.计算当前线路法线与二线交点的长度xjj
					double spt[2], fwj, PtOnFld[2], FLDcml;
					xlpoint PZ;
					PZ.lc = road[i].hdmdes[jcross].cml;
					road[i].pm->xlpoint_pz(&PZ);
					spt[0] = PZ.x, spt[1] = PZ.y;
					fwj = PZ.a;
					ZDroad.pm->CalJD_ZX_XL(spt, fwj + 0.5*pi, PtOnFld, FLDcml);
					double xjj = sqrt((spt[0] - PtOnFld[0])*(spt[0] - PtOnFld[0]) + (spt[1] - PtOnFld[1])*(spt[1] - PtOnFld[1]));//相关道路上的投影里程			   
					//3.if(bpc>xjj) 
					if (bpc > xjj)//设置关联
					{
						glcml = FLDcml;
						ZJ2 = -100;//特殊关联标志
						return;
					}
					else
					{
						spt[0] = PZ.x + bpc * cos(fwj + 0.5*pi);
						spt[1] = PZ.y + bpc * sin(fwj + 0.5*pi);
						//4.else 求坡脚点到二线的长度len,及投影里程prjml
						double prjml = ZDroad.pm->PROJ_ML(spt[0], spt[1]);
						//5.计算二线prjml处坡脚点长度bpc1;
						if (prjml > ZDroad.hdmdes[j + 1].cml + 0.001 || prjml < ZDroad.hdmdes[j].cml - 0.001)
							continue;
						else
						{
							double bpc1;
							if (fabs(ZDroad.hdmdes[j + 1].cml - ZDroad.hdmdes[j].cml) < 0.0001)
								bpc1 = LDesPoint1[(Lnpt1 - 1) * 2];
							else
								bpc1 = LDesPoint1[(Lnpt1 - 1) * 2] + (prjml - ZDroad.hdmdes[j].cml)*(LDesPoint2[(Lnpt2 - 1) * 2] - LDesPoint1[(Lnpt1 - 1) * 2]) / (ZDroad.hdmdes[j + 1].cml - ZDroad.hdmdes[j].cml);
							bpc1 = fabs(bpc1);
							//6.if(len1>bpc1) 无关联
							PZ.lc = prjml;
							ZDroad.pm->xlpoint_pz(&PZ);
							double len1 = sqrt((PZ.x - spt[0])*(PZ.x - spt[0]) + (PZ.y - spt[1])*(PZ.y - spt[1]));
							if (len1 < bpc1)
							{
								//7 else 设置关联
								glcml = prjml;
								ZJ2 = -100;//特殊关联标志
								return;
							}

						}
					}

				}
			}

		}
	}
}

//画指定里程的横断面(按互通)
void HdmDes::Draw_ZD_Hdm(double sml, double eml)
{
	double NewLearpt[400];
	double Learpt[400], Rearpt[400];
	double LBenchPt[400], RBenchPt[400];
	//int  DorS;
	int i;
	AcGePoint3d pt;
	CROSS pCross;
	CROSS GLCross;

	if (acdbHostApplicationServices()->workingDatabase()->loadLineTypeFile(L"DASHDOTX2", L"acadiso.lin") != Acad::eOk)
		ads_printf(L"加载DASHDOTX2线形失败!\n");
	CreateLayer(L"Hdm");//建立Hdm层

	pt.x = 100.0, pt.y = 100.0;
	Cal_CrossOriPt(0, pt);//得到每个横断面的绘图原点

	//NCRS=89;
	CString pszLabel = "正在绘制主线横断面";
	acedSetStatusBarProgressMeter(pszLabel, 0, 100);
	for (i = 0; i < road[0].NCRS; i++)//一线
	{
		int pos = (int)i*100.0 / road[0].NCRS;

		acedSetStatusBarProgressMeterPos(pos);

		if (road[0].hdmdes[i].cml > sml - 0.01&&road[0].hdmdes[i].cml < eml + 0.01)
		{
			//		if(road[0].hdmdes[i].DorS==1)//单路面
			//		{
			int k;
			for (k = 0; k < road[0].hdmdmx[i].ZEarPtNum; k++)
			{
				Learpt[k * 2] = road[0].hdmdmx[i].ZEarPtAry[k].x;
				Learpt[k * 2 + 1] = road[0].hdmdmx[i].ZEarPtAry[k].y;
			}

			for (k = 0; k < road[0].hdmdmx[i].YEarPtNum; k++)
			{
				Rearpt[k * 2] = road[0].hdmdmx[i].YEarPtAry[k].x;
				Rearpt[k * 2 + 1] = road[0].hdmdmx[i].YEarPtAry[k].y;
			}

			//////////////////////////////////////////////////////////////////////////
			for (k = 0; k < road[0].hdmBench[i].ZEarPtNum; k++)
			{
				LBenchPt[k * 2] = road[0].hdmBench[i].ZEarPtAry[k].x;
				LBenchPt[k * 2 + 1] = road[0].hdmBench[i].ZEarPtAry[k].y;
			}

			for (k = 0; k < road[0].hdmBench[i].YEarPtNum; k++)
			{
				RBenchPt[k * 2] = road[0].hdmBench[i].YEarPtAry[k].x;
				RBenchPt[k * 2 + 1] = road[0].hdmBench[i].YEarPtAry[k].y;
			}
			//////////////////////////////////////////////////////////////////////////

			//		CalNewZB(road[0].hdmdes[i].offsetX,road[0].hdmdmx[i].EarH,Learpt,road[0].hdmdmx[i].ZEarPtNum,Rearpt,road[0].hdmdmx[i].YEarPtNum,
			//			NewYd,NewLearpt,NewNumL,NewRearpt,NewNumR);
			road[0].hdmdes[i].newLYd = road[0].hdmdes[i].newRYd = road[0].hdmdmx[i].EarH;
			//左右都是桥
			if (road[0].hdmdes[i].ZDMXZ == 3 && road[0].hdmdes[i].YDMXZ == 3)
				continue;
			//左右都是隧
			if (road[0].hdmdes[i].ZDMXZ == 4 && road[0].hdmdes[i].YDMXZ == 4)
				continue;

			if (road[0].hdmdes[i].ZDMXZ == -1 || road[0].hdmdes[i].ZDMXZ == -2
				|| road[0].hdmdes[i].YDMXZ == -1 || road[0].hdmdes[i].YDMXZ == -2)
			{
				pt.x = road[0].hdmdes[i].tX0;//桥隧处标注点
				pt.y = road[0].hdmdes[i].tY0;
				BiaoZhuQS(0, road[0].hdmdes[i].cml, pt); //标注桥隧位置
			}

			pCross.m_OriPoint.x = road[0].hdmdes[i].Xo;
			pCross.m_OriPoint.y = road[0].hdmdes[i].Yo;	//每个断面的绘图原点
			pCross.m_BTinf = road[0].hdmdes[i].ZDMXZ;
			//	road[0].hdmdes[i].xlxz=0;road[0].hdmdes[i].r_bh=-1;//一线，用于交互设计

			setCROSSAutoDesignData(pCross, 0, i, road[0].hdmdmx[i].EarH,
				Learpt, road[0].hdmdmx[i].ZEarPtNum, Rearpt, road[0].hdmdmx[i].YEarPtNum,
				LBenchPt, road[0].hdmBench[i].ZEarPtNum, RBenchPt, road[0].hdmBench[i].YEarPtNum);

			//	pCross.DorS=road[0].hdmdes[i].DorS;
			pCross.DorS = 1;
			pCross.offset = road[0].hdmdes[i].offsetX;//一线中心线相对与新的地面线的移动量

			pCross.Draw();

			road[0].hdmdes[i].LgouId = pCross.LgouId;
			road[0].hdmdes[i].RgouId = pCross.RgouId;

			if (road[0].hdmdes[i].IfHasZlink)//有关联断面,绘关联
			{
				int iroad;
				for (iroad = 0; iroad < ZRoadSum; iroad++)
				{
					if (Zroad[iroad].roadname == road[0].hdmdes[i].zlink->glRoadName)
						break;
				}

				int jcross = FindIDM(Zroad[iroad], road[0].hdmdes[i].zlink->cml);

				for (int k = 0; k < Zroad[iroad].hdmdmx[jcross].ZEarPtNum; k++)
				{
					Learpt[k * 2] = Zroad[iroad].hdmdmx[jcross].ZEarPtAry[k].x;
					Learpt[k * 2 + 1] = Zroad[iroad].hdmdmx[jcross].ZEarPtAry[k].y;
				}

				for (int k = 0; k < Zroad[iroad].hdmdmx[jcross].YEarPtNum; k++)
				{
					Rearpt[k * 2] = Zroad[iroad].hdmdmx[jcross].YEarPtAry[k].x;
					Rearpt[k * 2 + 1] = Zroad[iroad].hdmdmx[jcross].YEarPtAry[k].y;
				}


				/*
				if(road[0].hdmdes[i].xjj>-0.0001)//右线分离
				{
				if(road[iroad].hdmdes[jcross].Lnpt>0)
				GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[0].hdmdes[i].RPTR[road[0].hdmdes[i].Rnpt-1].x-road[iroad].hdmdes[jcross].RPTL[road[iroad].hdmdes[jcross].Lnpt-1].x)*Sfactor;
				//	dy1 = road[0].hdmdes[i].RPTR[road[0].hdmdes[i].Rnpt-1].y+road[0].hdmdmx[i].EarH-road[0].hdmdes[i].RHFR[1];
				//	dy2 = road[iroad].hdmdes[jcross].RHFL[1] - (road[iroad].hdmdes[jcross].RPTL[road[iroad].hdmdes[jcross].Lnpt-1].y+road[iroad].hdmdmx[jcross].EarH);
				GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[iroad].hdmdes[jcross].RHFL[1]-road[0].hdmdes[i].RHFR[1])*Sfactor;	//每个断面的绘图原点
				}
				else
				{*/

				if (road[0].hdmdes[i].zlink->Rnpt > 0)
					GLCross.m_OriPoint.x = pCross.m_OriPoint.x -
					fabs(road[0].hdmdes[i].RPTL[road[0].hdmdes[i].Lnpt - 1].x - road[0].hdmdes[i].zlink->RPTR[road[0].hdmdes[i].zlink->Rnpt - 1].x)*Sfactor;
				GLCross.m_OriPoint.y = pCross.m_OriPoint.y;//+ (road[iroad].hdmdes[jcross].RHFR[1]-road[0].hdmdes[i].RHFL[1])*Sfactor;	//每个断面的绘图原点
				//}
				road[0].hdmdes[i].zlink->Ymin = road[0].hdmdes[i].Ymin;
				setCROSSAutoDesignData(GLCross, Zroad[iroad], jcross, road[0].hdmdes[i].zlink,
					Zroad[iroad].hdmdmx[jcross].EarH, Learpt, Zroad[iroad].hdmdmx[jcross].ZEarPtNum,
					Rearpt, Zroad[iroad].hdmdmx[jcross].YEarPtNum);

				GLCross.DorS = Zroad[iroad].hdmdes[jcross].DorS;
				GLCross.offset = Zroad[iroad].hdmdes[jcross].offsetX;//一线中心线相对与新的地面线的移动量
				GLCross.IsLinkHdm = true;
				if (fabs(road[0].hdmdes[i].xjj) < 3)
					GLCross.BzTWInf = -1;

				GLCross.Draw();

			}

			if (road[0].hdmdes[i].IfHasYlink)//有关联断面,绘关联
			{
				//				    ads_printf(L"dml=%lf\n",road[0].hdmdes[i].dml);
				int iroad;
				for (iroad = 0; iroad < YRoadSum; iroad++)
				{
					if (Yroad[iroad].roadname == road[0].hdmdes[i].ylink->glRoadName)
						break;
				}
				int jcross = FindIDM(Yroad[iroad], road[0].hdmdes[i].ylink->cml);
				for (int k = 0; k < Yroad[iroad].hdmdmx[jcross].ZEarPtNum; k++)
				{
					Learpt[k * 2] = Yroad[iroad].hdmdmx[jcross].ZEarPtAry[k].x;
					Learpt[k * 2 + 1] = Yroad[iroad].hdmdmx[jcross].ZEarPtAry[k].y;
				}

				for (int k = 0; k < Yroad[iroad].hdmdmx[jcross].YEarPtNum; k++)
				{
					Rearpt[k * 2] = Yroad[iroad].hdmdmx[jcross].YEarPtAry[k].x;
					Rearpt[k * 2 + 1] = Yroad[iroad].hdmdmx[jcross].YEarPtAry[k].y;
				}

				if (road[0].hdmdes[i].ylink->Lnpt > 0)
					GLCross.m_OriPoint.x = pCross.m_OriPoint.x +
					(fabs(road[0].hdmdes[i].RPTR[road[0].hdmdes[i].Rnpt - 1].x) + fabs(road[0].hdmdes[i].ylink->RPTL[road[0].hdmdes[i].ylink->Lnpt - 1].x))*Sfactor;
				GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[iroad].hdmdes[jcross].RHFL[1]-road[0].hdmdes[i].RHFR[1])*Sfactor;	//每个断面的绘图原点
				//}
				road[0].hdmdes[i].ylink->Ymin = road[0].hdmdes[i].Ymin;

				setCROSSAutoDesignData(GLCross, Yroad[iroad], jcross, road[0].hdmdes[i].ylink,
					Yroad[iroad].hdmdmx[jcross].EarH, Learpt, Yroad[iroad].hdmdmx[jcross].ZEarPtNum,
					Rearpt, Yroad[iroad].hdmdmx[jcross].YEarPtNum);

				GLCross.DorS = Yroad[iroad].hdmdes[jcross].DorS;
				GLCross.offset = Yroad[iroad].hdmdes[jcross].offsetX;//一线中心线相对与新的地面线的移动量
				GLCross.IsLinkHdm = true;
				if (fabs(road[0].hdmdes[i].xjj) < 3)
					GLCross.BzTWInf = -1;
				GLCross.Draw();
			}


			//画图框	
		}
	}
	acedSetStatusBarProgressMeterPos(100);
	acedRestoreStatusBar();

}

JD_CENTER *HdmDes::GetPm(CString XL)
{
	int pos = XL.FindOneOf(L",");
	JD_CENTER *pm;
	pm = NULL;
	CString MdbName, roadname;
	MdbName = XL.Left(pos);
	int len = XL.GetLength();
	roadname = XL.Right(len - pos - 1);
	if (MdbName == "" || roadname == "")
		return NULL;
	pm = ReadPm(MdbName, roadname);
	return pm;
}

int HdmDes::SetBXDmx(CString mdbname, CString RoadName, double dmx[], double ZJ, double sml, double eml, JD_CENTER *pm)
{
	//读取横断面地面线
	double cml;
	double earpt[400], dh;
	int npt, n;

	RoadHdmdata RoadData;
	ReadHdmdmx(RoadName, mdbname, RoadData);
	n = 0;
	for (int i = 0; i < RoadData.NCRS; i++)
	{
		cml = pm->TYLC(RoadData.hdmdmx[i].lc);
		if (cml > eml + 0.001)
			break;
		else if (cml < sml - 0.001)
			continue;
		else
		{
			if (ZJ > 0.001)//右侧
			{
				npt = RoadData.hdmdmx[i].YEarPtNum;
				for (int j = 0; j < npt; j++)
				{
					earpt[j * 2] = RoadData.hdmdmx[i].YEarPtAry[j].x;
					earpt[j * 2 + 1] = RoadData.hdmdmx[i].YEarPtAry[j].y;
				}
				dh = Cal_deltah(earpt, npt, ZJ, 0, RoadData.hdmdmx[i].EarH);
				dmx[n * 2] = cml;
				dmx[n * 2 + 1] = -dh;
				n++;
			}
			else if (ZJ < -0.001)
			{
				npt = RoadData.hdmdmx[i].ZEarPtNum;
				for (int j = 0; j < npt; j++)
				{
					earpt[j * 2] = fabs(RoadData.hdmdmx[i].ZEarPtAry[j].x);
					earpt[j * 2 + 1] = RoadData.hdmdmx[i].ZEarPtAry[j].y;
				}
				dh = Cal_deltah(earpt, npt, ZJ, 0, RoadData.hdmdmx[i].EarH);
				dmx[n * 2] = cml;
				dmx[n * 2 + 1] = -dh;
				n++;
			}
			else
			{
				dmx[n * 2] = cml;
				dmx[n * 2 + 1] = RoadData.hdmdmx[i].EarH;
				n++;
			}
		}

	}
	return n;
}
//给定直线,线路平面,在直线上找到一点到线路距离等于给定宽度
void HdmDes::SetLinkHdmData(CRSDAT *link, RoadHdmdata &ZDroad, int jcross)
{
	link->cml = ZDroad.hdmdes[jcross].cml;
	link->dml = ZDroad.hdmdes[jcross].dml;
	link->newLYd = ZDroad.hdmdes[jcross].newLYd;
	link->newRYd = ZDroad.hdmdes[jcross].newRYd;
	link->xjj = ZDroad.hdmdes[jcross].xjj;
	link->FillArea = ZDroad.hdmdes[jcross].FillArea;
	link->CutArea = ZDroad.hdmdes[jcross].CutArea;
	link->Ldeltah = ZDroad.hdmdes[jcross].Ldeltah;
	link->Rdeltah = ZDroad.hdmdes[jcross].Rdeltah;
	//1.左侧
	link->ZDMXZ = ZDroad.hdmdes[jcross].ZDMXZ;
	int j;
	for (j = 0; j < 3; j++)
		link->zlmhd[j] = ZDroad.hdmdes[jcross].zlmhd[j];
	for (j = 0; j < 5; j++)
	{
		link->RHFL[2 * j] = ZDroad.hdmdes[jcross].RHFL[2 * j];
		link->RHFL[2 * j + 1] = ZDroad.hdmdes[jcross].RHFL[2 * j + 1];
	}
	link->Zt = ZDroad.hdmdes[jcross].Zt;
	link->ZHc = ZDroad.hdmdes[jcross].ZHc;
	link->Lnpt = ZDroad.hdmdes[jcross].Lnpt;

	if (link->RPTL.length() > 0)
		link->RPTL.removeSubArray(0, link->RPTL.length() - 1);
	AcGePoint3d pt;

	for (j = 0; j < link->Lnpt; j++)
	{
		pt.x = ZDroad.hdmdes[jcross].RPTL[j].x;
		pt.y = ZDroad.hdmdes[jcross].RPTL[j].y;
		pt.z = 0.0;
		link->RPTL.append(pt);
	}
	//左水沟点
	link->LIfSetGouH = ZDroad.hdmdes[jcross].LIfSetGouH;
	link->LGouH = ZDroad.hdmdes[jcross].LGouH;
	link->LGouProperty = ZDroad.hdmdes[jcross].LGouProperty;
	link->LGouPtNum = ZDroad.hdmdes[jcross].LGouPtNum;
	link->LJSGouPtNum = ZDroad.hdmdes[jcross].LJSGouPtNum;
	for (j = 0; j < link->LGouPtNum; j++)
	{
		link->Lgou[j * 2] = ZDroad.hdmdes[jcross].Lgou[j * 2];
		link->Lgou[j * 2 + 1] = ZDroad.hdmdes[jcross].Lgou[j * 2 + 1];
	}
	for (j = 0; j < link->LJSGouPtNum; j++)
	{
		link->LJSgou[j * 2] = ZDroad.hdmdes[jcross].LJSgou[j * 2];
		link->LJSgou[j * 2 + 1] = ZDroad.hdmdes[jcross].LJSgou[j * 2 + 1];
	}

	//2.右侧
	link->YDMXZ = ZDroad.hdmdes[jcross].YDMXZ;
	for (j = 0; j < 3; j++)
		link->ylmhd[j] = ZDroad.hdmdes[jcross].ylmhd[j];
	for (j = 0; j < 5; j++)
	{
		link->RHFR[2 * j] = ZDroad.hdmdes[jcross].RHFR[2 * j];
		link->RHFR[2 * j + 1] = ZDroad.hdmdes[jcross].RHFR[2 * j + 1];
	}
	link->Yt = ZDroad.hdmdes[jcross].Yt;
	link->YHc = ZDroad.hdmdes[jcross].YHc;

	link->Rnpt = ZDroad.hdmdes[jcross].Rnpt;
	if (link->RPTR.length() > 0)
		link->RPTR.removeSubArray(0, link->RPTR.length() - 1);

	for (j = 0; j < link->Rnpt; j++)
	{
		pt.x = ZDroad.hdmdes[jcross].RPTR[j].x;
		pt.y = ZDroad.hdmdes[jcross].RPTR[j].y;
		pt.z = 0.0;
		link->RPTR.append(pt);
	}
	//右水沟点
	link->RIfSetGouH = ZDroad.hdmdes[jcross].RIfSetGouH;
	link->RGouH = ZDroad.hdmdes[jcross].RGouH;
	link->RGouProperty = ZDroad.hdmdes[jcross].RGouProperty;
	link->RGouPtNum = ZDroad.hdmdes[jcross].RGouPtNum;
	link->RJSGouPtNum = ZDroad.hdmdes[jcross].RJSGouPtNum;
	for (j = 0; j < link->RGouPtNum; j++)
	{
		link->Rgou[j * 2] = ZDroad.hdmdes[jcross].Rgou[j * 2];
		link->Rgou[j * 2 + 1] = ZDroad.hdmdes[jcross].Rgou[j * 2 + 1];
	}
	for (j = 0; j < link->RJSGouPtNum; j++)
	{
		link->RJSgou[j * 2] = ZDroad.hdmdes[jcross].RJSgou[j * 2];
		link->RJSgou[j * 2 + 1] = ZDroad.hdmdes[jcross].RJSgou[j * 2 + 1];
	}

}
//弧形边坡
//设计ARC边坡
int HdmDes::DesArcBp(double R, int EarPtNum2, int EarPtSum, double EarPtList[], double DesPtList[], int &DesPtSum)
{
	//判别边坡斜长是否超过5m
	bool IfSetArc1, IfSetArc2;
	double bpc;
	IfSetArc1 = false;

	if (DesPtSum > 10)//至少两级边坡
		IfSetArc1 = true;
	else//一级边坡
	{
		//边坡高
		bpc = sqrt((DesPtList[9 * 2 + 1] - DesPtList[8 * 2 + 1])*(DesPtList[9 * 2 + 1] - DesPtList[8 * 2 + 1]) + (DesPtList[9 * 2] - DesPtList[8 * 2])*(DesPtList[9 * 2] - DesPtList[8 * 2]));
		if (bpc >= R)
			IfSetArc1 = true;
	}
	//地面横坡是否向上
	//	double dmhp=GetDmhp(DesPtList[(DesPtSum-1)*2],EarPtList[(EarPtSum-1)*2],EarPtList,EarPtSum);

	if (IfSetArc1)
	{
		//以坡顶点为圆心，R为半径，求圆与地面线交点
		double Xo, Yo, jd[2];
		Xo = DesPtList[(DesPtSum - 1) * 2];
		Yo = DesPtList[(DesPtSum - 1) * 2 + 1];//圆心
		bpc = sqrt((DesPtList[(DesPtSum - 1) * 2 + 1] - DesPtList[(DesPtSum - 2) * 2 + 1])*(DesPtList[(DesPtSum - 1) * 2 + 1] - DesPtList[(DesPtSum - 2) * 2 + 1]) +
			(DesPtList[(DesPtSum - 1) * 2] - DesPtList[(DesPtSum - 2) * 2])*(DesPtList[(DesPtSum - 1) * 2] - DesPtList[(DesPtSum - 2) * 2]));
		//ARC圆心
		int inf = 0;
		inf = CalDmxJD(0, EarPtSum, EarPtList, Xo, Yo, R, jd);

		if (inf)//找到交点
		{
			//计算ARC圆心
			double fwj1, fwj2, zj, ArcR, ArcSpt[2], ArcCen[2], ArcEpt[2];
			xyddaa(Yo, Xo, DesPtList[(DesPtSum - 2) * 2 + 1], DesPtList[(DesPtSum - 2) * 2], &fwj1);
			xyddaa(Yo, Xo, jd[1], jd[0], &fwj2);
			zj = fabs(fwj2 - fwj1);

			ArcR = fabs(R*tan(0.5*zj));

			ArcSpt[1] = DesPtList[(DesPtSum - 1) * 2] - R * (DesPtList[(DesPtSum - 1) * 2] - DesPtList[(DesPtSum - 2) * 2]) / bpc;
			ArcSpt[0] = DesPtList[(DesPtSum - 1) * 2 + 1] - R * (DesPtList[(DesPtSum - 1) * 2 + 1] - DesPtList[(DesPtSum - 2) * 2 + 1]) / bpc;
			ArcEpt[0] = jd[1];
			ArcEpt[1] = jd[0];
			ArcCen[0] = ArcSpt[0] + ArcR * cos(fwj1 - 0.5*pi);
			ArcCen[1] = ArcSpt[1] + ArcR * sin(fwj1 - 0.5*pi);


			DesPtList[(DesPtSum - 1) * 2] = ArcSpt[1];
			DesPtList[(DesPtSum - 1) * 2 + 1] = ArcSpt[0];
			zj = fabs(pi - zj);


			xyddaa(ArcCen[0], ArcCen[1], ArcSpt[0], ArcSpt[1], &fwj1);
			for (int i = 0; i < 30; i++)
			{
				DesPtList[DesPtSum * 2] = ArcCen[1] + ArcR * sin(fwj1 + i * zj / 30.0);
				DesPtList[DesPtSum * 2 + 1] = ArcCen[0] + ArcR * cos(fwj1 + i * zj / 30.0);
				DesPtSum++;
			}
			DesPtList[DesPtSum * 2] = ArcEpt[1];
			DesPtList[DesPtSum * 2 + 1] = ArcEpt[0];
			DesPtSum++;
		}
	}
	//计算ARC与地面线段交点
	return 1;
}

int HdmDes::CalDmxJD(int EarPtNum2, int EarPtSum, double EarPtList[], double Xo, double Yo, double R, double jd[2])
{
	double x1, y1, x2, y2;
	double Spt[2], Ept[2];
	double xmin, ymin, xmax, ymax;

	for (int i = EarPtNum2; i < EarPtSum - 1; i++)
	{
		Spt[0] = EarPtList[i * 2], Spt[1] = EarPtList[i * 2 + 1];
		Ept[0] = EarPtList[(i + 1) * 2], Ept[1] = EarPtList[(i + 1) * 2 + 1];

		if (fabs(Ept[0] - Spt[0]) > 0.1)
		{
			double K, b;
			K = (Ept[1] - Spt[1]) / (Ept[0] - Spt[0]);
			b = Ept[1] - K * Ept[0];
			double A = 1 + K * K;
			double B = 2 * K*(b - Yo) - 2 * Xo;
			double C = Xo * Xo + (b - Yo)*(b - Yo) - R * R;
			x1 = -B / A / 2.0 + sqrt((B / A)*(B / A) / 4 - C / A);
			y1 = K * x1 + b;
			x2 = -B / A / 2.0 - sqrt((B / A)*(B / A) / 4 - C / A);
			y2 = K * x2 + b;
		}
		else//平行于Y轴
		{
			if (R*R - (Spt[0] - Xo)*(Spt[0] - Xo) > 0.0)
			{
				x1 = x2 = Spt[0];
				y1 = Yo + sqrt(R*R - (Spt[0] - Xo)*(Spt[0] - Xo));
				y2 = Yo - sqrt(R*R - (Spt[0] - Xo)*(Spt[0] - Xo));
			}
		}

		xmin = Spt[0] < Ept[0] ? Spt[0] : Ept[0];
		ymin = Spt[1] < Ept[1] ? Spt[1] : Ept[1];
		xmax = Spt[0] > Ept[0] ? Spt[0] : Ept[0];
		ymax = Spt[1] > Ept[1] ? Spt[1] : Ept[1];

		if (x1 > Xo && x1 > xmin - 0.001 && x1<xmax + 0.001 && y1>ymin - 0.001 && y1 < ymax + 0.001)
		{
			jd[0] = x1, jd[1] = y1;
			return 1;
		}
		if (x2 > Xo && x2 > xmin - 0.001 && x2<xmax + 0.001 && y2>ymin - 0.001 && y2 < ymax + 0.001)
		{
			jd[0] = x2, jd[1] = y2;
			return 1;
		}
	}
	return 0;
}

double HdmDes::xyddaa(double xb, double yb, double xe, double ye, double *f)
{
	double dx, dy, dd, aa;

	dx = xe - xb; dy = ye - yb; dd = sqrt(dx*dx + dy * dy);
	if (fabs(dx) < 0.000000001) {
		if (dy >= 0.0) aa = pi * 0.5;
		else if (dy < 0.0) aa = pi * 1.5;
	}
	else { aa = atan(dy / dx); };

	if (dy >= 0 && dx < -0.00000001) { aa = aa + pi; }
	else if (dy < 0 && dx < -0.00000001) { aa = aa + pi; }
	else if (dy<0 && dx>0.00000001) { aa = aa + 2 * pi; };

	if (aa < -0.00000001) { aa = aa + 2 * pi; }
	else if (aa > 2 * pi) { aa = aa - 2 * pi; };
	*f = aa;
	return(dd);
}

double HdmDes::FindWichCTK(double cml, JD_CENTER *pm, int NCTKD, ctkddata CTKD[], double &ctwid)
{
	int i;
	double sml, eml, zj, x, y;
	int inf;

	ctwid = 0.0;
	inf = 0;
	for (i = 0; i < NCTKD; i++)
	{
		sml = pm->TYLC(CTKD[i].Sdml);//分段终里程
		eml = pm->TYLC(CTKD[i].Edml);
		if (cml<eml + 0.001 && cml>sml - 0.001)
		{
			inf = 1;
			break;
		}
	}

	if (inf == 1)
	{
		x = cml - sml;
		y = eml - cml;
		if (x + y > 0)
			ctwid = (CTKD[i].Sctkd*y + CTKD[i].Ectkd*x) / (x + y);//土埂宽
		else
			ctwid = CTKD[i].Sctkd;
	}

	return ctwid;
}
//查找弧形边坡半径
void HdmDes::FindWichArcBp(double cml, JD_CENTER *pm, int narcbp, arcbpata  arcbp[], double ArcBpR[4])
{
	int i;
	double sml, eml, zj, x, y;

	//初始化
	for (i = 0; i < 4; i++)
		ArcBpR[i] = 0.0;

	for (i = 0; i < narcbp; i++)
	{
		sml = pm->TYLC(arcbp[i].Sdml);//分段终里程
		eml = pm->TYLC(arcbp[i].Edml);
		if (cml<eml + 0.001 && cml>sml - 0.001)//设置了值
		{
			double R;
			if (fabs(eml - sml) > 1.0e-4)
				R = arcbp[i].SR + (cml - sml) / (eml - sml)*(arcbp[i].ER - arcbp[i].SR);
			else
				R = 0.5*(arcbp[i].SR + arcbp[i].ER);
			if (arcbp[i].ArcLocation == 0)
				ArcBpR[0] = R;
			else if (arcbp[i].ArcLocation == 1)
				ArcBpR[1] = R;
			else if (arcbp[i].ArcLocation == 2)
				ArcBpR[2] = R;
			else
				ArcBpR[3] = R;

		}
	}
}

//在主线上插入分离段起里程,按整幅路面设计,-1 start 1-end
int HdmDes::InsertFLDStartOrEndHdm(int iroad, int StartOrEnd)
{
	//找到位置
	double sml, Zdesh, Ydesh;
	if (StartOrEnd < 0)//start
		sml = road[iroad].SmlOnZx;
	else
		sml = road[iroad].EmlOnZx;

	int j;
	j = 0;
	while (j < road[0].NCRS && road[0].hdmdes[j].cml < sml + 0.001)
		j++;
	//补充地面线
	if (StartOrEnd < 0)
		j = j - 1 < 0 ? 0 : j - 1;
	if (j > road[0].NCRS - 1) j = road[0].NCRS - 1;


	if (j == road[0].NCRS - 1 || fabs(road[0].hdmdes[j].cml - sml) < 1)//有一样的里程
		return j;

	//没有该里程，插入
	for (int k = road[0].NCRS; k > j + 1; k--)
	{
		SetDmxData(road[0].hdmdmx[k], road[0].hdmdmx[k - 1]);
		SetDmxData(road[0].hdmBench[k], road[0].hdmBench[k - 1]);
		road[0].hdmdes[k] = road[0].hdmdes[k - 1];
	}
	//设置地面线
	double cml1, cml, cml2, dml;
	CString GH;
	cml = sml;
	//ads_printf(L"############## i=%d cml=%lf\n",iroad,cml);
	dml = road[0].pm->XLC(sml, GH);
	cml1 = road[0].pm->TYLC(road[0].hdmdmx[j].lc);
	cml2 = road[0].pm->TYLC(road[0].hdmdmx[j + 2].lc);


	//////////////////////////////////////////////////////////////////////////
	bool IsInsertByDTM = true;//默认采用数模内插
	IsInsertByDTM = InsertHdmDmxByDTM(0, j + 1, cml);
	if (IsInsertByDTM)//数模内插成功
	{
		if (cml - cml1 > cml2 - cml)
		{
			road[0].hdmdmx[j + 1].BTxz = road[0].hdmdmx[j + 2].BTxz;
			_tcscpy(road[0].hdmdmx[j + 1].flag, road[0].hdmdmx[j + 2].flag);
		}
		else
		{
			road[0].hdmdmx[j + 1].BTxz = road[0].hdmdmx[j].BTxz;
			_tcscpy(road[0].hdmdmx[j + 1].flag, road[0].hdmdmx[j].flag);
		}
	}

	else
	{
		if (cml - cml1 > cml2 - cml)
			SetDmxData(road[0].hdmdmx[j + 1], road[0].hdmdmx[j + 2]);
		else
			SetDmxData(road[0].hdmdmx[j + 1], road[0].hdmdmx[j]);
	}
	//////////////////////////////////////////////////////////////////////////

	road[0].hdmdmx[j + 1].lc = dml;
	//设置路面信息

	InitHdmData(0, j + 1);//设置初值
	road[0].hdmdes[j + 1].cml = cml;
	road[0].hdmdes[j + 1].dml = dml;
	road[0].hdmdes[j + 1].glRoadName = "无";
	road[0].hdmdes[j + 1].glcml = -1;
	road[0].hdmdes[j + 1].xjj = 0.0;//初始值

	_tcscpy(road[0].hdmdes[j + 1].ckml, road[0].pm->LCchr(GH, dml, 3));

	//计算路面标高
	//1.计算左幅右幅设计标高		
	int fldhdmno;
	if (StartOrEnd < 0)
		fldhdmno = 0;
	else
		fldhdmno = road[iroad].NCRS - 1;

	if (road[iroad].ZxOrYx < 0)//分离段为左线
	{
		//////////////////////////////////////////////////////////////////////////
		//考虑线路中线与路基中线不一致，路面点需从新计算，（删除）
		//		for(int k=0; k<10; k++)
		//			road[0].hdmdes[j+1].RHFL[k] = road[iroad].hdmdes[fldhdmno].RHFL[k];
		//////////////////////////////////////////////////////////////////////////

		//计算断面属性       			  
		// 		road[0].hdmdes[j+1].ZDMXZ = road[iroad].hdmdes[fldhdmno].ZDMXZ;
		// 		road[0].hdmdes[j+1].BriZZDK =  road[iroad].hdmdes[fldhdmno].BriZZDK;
		road[0].hdmdes[j + 1].ZDMXZ = SetDmProperty(cml, road[0].pm, road[0].NZBri, road[0].ZBri,
			road[0].NAllBri, road[0].AllBri,
			road[0].NZTun, road[0].ZTun,
			road[0].NAllTun, road[0].AllTun, -1, road[0].hdmdes[j + 1].BriZZDK, road[0].hdmdes[j].ZDMXZ);
		//////////////////////////////////////////////////////////////////////////
		//考虑线路中线与路基中线不一致，换标高计算方法（修改）
		//		Ydesh = CalDesH(cml,road[0].YZM,road[0].AllZM);
		CalOffsetByXLZX(cml, road[0].NYLMK, road[0].YLMK, road[0].hdmdes[j + 1].OffsetByXLZX);
		CalFGDBYDesH(cml, 0, Ydesh, 1);
		//////////////////////////////////////////////////////////////////////////
		if (road[0].YcgNm > 0)
			CalLMPT(cml, Ydesh, road[0].YcgNm, road[0].Ycg, road[0].YjkNm,
				road[0].Yjk, road[0].NYLMK, road[0].YLMK, road[0].hdmdes[j + 1].RHFR,
				1, road[0].BxNum, road[0].pBXArr, road[0].pm);

		//////////////////////////////////////////////////////////////////////////
		//考虑线路中线与路基中线不一致，路面点需从新计算（添加）
		if (road[0].ZcgNm > 0)
			CalLMPT(cml, Ydesh, road[0].ZcgNm, road[0].Zcg, road[0].ZjkNm,
				road[0].Zjk, road[0].NZLMK, road[0].ZLMK, road[0].hdmdes[j + 1].RHFL,
				-1, road[0].BxNum, road[0].pBXArr, road[0].pm);
		//////////////////////////////////////////////////////////////////////////

		road[0].hdmdes[j + 1].YDMXZ = SetDmProperty(cml, road[0].pm, road[0].NYBri, road[0].YBri,
			road[0].NAllBri, road[0].AllBri,
			road[0].NYTun, road[0].YTun,
			road[0].NAllTun, road[0].AllTun, 1, road[0].hdmdes[j + 1].BriYZDK, road[0].hdmdes[j].YDMXZ);
	}
	else
	{
		//////////////////////////////////////////////////////////////////////////
		//考虑线路中线与路基中线不一致，路面点需从新计算，（删除）
		// 		for(int k=0; k<10; k++)
		// 			road[0].hdmdes[j+1].RHFR[k] = road[iroad].hdmdes[fldhdmno].RHFR[k];
		//////////////////////////////////////////////////////////////////////////

		//计算断面属性       			  
		// 		road[0].hdmdes[j+1].YDMXZ = road[iroad].hdmdes[fldhdmno].YDMXZ;
		// 		road[0].hdmdes[j+1].BriYZDK =  road[iroad].hdmdes[fldhdmno].BriYZDK;
		road[0].hdmdes[j + 1].YDMXZ = SetDmProperty(cml, road[0].pm, road[0].NYBri, road[0].YBri,
			road[0].NAllBri, road[0].AllBri,
			road[0].NYTun, road[0].YTun,
			road[0].NAllTun, road[0].AllTun, 1, road[0].hdmdes[j + 1].BriYZDK, road[0].hdmdes[j].YDMXZ);

		//////////////////////////////////////////////////////////////////////////
		//考虑线路中线与路基中线不一致，换标高计算方法（修改）
		//		Zdesh = CalDesH(cml,road[0].ZZM,road[0].AllZM);
		CalOffsetByXLZX(cml, road[0].NZLMK, road[0].ZLMK, road[0].hdmdes[j + 1].OffsetByXLZX);
		CalFGDBYDesH(cml, iroad, Zdesh, -1);
		//////////////////////////////////////////////////////////////////////////
		if (road[0].ZcgNm > 0)
			CalLMPT(cml, Zdesh, road[0].ZcgNm, road[0].Zcg, road[0].ZjkNm,
				road[0].Zjk, road[0].NZLMK, road[0].ZLMK, road[0].hdmdes[j + 1].RHFL,
				-1, road[0].BxNum, road[0].pBXArr, road[0].pm);

		//////////////////////////////////////////////////////////////////////////
		//考虑线路中线与路基中线不一致，路面点重新计算（添加）
		if (road[0].YcgNm > 0)
			CalLMPT(cml, Zdesh, road[0].YcgNm, road[0].Ycg, road[0].YjkNm,
				road[0].Yjk, road[0].NYLMK, road[0].YLMK, road[0].hdmdes[j + 1].RHFR,
				1, road[0].BxNum, road[0].pBXArr, road[0].pm);
		//////////////////////////////////////////////////////////////////////////

		road[0].hdmdes[j + 1].ZDMXZ = SetDmProperty(cml, road[0].pm, road[0].NZBri, road[0].ZBri,
			road[0].NAllBri, road[0].AllBri,
			road[0].NZTun, road[0].ZTun,
			road[0].NAllTun, road[0].AllTun, -1, road[0].hdmdes[j + 1].BriZZDK, road[0].hdmdes[j].ZDMXZ);

	}

	road[0].hdmdes[j + 1].IfHasDes = false;
	road[0].hdmdes[j + 1].IfFldSEHdm = true;
	road[0].hdmdes[j + 1].IsInsertHdm = 1;
	road[0].NCRS++;

	return j + 1;
}

//设置挡墙信息
void HdmDes::Cal_HdmDQinf(int iroad, int jcross)
{
	double ZZJ, YZJ;
	ZZJ = FindWichDQ(road[iroad].hdmdes[jcross].cml, road[iroad].pm, road[iroad].hdmbz.NZDQ, road[iroad].hdmbz.ZDQ);
	YZJ = FindWichDQ(road[iroad].hdmdes[jcross].cml, road[iroad].pm, road[iroad].hdmbz.NYDQ, road[iroad].hdmbz.YDQ);

	if (ZZJ < 999)
	{
		if (YZJ < 999)
			road[iroad].hdmdes[jcross].IfSetDQ = 2;
		else
			road[iroad].hdmdes[jcross].IfSetDQ = -1;
	}
	else
	{
		if (YZJ < 999)
			road[iroad].hdmdes[jcross].IfSetDQ = 1;
		else
			road[iroad].hdmdes[jcross].IfSetDQ = 0;
	}

}

/************************************************************************
判断是否需要自动推平或填平
返回值：ture-需要推平，false-无需推平
输入参数：
LDorLQ			路堤或路堑 -1-路堤 +1-路堑
nStartEarthPt	起始地面点（离硬路肩点最近的并且靠线路中心线一侧的点）下标
nEarthPtsum		地面点总数
EarthPtList		地面点数组
YLJPt			硬露肩点
dYLJPL			硬露肩坡率
输出参数：
JD				推平后与路面交点
dDist			硬露肩点与推平后交点的水平距离
************************************************************************/
bool HdmDes::IsAutoTP(int LDorLQ, int nEarthPtsum, double EarthPtList[], double TLJPt[2], double TLJPL, double dGK, double JD[2], double& dDist)
{
	int i, inf;
	double X1, Y1, X2, Y2;
	double Yd;
	int nStartEarthPt;
	inf = 100;
	Gety(TLJPt[0], nEarthPtsum, EarthPtList, Yd, nStartEarthPt);
	for (i = nStartEarthPt; i < nEarthPtsum - 1; i++)
	{
		X1 = EarthPtList[i * 2];
		Y1 = EarthPtList[i * 2 + 1];
		X2 = EarthPtList[(i + 1) * 2];
		Y2 = EarthPtList[(i + 1) * 2 + 1];
		inf = INTERS(&JD[0], &JD[1], X1, Y1, X2, Y2, TLJPt[0], TLJPt[1], TLJPt[0] + 100.0, TLJPt[1] - 100.0*TLJPL);
		if (inf == 0)//有交点
		{
			//			dDist = sqrt( (TLJPt[0]-JD[0])*(TLJPt[0]-JD[0]) + (TLJPt[1]-JD[1])*(TLJPt[1]-JD[1]) );
			dDist = JD[0] - TLJPt[0];
			if (LDorLQ*(Y1 - Y2) > 0.001 && dDist < 5.0 + dGK)
				return true;
		}
	}
	return false;
}

/************************************************************************
自动填平路堑设计
************************************************************************/
int HdmDes::AutoTPLQDes(double TPdist, int& DesPtSum, double DesPtList[], int EarthPtSum, double EarthPtList[], double GK, double GS, double GP1, double GP2, double GDR, double LQBPPL, double SLPTPL, double& GouH, double& GouX, int &LDSGPtSum, double LDSGPt[])
{
	double GouWide;
	double StartDesPt[2];
	int inf;
	GouWide = GK + GS * (GP1 + GP2);
	if (TPdist < GouWide + 2.0)//推平距离小于一个水沟宽+2.0m
	{
		double StartDesPt[2];
		LDSGPt[0] = DesPtList[4 * 2];
		LDSGPt[1] = DesPtList[4 * 2 + 1];
		LDSGPt[1 * 2] = LDSGPt[0];
		LDSGPt[1 * 2 + 1] = LDSGPt[1];
		LDSGPt[2 * 2] = LDSGPt[1 * 2] + GS * GP1;
		LDSGPt[2 * 2 + 1] = LDSGPt[1 * 2 + 1] - GS;
		LDSGPt[3 * 2] = LDSGPt[2 * 2] + GK;
		LDSGPt[3 * 2 + 1] = LDSGPt[2 * 2 + 1];
		LDSGPt[4 * 2] = LDSGPt[3 * 2] + GS * GP2;
		LDSGPt[4 * 2 + 1] = LDSGPt[3 * 2 + 1] + GS;
		GouH = LDSGPt[3 * 2 + 1];
		GouX = LDSGPt[2 * 2] + 0.5 * GK;
		LDSGPtSum = 5;
		StartDesPt[0] = LDSGPt[4 * 2];
		StartDesPt[1] = LDSGPt[4 * 2 + 1];
		inf = -1;
		double Yd = 0.0;
		int nStartEarthPt;
		double X1, Y1, X2, Y2, JDX, JDY;
		Gety(StartDesPt[0], EarthPtSum, EarthPtList, Yd, nStartEarthPt);
		int i;
		for (i = nStartEarthPt; i < EarthPtSum - 1; i++)
		{
			X1 = EarthPtList[i * 2];
			Y1 = EarthPtList[i * 2 + 1];
			X2 = EarthPtList[(i + 1) * 2];
			Y2 = EarthPtList[(i + 1) * 2 + 1];
			if (TPdist < GouWide)//推平距离小于沟宽
				inf = INTERS(&JDX, &JDY, X1, Y1, X2, Y2, StartDesPt[0], StartDesPt[1], StartDesPt[0] + 100.0*LQBPPL, StartDesPt[1] + 100.0);
			else
				inf = INTERS(&JDX, &JDY, X1, Y1, X2, Y2, StartDesPt[0], StartDesPt[1], StartDesPt[0] + 100.0, StartDesPt[1] + 100.0*SLPTPL*0.01);

			if (inf == 0)//有交点
			{
				LDSGPt[5 * 2] = JDX;
				LDSGPt[5 * 2 + 1] = JDY;
				LDSGPtSum = 6;
				break;
			}
		}

		if (i == EarthPtSum - 1 || JDX > DesPtList[4 * 2] + TPdist + GouWide)//当最终的交点X坐标超过了推平距离+沟顶宽则不再推平（暂定）
		{
			for (int j = 0; j < LDSGPtSum; j++)
			{
				LDSGPt[2 * j] = 0.0;
				LDSGPt[2 * j + 1] = 0.0;
			}
			LDSGPtSum = 0;
			return -1;//无交点，无法完成设计
		}
	}


	else//推平距离大于沟宽+2.0m
	{
		double Yd = 0.0;
		int nStartEarthPt;
		double X1, Y1, X2, Y2, JDX, JDY;
		StartDesPt[0] = DesPtList[4 * 2];
		StartDesPt[1] = DesPtList[4 * 2 + 1];
		LDSGPt[0] = StartDesPt[0];
		LDSGPt[1] = StartDesPt[1];
		LDSGPtSum = 1;
		Gety(TPdist + DesPtList[4 * 2], EarthPtSum, EarthPtList, Yd, nStartEarthPt);
		int i;
		for (i = nStartEarthPt; i < EarthPtSum - 1; i++)
		{
			X1 = EarthPtList[i * 2] - 2.0 - GouWide;
			Y1 = EarthPtList[i * 2 + 1] - 2.0*0.1;
			X2 = EarthPtList[(i + 1) * 2] - 2.0 - GouWide;
			Y2 = EarthPtList[(i + 1) * 2 + 1] - 2.0*0.1;
			inf = INTERS(&JDX, &JDY, X1, Y1, X2, Y2, StartDesPt[0], StartDesPt[1], StartDesPt[0] + 100.0, StartDesPt[1] - 100.0*0.1);
			if (inf == 0)//有交点
			{
				LDSGPt[1 * 2] = JDX;
				LDSGPt[1 * 2 + 1] = JDY;
				LDSGPtSum = 2;
				break;
			}
		}
		if (i == EarthPtSum - 1 || JDX > DesPtList[4 * 2] + TPdist + GouWide)//当最终的交点X坐标超过了推平距离+沟顶宽则不再推平（暂定）
		{
			for (int j = 0; j < LDSGPtSum; j++)
			{
				LDSGPt[2 * j] = 0.0;
				LDSGPt[2 * j + 1] = 0.0;
			}
			LDSGPt = 0;
			return -1;//无交点，无法完成设计
		}
		LDSGPt[2 * 2] = LDSGPt[1 * 2] + GS * GP1;
		LDSGPt[2 * 2 + 1] = LDSGPt[1 * 2 + 1] - GS;
		LDSGPt[3 * 2] = LDSGPt[2 * 2] + GK;
		LDSGPt[3 * 2 + 1] = LDSGPt[2 * 2 + 1];
		LDSGPt[4 * 2] = LDSGPt[3 * 2] + GS * GP2;
		LDSGPt[4 * 2 + 1] = LDSGPt[3 * 2 + 1] + GS;
		LDSGPt[5 * 2] = LDSGPt[4 * 2] + 2.0;
		LDSGPt[5 * 2 + 1] = LDSGPt[4 * 2 + 1] + 2.0 *0.1;
		GouH = LDSGPt[3 * 2 + 1];
		GouX = LDSGPt[2 * 2] + 0.5 * GK;
		LDSGPtSum = 6;

	}

	if (GDR > 0.001)//如采用蝶形沟，修正设计点数组
	{
		double spt[2], ept[2], pt[20];
		int StartIndex = 2;

		spt[0] = LDSGPt[StartIndex * 2], spt[1] = LDSGPt[StartIndex * 2 + 1];
		ept[0] = LDSGPt[(StartIndex + 1) * 2], ept[1] = LDSGPt[(StartIndex + 1) * 2 + 1];
		GetArcPt(spt, ept, GDR, 10, pt);
		//2修正设计点
		int npt, i;
		double despt[200];
		npt = 0;
		for (i = 0; i <= StartIndex; i++)
		{
			despt[npt * 2] = LDSGPt[i * 2];
			despt[npt * 2 + 1] = LDSGPt[i * 2 + 1];
			npt++;
		}
		for (i = 0; i < 10; i++)
		{
			despt[npt * 2] = pt[i * 2];
			despt[npt * 2 + 1] = pt[i * 2 + 1];

			npt++;
		}
		for (i = StartIndex + 1; i < LDSGPtSum; i++)
		{
			despt[npt * 2] = LDSGPt[i * 2];
			despt[npt * 2 + 1] = LDSGPt[i * 2 + 1];
			npt++;
		}

		LDSGPtSum = npt;
		for (i = 0; i < LDSGPtSum; i++)
		{
			LDSGPt[i * 2] = despt[i * 2];
			LDSGPt[i * 2 + 1] = despt[i * 2 + 1];
		}
	}

	return 1;
}

int HdmDes::AutoTPLDDes(double TPdist, int& DesPtSum, double DesPtList[], int EarthPtSum, double EarthPtList[], double& GK, double& GS, double& GP1, double& GP2, double GDR, double SLPTPL, double& GouH, double& GouX, int &LDSGPtSum, double LDSGPt[])
{
	double GouWide;
	double StartDesPt[2];
	int inf;
	GouWide = GK + GS * (GP1 + GP2);
	if (TPdist < GouWide)
	{
		DesPtList[5 * 2] = DesPtList[4 * 2] + TPdist;
		DesPtList[5 * 2 + 1] = DesPtList[4 * 2 + 1] - TPdist * 0.1;
		GouH = DesPtList[5 * 2];
		GouX = DesPtList[5 * 2 + 1];
		DesPtSum = 6;
		LDSGPtSum = 0;
		return 1;
	}

	else if (TPdist < GouWide + 2.0)//推平距离小于一个水沟宽+2.0
	{
		double StartDesPt[2];
		LDSGPt[0] = DesPtList[4 * 2];
		LDSGPt[1] = DesPtList[4 * 2 + 1];
		LDSGPt[1 * 2] = LDSGPt[0];
		LDSGPt[1 * 2 + 1] = LDSGPt[1];
		LDSGPt[2 * 2] = LDSGPt[1 * 2] + GS * GP1;
		LDSGPt[2 * 2 + 1] = LDSGPt[1 * 2 + 1] - GS;
		LDSGPt[3 * 2] = LDSGPt[2 * 2] + GK;
		LDSGPt[3 * 2 + 1] = LDSGPt[2 * 2 + 1];
		LDSGPt[4 * 2] = LDSGPt[3 * 2] + GS * GP2;
		LDSGPt[4 * 2 + 1] = LDSGPt[3 * 2 + 1] + GS;
		GouH = LDSGPt[2 * 2 + 1];
		GouX = LDSGPt[2 * 2] + 0.5 * GK;
		LDSGPtSum = 5;
		StartDesPt[0] = LDSGPt[4 * 2];
		StartDesPt[1] = LDSGPt[4 * 2 + 1];
		inf = -1;
		double Yd = 0.0;
		int nStartEarthPt;
		double X1, Y1, X2, Y2, JDX, JDY;
		Gety(StartDesPt[0], EarthPtSum, EarthPtList, Yd, nStartEarthPt);
		int i;
		for (i = nStartEarthPt; i < EarthPtSum - 1; i++)
		{
			X1 = EarthPtList[i * 2];
			Y1 = EarthPtList[i * 2 + 1];
			X2 = EarthPtList[(i + 1) * 2];
			Y2 = EarthPtList[(i + 1) * 2 + 1];
			inf = INTERS(&JDX, &JDY, X1, Y1, X2, Y2, StartDesPt[0], StartDesPt[1], StartDesPt[0] + 100.0, StartDesPt[1] + 100.0*SLPTPL*0.01);
			if (inf == 0)//有交点
			{
				LDSGPt[2 * 5] = JDX;
				LDSGPt[2 * 5 + 1] = JDY;
				LDSGPtSum = 6;
				break;
			}
		}
		if (i == EarthPtSum - 1 || JDX > DesPtList[4 * 2] + TPdist + GouWide)
		{
			for (int j = 0; j < LDSGPtSum; j++)
			{
				LDSGPt[j * 2] = 0.0;
				LDSGPt[j * 2 + 1] = 0.0;
			}
			LDSGPtSum = 0;
			return -1;//无交点，无法完成设计
		}
	}


	else//推平距离大于沟宽+2.0m
	{
		double Yd = 0.0;
		int nStartEarthPt;
		double X1, Y1, X2, Y2, JDX, JDY;
		StartDesPt[0] = DesPtList[4 * 2];
		StartDesPt[1] = DesPtList[4 * 2 + 1];
		LDSGPt[0] = StartDesPt[0];
		LDSGPt[1] = StartDesPt[1];
		LDSGPtSum = 1;
		Gety(TPdist + DesPtList[4 * 2], EarthPtSum, EarthPtList, Yd, nStartEarthPt);
		int i;
		for (i = nStartEarthPt; i < EarthPtSum - 1; i++)
		{
			X1 = EarthPtList[i * 2] - 2.0 - GouWide;
			Y1 = EarthPtList[i * 2 + 1] - 2.0*0.1;
			X2 = EarthPtList[(i + 1) * 2] - 2.0 - GouWide;
			Y2 = EarthPtList[(i + 1) * 2 + 1] - 2.0*0.1;
			inf = INTERS(&JDX, &JDY, X1, Y1, X2, Y2, StartDesPt[0], StartDesPt[1], StartDesPt[0] + 100.0, StartDesPt[1] - 100.0*0.1);
			if (inf == 0)//有交点
			{
				LDSGPt[1 * 2] = JDX;
				LDSGPt[1 * 2 + 1] = JDY;
				LDSGPtSum = 2;
				break;
			}
		}
		if (i == EarthPtSum - 1 || JDX > DesPtList[4 * 2] + TPdist + GouWide)
		{
			for (int j = 0; j < LDSGPtSum; j++)
			{
				LDSGPt[2 * j] = 0.0;
				LDSGPt[2 * j + 1] = 0.0;
			}
			LDSGPtSum = 0;
			return -1;//无交点，无法完成设计
		}
		LDSGPt[2 * 2] = LDSGPt[1 * 2] + GS * GP1;
		LDSGPt[2 * 2 + 1] = LDSGPt[1 * 2 + 1] - GS;
		LDSGPt[3 * 2] = LDSGPt[2 * 2] + GK;
		LDSGPt[3 * 2 + 1] = LDSGPt[2 * 2 + 1];
		LDSGPt[4 * 2] = LDSGPt[3 * 2] + GS * GP2;
		LDSGPt[4 * 2 + 1] = LDSGPt[3 * 2 + 1] + GS;
		LDSGPt[5 * 2] = LDSGPt[4 * 2] + 2.0;
		LDSGPt[5 * 2 + 1] = LDSGPt[4 * 2 + 1] + 2.0 *0.1;
		GouH = LDSGPt[2 * 2 + 1];
		GouX = LDSGPt[2 * 2] + 0.5 * GK;
		LDSGPtSum = 6;

	}

	if (GDR > 0.001 && TPdist > GouWide)//如采用蝶形沟，修正设计点数组
	{
		double spt[2], ept[2], pt[20];
		int StartIndex = 2;

		spt[0] = LDSGPt[StartIndex * 2], spt[1] = LDSGPt[StartIndex * 2 + 1];
		ept[0] = LDSGPt[(StartIndex + 1) * 2], ept[1] = LDSGPt[(StartIndex + 1) * 2 + 1];
		GetArcPt(spt, ept, GDR, 10, pt);
		//2修正设计点
		int npt, i;
		double despt[200];
		npt = 0;
		for (i = 0; i <= StartIndex; i++)
		{
			despt[npt * 2] = LDSGPt[i * 2];
			despt[npt * 2 + 1] = LDSGPt[i * 2 + 1];
			npt++;
		}
		for (i = 0; i < 10; i++)
		{
			despt[npt * 2] = pt[i * 2];
			despt[npt * 2 + 1] = pt[i * 2 + 1];

			npt++;
		}
		for (i = StartIndex + 1; i < LDSGPtSum; i++)
		{
			despt[npt * 2] = LDSGPt[i * 2];
			despt[npt * 2 + 1] = LDSGPt[i * 2 + 1];
			npt++;
		}

		LDSGPtSum = npt;
		for (i = 0; i < LDSGPtSum; i++)
		{
			LDSGPt[i * 2] = despt[i * 2];
			LDSGPt[i * 2 + 1] = despt[i * 2 + 1];
		}
	}

	return 1;
}

// **********************************************************************
// 自动设计高陡边坡台阶
// 返回值：1-设计成功，0-设计失败
// 输入参数：
// BenchStartPt[2]			设置台阶的起点
// nEarthPtsum				地面点总数
// EarthPtList				地面点数组
// 输出参数：
// BenchPtSum				台阶点总数
// BenchPtList[]			台阶点数组
// CutBenchArea			开挖台阶土石方
// 附注：
// BenchPtList[] 实质为开挖台阶后的新地面线点
// **********************************************************************int HdmDes::AutoCutBench(double BenchStartPt[2],int& BenchPtSum, double BenchPtList[], int EarthPtSum, double EarthPtList[],double& CutBenchArea)
// {
// 	CutBenchArea = 0.0;
// 	BenchPtSum = 0;
// 
// 	if (-BenchStartPt[1] / BenchStartPt[0] > 0.2)//地面横坡大于1:5
// 	{
// 		double MinBenchHight;//台阶最小高度
// 		MinBenchHight = 0.2;//暂定为0.2m
// 		double BenchInflexionPt[2];//台阶的拐点
// 		double BenchEndPt[2];//每级台阶的终点，同时也是下级台阶的起点
// 		double BenchStarPtYd;//台阶的起点处的地面Y坐标
// 		double BenchInflexionPtYd;//台阶的拐点处的地面Y坐标
// 		int BenchInflexionPtNum;//台阶的拐点处对应的地面点数组的下标号
// 		int BenchStartPtNum;//台阶的起点处对应的地面点数组的下标号
// 		int DesInf;//设计信息
// 		DesInf = 0;//初始化为设计失败
// 		
// 		CutBenchArea = 0.0;//初始化为0
// 		
// 		int BenchLeverSum;//台阶总数
// 		BenchLeverSum = 0;
// 		
// 		BenchPtSum = 1;//初始化为1
// 		BenchPtList[0] = BenchStartPt[0];
// 		BenchPtList[1] = BenchStartPt[1];
// 		
// 		while (BenchStartPt[0]>2.0)
// 		{
// 			BenchInflexionPt[0] = BenchStartPt[0] - 2.0;//每级台阶宽度为2.0m
// 			BenchInflexionPt[1] = BenchStartPt[1] - 2.0 * 0.04;//每级台阶向内侧倾斜4%
// 			DesInf = Gety(BenchInflexionPt[0],EarthPtSum,EarthPtList,BenchInflexionPtYd,BenchInflexionPtNum);//计算台阶拐点处的地面Y坐标
// 			if (DesInf!=1)//设计失败
// 			{
// 				for (int i=0; i<BenchPtSum; i++)
// 				{
// 					BenchPtList[2*i] = 0.0;
// 					BenchPtList[2*i+1] = 0.0;
// 				}
// 				BenchPtSum = 0.0;
// 				return 0;
// 			}
// 			
// 			BenchEndPt[0] = BenchInflexionPt[0];
// 			BenchEndPt[1] = BenchInflexionPtYd;
// 			
// 			//如果台阶高度大于最小台阶高，则将台阶点存入BenchPtList[]数组，否则将该级台阶范围内的地面点存入BenchPtList[]数组
// 			if (BenchInflexionPtYd - BenchInflexionPt[1] > MinBenchHight)
// 			{
// 				BenchPtList[2*BenchPtSum] = BenchInflexionPt[0];
// 				BenchPtList[2*BenchPtSum+1] = BenchInflexionPt[1];
// 				BenchPtSum++ ;
// 				BenchPtList[2*BenchPtSum] = BenchEndPt[0];
// 				BenchPtList[2*BenchPtSum+1] = BenchEndPt[1];
// 				BenchPtSum++ ;
// 				BenchLeverSum +=1 ;
// 			}
// 			else
// 			{
// 				DesInf = Gety(BenchStartPt[0],EarthPtSum,EarthPtList,BenchStarPtYd,BenchStartPtNum);//计算台阶起点处的地面Y坐标
// 				if (DesInf!=1)//设计失败
// 				{
// 					for (int i=0; i<BenchPtSum; i++)
// 					{
// 						BenchPtList[2*i] = 0.0;
// 						BenchPtList[2*i+1] = 0.0;
// 					}
// 					BenchPtSum = 0.0;
// 				}
// 				if (BenchStartPtNum>BenchInflexionPtNum)
// 				{
// 					for (int i=BenchStartPtNum; i>BenchInflexionPtNum; i--)
// 					{
// 						BenchPtList[2*BenchPtSum] = EarthPtList[2*i];
// 						BenchPtList[2*BenchPtSum+1] = EarthPtList[2*i+1];
// 						BenchPtSum++ ;
// 					}
// 				}
// 
// 				BenchPtList[2*BenchPtSum] = BenchEndPt[0];
// 				BenchPtList[2*BenchPtSum+1] = BenchEndPt[1];
// 				BenchPtSum++ ;
// 
// 			}
// 			
// 			//下一级台阶的起点是当前台阶的终点
// 			BenchStartPt[0] = BenchEndPt[0];
// 			BenchStartPt[1] = BenchEndPt[1];
// 		}
// 		
// 		if (BenchLeverSum==0)//台阶总数为0,设计台阶失败，清空数组
// 		{
// 			for (int i=0; i<BenchPtSum; i++)
// 			{
// 				BenchPtList[2*i] = 0.0;
// 				BenchPtList[2*i+1] = 0.0;
// 			}
// 			BenchPtSum = 0.0;
// 			return 0;
// 		}
// 		
// 		else//将BenchPtList[]数组整理成由中心向两侧的形式
// 		{
// 			double TmpPtX,TmpPtY;
// 			for (int i=0; i<BenchPtSum/2; i++)
// 			{
// 				TmpPtX = BenchPtList[2*i];
// 				TmpPtY = BenchPtList[2*i+1];
// 				BenchPtList[2*i] = BenchPtList[2*(BenchPtSum-1-i)];
// 				BenchPtList[2*i+1] = BenchPtList[2*(BenchPtSum-1-i)+1];
// 				BenchPtList[2*(BenchPtSum-1-i)] = TmpPtX;
// 				BenchPtList[2*(BenchPtSum-1-i)+1] = TmpPtY;
// 			}						
// 		}
// 
// 		double FillBenchArea=0.0;
// 		CutBenchArea = 0.0;
// 		cal_polygon_area(BenchPtSum,BenchPtList,EarthPtSum,EarthPtList,FillBenchArea,CutBenchArea);
// 		if (CutBenchArea<0.001)
// 			return 0;
// 		
// 		return 1;
// 	}
// 	
// 	else
// 		return 0;
// }


/***********************************************************************
自动设计高陡边坡台阶
返回值：1-设计成功，0-设计失败
输入参数：
BenchStartPt[2]			设置台阶的起点
nEarthPtsum				地面点总数
EarthPtList				地面点数组
输出参数：
BenchPtSum				台阶点总数
BenchPtList[]			台阶点数组
CutBenchArea			开挖台阶土石方
附注：
BenchPtList[] 只包括台阶点，不包括地面线点
***********************************************************************/
int HdmDes::AutoCutBench(double BenchStartPt[2], int& BenchPtSum, double BenchPtList[], int EarthPtSum, double EarthPtList[], double LMPtList[10], double LMHD[3], double& CutBenchArea)
{
	CutBenchArea = 0.0;
	BenchPtSum = 0;

	if (-BenchStartPt[1] / BenchStartPt[0] > 0.2)//地面横坡大于1:5
	{
		double NewEarthPtList[400];
		int NewEarthPtSum;
		NewEarthPtSum = 0;
		double MinBenchHight;//台阶最小高度
		MinBenchHight = 0.2;//暂定为0.2m
		double BenchInflexionPt[2];//台阶的拐点
		double BenchEndPt[2];//每级台阶的终点，同时也是下级台阶的起点
		double BenchStarPtYd;//台阶的起点处的地面Y坐标
		double BenchInflexionPtYd;//台阶的拐点处的地面Y坐标
		int BenchInflexionPtNum;//台阶的拐点处对应的地面点数组的下标号
		int BenchStartPtNum;//台阶的起点处对应的地面点数组的下标号
		int DesInf;//设计信息
		DesInf = 0;//初始化为设计失败

		CutBenchArea = 0.0;//初始化为0

		int BenchLeverSum;//台阶总数
		BenchLeverSum = 0;

		NewEarthPtSum = 1;//初始化为1
		NewEarthPtList[0] = BenchStartPt[0];
		NewEarthPtList[1] = BenchStartPt[1];
		BenchPtList[0] = BenchStartPt[0];
		BenchPtList[1] = BenchStartPt[1];

		//////////////////////////////////////////////////////////////////////////
		//计算除去路面厚度后的路面设计点
		double despoints[16];
		for (int i = 0; i < 4; i++)
			despoints[i] = LMPtList[i];
		int npt = 2;
		despoints[npt * 2] = LMPtList[2];
		despoints[npt * 2 + 1] = LMPtList[3] - LMHD[0];
		npt++;
		despoints[npt * 2] = LMPtList[4];
		despoints[npt * 2 + 1] = LMPtList[5] - LMHD[0];
		npt++;
		despoints[npt * 2] = LMPtList[4];
		despoints[npt * 2 + 1] = LMPtList[5] - LMHD[1];
		npt++;
		despoints[npt * 2] = LMPtList[6];
		despoints[npt * 2 + 1] = LMPtList[7] - LMHD[1];
		npt++;
		despoints[npt * 2] = LMPtList[6];
		despoints[npt * 2 + 1] = LMPtList[7] - LMHD[2];
		npt++;
		despoints[npt * 2] = LMPtList[8];
		despoints[npt * 2 + 1] = LMPtList[9] - LMHD[2];
		//////////////////////////////////////////////////////////////////////////
		double dh = 100.0;//除去路面厚度后的路面点台阶点的高差
		while (BenchStartPt[0] > 2.0 && dh > 0.0)
		{
			BenchInflexionPt[0] = BenchStartPt[0] - 2.0;//每级台阶宽度为2.0m
			BenchInflexionPt[1] = BenchStartPt[1] - 2.0 * 0.04;//每级台阶向内侧倾斜4%
			DesInf = Gety(BenchInflexionPt[0], EarthPtSum, EarthPtList, BenchInflexionPtYd, BenchInflexionPtNum);//计算台阶拐点处的地面Y坐标
			if (DesInf != 1)//设计失败
			{
				for (int i = 0; i < NewEarthPtSum; i++)
				{
					NewEarthPtList[2 * i] = 0.0;
					NewEarthPtList[2 * i + 1] = 0.0;
				}
				NewEarthPtSum = 0.0;
				return 0;
			}

			BenchEndPt[0] = BenchInflexionPt[0];
			BenchEndPt[1] = BenchInflexionPtYd;

			double NewLMYd = 0.0;
			int NewNum;
			DesInf = Gety(BenchEndPt[0], 8, despoints, NewLMYd, NewNum);
			if (DesInf == 1)
			{
				dh = NewLMYd - BenchEndPt[1];
				// 				if (dh<0.0)
				// 				{
				// 					BenchEndPt[0] = BenchInflexionPt[0];
				// 					BenchEndPt[1] = NewLMYd;
				// 				}
			}
			else
				dh = 100.0;

			//如果台阶高度大于最小台阶高，则将台阶点存入BenchPtList[]数组，否则将该级台阶范围内的地面点存入BenchPtList[]数组
			if (BenchInflexionPtYd - BenchInflexionPt[1] > MinBenchHight)
			{
				NewEarthPtList[2 * NewEarthPtSum] = BenchInflexionPt[0];
				NewEarthPtList[2 * NewEarthPtSum + 1] = BenchInflexionPt[1];
				NewEarthPtSum++;
				NewEarthPtList[2 * NewEarthPtSum] = BenchEndPt[0];
				NewEarthPtList[2 * NewEarthPtSum + 1] = BenchEndPt[1];
				NewEarthPtSum++;

				BenchPtList[BenchLeverSum * 6 + 0] = BenchStartPt[0];
				BenchPtList[BenchLeverSum * 6 + 1] = BenchStartPt[1];
				BenchPtList[BenchLeverSum * 6 + 2] = BenchInflexionPt[0];
				BenchPtList[BenchLeverSum * 6 + 3] = BenchInflexionPt[1];
				BenchPtList[BenchLeverSum * 6 + 4] = BenchEndPt[0];
				BenchPtList[BenchLeverSum * 6 + 5] = BenchEndPt[1];
				BenchLeverSum += 1;
			}
			else
			{
				DesInf = Gety(BenchStartPt[0], EarthPtSum, EarthPtList, BenchStarPtYd, BenchStartPtNum);//计算台阶起点处的地面Y坐标
				if (DesInf != 1)//设计失败
				{
					for (int i = 0; i < NewEarthPtSum; i++)
					{
						NewEarthPtList[2 * i] = 0.0;
						NewEarthPtList[2 * i + 1] = 0.0;
					}
					NewEarthPtSum = 0.0;
					return 0;
				}
				if (BenchStartPtNum > BenchInflexionPtNum)
				{
					for (int i = BenchStartPtNum; i > BenchInflexionPtNum; i--)
					{
						NewEarthPtList[2 * NewEarthPtSum] = EarthPtList[2 * i];
						NewEarthPtList[2 * NewEarthPtSum + 1] = EarthPtList[2 * i + 1];
						NewEarthPtSum++;
					}
				}

				NewEarthPtList[2 * NewEarthPtSum] = BenchEndPt[0];
				NewEarthPtList[2 * NewEarthPtSum + 1] = BenchEndPt[1];
				NewEarthPtSum++;

			}

			//下一级台阶的起点是当前台阶的终点
			BenchStartPt[0] = BenchEndPt[0];
			BenchStartPt[1] = BenchEndPt[1];
		}

		if (BenchLeverSum == 0)//台阶总数为0,设计台阶失败，清空数组
		{
			int i;
			for (i = 0; i < NewEarthPtSum; i++)
			{
				NewEarthPtList[2 * i] = 0.0;
				NewEarthPtList[2 * i + 1] = 0.0;
			}
			NewEarthPtSum = 0.0;

			for (i = 0; i < BenchLeverSum; i++)
			{
				BenchPtList[BenchLeverSum * 6 + 0] = 0.0;
				BenchPtList[BenchLeverSum * 6 + 1] = 0.0;
				BenchPtList[BenchLeverSum * 6 + 2] = 0.0;
				BenchPtList[BenchLeverSum * 6 + 3] = 0.0;
				BenchPtList[BenchLeverSum * 6 + 4] = 0.0;
				BenchPtList[BenchLeverSum * 6 + 5] = 0.0;
			}
			return 0;
		}

		else//将NewEarthPtList[]数组整理成由中心向两侧的形式
		{
			double TmpPtX, TmpPtY;
			for (int i = 0; i < NewEarthPtSum / 2; i++)
			{
				TmpPtX = NewEarthPtList[2 * i];
				TmpPtY = NewEarthPtList[2 * i + 1];
				NewEarthPtList[2 * i] = NewEarthPtList[2 * (NewEarthPtSum - 1 - i)];
				NewEarthPtList[2 * i + 1] = NewEarthPtList[2 * (NewEarthPtSum - 1 - i) + 1];
				NewEarthPtList[2 * (NewEarthPtSum - 1 - i)] = TmpPtX;
				NewEarthPtList[2 * (NewEarthPtSum - 1 - i) + 1] = TmpPtY;
			}
		}

		double FillBenchArea = 0.0;
		CutBenchArea = 0.0;
		cal_polygon_area(NewEarthPtSum, NewEarthPtList, EarthPtSum, EarthPtList, FillBenchArea, CutBenchArea);
		if (CutBenchArea < 0.001)
			return 0;


		//将NewEarthPtList[]数组整理成由中心向两侧的形式
		BenchPtSum = BenchLeverSum * 3;
		double TmpPtX, TmpPtY;
		for (int i = 0; i < BenchPtSum / 2; i++)
		{
			TmpPtX = BenchPtList[2 * i];
			TmpPtY = BenchPtList[2 * i + 1];
			BenchPtList[2 * i] = BenchPtList[2 * (BenchPtSum - 1 - i)];
			BenchPtList[2 * i + 1] = BenchPtList[2 * (BenchPtSum - 1 - i) + 1];
			BenchPtList[2 * (BenchPtSum - 1 - i)] = TmpPtX;
			BenchPtList[2 * (BenchPtSum - 1 - i) + 1] = TmpPtY;
		}
		return 1;
	}

	else
		return 0;
}


/***********************************************************************
自动设计高陡边坡台阶
返回值：1-设计成功，0-设计失败
输入参数：
IsPJToLJCen				是否从坡脚点向路基中线方向开挖台阶
BenchStartPt[2]			设置台阶的起点
EarthPtsum				地面点总数
EarthPtList				地面点数组
StartX					开挖台阶范围的起始X坐标
EndX					开挖台阶范围的终止X坐标
输出参数：
BenchPtSum				台阶点总数
BenchPtList[]			台阶点数组
CutBenchArea			开挖台阶土石方
附注：
BenchPtList[] 只包括台阶点，不包括地面线点
IsPJToLJCen为真时StartX>EndX。IsPJToLJCen为假时StartX<EndX
***********************************************************************/
int HdmDes::AutoCutBench(bool IsPJToLJCen, double BenchStartPt[2], int& BenchPtSum, double BenchPtList[], int EarthPtSum, double EarthPtList[], double StartX, double EndX, double& CutBenchArea)
{
	//	ads_printf(L"StartX=%lf,EndX=%lf\n",StartX,EndX);
	//	ads_printf(L"开挖点X=%lf,Y=%lf",BenchStartPt[0],BenchStartPt[1]);
	CutBenchArea = 0.0;
	BenchPtSum = 0;
	double lmhp = 0.0;
	int flag = 1;
	if (IsPJToLJCen)
		flag = 1;
	else
		flag = -1;

	if (IsPJToLJCen)
	{
		lmhp = GetDmhp(EndX, StartX, EarthPtList, EarthPtSum);
		//		ads_printf(L"lmhp=%lf\n",lmhp);
		if (-lmhp < 0.2)
			return 0;
	}
	else
	{
		lmhp = GetDmhp(StartX, EndX, EarthPtList, EarthPtSum);
		//		ads_printf(L"lmhp=%lf\n",lmhp);
		if (lmhp < 0.2)
			return 0;
	}

	double NewEarthPtList[400];
	int NewEarthPtSum;
	NewEarthPtSum = 0;
	double MinBenchHight;//台阶最小高度
	MinBenchHight = 0.2;//暂定为0.2m
	double BenchInflexionPt[2];//台阶的拐点
	double BenchEndPt[2];//每级台阶的终点，同时也是下级台阶的起点
	double BenchStarPtYd;//台阶的起点处的地面Y坐标
	double BenchInflexionPtYd;//台阶的拐点处的地面Y坐标
	int BenchInflexionPtNum;//台阶的拐点处对应的地面点数组的下标号
	int BenchStartPtNum;//台阶的起点处对应的地面点数组的下标号
	int DesInf;//设计信息
	DesInf = 0;//初始化为设计失败

	CutBenchArea = 0.0;//初始化为0

	int BenchLeverSum;//台阶总数
	BenchLeverSum = 0;

	NewEarthPtSum = 1;//初始化为1
	NewEarthPtList[0] = BenchStartPt[0];
	NewEarthPtList[1] = BenchStartPt[1];
	BenchPtList[0] = BenchStartPt[0];
	BenchPtList[1] = BenchStartPt[1];

	while (flag*(BenchStartPt[0] - EndX) > 2.0)
	{
		BenchInflexionPt[0] = BenchStartPt[0] - flag * 2.0;//每级台阶宽度为2.0m
		BenchInflexionPt[1] = BenchStartPt[1] - 2.0 * 0.04;//每级台阶向内侧倾斜4%
		DesInf = Gety(BenchInflexionPt[0], EarthPtSum, EarthPtList, BenchInflexionPtYd, BenchInflexionPtNum);//计算台阶拐点处的地面Y坐标
		if (DesInf != 1)//设计失败
		{
			for (int i = 0; i < NewEarthPtSum; i++)
			{
				NewEarthPtList[2 * i] = 0.0;
				NewEarthPtList[2 * i + 1] = 0.0;
			}
			NewEarthPtSum = 0.0;
			return 0;
		}

		BenchEndPt[0] = BenchInflexionPt[0];
		BenchEndPt[1] = BenchInflexionPtYd;

		//如果台阶高度大于最小台阶高，则将台阶点存入BenchPtList[]数组，否则将该级台阶范围内的地面点存入BenchPtList[]数组
		if (BenchInflexionPtYd - BenchInflexionPt[1] > MinBenchHight)
		{
			NewEarthPtList[2 * NewEarthPtSum] = BenchInflexionPt[0];
			NewEarthPtList[2 * NewEarthPtSum + 1] = BenchInflexionPt[1];
			NewEarthPtSum++;
			NewEarthPtList[2 * NewEarthPtSum] = BenchEndPt[0];
			NewEarthPtList[2 * NewEarthPtSum + 1] = BenchEndPt[1];
			NewEarthPtSum++;

			BenchPtList[BenchLeverSum * 6 + 0] = BenchStartPt[0];
			BenchPtList[BenchLeverSum * 6 + 1] = BenchStartPt[1];
			BenchPtList[BenchLeverSum * 6 + 2] = BenchInflexionPt[0];
			BenchPtList[BenchLeverSum * 6 + 3] = BenchInflexionPt[1];
			BenchPtList[BenchLeverSum * 6 + 4] = BenchEndPt[0];
			BenchPtList[BenchLeverSum * 6 + 5] = BenchEndPt[1];
			BenchLeverSum += 1;
		}
		else
		{
			DesInf = Gety(BenchStartPt[0], EarthPtSum, EarthPtList, BenchStarPtYd, BenchStartPtNum);//计算台阶起点处的地面Y坐标
			if (DesInf != 1)//设计失败
			{
				for (int i = 0; i < NewEarthPtSum; i++)
				{
					NewEarthPtList[2 * i] = 0.0;
					NewEarthPtList[2 * i + 1] = 0.0;
				}
				NewEarthPtSum = 0.0;
				return 0;
			}
			if (BenchStartPtNum > BenchInflexionPtNum && IsPJToLJCen)
			{
				for (int i = BenchStartPtNum; i > BenchInflexionPtNum; i--)
				{
					NewEarthPtList[2 * NewEarthPtSum] = EarthPtList[2 * i];
					NewEarthPtList[2 * NewEarthPtSum + 1] = EarthPtList[2 * i + 1];
					NewEarthPtSum++;
				}
			}
			if (BenchStartPtNum < BenchInflexionPtNum && !IsPJToLJCen)
			{
				for (int i = BenchStartPtNum; i < BenchInflexionPtNum; i++)
				{
					NewEarthPtList[2 * NewEarthPtSum] = EarthPtList[2 * i];
					NewEarthPtList[2 * NewEarthPtSum + 1] = EarthPtList[2 * i + 1];
					NewEarthPtSum++;
				}
			}

			NewEarthPtList[2 * NewEarthPtSum] = BenchEndPt[0];
			NewEarthPtList[2 * NewEarthPtSum + 1] = BenchEndPt[1];
			NewEarthPtSum++;

		}
		//下一级台阶的起点是当前台阶的终点
		BenchStartPt[0] = BenchEndPt[0];
		BenchStartPt[1] = BenchEndPt[1];
	}
	if (BenchLeverSum == 0)//台阶总数为0,设计台阶失败，清空数组
	{
		for (int i = 0; i < NewEarthPtSum; i++)
		{
			NewEarthPtList[2 * i] = 0.0;
			NewEarthPtList[2 * i + 1] = 0.0;
		}
		NewEarthPtSum = 0.0;
		CutBenchArea = 0.0;
		return 0;
	}

	else//将NewEarthPtList[]数组整理成由中心向两侧的形式
	{
		if (IsPJToLJCen)
		{
			double TmpPtX, TmpPtY;
			for (int i = 0; i < NewEarthPtSum / 2; i++)
			{
				TmpPtX = NewEarthPtList[2 * i];
				TmpPtY = NewEarthPtList[2 * i + 1];
				NewEarthPtList[2 * i] = NewEarthPtList[2 * (NewEarthPtSum - 1 - i)];
				NewEarthPtList[2 * i + 1] = NewEarthPtList[2 * (NewEarthPtSum - 1 - i) + 1];
				NewEarthPtList[2 * (NewEarthPtSum - 1 - i)] = TmpPtX;
				NewEarthPtList[2 * (NewEarthPtSum - 1 - i) + 1] = TmpPtY;
			}
		}
	}

	double FillBenchArea = 0.0;
	CutBenchArea = 0.0;
	cal_polygon_area(NewEarthPtSum, NewEarthPtList, EarthPtSum, EarthPtList, FillBenchArea, CutBenchArea);
	if (CutBenchArea < 0.001)
		return 0;

	BenchPtSum = BenchLeverSum * 3;
	//	ads_printf(L"台阶点总数%d\n",BenchPtSum);
	//将NewEarthPtList[]数组整理成由中心向两侧的形式
	if (IsPJToLJCen)
	{
		double TmpPtX, TmpPtY;
		for (int i = 0; i < BenchPtSum / 2; i++)
		{
			TmpPtX = BenchPtList[2 * i];
			TmpPtY = BenchPtList[2 * i + 1];
			BenchPtList[2 * i] = BenchPtList[2 * (BenchPtSum - 1 - i)];
			BenchPtList[2 * i + 1] = BenchPtList[2 * (BenchPtSum - 1 - i) + 1];
			BenchPtList[2 * (BenchPtSum - 1 - i)] = TmpPtX;
			BenchPtList[2 * (BenchPtSum - 1 - i) + 1] = TmpPtY;
		}
	}

	return 1;
}


int HdmDes::AutoDesTFLQSGHdm(int& DesPtSum, double DesPtList[], int EarthPtSum, double EarthPtList[], double GK, double GS, double GP1, double GP2, double GDR, double SLPTPL, double& GouH, double& GouX, int &LDSGPtSum, double LDSGPt[])
{
	LDSGPtSum = 0;
	double GouWide;
	double StartDesPt[2];
	int inf = 0;
	GouWide = GK + GS * (GP1 + GP2);
	double Yd = 0.0;
	int nStartEarthPt;
	double X1, Y1, X2, Y2, JDX, JDY;
	double OffsetBPStartPt[2], OffsetBPEndPt[2];
	bool Sucess = false;//是否成功设计
	double TmpDesPtList[100];
	int TmpDesPtSum = DesPtSum;
	int i = 0;

	for (i = 0; i < TmpDesPtSum * 2; i++)
		TmpDesPtList[i] = DesPtList[i];

	while (TmpDesPtSum > 5)//从坡脚点依次向上搜索能做路堤路堑水沟的起点，一直搜索到路肩点
	{
		StartDesPt[0] = TmpDesPtList[(TmpDesPtSum - 1) * 2];
		StartDesPt[1] = TmpDesPtList[(TmpDesPtSum - 1) * 2 + 1];
		OffsetBPStartPt[0] = TmpDesPtList[(TmpDesPtSum - 1) * 2] + 2.0 + GouWide;
		OffsetBPStartPt[1] = TmpDesPtList[(TmpDesPtSum - 1) * 2 + 1];
		OffsetBPEndPt[0] = TmpDesPtList[(TmpDesPtSum - 2) * 2] + 2.0 + GouWide;
		OffsetBPEndPt[1] = TmpDesPtList[(TmpDesPtSum - 2) * 2 + 1];

		inf = Gety(StartDesPt[0], EarthPtSum, EarthPtList, Yd, nStartEarthPt);
		if (inf != 1)
			return 0;

		// 		if (EarthPtList[(nStartEarthPt+1)*2+1] - EarthPtList[(nStartEarthPt)*2+1] < 0.0)
		// 			return 0;

		for (int j = nStartEarthPt; j < EarthPtSum - 1; j++)
		{
			X1 = EarthPtList[j * 2];
			Y1 = EarthPtList[j * 2 + 1];
			X2 = EarthPtList[(j + 1) * 2];
			Y2 = EarthPtList[(j + 1) * 2 + 1];
			inf = INTERS(&JDX, &JDY, X1, Y1, X2, Y2, OffsetBPStartPt[0], OffsetBPStartPt[1], OffsetBPEndPt[0], OffsetBPEndPt[1]);
			if (inf == 0)//有交点
			{
				TmpDesPtList[(TmpDesPtSum - 1) * 2] = JDX - 2.0 - GouWide;
				TmpDesPtList[(TmpDesPtSum - 1) * 2 + 1] = JDY;
				Sucess = true;
				break;
			}
		}
		if (Sucess)
			break;
		else
			TmpDesPtSum--;
	}

	if (TmpDesPtSum == 5)//未找到交点，设计失败
		return 0;

	DesPtSum = TmpDesPtSum;
	for (i = 0; i < 2 * DesPtSum; i++)
		DesPtList[i] = TmpDesPtList[i];

	int GouStartIndex;
	LDSGPtSum = 6;
	LDSGPt[0 * 2] = DesPtList[(DesPtSum - 1) * 2];
	LDSGPt[0 * 2 + 1] = DesPtList[(DesPtSum - 1) * 2 + 1];
	LDSGPt[1 * 2] = LDSGPt[0 * 2] + 1.0;
	LDSGPt[1 * 2 + 1] = LDSGPt[0 * 2 + 1] - 1.0 * SLPTPL * 0.01;
	LDSGPt[2 * 2] = LDSGPt[1 * 2] + GS * GP1;
	LDSGPt[2 * 2 + 1] = LDSGPt[1 * 2 + 1] - GS;
	LDSGPt[3 * 2] = LDSGPt[2 * 2] + GK;
	LDSGPt[3 * 2 + 1] = LDSGPt[2 * 2 + 1];
	LDSGPt[4 * 2] = LDSGPt[3 * 2] + GS * GP2;
	LDSGPt[4 * 2 + 1] = LDSGPt[3 * 2 + 1] + GS;
	LDSGPt[5 * 2] = LDSGPt[4 * 2] + 1.0;
	LDSGPt[5 * 2 + 1] = LDSGPt[4 * 2 + 1] + 1.0 * SLPTPL * 0.01;
	GouX = 0.5 * (LDSGPt[2 * 2] + LDSGPt[3 * 2]);
	GouH = 0.5 * (LDSGPt[2 * 2 + 1] + LDSGPt[3 * 2 + 1]);
	//////////////////////////////////////////////////////////////////////////
	// 	DesPtSum++;
	// 	DesPtList[(DesPtSum-1)*2] = DesPtList[(DesPtSum-2)*2] + 1.0;
	// 	DesPtList[(DesPtSum-1)*2+1] = DesPtList[(DesPtSum-2)*2+1] - 1.0 * SLPTPL * 0.01;
	// 	DesPtSum++;
	// 	DesPtList[(DesPtSum-1)*2] = DesPtList[(DesPtSum-2)*2] + GS * GP1;
	// 	DesPtList[(DesPtSum-1)*2+1] = DesPtList[(DesPtSum-2)*2+1] - GS;
	// 	GouStartIndex = DesPtSum - 1;
	// 	DesPtSum++;
	// 	DesPtList[(DesPtSum-1)*2] = DesPtList[(DesPtSum-2)*2] + GK;
	// 	DesPtList[(DesPtSum-1)*2+1] = DesPtList[(DesPtSum-2)*2+1];
	// 	DesPtSum++;
	// 	DesPtList[(DesPtSum-1)*2] = DesPtList[(DesPtSum-2)*2] + GS * GP2;
	// 	DesPtList[(DesPtSum-1)*2+1] = DesPtList[(DesPtSum-2)*2+1] + GS;
	// 	DesPtSum++;
	// 	DesPtList[(DesPtSum-1)*2] = DesPtList[(DesPtSum-2)*2] + 1.0;
	// 	DesPtList[(DesPtSum-1)*2+1] = DesPtList[(DesPtSum-2)*2+1] + 1.0 * SLPTPL * 0.01;
	//////////////////////////////////////////////////////////////////////////
	GouStartIndex = 2;
	if (GDR > 0.001)//如采用蝶形沟，修正设计点数组
	{
		double spt[2], ept[2], pt[20];
		spt[0] = LDSGPt[GouStartIndex * 2], spt[1] = LDSGPt[GouStartIndex * 2 + 1];
		ept[0] = LDSGPt[(GouStartIndex + 1) * 2], ept[1] = LDSGPt[(GouStartIndex + 1) * 2 + 1];
		GetArcPt(spt, ept, GDR, 10, pt);
		//2修正水沟点
		int ptsum = LDSGPtSum + 10, npt, i;
		double despt[200];
		npt = 0;
		for (i = 0; i <= GouStartIndex; i++)
		{
			despt[npt * 2] = LDSGPt[i * 2];
			despt[npt * 2 + 1] = LDSGPt[i * 2 + 1];
			npt++;
		}
		for (i = 0; i < 10; i++)
		{
			despt[npt * 2] = pt[i * 2];
			despt[npt * 2 + 1] = pt[i * 2 + 1];

			npt++;
		}
		for (i = GouStartIndex + 1; i < LDSGPtSum; i++)
		{
			despt[npt * 2] = LDSGPt[i * 2];
			despt[npt * 2 + 1] = LDSGPt[i * 2 + 1];
			npt++;
		}

		LDSGPtSum = npt;
		for (i = 0; i < LDSGPtSum; i++)
		{
			LDSGPt[i * 2] = despt[i * 2];
			LDSGPt[i * 2 + 1] = despt[i * 2 + 1];
		}
	}


	return 1;
}


//////////////////////////////////////////////////////////////////////////
//由数模数据内插道路下标为iRoad横断面下标为iCross的横断面的地面线
//备注：该函数只为横断面设计插入关联断面时内插关联断面的地面线设计
//////////////////////////////////////////////////////////////////////////
bool HdmDes::InsertHdmDmxByDTM(int iRoad, int iCross, double cml)
{
	bool IsDtmExisting = false;
	//读数模
	//	if(!ptriDTM)
	//	ptriDTM = (triDTM_road *)new triDTM_road;
	//	if(ptriDTM)
	//	{

	if (ptriDTM.DTMHasRead == 0)
	{
		if (ptriDTM.Read_Dtm())
			IsDtmExisting = true;
		else
		{
			IsDtmExisting = false;//数模不存在
			return IsDtmExisting;
		}
	}
	//	}

	double xl[400], yl[400], zl[400];
	double xr[400], yr[400], zr[400];
	EdgeNode *CrsDmxHead, *Tmp;
	int LPnum = 0;
	int RPnum = 0;
	double LLd = 0.0;
	double RRd = 0.0;

	CString GH;
	double dml = road[iRoad].pm->XLC(cml, GH);
	road[iRoad].hdmdmx[iCross].lc = dml;

	int k = 0;

	//计算左右地面点

	LLd = FindIljxk(cml, road[iRoad].pm, road[iRoad].hdmbz.NZDM, road[iRoad].hdmbz.ZDM);//左侧限制宽
	RRd = FindIljxk(cml, road[iRoad].pm, road[iRoad].hdmbz.NYDM, road[iRoad].hdmbz.YDM);//右侧限制宽

	xlpoint PZ;
	PZ.lc = cml;
	road[iRoad].pm->xlpoint_pz(&PZ);
	double pt1[3], pt2[3], cita, x, y, yyt, Yd;
	Yd = 0.0;//初始值
	pt1[0] = PZ.x; pt1[1] = PZ.y; pt1[2] = 0.0;
	cita = PZ.a;
	x = PZ.x;
	y = PZ.y;
	yyt = cita - 0.5*pi;
	pt2[0] = x + LLd * cos(yyt);
	pt2[1] = y + LLd * sin(yyt);
	pt2[2] = 0.0;

	if (ptriDTM.DTMHasRead)
		CrsDmxHead = ptriDTM.FindInterPt(pt1, pt2, LPnum);
	else
		LPnum = 0;

	if (LPnum > 0)//左侧地面线有点
	{
		k = 0;
		while (CrsDmxHead)
		{
			xl[k] = CrsDmxHead->pt[0];
			yl[k] = CrsDmxHead->pt[1];
			zl[k] = CrsDmxHead->pt[2];

			Tmp = CrsDmxHead;
			CrsDmxHead = CrsDmxHead->next;
			free(Tmp);
			k++;
		}

		if (k > 0)
		{
			Yd = zl[0];
			if (Yd < 0.1&&k>1)
			{
				Yd = zl[1];
			}
		}

		for (k = 1; k < LPnum; k++)
		{
			xl[k] = sqrt((xl[k] - xl[0])*(xl[k] - xl[0]) + (yl[k] - yl[0])*(yl[k] - yl[0]));

			if (zl[k] < -100.0)//没数模 按中桩
				zl[k] = Yd;
			yl[k] = zl[k] - Yd;

		}
		xl[0] = 0.0;
		yl[0] = 0.0;
	}//至少有一个点
	else//一个点也没有
	{
		LPnum = 2;
		Yd = 0.0;
		xl[0] = 0.0;
		yl[0] = 0.0;

		xl[1] = LLd;
		yl[1] = 0.0;
	}

	yyt = cita + 0.5*pi;
	pt2[0] = x + RRd * cos(yyt);
	pt2[1] = y + RRd * sin(yyt);
	pt2[2] = 0.0;
	CrsDmxHead = ptriDTM.FindInterPt(pt1, pt2, RPnum);

	//计算横断面左侧地面点坐标
	if (RPnum > 0)
	{
		k = 0;
		while (CrsDmxHead)
		{
			xr[k] = CrsDmxHead->pt[0];
			yr[k] = CrsDmxHead->pt[1];
			zr[k] = CrsDmxHead->pt[2];
			Tmp = CrsDmxHead;
			CrsDmxHead = CrsDmxHead->next;
			free(Tmp);
			k++;
		}
		for (k = 1; k < RPnum; k++)
		{
			xr[k] = sqrt((xr[k] - xr[0])*(xr[k] - xr[0]) + (yr[k] - yr[0])*(yr[k] - yr[0]));

			if (zr[k] < -100.0)//没数模 按中桩
				zr[k] = Yd;
			yr[k] = zr[k] - Yd;
		}
		xr[0] = 0.0;
		yr[0] = 0.0;
	}
	else
	{
		RPnum = 2;
		Yd = 0.0;
		xr[0] = 0.0;
		yr[0] = 0.0;

		xr[1] = RRd;
		yr[1] = 0.0;
	}

	//地面线付值
	Point pt;
	road[iRoad].hdmdmx[iCross].EarH = Yd;
	road[iRoad].hdmdmx[iCross].ZEarPtNum = LPnum;
	road[iRoad].hdmdmx[iCross].ZEarPtAry.RemoveAll();
	for (k = 0; k < LPnum; k++)
	{
		pt.x = xl[k], pt.y = yl[k], pt.z = 0.0;
		road[iRoad].hdmdmx[iCross].ZEarPtAry.Add(pt);
	}
	road[iRoad].hdmdmx[iCross].YEarPtNum = RPnum;
	road[iRoad].hdmdmx[iCross].YEarPtAry.RemoveAll();
	for (k = 0; k < RPnum; k++)
	{
		pt.x = xr[k], pt.y = yr[k], pt.z = 0.0;
		road[iRoad].hdmdmx[iCross].YEarPtAry.Add(pt);
	}

	// 	if(ptriDTM->DTMHasRead)
	// 		ptriDTM->ReleaseDtm();

	return IsDtmExisting;
}

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
bool HdmDes::InsertHdmDmxByDTM(RoadHdmdata &ZDroad, int iCross, double cml)
{
	bool IsDtmExisting = false;
	//读数模
	//	if(!ptriDTM)
	//		ptriDTM = (triDTM_road *)new triDTM_road;
	//	if(ptriDTM)
	//	{
	if (ptriDTM.Read_Dtm())
		IsDtmExisting = true;
	else
	{
		IsDtmExisting = false;//数模不存在
		return IsDtmExisting;
	}
	//	}

	double xl[200], yl[200], zl[200];
	double xr[200], yr[200], zr[200];
	EdgeNode *CrsDmxHead, *Tmp;
	int LPnum = 0;
	int RPnum = 0;
	double LLd = 0.0;
	double RRd = 0.0;

	CString GH;
	double dml = ZDroad.pm->XLC(cml, GH);
	ZDroad.hdmdmx[iCross].lc = dml;

	int k = 0;

	//计算左右地面点

	LLd = FindIljxk(cml, ZDroad.pm, ZDroad.hdmbz.NZDM, ZDroad.hdmbz.ZDM);//左侧限制宽
	RRd = FindIljxk(cml, ZDroad.pm, ZDroad.hdmbz.NYDM, ZDroad.hdmbz.YDM);//右侧限制宽

	xlpoint PZ;
	PZ.lc = cml;
	ZDroad.pm->xlpoint_pz(&PZ);
	double pt1[3], pt2[3], cita, x, y, yyt, Yd;
	Yd = 0.0;//初始值
	pt1[0] = PZ.x; pt1[1] = PZ.y; pt1[2] = 0.0;
	cita = PZ.a;
	x = PZ.x;
	y = PZ.y;
	yyt = cita - 0.5*pi;
	pt2[0] = x + LLd * cos(yyt);
	pt2[1] = y + LLd * sin(yyt);
	pt2[2] = 0.0;

	if (ptriDTM.DTMHasRead)
		CrsDmxHead = ptriDTM.FindInterPt(pt1, pt2, LPnum);
	else
		LPnum = 0;

	if (LPnum > 0)//左侧地面线有点
	{
		k = 0;
		while (CrsDmxHead)
		{
			xl[k] = CrsDmxHead->pt[0];
			yl[k] = CrsDmxHead->pt[1];
			zl[k] = CrsDmxHead->pt[2];

			Tmp = CrsDmxHead;
			CrsDmxHead = CrsDmxHead->next;
			free(Tmp);
			k++;
		}

		if (k > 0)
		{
			Yd = zl[0];
			if (Yd < 0.1&&k>1)
			{
				Yd = zl[1];
			}
		}

		for (k = 1; k < LPnum; k++)
		{
			xl[k] = sqrt((xl[k] - xl[0])*(xl[k] - xl[0]) + (yl[k] - yl[0])*(yl[k] - yl[0]));

			if (zl[k] < -100.0)//没数模 按中桩
				zl[k] = Yd;
			yl[k] = zl[k] - Yd;

		}
		xl[0] = 0.0;
		yl[0] = 0.0;
	}//至少有一个点
	else//一个点也没有
	{
		LPnum = 2;
		Yd = 0.0;
		xl[0] = 0.0;
		yl[0] = 0.0;

		xl[1] = LLd;
		yl[1] = 0.0;
	}

	yyt = cita + 0.5*pi;
	pt2[0] = x + RRd * cos(yyt);
	pt2[1] = y + RRd * sin(yyt);
	pt2[2] = 0.0;
	CrsDmxHead = ptriDTM.FindInterPt(pt1, pt2, RPnum);

	//计算横断面左侧地面点坐标
	if (RPnum > 0)
	{
		k = 0;
		while (CrsDmxHead)
		{
			xr[k] = CrsDmxHead->pt[0];
			yr[k] = CrsDmxHead->pt[1];
			zr[k] = CrsDmxHead->pt[2];
			Tmp = CrsDmxHead;
			CrsDmxHead = CrsDmxHead->next;
			free(Tmp);
			k++;
		}
		for (k = 1; k < RPnum; k++)
		{
			xr[k] = sqrt((xr[k] - xr[0])*(xr[k] - xr[0]) + (yr[k] - yr[0])*(yr[k] - yr[0]));

			if (zr[k] < -100.0)//没数模 按中桩
				zr[k] = Yd;
			yr[k] = zr[k] - Yd;
		}
		xr[0] = 0.0;
		yr[0] = 0.0;
	}
	else
	{
		RPnum = 2;
		Yd = 0.0;
		xr[0] = 0.0;
		yr[0] = 0.0;

		xr[1] = RRd;
		yr[1] = 0.0;
	}

	//地面线付值
	Point pt;
	ZDroad.hdmdmx[iCross].EarH = Yd;
	ZDroad.hdmdmx[iCross].ZEarPtNum = LPnum;
	ZDroad.hdmdmx[iCross].ZEarPtAry.RemoveAll();
	for (k = 0; k < LPnum; k++)
	{
		pt.x = xl[k], pt.y = yl[k], pt.z = 0.0;
		ZDroad.hdmdmx[iCross].ZEarPtAry.Add(pt);
	}
	ZDroad.hdmdmx[iCross].YEarPtNum = RPnum;
	ZDroad.hdmdmx[iCross].YEarPtAry.RemoveAll();
	for (k = 0; k < RPnum; k++)
	{
		pt.x = xr[k], pt.y = yr[k], pt.z = 0.0;
		ZDroad.hdmdmx[iCross].YEarPtAry.Add(pt);
	}
	;
	if (ptriDTM.DTMHasRead)
		ptriDTM.ReleaseDtm();


	return IsDtmExisting;
}

void HdmDes::XJGDes(int& DesPtSum, double DesPtList[], double GK, double GS, double GP1, double GP2, double GDR, double& GouH, double& GouX, int& XJGPtSum, double XJGPtArray[])
{

	XJGPtSum = 6;
	XJGPtArray[0 * 2] = DesPtList[(DesPtSum - 1) * 2];
	XJGPtArray[0 * 2 + 1] = DesPtList[(DesPtSum - 1) * 2 + 1];
	XJGPtArray[1 * 2] = XJGPtArray[0 * 2];
	XJGPtArray[1 * 2 + 1] = XJGPtArray[0 * 2 + 1];
	XJGPtArray[2 * 2] = XJGPtArray[1 * 2] + GS * GP1;
	XJGPtArray[2 * 2 + 1] = XJGPtArray[1 * 2 + 1] - GS;
	XJGPtArray[3 * 2] = XJGPtArray[2 * 2] + GK;
	XJGPtArray[3 * 2 + 1] = XJGPtArray[2 * 2 + 1];
	XJGPtArray[4 * 2] = XJGPtArray[3 * 2] + GS * GP2;
	XJGPtArray[4 * 2 + 1] = XJGPtArray[3 * 2 + 1] + GS;
	XJGPtArray[5 * 2] = XJGPtArray[4 * 2];
	XJGPtArray[5 * 2 + 1] = XJGPtArray[4 * 2 + 1];
	GouX = 0.5 * (XJGPtArray[2 * 2] + XJGPtArray[3 * 2]);
	GouH = 0.5 * (XJGPtArray[2 * 2 + 1] + XJGPtArray[3 * 2 + 1]);


	if (GDR > 0.001)//如采用蝶形沟，修正设计点数组
	{
		double spt[2], ept[2], pt[20];
		int StartIndex;
		StartIndex = 2;

		spt[0] = XJGPtArray[StartIndex * 2], spt[1] = XJGPtArray[StartIndex * 2 + 1];
		ept[0] = XJGPtArray[(StartIndex + 1) * 2], ept[1] = XJGPtArray[(StartIndex + 1) * 2 + 1];
		GetArcPt(spt, ept, GDR, 10, pt);
		//2修正设计点
		int npt, i;
		double despt[200];
		npt = 0;
		for (i = 0; i <= StartIndex; i++)
		{
			despt[npt * 2] = XJGPtArray[i * 2];
			despt[npt * 2 + 1] = XJGPtArray[i * 2 + 1];
			npt++;
		}
		for (i = 0; i < 10; i++)
		{
			despt[npt * 2] = pt[i * 2];
			despt[npt * 2 + 1] = pt[i * 2 + 1];

			npt++;
		}
		for (i = StartIndex + 1; i < XJGPtSum; i++)
		{
			despt[npt * 2] = XJGPtArray[i * 2];
			despt[npt * 2 + 1] = XJGPtArray[i * 2 + 1];
			npt++;
		}

		XJGPtSum = npt;
		for (i = 0; i < XJGPtSum; i++)
		{
			XJGPtArray[i * 2] = despt[i * 2];
			XJGPtArray[i * 2 + 1] = despt[i * 2 + 1];
		}
	}

	return;
}


//////////////////////////////////////////////////////////////////////////
//给定线路中心与路基中心的偏移量计算路面点
//////////////////////////////////////////////////////////////////////////
double HdmDes::CalDesHOnFGDBY(double cml, double DesHOnXLZX, int cgNm, CgSZ cg[],
	int jkNm, CgSZ jk[], int NLMK, LMKdata *LMK, int ZorY,
	int BxNum, BXLMKD *pBXArr, JD_CENTER *pm)
{
	double RHF[10];
	double LMHP, YLJHP;
	double half_fgdk, lydk, cxdk, yljk, tljk, tljhp;
	int bkmode, sjbgmode;
	double fgdhp, fgdk;
	double DesHOnFGDBY = DesHOnXLZX;

	double OffsetByXLZX = 0.0;
	CalOffsetByXLZX(cml, NLMK, LMK, OffsetByXLZX);
	OffsetByXLZX = fabs(OffsetByXLZX);
	if (OffsetByXLZX < 0.001)
		return DesHOnXLZX;

	//计算路面横坡
	if (NLMK < 1)
	{
		ads_alert(L"请先输入路面宽数据!");
		return DesHOnFGDBY;
	}
	if (cgNm < 1)
	{
		ads_alert(L"请先计算超高分段数据!");
		return DesHOnFGDBY;
	}


	CalLMHP(cml, cgNm, cg, LMHP, YLJHP);
	CalFgdHp(cml, NLMK, LMK, fgdhp, fgdk);
	CalYljHp(cml, NLMK, LMK, LMHP, YLJHP);
	//计算路面宽(考虑加宽)
	CalLMK_JK(cml, NLMK, LMK, cgNm, cg, jkNm, jk, half_fgdk, lydk, cxdk, yljk, tljk, tljhp, bkmode, sjbgmode);
	CalLMKbyFile(cml, ZorY, pm, pBXArr, BxNum, half_fgdk, lydk, cxdk, yljk, tljk);

	//依据路面横坡调整土路肩横坡
	//	ads_printf(L"cml=%lf zory=%d lmhp=%lf tljhp=%lf\n",cml,ZorY,LMHP,tljhp);
	if (LMHP < -1.0*tljhp)
		tljhp = -1.0*LMHP;

	if (fgdhp > 90)//99为与车行道同坡
		fgdhp = LMHP;
	if (tljhp > 90)//99为与车行道同坡
		tljhp = LMHP;

	RHF[0] = 0.0;
	RHF[1] = 0.0;
	RHF[2] = half_fgdk;
	RHF[3] = RHF[1] + half_fgdk * fgdhp * 0.01;
	RHF[4] = RHF[2] + lydk + cxdk;
	RHF[5] = RHF[3] + (lydk + cxdk) * LMHP * 0.01;
	RHF[6] = RHF[4] + yljk;
	RHF[7] = RHF[5] + yljk * YLJHP * 0.01;
	RHF[8] = RHF[6] + tljk;
	RHF[9] = RHF[7] - tljk * tljhp * 0.01;

	int i;
	for (i = 0; i < 4; i++)
	{
		if (OffsetByXLZX > RHF[2 * i] - 0.001 && OffsetByXLZX < RHF[2 * i + 2] + 0.001)
			break;
	}
	if (i == 4)
	{
		ads_printf(L"\n连续里程%lf路面宽数据中路基中线与线路中线偏移量超过路面宽！", cml);
		return DesHOnXLZX;
	}
	else
	{
		double dh = 0.0;
		dh = DesHOnXLZX - (OffsetByXLZX - RHF[2 * i]) * (RHF[2 * i + 3] - RHF[2 * i + 1]) / (RHF[2 * i + 2] - RHF[2 * i]) - RHF[2 * i + 1];
		DesHOnFGDBY = dh;
		return DesHOnFGDBY;
	}
}


void HdmDes::CalFGDBYDesH(double cml, int iRoad, double& DesH, int LOrR)
{
	double half_fgdk, lydk, cxdk, yljk, tljk, lmhp, yljhp, tljhp, OffsetByXLZX;
	int bkmode, sjbgmode;
	double DesHOnFGDBY;
	double RHF[10];
	OffsetByXLZX = 0.0;

	if (LOrR < 0)
	{
		DesH = CalDesH(cml, road[iRoad].ZZM, road[iRoad].AllZM);//线路中线处的高程
		CalOffsetByXLZX(cml, road[iRoad].NZLMK, road[iRoad].ZLMK, OffsetByXLZX);//计算路基中线相对于线路中线的偏移量
	}
	else
	{
		DesH = CalDesH(cml, road[iRoad].YZM, road[iRoad].AllZM);//线路中线处的高程
		CalOffsetByXLZX(cml, road[iRoad].NYLMK, road[iRoad].YLMK, OffsetByXLZX);//计算路基中线相对于线路中线的偏移量
	}

	if (OffsetByXLZX > 0.001)//线路中线在路基中线的左边，利用左侧的路面宽数据和线路中线标高计算分隔带边缘的标高，修正Zdesh，Ydesh
	{
		DesHOnFGDBY = CalDesHOnFGDBY(cml, DesH, road[iRoad].ZcgNm, road[iRoad].Zcg, road[iRoad].ZjkNm,
			road[iRoad].Zjk, road[iRoad].NZLMK, road[iRoad].ZLMK,
			-1, road[iRoad].BxNum, road[iRoad].pBXArr, road[iRoad].pm);
		DesH = DesHOnFGDBY;
	}

	if (OffsetByXLZX < -0.001)
	{
		DesHOnFGDBY = CalDesHOnFGDBY(cml, DesH, road[iRoad].YcgNm, road[iRoad].Ycg, road[iRoad].YjkNm,
			road[iRoad].Yjk, road[iRoad].NYLMK, road[iRoad].YLMK,
			1, road[iRoad].BxNum, road[iRoad].pBXArr, road[iRoad].pm);
		DesH = DesHOnFGDBY;
	}
}

void HdmDes::CalOffsetByXLZX(double cml, int NLMK, LMKdata lmk[], double& OffsetByXLZX)
{
	double k;
	OffsetByXLZX = 0.0;
	if (NLMK < 1)
	{
		return;
	}

	if (NLMK == 1)
	{
		if (cml < lmk[0].cml + 0.1)
			OffsetByXLZX = lmk[0].OffsetByXLZX;
		else
			OffsetByXLZX = 0.0;
		return;
	}
	int i;
	for (i = 0; i < NLMK; i++)
	{
		if (cml < lmk[i].cml + 0.1)
			break;
	}

	if (i > 0 && i<NLMK && fabs(lmk[i].cml - lmk[i - 1].cml)>0.0001)
		k = (cml - lmk[i - 1].cml) / (lmk[i].cml - lmk[i - 1].cml);
	else
		k = 0;

	if (i == 0)
		i = 1;
	else if (i == NLMK)
		i = NLMK - 1;

	OffsetByXLZX = lmk[i - 1].OffsetByXLZX + k * (lmk[i].OffsetByXLZX - lmk[i - 1].OffsetByXLZX);
}


double HdmDes::CalQBTArea(double PJZJ, double hthd, int NearPt, double earpt[])
{
	double QBTarea = 0.0;
	int NewEarthPtNum = 0;
	double *newEarPtList = NULL;
	double wid = fabs(PJZJ);


	newEarPtList = new double[2 * (NearPt + 5)];
	int i = 0;
	while (i < NearPt && fabs(earpt[i * 2]) < wid)
	{
		newEarPtList[i * 2] = earpt[i * 2];

		newEarPtList[i * 2 + 1] = earpt[i * 2 + 1] - hthd;
		i++;
	}
	NewEarthPtNum = i;
	if (i == NearPt) i--;
	if (i > 0 && i < NearPt)
	{
		newEarPtList[i * 2] = wid;
		newEarPtList[i * 2 + 1] = earpt[(i - 1) * 2 + 1] + (wid - earpt[(i - 1) * 2])*(earpt[(i) * 2 + 1] - earpt[(i - 1) * 2 + 1]) / (earpt[(i) * 2] - earpt[(i - 1) * 2]) - hthd;

		i++;
		newEarPtList[i * 2] = wid;
		newEarPtList[i * 2 + 1] = earpt[(i - 1) * 2 + 1] + (wid - earpt[(i - 1) * 2])*(earpt[(i) * 2 + 1] - earpt[(i - 1) * 2 + 1]) / (earpt[(i) * 2] - earpt[(i - 1) * 2]);
		i++;
		NewEarthPtNum = i;
	}

	double fillarea, cutarea;

	cal_polygon_area(NewEarthPtNum, newEarPtList, NearPt, earpt, fillarea, cutarea);

	if (newEarPtList) delete[]newEarPtList;

	return cutarea;

}

void HdmDes::InitHdmBench(HDMDMXdata hdmBench[], int NDMX)
{
	for (int i = 0; i < NDMX; i++)
	{
		hdmBench[i].lc = 0.0;
		hdmBench[i].ZEarPtNum = 0;
		hdmBench[i].YEarPtNum = 0;
		hdmBench[i].ZEarPtAry.RemoveAll();
		hdmBench[i].YEarPtAry.RemoveAll();
	}
}

void HdmDes::CreateBenchPtArray(int DesPtSum, double DesPtList[], int EarthPtSum, double EarthPtList[], CArray<Point, Point>& BenchPtArray, double& CutBenchArea)
{
	BenchPtArray.RemoveAll();
	CutBenchArea = 0.0;
	//搜索设计线与地面线的交点
	double Area = 0.0;
	CArray<double, double> FDPtArray;
	AcGePoint2d TmpPt;

	AcDbPolyline *pPlineDes = new AcDbPolyline;
	for (int iDes = 0; iDes < DesPtSum; iDes++)
	{
		TmpPt.x = DesPtList[iDes * 2];
		TmpPt.y = DesPtList[iDes * 2 + 1];
		pPlineDes->addVertexAt(iDes, TmpPt);
	}

	AcDbPolyline *pPlineDmx = new AcDbPolyline;
	for (int iDmx = 0; iDmx < EarthPtSum; iDmx++)
	{
		TmpPt.x = EarthPtList[iDmx * 2];
		TmpPt.y = EarthPtList[iDmx * 2 + 1];
		pPlineDmx->addVertexAt(iDmx, TmpPt);
	}

	AcGePoint3dArray interPt;
	if (pPlineDmx->intersectWith(pPlineDes, AcDb::kExtendArg, interPt) == Acad::eOk)
	{
		double BenchStartPt[2], BenchPtList[400];
		int BenchPtSum = 0;
		interPt.insertAt(0, AcGePoint3d(0, 0, 0));
		int InterPtSum = interPt.logicalLength();
		//		ads_printf(L"交点个数%d",InterPtSum);
		FDPtArray.SetSize(InterPtSum);

		//搜索在设计线以下的地面线区间
		if (DesPtList[2 * DesPtSum - 1] < 0.0)//坡脚点低于路基中线地面，由坡脚向路基中线挖台阶
		{
			int iFD;
			for (iFD = 0; iFD < InterPtSum; iFD++)
				FDPtArray[iFD] = interPt[InterPtSum - iFD - 1].x;
			for (iFD = 0; iFD < InterPtSum - 1; iFD++)
			{
				double StartX, EndX;
				double Yd1, Yd2;
				int TmpPtIndex;
				StartX = FDPtArray[iFD];
				EndX = FDPtArray[iFD + 1];
				Gety(0.5*(StartX + EndX), EarthPtSum, EarthPtList, Yd1, TmpPtIndex);
				Gety(0.5*(StartX + EndX), DesPtSum, DesPtList, Yd2, TmpPtIndex);
				if (Yd2 - Yd1 > 0.0)
				{
					BenchStartPt[0] = StartX;
					Gety(StartX, EarthPtSum, EarthPtList, BenchStartPt[1], TmpPtIndex);
					if (AutoCutBench(true, BenchStartPt, BenchPtSum, BenchPtList, EarthPtSum, EarthPtList, StartX, EndX, Area))
					{
						Point TmpPt;
						for (int iPt = 0; iPt < BenchPtSum; iPt++)
						{
							TmpPt.x = BenchPtList[2 * iPt];
							TmpPt.y = BenchPtList[2 * iPt + 1];
							TmpPt.z = 0.0;
							BenchPtArray.Add(TmpPt);
						}
						CutBenchArea += Area;
					}
				}
			}
		}
		else//由路基中线向坡脚挖台阶
		{
			int iFD;
			for (iFD = 0; iFD < InterPtSum; iFD++)
			{
				FDPtArray[iFD] = interPt[iFD].x;
			}
			for (iFD = 0; iFD < InterPtSum - 1; iFD++)
			{
				double StartX, EndX;
				double Yd1, Yd2;
				int TmpPtIndex;
				StartX = FDPtArray[iFD];
				EndX = FDPtArray[iFD + 1];
				Gety(0.5*(StartX + EndX), EarthPtSum, EarthPtList, Yd1, TmpPtIndex);
				Gety(0.5*(StartX + EndX), DesPtSum, DesPtList, Yd2, TmpPtIndex);
				if (Yd2 - Yd1 > 0.0)
				{
					BenchStartPt[0] = StartX;
					Gety(StartX, EarthPtSum, EarthPtList, BenchStartPt[1], TmpPtIndex);
					if (AutoCutBench(false, BenchStartPt, BenchPtSum, BenchPtList, EarthPtSum, EarthPtList, StartX, EndX, Area))
					{
						Point TmpPt;
						for (int iPt = 0; iPt < BenchPtSum; iPt++)
						{
							TmpPt.x = BenchPtList[2 * iPt];
							TmpPt.y = BenchPtList[2 * iPt + 1];
							TmpPt.z = 0.0;
							BenchPtArray.Add(TmpPt);
						}
						CutBenchArea += Area;
					}
				}
			}
		}
	}

	delete pPlineDmx;
	delete pPlineDes;
}

/*===================================================================
函数名:DesignHdm_AutoDesign
------------------------------------------------------------
函数功能:自动设计横断面
------------------------------------------------------------
输入:
------------------------------------------------------------
输出:
------------------------------------------------------------
算法描述:
------------------------------------------------------------
编写日期:20190811
------------------------------------------------------------
备注：	去除了画图和导航命令
=====================================================================*/
void HdmDes::DesignHdm_AutoDesign()
{
	//0-一般断面,-1-桥头,-2-隧头
//         1-桥尾  2-隧尾
//         3-桥中
//         4-隧中
	acdbHostApplicationServices()->workingDatabase()->loadLineTypeFile(L"*.*", L"acadiso.lin");
	acdbHostApplicationServices()->workingDatabase()->setLtscale(0.1);
	CreateLayer(L"清表土");
	int i;
	if (!ReadFile(true))//读文件
		return;

	ReadBDFile();


	//从鼻端文件中读取左右关联道路，若道路总数>0按互通处理，否则按分离式处理
	CString xl1;
	xl1.Format(L"%s,%s", road[0].pm->mdbname, road[0].roadname);

	if (!SetHdmLm())
		return;//求路面

	FindAndReadLinkRoad(xl1);

	ads_printf(L"读数据库OK!\n");

	ads_printf(L"计算路面线OK!\n");

	if (ZRoadSum + YRoadSum < 1)//主线无关联道路,只考虑分离式路基设计
	{
		//设计主线横断面
		if (RoadSum > 0)
		{

			//if(!ptriDTM)
			//	ptriDTM = (triDTM_road *)new triDTM_road;

			if (ptriDTM.DTMHasRead == 0)
			{
				ptriDTM.Read_Dtm();

			}

			Cal_FLD_Fendml();
			ads_printf(L"计算分离点OK!\n");

			//往主线中插入分离段起终断面
			for (int i = 1; i < RoadSum; i++)
			{
				InsertFLDStartOrEndHdm(i, -1);
				InsertFLDStartOrEndHdm(i, 1);
			}


			Design_ZX_Hdm();

			Design_FLD_Hdm();

			if (ptriDTM.DTMHasRead == 1)
			{
				ptriDTM.ReleaseDtm();
			}

			WriteFile();

			ads_printf(L"输出成果数据OK!\n");
		}
	}
	else//主线有关联道路,按互通立交路基设计
	{
		//设计主线横断面
		if (RoadSum > 0)
		{
			Design_ZD_Hdm();

			WriteFile();

			ads_printf(L"输出成果数据OK!\n");
		}
	}
}
void HdmDes::DrawHDMwgx(double EarH, double DesH, double Ymin, double Ymax, AcGePoint3d *m_DesignPoints)
{
	//绘制横断面网格线
	int Lnum, Hnum;
	Lnum = 10;//行数
	double lenth = 2 * Sfactor;//间距-暂定
	//Ymax += lenth; Ymin -= lenth;
	double Heigth = fabs(Ymax - Ymin) * Sfactor;
	double Length = Lnum * lenth;
	Hnum = (int)Heigth / lenth + 1;//列数
	if (DesH > EarH)//填方
		Hnum++;
	if (Hnum <= 2)
	{
		Hnum = 3;
	}
	AcGePoint3d ptOr(m_DesignPoints[0].x, m_DesignPoints[0].y, 0);
	AcGeVector3d vec1, vec2;
	vec1.set(1, 0, 0);
	vec2.set(0, 1, 0);
	AcGePoint3d spt, ept;
	//标注文字
	double texth = lenth / 4;
	ACHAR ptx[16];
	CString str;
	double ang = 0;
	AcGePoint3d zpt;
	double YoH = floor(DesH);//中桩设计点
	//找到ptOr点y坐标取整后的坐标
	double delty = fabs(DesH - floor(DesH)) * Sfactor;
	AcGePoint3d Y1 = m_DesignPoints[0] - delty * vec2;
	AcGePoint3d ptIntY(m_DesignPoints[0].x, Y1.y, 0);//取整后
	if (Hnum % 2 == 1)//奇数
	{
		double halfHnum = 0.0;
		halfHnum = Hnum / 2;
		spt = ptIntY - Lnum / 2 * lenth*vec1;
		spt = spt - (floor(halfHnum)) * lenth*vec2;
		ept = ptIntY + Lnum / 2 * lenth*vec1;
		ept = ept - (floor(halfHnum)) * lenth*vec2;
	}
	else
	{
		spt = ptIntY - Lnum / 2 * lenth*vec1;
		spt = spt - Hnum / 2 * lenth*vec2;
		ept = ptIntY + Lnum / 2 * lenth*vec1;
		ept = ept - Hnum / 2 * lenth*vec2;
	}
	double deltH = fabs(spt.y - ptIntY.y) / Sfactor;
	int Orh = floor(YoH - deltH);
	str.Format(L"%d", Orh);
	_tcscpy(ptx, str);
	makeline(spt, ept, 8, 0, L"网格线", L"DOT3");
	maketext(spt, ptx, ang, texth, 8, 4);
	//绘制横线
	for (int i = 0; i < Hnum; i++)
	{
		spt = spt + lenth * vec2;
		ept = ept + lenth * vec2;
		makeline(spt, ept, 8, 0, L"网格线", L"DOT3");
		Orh = Orh + lenth / Sfactor;
		str.Format(L"%d", Orh);
		_tcscpy(ptx, str);
		maketext(spt, ptx, ang, texth, 8, 4);
	}
	//绘制竖线
	if (Hnum % 2 == 1)//奇数
	{
		double halfHnum = 0.0;
		halfHnum = Hnum / 2;
		spt = ptIntY - Lnum / 2 * lenth*vec1;
		spt = spt + (floor(halfHnum) + 1) * lenth*vec2;
		ept = ptIntY - Lnum / 2 * lenth*vec1;
		ept = ept - (floor(halfHnum)) * lenth*vec2;
	}
	else
	{
		spt = ptIntY - Lnum / 2 * lenth*vec1;
		spt = spt + Hnum / 2 * lenth*vec2;
		ept = ptIntY - Lnum / 2 * lenth*vec1;
		ept = ept - Hnum / 2 * lenth*vec2;
	}
	makeline(spt, ept, 8, 0, L"网格线", L"DOT3");

	_tcscpy(ptx, L"-10");
	zpt = ept - texth / 2 * vec2;
	maketext(zpt, ptx, ang, texth, 8, 3);
	for (int i = 0; i < Lnum; i++)
	{
		spt = spt + lenth * vec1;
		ept = ept + lenth * vec1;
		makeline(spt, ept, 8, 0, L"网格线", L"DOT3");
		str.Format(L"%d", 2 * i - 8);
		_tcscpy(ptx, str);
		zpt = ept - texth / 2 * vec2;
		maketext(zpt, ptx, ang, texth, 8, 3);
	}
}

void HdmDes::DrawHdmMap_Gutter(int iroad, double sml, double eml, double zk, double yk, CString TKname, int lnum)
{
	MAP = new HdmDes::Maplist[road[iroad].NCRS];

	//CreateMapList(iroad, sml, eml, zk, yk, lnum);
	CalMapList(iroad, sml, eml, zk, yk, lnum);

	ads_point INSPT;
	for (int i = 0; i < MAPSUM; i++)
	{

		if (MAP[i].ncrs > 0)
			ads_printf(L"\n共%d幅图, 正在输出第%d幅图(%s - %s)......",
				MAPSUM, i, road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml,
				road[iroad].hdmdes[MAP[i].HDMNO[MAP[i].ncrs - 1]].ckml);
		else
			ads_printf(L"共%d幅图, 正在输出第%d幅图(%s - %s)......",
				MAPSUM, i, road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml,
				road[iroad].hdmdes[MAP[i].HDMNO[0]].ckml);

		DrawAHdmMap_Gutter(iroad, i, MAP, zk, yk);//绘横断面图

		CFileFind fd;
		if (fd.FindFile(TKname))
		{
			INSPT[X] = MAP[i].SX + 390, INSPT[Y] = MAP[i].SY + 554.0 / 2.0 - 100 / 2.0;		//20190821	修改横断面绘图位置，如需修改需要和CreateMapList计算绘图原点处联合修改

			ACHAR str[256];
			_stprintf(str, L"%s", TKname);
			AcDbVoidPtrArray entitySet;
			AcDbObjectId pBlockId = BAS_DRAW_FUN::CreateBlockFromDwgFile(str, m_FrameBlockName);
			if (pBlockId > 0)
			{
				AcGePoint3d InsertPt(INSPT[X], INSPT[Y], 0.0);
				AcDbBlockReference* pBkRr = new AcDbBlockReference(InsertPt, pBlockId);
				pBkRr->setScaleFactors(AcGeScale3d(1, 1, 1));
				pBkRr->setLayer(L"图框");
				pBkRr->setColorIndex(0);
				BAS_DRAW_FUN::AddEntityToDbs(pBkRr);
			}
		}
		ads_printf(L"OK!");
	}

}

void HdmDes::DrawAHdmMap_Gutter(int iroad, int ipage, Maplist MAP[], double zk, double yk)
{
	int j;
	double Learpt[400], Rearpt[400];
	double LBenchPt[400], RBenchPt[400];
	double ZX_LearptOnLJZX[400], ZX_RearptOnLJZX[400];
	double FLX_LearptOnLJZX[400], FLX_RearptOnLJZX[400];
	double ZX_LBenchPtOnLJZX[400], ZX_RBenchPtOnLJZX[400];
	double ZX_EarHOnLJZX, FLX_EarHOnLJZX;
	double ZX_EarHOnXLZX, FLX_EarHOnXLZX;

	int NumLearpt, NumRearpt;
	int OffsetNumLearpt, OffsetNumRearpt;
	int Y_NewNumL;
	//int  DorS;
	AcGePoint3d pt;
	CROSS pCross;
	CROSS GLCross;


	for (int i = 0; i < MAP[ipage].ncrs; i++)//一线
	{

		j = MAP[ipage].HDMNO[i];

		if (road[iroad].hdmdes[j].DorS == 1)//单路面
		{

			int k;
			for (k = 0; k < road[iroad].hdmdmx[j].ZEarPtNum; k++)
			{
				Learpt[k * 2] = road[iroad].hdmdmx[j].ZEarPtAry[k].x;
				Learpt[k * 2 + 1] = road[iroad].hdmdmx[j].ZEarPtAry[k].y;
			}

			for (k = 0; k < road[iroad].hdmdmx[j].YEarPtNum; k++)
			{
				Rearpt[k * 2] = road[iroad].hdmdmx[j].YEarPtAry[k].x;
				Rearpt[k * 2 + 1] = road[iroad].hdmdmx[j].YEarPtAry[k].y;
			}

			//////////////////////////////////////////////////////////////////////////
			double LimitZ, LimitR;
			int iLim = 0;
			LimitZ = fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x) + zk;
			LimitR = fabs(road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x) + yk;
			for (k = 0; k < road[iroad].hdmBench[j].ZEarPtNum; k++)
			{
				if (road[iroad].hdmBench[j].ZEarPtAry[k].x < LimitZ)
				{
					LBenchPt[k * 2] = road[iroad].hdmBench[j].ZEarPtAry[k].x;
					LBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].ZEarPtAry[k].y;
					iLim++;
				}
				else
				{
					LBenchPt[k * 2] = road[iroad].hdmBench[j].ZEarPtAry[iLim].x;
					LBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].ZEarPtAry[iLim].y;
				}
			}

			for (k = 0; k < road[iroad].hdmBench[j].YEarPtNum; k++)
			{
				if (road[iroad].hdmBench[j].YEarPtAry[k].x < LimitR)
				{
					RBenchPt[k * 2] = road[iroad].hdmBench[j].YEarPtAry[k].x;
					RBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].YEarPtAry[k].y;
					iLim++;
				}
				else
				{
					RBenchPt[k * 2] = road[iroad].hdmBench[j].YEarPtAry[iLim].x;
					RBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].YEarPtAry[iLim].y;
				}
			}
			//////////////////////////////////////////////////////////////////////////
			//考虑路基中线与线路中线不重合，将相对于线路中线的地面点数据平移到路基中线（修改）
			ZX_EarHOnXLZX = road[iroad].hdmdmx[j].EarH;//线路中线处的地面标高
			NumLearpt = road[iroad].hdmdmx[j].ZEarPtNum;
			NumRearpt = road[iroad].hdmdmx[j].YEarPtNum;
			CalNewZB(road[iroad].hdmdes[j].OffsetByXLZX, ZX_EarHOnXLZX, Learpt, NumLearpt, Rearpt, NumRearpt,
				ZX_EarHOnLJZX, ZX_LearptOnLJZX, OffsetNumLearpt, ZX_RearptOnLJZX, OffsetNumRearpt);
			//////////////////////////////////////////////////////////////////////////
			road[iroad].hdmdes[j].newLYd = road[iroad].hdmdes[j].newRYd = road[iroad].hdmdmx[j].EarH;
			//左右都是桥
			if (road[iroad].hdmdes[j].ZDMXZ == 3 && road[iroad].hdmdes[j].YDMXZ == 3)
				continue;
			//左右都是隧
			if (road[iroad].hdmdes[j].ZDMXZ == 4 && road[iroad].hdmdes[j].YDMXZ == 4)
				continue;

			//				if(road[0].hdmdes[j].ZDMXZ==-1 || road[0].hdmdes[j].ZDMXZ==-2
			//				   ||road[0].hdmdes[j].YDMXZ==-1 || road[0].hdmdes[j].YDMXZ==-2)
			//				{
			//						pt.x=road[0].hdmdes[i].tX0;//桥隧处标注点
			//						pt.y=road[0].hdmdes[i].tY0;
			//						BiaoZhuQS(0,road[0].hdmdes[i].cml,pt); //标注桥隧位置
			//				}

			pCross.m_OriPoint.x = road[iroad].hdmdes[j].Xo;
			pCross.m_OriPoint.y = road[iroad].hdmdes[j].Yo;	//每个断面的绘图原点
			pCross.m_BTinf = road[iroad].hdmdes[j].ZDMXZ;
			//	road[0].hdmdes[i].xlxz=0;road[0].hdmdes[i].r_bh=-1;//一线，用于交互设计

			setCROSSAutoDesignData(pCross, iroad, j, ZX_EarHOnLJZX, ZX_LearptOnLJZX, OffsetNumLearpt, ZX_RearptOnLJZX, OffsetNumRearpt,
				LBenchPt, road[iroad].hdmBench[j].ZEarPtNum, RBenchPt, road[iroad].hdmBench[j].YEarPtNum);
			pCross.DorS = road[iroad].hdmdes[j].DorS;
			pCross.offset = road[iroad].hdmdes[j].offsetX;//一线中心线相对与新的地面线的移动量

		}
		if (road[iroad].hdmdes[j].DorS == 2)//双路面
		{
			//ads_printf(L"cmlzx=%lf %lf xjj=%lf\n",road[0].hdmdes[i].cml,road[0].hdmdes[i].FLDcml,road[0].hdmdes[i].xjj);				
			double ZX_Yd, ZX_Learpt[400], ZX_Rearpt[400];
			int ZX_NumL, ZX_NumR;
			double YX_Yd, YX_Learpt[400], YX_Rearpt[400];
			int YX_NumL, YX_NumR;

			double ZX_LBenchPt[400], ZX_RBenchPt[400];
			int ZX_BenchNumL, ZX_BenchNumR;
			double YX_LBenchPt[400], YX_RBenchPt[400];
			int YX_BenchNumL, YX_BenchNumR;

			if (road[iroad].hdmdes[j].xjj < -0.00001)//左线分离
			{
				YX_Yd = road[iroad].hdmdmx[j].EarH;
				YX_NumL = road[iroad].hdmdmx[j].ZEarPtNum;
				int k;
				for (k = 0; k < YX_NumL; k++)
				{
					YX_Learpt[k * 2] = road[iroad].hdmdmx[j].ZEarPtAry[k].x;
					YX_Learpt[k * 2 + 1] = road[iroad].hdmdmx[j].ZEarPtAry[k].y;
				}
				YX_NumR = road[iroad].hdmdmx[j].YEarPtNum;
				for (k = 0; k < YX_NumR; k++)
				{
					YX_Rearpt[k * 2] = road[iroad].hdmdmx[j].YEarPtAry[k].x;
					YX_Rearpt[k * 2 + 1] = road[iroad].hdmdmx[j].YEarPtAry[k].y;
				}
				//移轴
				CalNewZB(road[iroad].hdmdes[j].xjj, YX_Yd, YX_Learpt, YX_NumL, YX_Rearpt, YX_NumR,
					ZX_Yd, ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR);

				//////////////////////////////////////////////////////////////////////////
				YX_BenchNumL = road[iroad].hdmBench[j].ZEarPtNum;
				for (k = 0; k < YX_BenchNumL; k++)
				{
					YX_LBenchPt[k * 2] = road[iroad].hdmBench[j].ZEarPtAry[k].x;
					YX_LBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].ZEarPtAry[k].y;
				}
				YX_BenchNumR = road[iroad].hdmBench[j].YEarPtNum;
				for (k = 0; k < YX_BenchNumR; k++)
				{
					YX_RBenchPt[k * 2] = road[iroad].hdmBench[j].YEarPtAry[k].x;
					YX_RBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].YEarPtAry[k].y;
				}
				//移轴
				CalNewZB(road[iroad].hdmdes[j].xjj, YX_Yd, YX_LBenchPt, YX_BenchNumL, YX_RBenchPt, YX_BenchNumR,
					ZX_Yd, ZX_LBenchPt, ZX_BenchNumL, ZX_RBenchPt, ZX_BenchNumR);
				//////////////////////////////////////////////////////////////////////////
			}
			else
			{
				ZX_Yd = road[iroad].hdmdmx[j].EarH;
				ZX_NumL = road[iroad].hdmdmx[j].ZEarPtNum;
				int k;
				for (k = 0; k < ZX_NumL; k++)
				{
					ZX_Learpt[k * 2] = road[iroad].hdmdmx[j].ZEarPtAry[k].x;
					ZX_Learpt[k * 2 + 1] = road[iroad].hdmdmx[j].ZEarPtAry[k].y;
				}
				ZX_NumR = road[iroad].hdmdmx[j].YEarPtNum;
				for (k = 0; k < ZX_NumR; k++)
				{
					ZX_Rearpt[k * 2] = road[iroad].hdmdmx[j].YEarPtAry[k].x;
					ZX_Rearpt[k * 2 + 1] = road[iroad].hdmdmx[j].YEarPtAry[k].y;
				}
				//移轴
				CalNewZB(road[iroad].hdmdes[j].xjj, ZX_Yd, ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR,
					YX_Yd, YX_Learpt, YX_NumL, YX_Rearpt, YX_NumR);

				//////////////////////////////////////////////////////////////////////////
				ZX_BenchNumL = road[iroad].hdmBench[j].ZEarPtNum;
				for (k = 0; k < ZX_BenchNumL; k++)
				{
					ZX_LBenchPt[k * 2] = road[iroad].hdmBench[j].ZEarPtAry[k].x;
					ZX_LBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].ZEarPtAry[k].y;
				}
				ZX_BenchNumR = road[iroad].hdmBench[j].YEarPtNum;
				for (k = 0; k < ZX_BenchNumR; k++)
				{
					ZX_RBenchPt[k * 2] = road[iroad].hdmBench[j].YEarPtAry[k].x;
					ZX_RBenchPt[k * 2 + 1] = road[iroad].hdmBench[j].YEarPtAry[k].y;
				}
				//移轴
				CalNewZB(road[iroad].hdmdes[j].xjj, ZX_Yd, ZX_LBenchPt, ZX_BenchNumL, ZX_RBenchPt, ZX_BenchNumR,
					YX_Yd, YX_LBenchPt, YX_BenchNumL, YX_RBenchPt, YX_BenchNumR);
				//////////////////////////////////////////////////////////////////////////
			}

			if (road[iroad].hdmdes[j].ZDMXZ == 3 && road[iroad].hdmdes[j].YDMXZ == 3
				&&
				road[iroad].hdmdes[j].Y_ZDMXZ == 3 && road[iroad].hdmdes[j].Y_YDMXZ == 3)
				continue;
			//左右都是隧
			if (road[iroad].hdmdes[j].ZDMXZ == 4 && road[iroad].hdmdes[j].YDMXZ == 4
				&&
				road[iroad].hdmdes[j].Y_ZDMXZ == 4 && road[iroad].hdmdes[j].Y_YDMXZ == 4)
				continue;

			pCross.m_OriPoint.x = road[iroad].hdmdes[j].Xo;	//每个断面的绘图原点
			pCross.m_OriPoint.y = road[iroad].hdmdes[j].Yo;
			pCross.m_BTinf = road[iroad].hdmdes[j].ZDMXZ;

			setCROSSAutoDesignData(pCross, iroad, j, ZX_Yd,
				ZX_Learpt, ZX_NumL, ZX_Rearpt, ZX_NumR,
				ZX_LBenchPt, ZX_BenchNumL, ZX_RBenchPt, ZX_BenchNumR);//左线


			pCross.m_YBTinf = road[iroad].hdmdes[j].Y_YDMXZ;

			if (!((road[iroad].hdmdes[j].Y_ZDMXZ == 3 && road[iroad].hdmdes[j].Y_YDMXZ == 3)
				||
				(road[iroad].hdmdes[j].Y_ZDMXZ == 4 && road[iroad].hdmdes[j].Y_YDMXZ == 4)
				)
				)
			{
				Y_setCROSSAutoDesignData(pCross, j, YX_Yd);

			}

			pCross.DorS = road[iroad].hdmdes[j].DorS;
		}

		//20190815新增计算超高坡度
		double tempSlopePara = 0.0;
		CalLMHP(road[iroad].hdmdes[j].cml, road[iroad].ZcgNm, road[iroad].Zcg, pCross.m_SuphRate_L, tempSlopePara);
		CalLMHP(road[iroad].hdmdes[j].cml, road[iroad].YcgNm, road[iroad].Ycg, pCross.m_SuphRate_R, tempSlopePara);

		pCross.IsLinkHdm = false;
		pCross.m_IsModifyGutter = m_IsModifyGutter;
		pCross.m_GutterPath = m_GutterPath;
		pCross.m_GutterThick = m_GutterThick;
		pCross.m_Scale = Sfactor;
		pCross.m_LeftZdk = road[iroad].hdmdes[j].LZDK;
		pCross.m_RightZdk = road[iroad].hdmdes[j].RZDK;
		_tcscpy(pCross.m_GutterBlockName, m_GutterBlockName);

		//绘制网格
		DrawCrossNet(road[iroad].hdmdes[j].RHFL[1], road[iroad].hdmdes[j].Xmin, road[iroad].hdmdes[j].Xmax,
			road[iroad].hdmdes[j].Ymin, road[iroad].hdmdes[j].Ymax, pCross.LeftDesignLinePart->m_DesignPoints, pCross.m_NetCenterY);
		pCross.m_IsDrawCrossEarthPile = m_IsDrawCrossEarthPile;

		pCross.OutDraw();

		if (road[iroad].hdmdes[j].glcml > -0.0001)//有关联断面,绘关联
		{
			int glroad = GetIRoadByName(road[iroad].hdmdes[j].glRoadName);
			int jcross = FindIDM(glroad, road[iroad].hdmdes[j].glcml);
			TrimEarthLine(glroad, jcross, 3.0, 3.0);

			int k;
			for (k = 0; k < road[glroad].hdmdmx[jcross].ZEarPtNum; k++)
			{
				Learpt[k * 2] = road[glroad].hdmdmx[jcross].ZEarPtAry[k].x;
				Learpt[k * 2 + 1] = road[glroad].hdmdmx[jcross].ZEarPtAry[k].y;
			}
			for (k = 0; k < road[glroad].hdmdmx[jcross].YEarPtNum; k++)
			{
				Rearpt[k * 2] = road[glroad].hdmdmx[jcross].YEarPtAry[k].x;
				Rearpt[k * 2 + 1] = road[glroad].hdmdmx[jcross].YEarPtAry[k].y;
			}

			//////////////////////////////////////////////////////////////////////////
			for (k = 0; k < road[glroad].hdmBench[jcross].ZEarPtNum; k++)
			{
				LBenchPt[k * 2] = road[glroad].hdmBench[jcross].ZEarPtAry[k].x;
				LBenchPt[k * 2 + 1] = road[glroad].hdmBench[jcross].ZEarPtAry[k].y;
			}
			for (k = 0; k < road[glroad].hdmBench[jcross].YEarPtNum; k++)
			{
				RBenchPt[k * 2] = road[glroad].hdmBench[jcross].YEarPtAry[k].x;
				RBenchPt[k * 2 + 1] = road[glroad].hdmBench[jcross].YEarPtAry[k].y;
			}

			//////////////////////////////////////////////////////////////////////////
			FLX_EarHOnXLZX = road[glroad].hdmdmx[jcross].EarH;//线路中线处的地面标高
			NumLearpt = road[glroad].hdmdmx[jcross].ZEarPtNum;
			NumRearpt = road[glroad].hdmdmx[jcross].YEarPtNum;
			CalNewZB(road[glroad].hdmdes[jcross].OffsetByXLZX, FLX_EarHOnXLZX, Learpt, NumLearpt, Rearpt, NumRearpt,
				FLX_EarHOnLJZX, FLX_LearptOnLJZX, OffsetNumLearpt, FLX_RearptOnLJZX, OffsetNumRearpt);
			//					road[glroad].hdmdes[jcross].newLYd = road[glroad].hdmdes[jcross].newRYd = road[glroad].hdmdmx[jcross].EarH;

			if (iroad == 0 && road[glroad].ZxOrYx > -0.001 || iroad > 0 && road[iroad].ZxOrYx < 0)//右线分离
			{
				if (road[glroad].hdmdes[jcross].Lnpt > 0)
				{
					if (iroad == 0 && (road[glroad].hdmdes[jcross].LGouPtNum == 6 || road[glroad].hdmdes[jcross].LGouPtNum == 16))//有线间沟
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x - road[glroad].hdmdes[jcross].Lgou[2 * (road[glroad].hdmdes[jcross].LGouPtNum - 1)]) * Sfactor;
						road[glroad].hdmdes[jcross].Lgou[2 * (road[glroad].hdmdes[jcross].LGouPtNum - 1) + 1] = road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}
					else if (iroad > 0 && (road[iroad].hdmdes[j].RGouPtNum == 6 || road[iroad].hdmdes[j].RGouPtNum == 16))
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[iroad].hdmdes[j].Rgou[2 * (road[iroad].hdmdes[j].RGouPtNum - 1)] - road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].x) * Sfactor;
						road[iroad].hdmdes[j].Rgou[2 * (road[iroad].hdmdes[j].RGouPtNum - 1) + 1] = -road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}
					else
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x + (road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x - road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].x) * Sfactor;
						road[glroad].hdmdes[jcross].RPTL[road[glroad].hdmdes[jcross].Lnpt - 1].y = road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}

					GLCross.DX = GLCross.m_OriPoint.x + 20 * Sfactor;
					road[glroad].hdmdes[jcross].DX = GLCross.m_OriPoint.x + 30 * Sfactor;
					//		ads_printf(L"DX1=%lf\n",GLCross.DX);
				}
				//	dy1 = road[iroad].hdmdes[i].RPTR[road[iroad].hdmdes[i].Rnpt-1].y+road[iroad].hdmdmx[i].EarH-road[iroad].hdmdes[i].RHFR[1];
				//	dy2 = road[iroad].hdmdes[jcross].RHFL[1] - (road[iroad].hdmdes[jcross].RPTL[road[iroad].hdmdes[jcross].Lnpt-1].y+road[iroad].hdmdmx[jcross].EarH);
				GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[iroad].hdmdes[jcross].RHFL[1]-road[iroad].hdmdes[i].RHFR[1])*Sfactor;	//每个断面的绘图原点

			}
			else
			{
				if (road[glroad].hdmdes[jcross].Rnpt > 0)
				{
					if (iroad == 0 && (road[glroad].hdmdes[jcross].RGouPtNum == 6 || road[glroad].hdmdes[jcross].RGouPtNum == 16))
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x - road[glroad].hdmdes[jcross].Rgou[2 * (road[glroad].hdmdes[jcross].RGouPtNum - 1)]) * Sfactor;
						road[glroad].hdmdes[jcross].Rgou[2 * (road[glroad].hdmdes[jcross].RGouPtNum - 1) + 1] = road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}
					else if (iroad > 0 && (road[iroad].hdmdes[j].LGouPtNum == 6 || road[iroad].hdmdes[j].LGouPtNum == 16))
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[iroad].hdmdes[j].Lgou[2 * (road[iroad].hdmdes[j].LGouPtNum - 1)] - road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].x) * Sfactor;
						road[iroad].hdmdes[j].Lgou[2 * (road[iroad].hdmdes[j].LGouPtNum - 1) + 1] = -road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}
					else
					{
						GLCross.m_OriPoint.x = pCross.m_OriPoint.x - fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x - road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].x) * Sfactor;
						road[glroad].hdmdes[jcross].RPTR[road[glroad].hdmdes[jcross].Rnpt - 1].y = road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].y + ZX_EarHOnLJZX - FLX_EarHOnLJZX;
					}

					GLCross.DX = GLCross.m_OriPoint.x - 20 * Sfactor;
					road[glroad].hdmdes[jcross].DX = GLCross.m_OriPoint.x - 30 * Sfactor;

				}
				GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[glroad].hdmdes[jcross].RHFR[1]-road[iroad].hdmdes[i].RHFL[1])*Sfactor;	//每个断面的绘图原点

			}
			road[glroad].hdmdes[jcross].Ymin = road[iroad].hdmdes[j].Ymin;

			setCROSSAutoDesignData(GLCross, glroad, jcross, FLX_EarHOnLJZX, FLX_LearptOnLJZX, OffsetNumLearpt, FLX_RearptOnLJZX, OffsetNumRearpt,
				LBenchPt, road[glroad].hdmBench[jcross].ZEarPtNum, RBenchPt, road[glroad].hdmBench[jcross].YEarPtNum);

			GLCross.DorS = road[glroad].hdmdes[jcross].DorS;
			GLCross.offset = road[glroad].hdmdes[jcross].offsetX;//一线中心线相对与新的地面线的移动量
			GLCross.IsLinkHdm = true;
			if (fabs(road[iroad].hdmdes[j].xjj) < 3)
				GLCross.BzTWInf = -1;

			GLCross.OutDraw();
		}
		if (road[iroad].hdmdes[j].IfHasZlink)//有关联断面,绘关联
		{
			for (int iroad = 0; iroad < ZRoadSum; iroad++)
			{
				if (Zroad[iroad].roadname == road[iroad].hdmdes[j].zlink->glRoadName)
					break;
			}

			int jcross = FindIDM(Zroad[iroad], road[iroad].hdmdes[j].zlink->cml);

			int k;
			for (k = 0; k < Zroad[iroad].hdmdmx[jcross].ZEarPtNum; k++)
			{
				Learpt[k * 2] = Zroad[iroad].hdmdmx[jcross].ZEarPtAry[k].x;
				Learpt[k * 2 + 1] = Zroad[iroad].hdmdmx[jcross].ZEarPtAry[k].y;
			}

			for (k = 0; k < Zroad[iroad].hdmdmx[jcross].YEarPtNum; k++)
			{
				Rearpt[k * 2] = Zroad[iroad].hdmdmx[jcross].YEarPtAry[k].x;
				Rearpt[k * 2 + 1] = Zroad[iroad].hdmdmx[jcross].YEarPtAry[k].y;
			}

			if (road[iroad].hdmdes[j].zlink->Rnpt > 0)
				GLCross.m_OriPoint.x = pCross.m_OriPoint.x -
				fabs(road[iroad].hdmdes[j].RPTL[road[iroad].hdmdes[j].Lnpt - 1].x - road[iroad].hdmdes[j].zlink->RPTR[road[iroad].hdmdes[j].zlink->Rnpt - 1].x) * Sfactor;
			GLCross.m_OriPoint.y = pCross.m_OriPoint.y;//+ (road[iroad].hdmdes[j].RHFR[1]-road[iroad].hdmdes[j].RHFL[1])*Sfactor;	//每个断面的绘图原点
			//}
			road[iroad].hdmdes[j].zlink->Ymin = road[iroad].hdmdes[j].Ymin;
			setCROSSAutoDesignData(GLCross, Zroad[iroad], jcross, road[iroad].hdmdes[j].zlink,
				Zroad[iroad].hdmdmx[jcross].EarH, Learpt, Zroad[iroad].hdmdmx[jcross].ZEarPtNum,
				Rearpt, Zroad[iroad].hdmdmx[jcross].YEarPtNum);

			GLCross.DorS = Zroad[iroad].hdmdes[j].DorS;
			GLCross.offset = Zroad[iroad].hdmdes[j].offsetX;//一线中心线相对与新的地面线的移动量
			GLCross.IsLinkHdm = true;
			if (fabs(road[iroad].hdmdes[j].xjj) < 3)
				GLCross.BzTWInf = -1;

			GLCross.OutDraw();

		}

		if (road[iroad].hdmdes[j].IfHasYlink)//有关联断面,绘关联
		{
			//				    ads_printf(L"dml=%lf\n",road[iroad].hdmdes[j].dml);
			for (int iroad = 0; iroad < YRoadSum; iroad++)
			{
				if (Yroad[iroad].roadname == road[iroad].hdmdes[j].ylink->glRoadName)
					break;
			}
			int jcross = FindIDM(Yroad[iroad], road[iroad].hdmdes[j].ylink->cml);
			int k;
			for (k = 0; k < Yroad[iroad].hdmdmx[jcross].ZEarPtNum; k++)
			{
				Learpt[k * 2] = Yroad[iroad].hdmdmx[jcross].ZEarPtAry[k].x;
				Learpt[k * 2 + 1] = Yroad[iroad].hdmdmx[jcross].ZEarPtAry[k].y;
			}

			for (k = 0; k < Yroad[iroad].hdmdmx[jcross].YEarPtNum; k++)
			{
				Rearpt[k * 2] = Yroad[iroad].hdmdmx[jcross].YEarPtAry[k].x;
				Rearpt[k * 2 + 1] = Yroad[iroad].hdmdmx[jcross].YEarPtAry[k].y;
			}

			if (road[iroad].hdmdes[j].ylink->Lnpt > 0)
				GLCross.m_OriPoint.x = pCross.m_OriPoint.x +
				(fabs(road[iroad].hdmdes[j].RPTR[road[iroad].hdmdes[j].Rnpt - 1].x) + fabs(road[iroad].hdmdes[j].ylink->RPTL[road[iroad].hdmdes[j].ylink->Lnpt - 1].x)) * Sfactor;
			GLCross.m_OriPoint.y = pCross.m_OriPoint.y;// + (road[iroad].hdmdes[j].RHFL[1]-road[iroad].hdmdes[j].RHFR[1])*Sfactor;	//每个断面的绘图原点
			//}
			road[iroad].hdmdes[j].ylink->Ymin = road[iroad].hdmdes[j].Ymin;

			setCROSSAutoDesignData(GLCross, Yroad[iroad], jcross, road[iroad].hdmdes[j].ylink,
				Yroad[iroad].hdmdmx[jcross].EarH, Learpt, Yroad[iroad].hdmdmx[jcross].ZEarPtNum,
				Rearpt, Yroad[iroad].hdmdmx[jcross].YEarPtNum);

			GLCross.DorS = Yroad[iroad].hdmdes[j].DorS;
			GLCross.offset = Yroad[iroad].hdmdes[j].offsetX;//一线中心线相对与新的地面线的移动量
			GLCross.IsLinkHdm = true;
			if (fabs(road[iroad].hdmdes[j].xjj) < 3)
				GLCross.BzTWInf = -1;
			GLCross.OutDraw();
		}
		//DrawHDMwgx(road[iroad].hdmdes[j].newLYd, road[iroad].hdmdes[j].RHFL[1], road[iroad].hdmdes[j].Ymin, road[iroad].hdmdes[j].Ymax, pCross.LeftDesignLinePart->m_DesignPoints);
	}
}

//用于计算水沟填挖与断面整体填挖,边坡绿化面积，水沟长度，路面面积
void HdmDes::CalTorWforPSandDM(int iroad)
{
	//1.计算整个填挖方数量	以及	水沟填挖方数量
	//road[iroad].NCRS = 10;
	
	road[iroad].PSAreaT = 0.0;
	road[iroad].PSAreaW = 0.0;
	double PSVolT = 0.0;
	double PSVolW = 0.0;
	double DMVolT = 0.0;
	double DMVolW = 0.0;
	CalVolumeforPSandLJ(iroad, PSVolT, PSVolW, DMVolT, DMVolW);
	road[iroad].PSAreaT = PSVolT;
	road[iroad].PSAreaW = PSVolW;
	road[iroad].DMAreaT = DMVolT;
	road[iroad].DMAreaW = DMVolW;
	//2.路面面积计算
	double LMAreaL = 0.0;//左侧路面面积
	double LMAreaR = 0.0;//右侧路面面积
	CalLMArea(iroad, LMAreaL, LMAreaR);
	road[iroad].LMArea = LMAreaL + LMAreaR;
	//3.绿化面积计算-模拟计算
	//除去起终断面外，均按照一个断面的控制范围距前一段面一半距离，距后一断面一半距离的原则计算面积
	double BPAreaL = 0.0;//左侧边坡绿化面积
	double BPAreaR = 0.0;//右侧边坡绿化面积
	CalBPArea(iroad, BPAreaL, BPAreaR);
	road[iroad].L_BPArea = BPAreaL;
	road[iroad].R_BPArea = BPAreaR;
	//4.水沟长度计算
	double CGLength = 0.0;//侧沟长度
	double PSGLength = 0.0;//排水沟长度
	double TGLength = 0.0;//天沟长度
	CalLengthofPS(iroad, CGLength, PSGLength, TGLength);
	road[iroad].CGLength = CGLength;
	road[iroad].TGLength = TGLength;
	road[iroad].PSGLength = PSGLength;
	//5.水沟浆砌计算
	double CGJQvolume = 0.0;//侧沟浆砌体积
	double PSGJQvolume = 0.0;//排水沟浆砌体积
	double TGJQvolume = 0.0;//天沟浆砌体积
	CalJQvolumeofPS(iroad, CGJQvolume, PSGJQvolume, TGJQvolume);
	road[iroad].CGJQvolume = CGJQvolume;
	road[iroad].PSGJQvolume = PSGJQvolume;
	road[iroad].TGJQvolume = TGJQvolume;
}

//水沟填挖方计算-是计算体积，不是面积
void HdmDes::CalVolumeforPSandLJ(int iroad, double& PSVolT, double& PSVolW, double& DMVolT, double& DMVolW)
{
	//计算每个断面的水沟挖填方和断面挖填方
	double PSAreaT = 0.0; double PSAreaTe = 0.0;
	double PSAreaW = 0.0; double PSAreaWe = 0.0;
	double DMAreaT = 0.0; double DMAreaTe = 0.0;
	double DMAreaW = 0.0; double DMAreaWe = 0.0;

	bool IfBriTunEnd = false;
	bool IfBriTunStart = false;
	for (int j = 0; j < road[iroad].NCRS; j++)
	{
		//桥中、隧中直接跳过
		if (road[iroad].hdmdes[j].ZDMXZ == 3 || road[iroad].hdmdes[j].ZDMXZ == 4)
			continue;

		//检测桥头信息（暂时并未用上）
		IfBriTunStart = false;
		if (road[iroad].hdmdes[j].ZDMXZ == -1 || road[iroad].hdmdes[j].ZDMXZ == -2)
			IfBriTunStart = true;

		//检测桥尾信息
		IfBriTunEnd = false;
		if (road[iroad].hdmdes[j].ZDMXZ == 1 || road[iroad].hdmdes[j].ZDMXZ == 2)
			IfBriTunEnd = true;

		//桥尾或隧道尾
		if (j == 0 || IfBriTunEnd)
			continue;

		double Dis = fabs(road[iroad].hdmdes[j].cml - road[iroad].hdmdes[j - 1].cml);

		//水沟填方
		PSAreaT = road[iroad].hdmdes[j].GouTarea;
		PSAreaTe = road[iroad].hdmdes[j - 1].GouTarea;
		PSVolT += (PSAreaT + PSAreaTe) / 2 * Dis;
		//水沟挖方
		PSAreaW = road[iroad].hdmdes[j].GouWarea;
		PSAreaWe = road[iroad].hdmdes[j - 1].GouWarea;
		PSVolW += (PSAreaW + PSAreaWe) / 2 * Dis;
		//断面填方
		DMAreaT = road[iroad].hdmdes[j].FillArea;
		DMAreaTe = road[iroad].hdmdes[j - 1].FillArea;
		DMVolT += (DMAreaT + DMAreaTe) / 2 * Dis;
		//断面挖方
		DMAreaW = road[iroad].hdmdes[j].CutArea;
		DMAreaWe = road[iroad].hdmdes[j - 1].CutArea;
		DMVolW += (DMAreaW + DMAreaWe) / 2 * Dis;
	}
}
//计算路面面积
void HdmDes::CalLMArea(int iroad, double& LMAreaL, double& LMAreaR)
{
	//首先获取路面厚度设计标准，分段终里程，厚度
	double QDWith = 0.0;
	double ZDWith = 0.0;
	double Length = 0.0;
	double ml = 0.0;
	double mlnext = 0.0;
	double QDml = 0.0;
	//左侧
	QDWith = fabs(road[iroad].hdmdes[0].RHFL[8]);
	QDml = road[iroad].hdmdes[0].cml;
	for (int j = 0; j < road[iroad].hdmbz.NZLMHD; j++)
	{
		ml = road[iroad].pm->TYLC(road[iroad].hdmbz.ZLMHD[j].dml);
		if (j == road[iroad].hdmbz.NZLMHD - 1)//最后一个
		{
			mlnext = road[iroad].hdmdes[road[iroad].NCRS - 1].cml;
		}
		else
		{
			mlnext = road[iroad].pm->TYLC(road[iroad].hdmbz.ZLMHD[j + 1].dml);
		}
		for (int idm = 0; idm < road[iroad].NCRS; idm++)
		{
			if (road[iroad].hdmdes[idm].cml > ml - 0.001 && road[iroad].hdmdes[idm].cml < mlnext + 0.001)
			{
				Length = fabs(road[iroad].hdmdes[idm].cml - QDml);
				ZDWith = fabs(road[iroad].hdmdes[idm].RHFL[8]);
				LMAreaL += (QDWith + ZDWith) / 2 * Length;
				QDWith = ZDWith;
				QDml = road[iroad].hdmdes[idm].cml;
			}
		}
	}
	//右侧
	QDWith = fabs(road[iroad].hdmdes[0].RHFR[8]);
	QDml = road[iroad].hdmdes[0].cml;
	for (int j = 0; j < road[iroad].hdmbz.NYLMHD; j++)
	{
		ml = road[iroad].pm->TYLC(road[iroad].hdmbz.YLMHD[j].dml);
		if (j == road[iroad].hdmbz.NYLMHD - 1)//最后一个
		{
			mlnext = road[iroad].hdmdes[road[iroad].NCRS - 1].cml;
		}
		else
		{
			mlnext = road[iroad].pm->TYLC(road[iroad].hdmbz.YLMHD[j + 1].dml);
		}
		for (int idm = 0; idm < road[iroad].NCRS; idm++)
		{
			if (road[iroad].hdmdes[idm].cml > ml - 0.001 && road[iroad].hdmdes[idm].cml < mlnext + 0.001)
			{
				Length = fabs(road[iroad].hdmdes[idm].cml - QDml);
				ZDWith = fabs(road[iroad].hdmdes[idm].RHFR[8]);
				LMAreaR += (QDWith + ZDWith) / 2 * Length;
				QDWith = ZDWith;
				QDml = road[iroad].hdmdes[idm].cml;
			}
		}
	}
}
//计算断面左右边坡绿化面积
void HdmDes::CalBPArea(int iroad, double& BPAreaL, double& BPAreaR)
{
	double QDWith = 0.0;
	double ZDWith = 0.0;
	double Length = 0.0;
	Length = 0.0;

	bool IfBriTunEnd = false;
	bool IfBriTunStart = false;
	for (int j = 0; j < road[iroad].NCRS; j++)
	{
		//桥中、隧中直接跳过
		if (road[iroad].hdmdes[j].ZDMXZ == 3 || road[iroad].hdmdes[j].ZDMXZ == 4)
			continue;

		//检测桥头信息（暂时并未用上）
		IfBriTunStart = false;
		if (road[iroad].hdmdes[j].ZDMXZ == -1 || road[iroad].hdmdes[j].ZDMXZ == -2)
			IfBriTunStart = true;

		//检测桥尾信息
		IfBriTunEnd = false;
		if (road[iroad].hdmdes[j].ZDMXZ == 1 || road[iroad].hdmdes[j].ZDMXZ == 2)
			IfBriTunEnd = true;

		//桥尾或隧道尾
		if (j == 0 || IfBriTunEnd)
			continue;

		double Dis = fabs(road[iroad].hdmdes[j].cml - road[iroad].hdmdes[j - 1].cml);

		//左侧
		QDWith = road[iroad].hdmdes[j - 1].Z_LGrasslength;
		ZDWith = road[iroad].hdmdes[j].Z_LGrasslength;
		BPAreaL += (ZDWith + QDWith) * Dis / 2;
		//右侧
		QDWith = road[iroad].hdmdes[j - 1].Y_RGrasslength;
		ZDWith = road[iroad].hdmdes[j].Y_RGrasslength;
		BPAreaR += (ZDWith + QDWith) * Dis / 2;
	}
}
//计算水沟长度
void HdmDes::CalLengthofPS(int iroad, double& CGLength, double& PSGLength, double& TGLength)
{
	if (road[iroad].NCRS <= 0)
		return;

	//设置参数
	bool IfBriTunEnd = false;
	bool IfBriTunStart = false;

	////////////////////////////////////////左侧

	//第一个断面和最后一个断面需分开处理
	for (int j = 0; j + 1 < road[iroad].NCRS; j++)
	{
		//桥中、隧中直接跳过
		if (road[iroad].hdmdes[j].ZDMXZ == 3 || road[iroad].hdmdes[j].ZDMXZ == 4)
			continue;

		//检测桥头信息
		IfBriTunStart = false;
		if (road[iroad].hdmdes[j].ZDMXZ == -1 || road[iroad].hdmdes[j].ZDMXZ == -2)
			IfBriTunStart = true;

		//检测桥尾信息
		IfBriTunEnd = false;
		if (road[iroad].hdmdes[j].ZDMXZ == 1 || road[iroad].hdmdes[j].ZDMXZ == 2)
			IfBriTunEnd = true;

		if (j == 0 && !IfBriTunStart)	//如果一开始就是桥头，那么不需要添加
		{
			if (road[iroad].hdmdes[j].LGouProperty == 1)//排水沟
			{
				PSGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
			else if (road[iroad].hdmdes[j].LGouProperty == 2)//侧沟
			{
				CGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
			else if (road[iroad].hdmdes[j].LGouProperty != 0 && CheckLateralGutterExist(road[iroad].hdmdes[j], LEFT))//天沟
			{
				TGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
		}
		else
		{
			if (road[iroad].hdmdes[j].LGouProperty == 1)//排水沟
			{
				//前一段面
				if (!IfBriTunEnd)	//桥尾、隧尾前一段不加
					PSGLength += fabs(road[iroad].hdmdes[j].cml - road[iroad].hdmdes[j - 1].cml) / 2;
				//后一断面
				if (!IfBriTunStart)	//桥头、隧头后一段不加
					PSGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
			else if (road[iroad].hdmdes[j].LGouProperty == 2)//侧沟
			{
				//前一段面
				if (!IfBriTunEnd)	//桥尾、隧尾前一段不加
					CGLength += fabs(road[iroad].hdmdes[j].cml - road[iroad].hdmdes[j - 1].cml) / 2;
				//后一断面
				if (!IfBriTunStart)	//桥头、隧头后一段不加
					CGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
			else if (road[iroad].hdmdes[j].LGouProperty != 0 && CheckLateralGutterExist(road[iroad].hdmdes[j], LEFT))//天沟
			{
				//前一段面
				if (!IfBriTunEnd)	//桥尾、隧尾前一段不加
					TGLength += fabs(road[iroad].hdmdes[j].cml - road[iroad].hdmdes[j - 1].cml) / 2;
				//后一断面
				if (!IfBriTunStart)	//桥头、隧头后一段不加
					TGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
		}
	}

	//检测桥尾信息
	IfBriTunEnd = false;
	if (road[iroad].hdmdes[road[iroad].NCRS - 1].ZDMXZ == 1 || road[iroad].hdmdes[road[iroad].NCRS - 1].ZDMXZ == 2)
		IfBriTunEnd = true;

	if (!IfBriTunEnd)
	{
		//左侧最后一个断面
		if (road[iroad].hdmdes[road[iroad].NCRS - 1].LGouProperty == 1)//排水沟
		{
			PSGLength += fabs(road[iroad].hdmdes[road[iroad].NCRS - 2].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml) / 2;
		}
		else if (road[iroad].hdmdes[road[iroad].NCRS - 1].LGouProperty == 2)//侧沟
		{
			CGLength += fabs(road[iroad].hdmdes[road[iroad].NCRS - 2].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml) / 2;
		}
		else if (road[iroad].hdmdes[road[iroad].NCRS - 1].LGouProperty != 0 && CheckLateralGutterExist(road[iroad].hdmdes[road[iroad].NCRS - 1], LEFT))//天沟
		{
			TGLength += fabs(road[iroad].hdmdes[road[iroad].NCRS - 2].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml) / 2;
		}
	}


	////////////////////////////////////////右侧

	for (int j = 0; j + 1 < road[iroad].NCRS; j++)
	{
		//桥中、隧中直接跳过
		if (road[iroad].hdmdes[j].ZDMXZ == 3 || road[iroad].hdmdes[j].ZDMXZ == 4)
			continue;

		//检测桥头信息
		IfBriTunStart = false;
		if (road[iroad].hdmdes[j].ZDMXZ == -1 || road[iroad].hdmdes[j].ZDMXZ == -2)
			IfBriTunStart = true;

		//检测桥尾信息
		IfBriTunEnd = false;
		if (road[iroad].hdmdes[j].ZDMXZ == 1 || road[iroad].hdmdes[j].ZDMXZ == 2)
			IfBriTunEnd = true;


		if (j == 0 && !IfBriTunStart)
		{
			if (road[iroad].hdmdes[j].RGouProperty == 1)//排水沟
			{
				PSGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
			else if (road[iroad].hdmdes[j].RGouProperty == 2)//侧沟
			{
				CGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
			else if (road[iroad].hdmdes[j].RGouProperty != 0 && CheckLateralGutterExist(road[iroad].hdmdes[j], RIGHT))//天沟
			{
				TGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
		}
		else
		{
			if (road[iroad].hdmdes[j].RGouProperty == 1)//排水沟
			{
				//前一段面
				if (!IfBriTunEnd)	//桥尾、隧尾前一段不加
					PSGLength += fabs(road[iroad].hdmdes[j].cml - road[iroad].hdmdes[j - 1].cml) / 2;
				//后一断面
				if (!IfBriTunStart)	//桥头、隧头后一段不加
					PSGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
			else if (road[iroad].hdmdes[j].RGouProperty == 2)//侧沟
			{
				//前一段面
				if (!IfBriTunEnd)	//桥尾、隧尾前一段不加
					CGLength += fabs(road[iroad].hdmdes[j].cml - road[iroad].hdmdes[j - 1].cml) / 2;
				//后一断面
				if (!IfBriTunStart)	//桥头、隧头后一段不加
					CGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
			else if (road[iroad].hdmdes[j].RGouProperty != 0 && CheckLateralGutterExist(road[iroad].hdmdes[j], RIGHT))//天沟
			{
				//前一段面
				if (!IfBriTunEnd)	//桥尾、隧尾前一段不加
					TGLength += fabs(road[iroad].hdmdes[j].cml - road[iroad].hdmdes[j - 1].cml) / 2;
				//后一断面
				if (!IfBriTunStart)	//桥头、隧头后一段不加
					TGLength += fabs(road[iroad].hdmdes[j + 1].cml - road[iroad].hdmdes[j].cml) / 2;
			}
		}
	}

	//检测桥尾信息
	IfBriTunEnd = false;
	if (road[iroad].hdmdes[road[iroad].NCRS - 1].ZDMXZ == 1 || road[iroad].hdmdes[road[iroad].NCRS - 1].ZDMXZ == 2)
		IfBriTunEnd = true;

	//右侧最后一个断面
	if (!IfBriTunEnd)
	{
		if (road[iroad].hdmdes[road[iroad].NCRS - 1].RGouProperty == 1)//排水沟
		{
			PSGLength += fabs(road[iroad].hdmdes[road[iroad].NCRS - 2].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml) / 2;
		}
		else if (road[iroad].hdmdes[road[iroad].NCRS - 1].RGouProperty == 2)//侧沟
		{
			CGLength += fabs(road[iroad].hdmdes[road[iroad].NCRS - 2].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml) / 2;
		}
		else if (road[iroad].hdmdes[road[iroad].NCRS - 1].RGouProperty != 0 && CheckLateralGutterExist(road[iroad].hdmdes[road[iroad].NCRS - 1], RIGHT))//天沟
		{
			TGLength += fabs(road[iroad].hdmdes[road[iroad].NCRS - 2].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml) / 2;
		}
	}
}

//水沟浆砌体积计算
void HdmDes::CalJQvolumeofPS(int iroad, double& CGJQvolume, double& PSGJQvolume, double& TGJQvolume)
{
	if (road[iroad].NCRS <= 0)
		return;

	//设置参数
	bool IfBriTunEnd = false;
	bool IfBriTunStart = false;
	double PSAreaL = 0.0; double PSAreaLe = 0.0;
	double PSAreaR = 0.0; double PSAreaRe = 0.0;

	//循环计算浆砌面积
	for (int j = 0; j < road[iroad].NCRS; j++)
	{
		//桥中、隧中直接跳过
		if (road[iroad].hdmdes[j].ZDMXZ == 3 || road[iroad].hdmdes[j].ZDMXZ == 4)
			continue;

		//检测桥头信息（暂时并未用上）
		IfBriTunStart = false;
		if (road[iroad].hdmdes[j].ZDMXZ == -1 || road[iroad].hdmdes[j].ZDMXZ == -2)
			IfBriTunStart = true;

		//检测桥尾信息
		IfBriTunEnd = false;
		if (road[iroad].hdmdes[j].ZDMXZ == 1 || road[iroad].hdmdes[j].ZDMXZ == 2)
			IfBriTunEnd = true;

		//桥尾或隧道尾
		if (j == 0 || IfBriTunEnd)
			continue;

		double Dis = fabs(road[iroad].hdmdes[j].cml - road[iroad].hdmdes[j - 1].cml);

		//左侧
		if (road[iroad].hdmdes[j].LGouProperty == 1)//排水沟
		{
			PSAreaL = road[iroad].hdmdes[j - 1].Z_LSGJQarea;
			PSAreaLe = road[iroad].hdmdes[j].Z_LSGJQarea;
			PSGJQvolume += (PSAreaL + PSAreaLe) / 2 * Dis;
		}
		else if (road[iroad].hdmdes[j].LGouProperty == 2)//侧沟
		{
			PSAreaL = road[iroad].hdmdes[j - 1].Z_LSGJQarea;
			PSAreaLe = road[iroad].hdmdes[j].Z_LSGJQarea;
			CGJQvolume += (PSAreaL + PSAreaLe) / 2 * Dis;
		}
		else if (road[iroad].hdmdes[j].LGouProperty != 0 && CheckLateralGutterExist(road[iroad].hdmdes[j], LEFT))//天沟
		{
			PSAreaL = road[iroad].hdmdes[j - 1].Z_LSGJQarea;
			PSAreaLe = road[iroad].hdmdes[j].Z_LSGJQarea;
			TGJQvolume += (PSAreaL + PSAreaLe) / 2 * Dis;
		}

		//右侧
		if (road[iroad].hdmdes[j].RGouProperty == 1)//排水沟
		{
			PSAreaL = road[iroad].hdmdes[j - 1].Y_RSGJQarea;
			PSAreaLe = road[iroad].hdmdes[j].Y_RSGJQarea;
			PSGJQvolume += (PSAreaL + PSAreaLe) / 2 * Dis;
		}
		else if (road[iroad].hdmdes[j].RGouProperty == 2)//侧沟
		{
			PSAreaL = road[iroad].hdmdes[j - 1].Y_RSGJQarea;
			PSAreaLe = road[iroad].hdmdes[j].Y_RSGJQarea;
			CGJQvolume += (PSAreaL + PSAreaLe) / 2 * Dis;
		}
		else if (road[iroad].hdmdes[j].RGouProperty != 0 && CheckLateralGutterExist(road[iroad].hdmdes[j], RIGHT))//天沟
		{
			PSAreaL = road[iroad].hdmdes[j - 1].Y_RSGJQarea;
			PSAreaLe = road[iroad].hdmdes[j].Y_RSGJQarea;
			TGJQvolume += (PSAreaL + PSAreaLe) / 2 * Dis;
		}
	}
}
//绘制工程数量表格
void HdmDes::DrawGCSL()
{
	bool ROK = false;
	CDrawGCSLBandDYT dlg;
	//20200329梁柱，加else分支
	if (dlg.DoModal() == IDOK)
	{
		ROK = true;
	}
	else
		return;
	//读文件	
	if (dlg.PathArray.size() == 1)
	{
		if (!ReadFile(false))//横断面标准
			return;

		ReadBDFile();

		//从鼻端文件中读取左右关联道路，若道路总数>0按互通处理，否则按分离式处理
		CString xl1;
		xl1.Format(L"%s,%s", road[0].pm->mdbname, road[0].roadname);

		//	SetHdmLm();//求路面

		FindAndReadLinkRoad_for3d(xl1);

		ads_printf(L"读数据库OK!\n");

		ads_printf(L"roadsum=%d\n", RoadSum);
		//横断面成果
		for (int i = 0; i < RoadSum; i++)
		{

			if (!ReadHdmResultFile(i))
				return;

			if (!ReadHdmAreaFile(i))
				return;
		}
		//CDrawGCSLBandDYT dlg;

		if (ROK)//输入设计参数
		{
			int iroad = 0;
			double OriX = 0.0;
			double OriY = 0.0;//左上角点
			OriX = _wtof(dlg.m_PTX);
			OriY = _wtof(dlg.m_PTY);
			//传递桩号数组
			m_CrossTypeArray = dlg.m_CrossTypeArray;

			//修正横断面数组
			ModifyCrossArray(iroad);

			//计算工程数量
			CalTorWforPSandDM(iroad);

			if (dlg.m_IsToExcel)
			{
				WriteQuantityToExcel(iroad);
			}
			else
			{
				//绘制图框
				acDocManager->lockDocument(acDocManager->curDocument(), AcAp::kWrite);
				//绘制图框
				DrawTK(OriX, OriY, 1.0);
				//绘制文字
				DrawWord(OriX, OriY, 1.0);
				//标注文字
				DrawData(iroad, OriX, OriY, 1.0);
				acDocManager->unlockDocument(acDocManager->curDocument());
			}


		}
	}
	//20200303梁柱
	else if (dlg.PathArray.size() > 1 && dlg.m_IsToExcel)
	{
		RoadLen = 0, FillEarWok = 0, CutEarWok = 0, CutStnWok = 0, C25 = 0, BrkStn = 0, BrkPav = 0, C15 = 0, GutLen = 0, EarWok = 0, M75 = 0, B = 0, Steel = 0, GreAre = 0, HanGuan = 0, YDAllArea = 0;
		ACHAR OriFilePath[280];
		_stprintf(OriFilePath, L"%s\\lib\\用地模板.xlt", SysPath);

		ReadWorkdir();
		CString DesFilePath = Cworkdir + L"\\RESULT\\方案汇总统计表.xls";

		CopyFile(OriFilePath, DesFilePath, false);

		//初始化Excel
		//设置参数
		_Application	ExcelApp;			//应用程序
		Workbooks		ExcelWorkBooks;		//工作集
		_Workbook		ExcelWorkBook;		//单个工作簿
		Worksheets		ExcelWorksheets;	//表(Sheet)集
		//_Worksheet		ExcelWorksheet;		//单个表
		//Range			ExcelRange;			//单元格
		//初始化程序
		if (!ExcelApp.CreateDispatch(L"Excel.Application", NULL))
		{
			AfxMessageBox(L"不能打开Excel表格!请确认Excel已经安装正确!");
			return;
		}

		//初始化工作簿、表集
		ExcelWorkBooks.AttachDispatch(ExcelApp.GetWorkbooks(), true);
		ExcelWorkBook.AttachDispatch(ExcelWorkBooks.Add(_variant_t(DesFilePath)));
		ExcelWorksheets.AttachDispatch(ExcelWorkBook.GetWorksheets(), true);
		///////////////

		bool One_excel = true;
		for (int i = 0; i < dlg.PathArray.size(); i++)
		{
			//20200329梁柱
			if (!ReadFile(false, dlg.PathArray.at(i)))
			{
				acutPrintf(_T("输出%s方案时发生错误！请检查方案设计是否完整！"), dlg.PathArray.at(i));
				if (i== dlg.PathArray.size()-1)
				{
					WriteQuantityToExcel_all(0, true, ExcelWorksheets);
				}				
				continue;
			}
			//////////////////
			ReadBDFile();
			CString Xl1, TempStr1, TempStr2;
			Xl1.Format(L"%s,%s", road[0].pm->mdbname, road[0].roadname);
			TempStr2 = road[0].pm->mdbname;
			FindAndReadLinkRoad_for3d(Xl1);
			TempStr1 = Cworkdir + "\\data\\";
			TempStr1.MakeUpper();
			TempStr2.MakeUpper();
			TempStr2.Replace(TempStr1, NULL);
			TempStr2.Replace(L".MDB", NULL);
			Pro = TempStr2;
			//20200329梁柱
			bool Hasread = true;
			for (int k = 0; k < RoadSum; k++)
			{
				if (!ReadHdmResultFile(k))
				{
					Hasread = false;
					break;
				}
				if (!ReadHdmAreaFile(k))
				{
					Hasread = false;
					break;
				}
			}
			if (Hasread==false)
			{
				continue;
			}
			////////////////
			if (ROK)
			{
				int iroad = 0;

				m_CrossTypeArray = dlg.m_CrossTypeArray;

				ModifyCrossArray(iroad);

				CalTorWforPSandDM(iroad);

				WriteQuantityToExcel(iroad, true, ExcelWorksheets, i + 1);
				//20200322梁柱添加出汇总表
				if (i == dlg.PathArray.size() - 1)
				{
					WriteQuantityToExcel_all(iroad, true, ExcelWorksheets);
				}

			}
		}
		ExcelApp.SetVisible(true);
		ExcelApp.SetUserControl(true);   //调用excel表

		ExcelWorksheets.ReleaseDispatch();
		ExcelWorkBook.ReleaseDispatch();
		ExcelWorkBooks.ReleaseDispatch();
		ExcelWorkBook.Close(_variant_t((long)1), _variant_t(), _variant_t());
		ExcelWorkBooks.Close();

		ExcelApp.Quit();
		ExcelApp.ReleaseDispatch();
	}
	else if (dlg.PathArray.size() > 1 && !dlg.m_IsToExcel)
	{
		for (int i = 0; i < dlg.PathArray.size(); i++)
		{
			if (!ReadFile(false, dlg.PathArray.at(i)))
			{
				acutPrintf(_T("输出第%d个方案时发生错误！"), i + 1);
				return;
			}
			ReadBDFile();
			CString Xl1;
			Xl1.Format(L"%s,%s", road[0].pm->mdbname, road[0].roadname);
			FindAndReadLinkRoad_for3d(Xl1);

			for (int i = 0; i < RoadSum; i++)
			{
				if (!ReadHdmResultFile(i))
					return;
				if (!ReadHdmAreaFile(i))
				{
					return;
				}
			}
			if (ROK)
			{
				int iroad = 0;
				double OriX = 0.0;
				double OriY = 0.0;
				OriX = _wtof(dlg.m_PTX);
				OriY = _wtof(dlg.m_PTY);

				m_CrossTypeArray = dlg.m_CrossTypeArray;

				ModifyCrossArray(iroad);

				CalTorWforPSandDM(iroad);


				acDocManager->lockDocument(acDocManager->curDocument(), AcAp::kWrite);
				DrawTK(OriX , OriY+ i * 120, 1.0);
				DrawWord(OriX , OriY+ i * 120, 1.0);
				DrawData(iroad, OriX  , OriY+i * 120, 1.0);
				acDocManager->unlockDocument(acDocManager->curDocument());

			}
		}

	}

}

//标注文字
void HdmDes::DrawData(int iroad, double OriX, double OriY, double DFACTOR)
{
	//20190912新增	文字样式	图层名
	ACHAR TextStyle[32], LayerName[256];
	_tcscpy(TextStyle, L"宋体");
	_tcscpy(LayerName, L"工程数量表-文字");

	//20191018	路面分层可调
	int ColNum_RoadArea = max(road[0].hdmbz.m_RoadLayerArray_L.size(), road[0].hdmbz.m_RoadLayerArray_R.size());

	//定义一些尺寸
	double d1, d2, d3, d4, h1;
	double texth;
	d1 = 10 * DFACTOR;
	d2 = 25 * DFACTOR;
	d3 = 60 * DFACTOR;
	d4 = 30 * DFACTOR;
	h1 = 5 * DFACTOR;
	double Wtab = d1 + d2 + d3 + d2 + 2 * d4;//表长
	double Htab = 20 * h1;//表高
	texth = 4 * DFACTOR;
	//外框四点
	AcGePoint3d  ptzs, ptzx, ptyx, ptys;
	ptzs.x = OriX; ptzs.y = OriY;
	ptzx.x = OriX; ptzx.y = OriY - Htab;
	ptyx.x = OriX + Wtab; ptyx.y = OriY - Htab;
	ptys.x = OriX + Wtab; ptys.y = OriY;
	//注字
	AcGePoint3d spt, ept, TextPt;
	AcGeVector3d vec1, vec2;
	vec1.set(1, 0, 0);
	vec2.set(0, -1, 0);
	CString str = L"";
	ACHAR chr[32];
	//道路长度
	double Length;
	Length = fabs(road[iroad].hdmdes[0].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml);
	str.Format(L"%0.3f", Length);
	_tcscpy(chr, str);
	spt = ptzs + 3.5*h1*vec2;
	spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//断面填挖
	str.Format(L"%0.3f", road[iroad].DMAreaT);
	_tcscpy(chr, str);
	spt = ptzs + 4.5*h1*vec2;
	spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	str.Format(L"%0.3f", road[iroad].DMAreaW);
	_tcscpy(chr, str);
	spt = ptzs + 5.5*h1*vec2;
	spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"0");
	spt = ptzs + 6.5*h1*vec2;
	spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//路面面积
	for (int i = 0; i < ColNum_RoadArea; i++)
	{
		str.Format(L"%0.3f", road[iroad].LMArea);
		_tcscpy(chr, str);
		spt = spt + h1 * vec2;
		maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	}
	//str.Format(L"%0.3f", road[iroad].LMArea);
	//_tcscpy(chr, str);
	//spt = ptzs + 7.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	//maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//str.Format(L"%0.3f", road[iroad].LMArea);
	//_tcscpy(chr, str);
	//spt = ptzs + 8.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	//maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//_tcscpy(chr, L"0");
	//spt = ptzs + 9.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	//maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//支挡工程
	//str.Format(L"%0.3f", road[iroad]);
	_tcscpy(chr, L"0");
	//spt = ptzs + 10.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//附属工程
	Length = fabs(road[iroad].PSGLength + road[iroad].CGLength + road[iroad].TGLength);
	if (Length > 0)
		str.Format(L"%0.3f", Length);
	else
		str.Format(L"%0.0f", Length);
	_tcscpy(chr, str);
	//spt = ptzs + 11.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	Length = fabs(road[iroad].PSAreaT + road[iroad].PSAreaW);
	if (Length > 0)
		str.Format(L"%0.3f", Length);
	else
		str.Format(L"%0.0f", Length);
	_tcscpy(chr, str);
	//spt = ptzs + 12.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	Length = fabs(road[iroad].PSGJQvolume + road[iroad].CGJQvolume + road[iroad].TGJQvolume);
	if (Length > 0)
		str.Format(L"%0.3f", Length);
	else
		str.Format(L"%0.0f", Length);
	_tcscpy(chr, str);
	//spt = ptzs + 13.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//安全设施
	_tcscpy(chr, L"0");
	//spt = ptzs + 14.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"0");
	//spt = ptzs + 15.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//绿地面积
	Length = fabs(road[iroad].L_BPArea + road[iroad].R_BPArea);
	str.Format(L"%0.3f", Length);
	_tcscpy(chr, str);
	//spt = ptzs + 16.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//排水管涵
	_tcscpy(chr, L"0");
	//spt = ptzs + 17.5*h1*vec2;
	//spt = spt + (d1 + 2 * d2 + d3 + d4 / 2) * vec1;
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);

	//路面宽度
	str.Format(L"%0.3f", fabs(road[iroad].hdmdes[0].RHFL[8]) + fabs(road[iroad].hdmdes[0].RHFR[8]));
	_tcscpy(chr, str);
	
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);

	//用地面积
	double Larea = 0, Rarea = 0;
	for (int i = 0; i < road[iroad].NCRS - 1; i++)
	{
		Larea += (road[iroad].hdmdes[i + 1].cml - road[iroad].hdmdes[i].cml)*road[iroad].hdmdes[i].LZDK;
		Rarea += (road[iroad].hdmdes[i + 1].cml - road[iroad].hdmdes[i].cml)*road[iroad].hdmdes[i].RZDK;
	}
	str.Format(L"%0.3f", (Larea+ Rarea)*3/2000.0);
	_tcscpy(chr, str);
	
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);

}

//输出工程数量表到Excel	20190915新增
//20200303梁柱
//函数参数，加分之，批量出图在else部分
//20200327梁柱，新增路面出表信息
std::vector<CString>LayerNames;
std::vector<double>LayerValues;
struct LmLayerinfor
{
	std::vector<CString>Layername;
	std::vector<double> depth;
	std::vector<double> aera;
	std::vector<bool>newlm;
}LmLayerInfor;
//20200327梁柱，新增路面出表信息
void HdmDes::ReadLmInfor()
{
	map<CString, double> RoadLayerMap;
	for (int i = 0; i < road[0].hdmbz.m_RoadLayerArray_L.size(); i++)
		RoadLayerMap[road[0].hdmbz.m_RoadLayerArray_L[i].LayerName] = road[0].hdmbz.m_RoadLayerArray_L[i].LayerThickness;
	for (int i = 0; i < road[0].hdmbz.m_RoadLayerArray_R.size(); i++)
		RoadLayerMap[road[0].hdmbz.m_RoadLayerArray_R[i].LayerName] = road[0].hdmbz.m_RoadLayerArray_R[i].LayerThickness;
	map<CString, double>::iterator map_it = RoadLayerMap.begin();
	LayerNames.clear();
	LayerValues.clear();

	while (map_it != RoadLayerMap.end())
	{
		bool flag = false;
		if (LmLayerInfor.Layername.size()==0)
		{
			LmLayerInfor.Layername.push_back(map_it->first);
			LmLayerInfor.depth.push_back(map_it->second);
			LmLayerInfor.newlm.push_back(true);
		}
		for (int i = 0; i < LmLayerInfor.Layername.size(); i++)
		{
			if (!_tcscmp(LmLayerInfor.Layername.at(i), map_it->first)&&fabs(LmLayerInfor.depth.at(i)-map_it->second)==0)
			{
				flag = true;
				
			}
		}
		if (flag==false)
		{
			LmLayerInfor.Layername.push_back(map_it->first);
			LmLayerInfor.depth.push_back(map_it->second);
			LmLayerInfor.newlm.push_back(true);
		}
		LayerNames.push_back(map_it->first);
		LayerValues.push_back(map_it->second);
		++map_it;
	}
}
//20200327梁柱，新增路面出表信息
void HdmDes::WriteQuantityToExcel(int iroad, bool One_excel, Worksheets m_ExcelWorksheets, int sheet_num)
{
	
	ReadLmInfor();
	CString LayerName;
	
	double LayeyValue;
	ACHAR LayerMes[40] = L"";
	int count = LayerNames.size() - 3;
	
	if (!One_excel)
	{
		//获取模板文件路径
		ACHAR OriFilePath[280];
		_stprintf(OriFilePath, L"%s\\lib\\用地模板.xlt", SysPath);

		ReadWorkdir();
		CString DesFilePath = Cworkdir + L"\\RESULT\\" + Pro + L".xls";

		CopyFile(OriFilePath, DesFilePath, false);

		//初始化Excel
		//设置参数
		_Application	ExcelApp;			//应用程序
		Workbooks		ExcelWorkBooks;		//工作集
		_Workbook		ExcelWorkBook;		//单个工作簿
		Worksheets		ExcelWorksheets;	//表(Sheet)集
		_Worksheet		ExcelWorksheet;		//单个表
		Range			ExcelRange;			//单元格
		//初始化程序
		if (!ExcelApp.CreateDispatch(L"Excel.Application", NULL))
		{
			AfxMessageBox(L"不能打开Excel表格!请确认Excel已经安装正确!");
			return;
		}

		//初始化工作簿、表集
		ExcelWorkBooks.AttachDispatch(ExcelApp.GetWorkbooks(), true);
		ExcelWorkBook.AttachDispatch(ExcelWorkBooks.Add(_variant_t(DesFilePath)));
		ExcelWorksheets.AttachDispatch(ExcelWorkBook.GetWorksheets(), true);


		ExcelWorksheet.AttachDispatch(ExcelWorksheets.GetItem(_variant_t(L"Sheet1")), true);
		//得到全部Cells，此时,rgMyRge是cells的集合 
		ExcelRange.AttachDispatch(ExcelWorksheet.GetCells(), true);

		//设置表格
		//第一行
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"A", L"C");
		ExcelRange.SetItem(_variant_t(1), _variant_t(1), _variant_t(L"工程项目"));
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"D", L"D");
		ExcelRange.SetItem(_variant_t(1), _variant_t(4), _variant_t(L"单位"));
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"E", L"E");
		ExcelRange.SetItem(_variant_t(1), _variant_t(5), _variant_t(L"数量"));
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"F", L"F");
		ExcelRange.SetItem(_variant_t(1), _variant_t(6), _variant_t(L"附注"));
		//左侧信息
		
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 4, 16+count, L"A", L"A");

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 4, 4, L"B", L"C");
		ExcelRange.SetItem(_variant_t(4), _variant_t(2), _variant_t(L"道路长度"));
		ExcelRange.SetItem(_variant_t(4), _variant_t(4), _variant_t(L"m"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 5, 7, L"B", L"B");
		ExcelRange.SetItem(_variant_t(5), _variant_t(2), _variant_t(L"断面土石方"));
		ExcelRange.SetItem(_variant_t(5), _variant_t(3), _variant_t(L"填方（含夯填土）"));
		ExcelRange.SetItem(_variant_t(6), _variant_t(3), _variant_t(L"挖土"));
		ExcelRange.SetItem(_variant_t(7), _variant_t(3), _variant_t(L"挖石"));
		for (int Line = 5; Line <= 7; Line++)
			ExcelRange.SetItem(_variant_t(Line), _variant_t(4), _variant_t(L"m³"));
		if (LayerNames.size()>0)
		{
			MergeCellInExcel(ExcelWorksheet, ExcelRange, 8, 8 + LayerNames.size() - 1, L"B", L"B");
			ExcelRange.SetItem(_variant_t(8), _variant_t(2), _variant_t(L"路面面积"));
			for (int i = 0; i < LayerNames.size(); i++)
			{
				_stprintf(LayerMes, L"%s（厚%.3lfm）", LayerNames.at(i), LayerValues.at(i));
				ExcelRange.SetItem(_variant_t(8 + i), _variant_t(3), _variant_t(LayerMes));
				ExcelRange.SetItem(_variant_t(8 + i), _variant_t(4), _variant_t(L"m²"));
				_tcscpy(LayerMes, L"");
			}

		}
		
		/*ExcelRange.SetItem(_variant_t(8), _variant_t(3), _variant_t(L"C25混凝土面层（厚0.23m）"));
		ExcelRange.SetItem(_variant_t(9), _variant_t(3), _variant_t(L"5%水泥稳定碎石（厚0.18m）"));
		ExcelRange.SetItem(_variant_t(10), _variant_t(3), _variant_t(L"碎石路面（厚0.18m）"));*/
		/*for (int Line = 8; Line <= 10; Line++)
			ExcelRange.SetItem(_variant_t(Line), _variant_t(4), _variant_t(L"m²"));*/

		ExcelRange.SetItem(_variant_t(11+ count), _variant_t(2), _variant_t(L"支挡工程"));
		ExcelRange.SetItem(_variant_t(11 + count), _variant_t(3), _variant_t(L"C15片石混凝土"));
		ExcelRange.SetItem(_variant_t(11 + count), _variant_t(4), _variant_t(L"m³"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 12 + count, 14 + count, L"B", L"B");
		ExcelRange.SetItem(_variant_t(12 + count), _variant_t(2), _variant_t(L"附属工程"));
		ExcelRange.SetItem(_variant_t(12 + count), _variant_t(3), _variant_t(L"水沟长度"));
		ExcelRange.SetItem(_variant_t(13 + count), _variant_t(3), _variant_t(L"土石方"));
		ExcelRange.SetItem(_variant_t(14 + count), _variant_t(3), _variant_t(L"M7.5浆砌片石"));
		ExcelRange.SetItem(_variant_t(12 + count), _variant_t(4), _variant_t(L"m"));
		ExcelRange.SetItem(_variant_t(13 + count), _variant_t(4), _variant_t(L"m³"));
		ExcelRange.SetItem(_variant_t(14 + count), _variant_t(4), _variant_t(L"m³"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 15 + count, 16 + count, L"B", L"B");
		ExcelRange.SetItem(_variant_t(15 + count), _variant_t(2), _variant_t(L"安全设施"));
		ExcelRange.SetItem(_variant_t(15 + count), _variant_t(3), _variant_t(L"路侧式B级双波波形梁护栏"));
		ExcelRange.SetItem(_variant_t(16 + count), _variant_t(3), _variant_t(L"钢筋混凝土护栏"));
		ExcelRange.SetItem(_variant_t(15 + count), _variant_t(4), _variant_t(L"m"));
		ExcelRange.SetItem(_variant_t(16 + count), _variant_t(4), _variant_t(L"m³"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 17 + count, 17 + count, L"A", L"C");
		ExcelRange.SetItem(_variant_t(17 + count), _variant_t(1), _variant_t(L"绿地面积"));
		ExcelRange.SetItem(_variant_t(17 + count), _variant_t(4), _variant_t(L"m²"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 18 + count, 18 + count, L"A", L"C");
		ExcelRange.SetItem(_variant_t(18 + count), _variant_t(1), _variant_t(L"排水涵管"));
		ExcelRange.SetItem(_variant_t(18 + count), _variant_t(4), _variant_t(L"m"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 19 + count, 19 + count, L"A", L"C");
		ExcelRange.SetItem(_variant_t(19 + count), _variant_t(1), _variant_t(L"路面宽度"));
		ExcelRange.SetItem(_variant_t(19 + count), _variant_t(4), _variant_t(L"m"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 20 + count, 20 + count, L"A", L"C");
		ExcelRange.SetItem(_variant_t(20 + count), _variant_t(1), _variant_t(L"用地面积"));
		ExcelRange.SetItem(_variant_t(20 + count), _variant_t(4), _variant_t(L"亩"));
		//写内容
		//道路长度
		double Length;
		CString str;
		Length = fabs(road[iroad].hdmdes[0].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml);
		str.Format(L"%0.3f", Length);
		ExcelRange.SetItem(_variant_t(4), _variant_t(5), _variant_t(str));

		//断面土石方
		//填方
		str.Format(L"%0.3f", road[iroad].DMAreaT);
		ExcelRange.SetItem(_variant_t(5), _variant_t(5), _variant_t(str));
		//挖方
		str.Format(L"%0.3f", road[iroad].DMAreaW);
		ExcelRange.SetItem(_variant_t(6), _variant_t(5), _variant_t(str));
		//挖石
		str.Format(L"0");
		ExcelRange.SetItem(_variant_t(7), _variant_t(5), _variant_t(str));

		//路面面积
		for (int i = 0; i < LayerNames.size(); i++)
		{
			str.Format(L"%0.3f", road[iroad].LMArea);
			ExcelRange.SetItem(_variant_t(8+i), _variant_t(5), _variant_t(str));
		}
		/*str.Format(L"%0.3f", road[iroad].LMArea);
		ExcelRange.SetItem(_variant_t(8 ), _variant_t(5), _variant_t(str));
		str.Format(L"%0.3f", road[iroad].LMArea);
		ExcelRange.SetItem(_variant_t(9 + count), _variant_t(5), _variant_t(str));
		str.Format(L"0");
		ExcelRange.SetItem(_variant_t(10 + count), _variant_t(5), _variant_t(str));*/

		//支挡工程
		str.Format(L"0");
		ExcelRange.SetItem(_variant_t(11 + count), _variant_t(5), _variant_t(str));

		//附属工程
		//水沟长度
		Length = fabs(road[iroad].PSGLength + road[iroad].CGLength + road[iroad].TGLength);
		if (Length > 0)
			str.Format(L"%0.3f", Length);
		else
			str.Format(L"%0.0f", Length);
		ExcelRange.SetItem(_variant_t(12 + count), _variant_t(5), _variant_t(str));
		//土石方
		Length = fabs(road[iroad].PSAreaT + road[iroad].PSAreaW);
		if (Length > 0)
			str.Format(L"%0.3f", Length);
		else
			str.Format(L"%0.0f", Length);
		ExcelRange.SetItem(_variant_t(13 + count), _variant_t(5), _variant_t(str));
		//浆砌片石
		Length = fabs(road[iroad].PSGJQvolume + road[iroad].CGJQvolume + road[iroad].TGJQvolume);
		if (Length > 0)
			str.Format(L"%0.3f", Length);
		else
			str.Format(L"%0.0f", Length);
		ExcelRange.SetItem(_variant_t(14 + count), _variant_t(5), _variant_t(str));

		//安全设施
		str.Format(L"0");
		ExcelRange.SetItem(_variant_t(15 + count), _variant_t(5), _variant_t(str));
		str.Format(L"0");
		ExcelRange.SetItem(_variant_t(16 + count), _variant_t(5), _variant_t(str));

		//绿地面积
		Length = fabs(road[iroad].L_BPArea + road[iroad].R_BPArea);
		str.Format(L"%0.3f", Length);
		ExcelRange.SetItem(_variant_t(17 + count), _variant_t(5), _variant_t(str));

		//排水管涵
		str.Format(L"0");
		ExcelRange.SetItem(_variant_t(18 + count), _variant_t(5), _variant_t(str));

		//路面宽度
		str.Format(L"%0.3f", fabs(road[iroad].hdmdes[0].RHFL[8]) + fabs(road[iroad].hdmdes[0].RHFR[8]));
		ExcelRange.SetItem(_variant_t(19 + count), _variant_t(5), _variant_t(str));

		//用地面积
		double Larea=0, Rarea=0;
		for (int i = 0; i < road[iroad].NCRS-1; i++)
		{
			Larea += (road[iroad].hdmdes[i+1].cml-road[iroad].hdmdes[i].cml)*road[iroad].hdmdes[i].LZDK;
			Rarea += (road[iroad].hdmdes[i + 1].cml - road[iroad].hdmdes[i].cml)*road[iroad].hdmdes[i].RZDK;
		}
		
		str.Format(L"%0.3f", (Larea+Rarea)*3/2000.0);
		ExcelRange.SetItem(_variant_t(20 + count), _variant_t(5), _variant_t(str));

		//设置宽度
		Range Cols;
		ExcelRange.ReleaseDispatch();
		LPDISPATCH pd = NULL;
		ACHAR scp[10];
		ACHAR fcp[10];
		_stprintf(scp, L"%s%ld", L"A", 1);
		_stprintf(fcp, L"%s%ld", L"F", 18);
		VERIFY(pd = ExcelWorksheet.GetRange(COleVariant(scp), COleVariant(fcp)));
		ExcelRange.AttachDispatch(pd);
		Cols = ExcelRange.GetEntireColumn();
		Cols.AutoFit();

		//断开连接
		ExcelRange.ReleaseDispatch();

		ExcelWorksheet.Activate();
		ExcelApp.SetVisible(true);
		ExcelApp.SetUserControl(true);   //调用excel表

		ExcelWorksheet.ReleaseDispatch();
		ExcelWorksheets.ReleaseDispatch();
		ExcelWorkBook.ReleaseDispatch();
		ExcelWorkBooks.ReleaseDispatch();
		ExcelWorkBook.Close(_variant_t((long)1), _variant_t(), _variant_t());
		ExcelWorkBooks.Close();

		ExcelApp.Quit();
		ExcelApp.ReleaseDispatch();
	}
	else
	{
		////获取模板文件路径

		_Worksheet		ExcelWorksheet;		//单个表
		Range			ExcelRange;			//单元格

		VARIANT varOptional;
		VariantInit(&varOptional);
		varOptional.vt = VT_ERROR;
		varOptional.scode = DISP_E_PARAMNOTFOUND;
		CString mes;
		if (sheet_num <= 2)
		{
			mes.Format(L"Sheet%d", sheet_num + 1);
		}
		else
		{
			mes.Format(L"Sheet%d", sheet_num + 1);
			m_ExcelWorksheets.Add(varOptional, varOptional, varOptional, varOptional);
		}
		//double RoadLen, FillEarWok, CutEarWok, CutStnWok, C25, BrkStn, BrkPav, C15, GutLen, EarWok, M75, B, Steel, GreAre, HanGuan;
		//mes.Format(L"Sheet%d", sheet_num);
		ExcelWorksheet.AttachDispatch(m_ExcelWorksheets.GetItem(_variant_t(mes)), true);
		CString name = L"";
		name.Format(L"工程项目（%s）", Pro);
		//ExcelWorksheet.SetName(name);
		//ExcelWorksheet.Move(varOptional, varOptional);
		//得到全部Cells，此时,rgMyRge是cells的集合 
		ExcelRange.AttachDispatch(ExcelWorksheet.GetCells(), true);
		
		//设置表格
		//第一行
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"A", L"C");
		ExcelRange.SetItem(_variant_t(1), _variant_t(1), _variant_t(name));
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"D", L"D");
		ExcelRange.SetItem(_variant_t(1), _variant_t(4), _variant_t(L"单位"));
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"E", L"E");
		ExcelRange.SetItem(_variant_t(1), _variant_t(5), _variant_t(L"数量"));
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"F", L"F");
		ExcelRange.SetItem(_variant_t(1), _variant_t(6), _variant_t(L"附注"));
		//左侧信息
		
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 4, 16+count, L"A", L"A");

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 4, 4, L"B", L"C");
		ExcelRange.SetItem(_variant_t(4), _variant_t(2), _variant_t(L"道路长度"));
		ExcelRange.SetItem(_variant_t(4), _variant_t(4), _variant_t(L"m"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 5, 7, L"B", L"B");
		ExcelRange.SetItem(_variant_t(5), _variant_t(2), _variant_t(L"断面土石方"));
		ExcelRange.SetItem(_variant_t(5), _variant_t(3), _variant_t(L"填方（含夯填土）"));
		ExcelRange.SetItem(_variant_t(6), _variant_t(3), _variant_t(L"挖土"));
		ExcelRange.SetItem(_variant_t(7), _variant_t(3), _variant_t(L"挖石"));
		for (int Line = 5; Line <= 7; Line++)
			ExcelRange.SetItem(_variant_t(Line), _variant_t(4), _variant_t(L"m³"));
		///////////////////
		if (LayerNames.size()>0)
		{
			MergeCellInExcel(ExcelWorksheet, ExcelRange, 8, 10 + count, L"B", L"B");
			ExcelRange.SetItem(_variant_t(8), _variant_t(2), _variant_t(L"路面面积"));
			for (int i = 0; i < LayerNames.size(); i++)
			{
				_stprintf(LayerMes, L"%s（厚%.3lfm）", LayerNames.at(i), LayerValues.at(i));
				ExcelRange.SetItem(_variant_t(8 + i), _variant_t(3), _variant_t(LayerMes));
				ExcelRange.SetItem(_variant_t(8 + i), _variant_t(4), _variant_t(L"m²"));
				_tcscpy(LayerMes, L"");
			}

		}
		
		/*MergeCellInExcel(ExcelWorksheet, ExcelRange, 8, 10, L"B", L"B");
		ExcelRange.SetItem(_variant_t(8), _variant_t(2), _variant_t(L"路面面积"));
		ExcelRange.SetItem(_variant_t(8), _variant_t(3), _variant_t(L"C25混凝土面层（厚0.23m）"));
		ExcelRange.SetItem(_variant_t(9), _variant_t(3), _variant_t(L"5%水泥稳定碎石（厚0.18m）"));
		ExcelRange.SetItem(_variant_t(10), _variant_t(3), _variant_t(L"碎石路面（厚0.18m）"));
		for (int Line = 8; Line <= 10; Line++)
			ExcelRange.SetItem(_variant_t(Line), _variant_t(4), _variant_t(L"m²"));*/

		ExcelRange.SetItem(_variant_t(11 + count), _variant_t(2), _variant_t(L"支挡工程"));
		ExcelRange.SetItem(_variant_t(11 + count), _variant_t(3), _variant_t(L"C15片石混凝土"));
		ExcelRange.SetItem(_variant_t(11 + count), _variant_t(4), _variant_t(L"m³"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 12 + count, 14 + count, L"B", L"B");
		ExcelRange.SetItem(_variant_t(12 + count), _variant_t(2), _variant_t(L"附属工程"));
		ExcelRange.SetItem(_variant_t(12 + count), _variant_t(3), _variant_t(L"水沟长度"));
		ExcelRange.SetItem(_variant_t(13 + count), _variant_t(3), _variant_t(L"土石方"));
		ExcelRange.SetItem(_variant_t(14 + count), _variant_t(3), _variant_t(L"M7.5浆砌片石"));
		ExcelRange.SetItem(_variant_t(12 + count), _variant_t(4), _variant_t(L"m"));
		ExcelRange.SetItem(_variant_t(13 + count), _variant_t(4), _variant_t(L"m³"));
		ExcelRange.SetItem(_variant_t(14 + count), _variant_t(4), _variant_t(L"m³"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 15 + count, 16 + count, L"B", L"B");
		ExcelRange.SetItem(_variant_t(15 + count), _variant_t(2), _variant_t(L"安全设施"));
		ExcelRange.SetItem(_variant_t(15 + count), _variant_t(3), _variant_t(L"路侧式B级双波波形梁护栏"));
		ExcelRange.SetItem(_variant_t(16 + count), _variant_t(3), _variant_t(L"钢筋混凝土护栏"));
		ExcelRange.SetItem(_variant_t(15 + count), _variant_t(4), _variant_t(L"m"));
		ExcelRange.SetItem(_variant_t(16 + count), _variant_t(4), _variant_t(L"m³"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 17 + count, 17 + count, L"A", L"C");
		ExcelRange.SetItem(_variant_t(17 + count), _variant_t(1), _variant_t(L"绿地面积"));
		ExcelRange.SetItem(_variant_t(17 + count), _variant_t(4), _variant_t(L"m²"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 18 + count, 18 + count, L"A", L"C");
		ExcelRange.SetItem(_variant_t(18 + count), _variant_t(1), _variant_t(L"排水涵管"));
		ExcelRange.SetItem(_variant_t(18 + count), _variant_t(4), _variant_t(L"m"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 19 + count, 19 + count, L"A", L"C");
		ExcelRange.SetItem(_variant_t(19 + count), _variant_t(1), _variant_t(L"路面宽度"));
		ExcelRange.SetItem(_variant_t(19 + count), _variant_t(4), _variant_t(L"m"));

		MergeCellInExcel(ExcelWorksheet, ExcelRange, 20 + count, 20 + count, L"A", L"C");
		ExcelRange.SetItem(_variant_t(20 + count), _variant_t(1), _variant_t(L"用地面积"));
		ExcelRange.SetItem(_variant_t(20 + count), _variant_t(4), _variant_t(L"亩"));

		//写内容
		//道路长度
		double Length;
		CString str;
		Length = fabs(road[iroad].hdmdes[0].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml);
		//20200322梁柱添加，汇总表统计数据，下同；
		RoadLen += Length;
		str.Format(L"%0.3f", Length);
		ExcelRange.SetItem(_variant_t(4), _variant_t(5), _variant_t(str));

		//断面土石方
		//填方
		FillEarWok += road[iroad].DMAreaT;
		str.Format(L"%0.3f", road[iroad].DMAreaT);
		ExcelRange.SetItem(_variant_t(5), _variant_t(5), _variant_t(str));
		//挖方
		CutEarWok += road[iroad].DMAreaW;
		str.Format(L"%0.3f", road[iroad].DMAreaW);
		ExcelRange.SetItem(_variant_t(6), _variant_t(5), _variant_t(str));
		//挖石
		CutStnWok += 0;
		str.Format(L"0");
		ExcelRange.SetItem(_variant_t(7), _variant_t(5), _variant_t(str));

		//路面面积
		for (int j = 0; j < LayerNames.size(); j++)
		{
			for (int i = 0; i < LmLayerInfor.Layername.size(); i++)
			{
				if (LmLayerInfor.newlm.at(i))
				{
					LmLayerInfor.aera.push_back(road[iroad].LMArea);
					LmLayerInfor.newlm.at(i) = false;
				}
				else
				{
					if (!_tcscmp(LmLayerInfor.Layername.at(i), LayerNames.at(j))&&fabs(LmLayerInfor.depth.at(i)-LayerValues.at(j))==0)
					{
						LmLayerInfor.aera.at(i) += road[iroad].LMArea;
					}
				}
			}
		}
		
		for (int i = 0; i < LayerNames.size(); i++)
		{
			str.Format(L"%0.3f", road[iroad].LMArea);
			ExcelRange.SetItem(_variant_t(8 + i), _variant_t(5), _variant_t(str));
		}
		//C25 += road[iroad].LMArea;
		/*str.Format(L"%0.3f", road[iroad].LMArea);
		ExcelRange.SetItem(_variant_t(8 + count), _variant_t(5), _variant_t(str));
		BrkStn += road[iroad].LMArea;
		str.Format(L"%0.3f", road[iroad].LMArea);
		ExcelRange.SetItem(_variant_t(9 + count), _variant_t(5), _variant_t(str));
		str.Format(L"0");
		BrkPav += 0;
		ExcelRange.SetItem(_variant_t(10 + count), _variant_t(5), _variant_t(str));*/

		//支挡工程
		str.Format(L"0");
		C15 += 0;
		ExcelRange.SetItem(_variant_t(11 + count), _variant_t(5), _variant_t(str));

		//附属工程
		//水沟长度

		Length = fabs(road[iroad].PSGLength + road[iroad].CGLength + road[iroad].TGLength);
		if (Length > 0)
			str.Format(L"%0.3f", Length);
		else
			str.Format(L"%0.0f", Length);
		GutLen += Length;
		ExcelRange.SetItem(_variant_t(12 + count), _variant_t(5), _variant_t(str));
		//土石方
		Length = fabs(road[iroad].PSAreaT + road[iroad].PSAreaW);
		EarWok += Length;
		if (Length > 0)
			str.Format(L"%0.3f", Length);
		else
			str.Format(L"%0.0f", Length);
		ExcelRange.SetItem(_variant_t(13 + count), _variant_t(5), _variant_t(str));
		//浆砌片石
		Length = fabs(road[iroad].PSGJQvolume + road[iroad].CGJQvolume + road[iroad].TGJQvolume);
		M75 += Length;
		if (Length > 0)
			str.Format(L"%0.3f", Length);
		else
			str.Format(L"%0.0f", Length);
		ExcelRange.SetItem(_variant_t(14 + count), _variant_t(5), _variant_t(str));

		//安全设施
		str.Format(L"0");
		B += 0;
		ExcelRange.SetItem(_variant_t(15 + count), _variant_t(5), _variant_t(str));
		str.Format(L"0");
		Steel = 0;
		ExcelRange.SetItem(_variant_t(16 + count), _variant_t(5), _variant_t(str));

		//绿地面积
		Length = fabs(road[iroad].L_BPArea + road[iroad].R_BPArea);
		GreAre += Length;
		str.Format(L"%0.3f", Length);
		ExcelRange.SetItem(_variant_t(17 + count), _variant_t(5), _variant_t(str));

		//排水管涵
		str.Format(L"0");
		HanGuan += 0;
		ExcelRange.SetItem(_variant_t(18 + count), _variant_t(5), _variant_t(str));

		//路面宽度
		str.Format(L"%0.3f", fabs(road[iroad].hdmdes[0].RHFL[8]) + fabs(road[iroad].hdmdes[0].RHFR[8]));
		ExcelRange.SetItem(_variant_t(19 + count), _variant_t(5), _variant_t(str));

		//用地面积
		double Larea = 0, Rarea = 0;
		for (int i = 0; i < road[iroad].NCRS - 1; i++)
		{
			Larea += (road[iroad].hdmdes[i + 1].cml - road[iroad].hdmdes[i].cml)*road[iroad].hdmdes[i].LZDK;
			Rarea += (road[iroad].hdmdes[i + 1].cml - road[iroad].hdmdes[i].cml)*road[iroad].hdmdes[i].RZDK;
		}

		str.Format(L"%0.3f", (Larea + Rarea) * 3 / 2000.0);
		YDAllArea += (Larea + Rarea) * 3 / 2000.0;
		ExcelRange.SetItem(_variant_t(20 + count), _variant_t(5), _variant_t(str));

		//设置宽度
		Range Cols;
		ExcelRange.ReleaseDispatch();
		LPDISPATCH pd = NULL;
		ACHAR scp[10];
		ACHAR fcp[10];
		_stprintf(scp, L"%s%ld", L"A", 1);
		_stprintf(fcp, L"%s%ld", L"F", 18);
		VERIFY(pd = ExcelWorksheet.GetRange(COleVariant(scp), COleVariant(fcp)));
		ExcelRange.AttachDispatch(pd);
		Cols = ExcelRange.GetEntireColumn();
		Cols.AutoFit();



		//断开连接
		ExcelRange.ReleaseDispatch();

		ExcelWorksheet.Activate();
		//ExcelApp.SetVisible(true);
		//ExcelApp.SetUserControl(true);   //调用excel表

		ExcelWorksheet.ReleaseDispatch();
		//ExcelWorksheets.ReleaseDispatch();
		//ExcelWorkBook.ReleaseDispatch();
		//ExcelWorkBooks.ReleaseDispatch();
		//ExcelWorkBook.Close(_variant_t((long)1), _variant_t(), _variant_t());
		//ExcelWorkBooks.Close();

		//ExcelApp.Quit();
		//ExcelApp.ReleaseDispatch();
	}
	////获取模板文件路径
	//ACHAR OriFilePath[280];
	//_stprintf(OriFilePath, L"%s\\lib\\用地模板.xlt", SysPath);

	//ReadWorkdir();
	//CString DesFilePath = Cworkdir + L"\\RESULT\\" + Pro + L".xls";

	//CopyFile(OriFilePath, DesFilePath, false);

	////初始化Excel
	////设置参数
	//_Application	ExcelApp;			//应用程序
	//Workbooks		ExcelWorkBooks;		//工作集
	//_Workbook		ExcelWorkBook;		//单个工作簿
	//Worksheets		ExcelWorksheets;	//表(Sheet)集
	//_Worksheet		ExcelWorksheet;		//单个表
	//Range			ExcelRange;			//单元格
	////初始化程序
	//if (!ExcelApp.CreateDispatch(L"Excel.Application", NULL))
	//{
	//	AfxMessageBox(L"不能打开Excel表格!请确认Excel已经安装正确!");
	//	return;
	//}

	////初始化工作簿、表集
	//ExcelWorkBooks.AttachDispatch(ExcelApp.GetWorkbooks(), true);
	//ExcelWorkBook.AttachDispatch(ExcelWorkBooks.Add(_variant_t(DesFilePath)));
	//ExcelWorksheets.AttachDispatch(ExcelWorkBook.GetWorksheets(), true);


	//ExcelWorksheet.AttachDispatch(ExcelWorksheets.GetItem(_variant_t(L"Sheet1")), true);
	////得到全部Cells，此时,rgMyRge是cells的集合 
	//ExcelRange.AttachDispatch(ExcelWorksheet.GetCells(), true);

	////设置表格
	////第一行
	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"A", L"C");
	//ExcelRange.SetItem(_variant_t(1), _variant_t(1), _variant_t(L"工程项目"));
	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"D", L"D");
	//ExcelRange.SetItem(_variant_t(1), _variant_t(4), _variant_t(L"单位"));
	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"E", L"E");
	//ExcelRange.SetItem(_variant_t(1), _variant_t(5), _variant_t(L"数量"));
	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"F", L"F");
	//ExcelRange.SetItem(_variant_t(1), _variant_t(6), _variant_t(L"附注"));
	////左侧信息
	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 4, 16, L"A", L"A");

	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 4, 4, L"B", L"C");
	//ExcelRange.SetItem(_variant_t(4), _variant_t(2), _variant_t(L"道路长度"));
	//ExcelRange.SetItem(_variant_t(4), _variant_t(4), _variant_t(L"m"));

	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 5, 7, L"B", L"B");
	//ExcelRange.SetItem(_variant_t(5), _variant_t(2), _variant_t(L"断面土石方"));
	//ExcelRange.SetItem(_variant_t(5), _variant_t(3), _variant_t(L"填方（含夯填土）"));
	//ExcelRange.SetItem(_variant_t(6), _variant_t(3), _variant_t(L"挖土"));
	//ExcelRange.SetItem(_variant_t(7), _variant_t(3), _variant_t(L"挖石"));
	//for (int Line = 5; Line <= 7; Line++)
	//	ExcelRange.SetItem(_variant_t(Line), _variant_t(4), _variant_t(L"m³"));

	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 8, 10, L"B", L"B");
	//ExcelRange.SetItem(_variant_t(8), _variant_t(2), _variant_t(L"路面面积"));
	//ExcelRange.SetItem(_variant_t(8), _variant_t(3), _variant_t(L"C25混凝土面层（厚0.23m）"));
	//ExcelRange.SetItem(_variant_t(9), _variant_t(3), _variant_t(L"5%水泥稳定碎石（厚0.18m）"));
	//ExcelRange.SetItem(_variant_t(10), _variant_t(3), _variant_t(L"碎石路面（厚0.18m）"));
	//for (int Line = 8; Line <= 10; Line++)
	//	ExcelRange.SetItem(_variant_t(Line), _variant_t(4), _variant_t(L"m²"));

	//ExcelRange.SetItem(_variant_t(11), _variant_t(2), _variant_t(L"支挡工程"));
	//ExcelRange.SetItem(_variant_t(11), _variant_t(3), _variant_t(L"C15片石混凝土"));
	//ExcelRange.SetItem(_variant_t(11), _variant_t(4), _variant_t(L"m³"));

	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 12, 14, L"B", L"B");
	//ExcelRange.SetItem(_variant_t(12), _variant_t(2), _variant_t(L"附属工程"));
	//ExcelRange.SetItem(_variant_t(12), _variant_t(3), _variant_t(L"水沟长度"));
	//ExcelRange.SetItem(_variant_t(13), _variant_t(3), _variant_t(L"土石方"));
	//ExcelRange.SetItem(_variant_t(14), _variant_t(3), _variant_t(L"M7.5浆砌片石"));
	//ExcelRange.SetItem(_variant_t(12), _variant_t(4), _variant_t(L"m"));
	//ExcelRange.SetItem(_variant_t(13), _variant_t(4), _variant_t(L"m³"));
	//ExcelRange.SetItem(_variant_t(14), _variant_t(4), _variant_t(L"m³"));

	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 15, 16, L"B", L"B");
	//ExcelRange.SetItem(_variant_t(15), _variant_t(2), _variant_t(L"安全设施"));
	//ExcelRange.SetItem(_variant_t(15), _variant_t(3), _variant_t(L"路侧式B级双波波形梁护栏"));
	//ExcelRange.SetItem(_variant_t(16), _variant_t(3), _variant_t(L"钢筋混凝土护栏"));
	//ExcelRange.SetItem(_variant_t(15), _variant_t(4), _variant_t(L"m"));
	//ExcelRange.SetItem(_variant_t(16), _variant_t(4), _variant_t(L"m³"));

	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 17, 17, L"A", L"C");
	//ExcelRange.SetItem(_variant_t(17), _variant_t(1), _variant_t(L"绿地面积"));
	//ExcelRange.SetItem(_variant_t(17), _variant_t(4), _variant_t(L"m²"));

	//MergeCellInExcel(ExcelWorksheet, ExcelRange, 18, 18, L"A", L"C");
	//ExcelRange.SetItem(_variant_t(18), _variant_t(1), _variant_t(L"排水涵管"));
	//ExcelRange.SetItem(_variant_t(18), _variant_t(4), _variant_t(L"m"));

	////写内容
	////道路长度
	//double Length;
	//CString str;
	//Length = fabs(road[iroad].hdmdes[0].cml - road[iroad].hdmdes[road[iroad].NCRS - 1].cml);
	//str.Format(L"%0.3f", Length);
	//ExcelRange.SetItem(_variant_t(4), _variant_t(5), _variant_t(str));

	////断面土石方
	////填方
	//str.Format(L"%0.3f", road[iroad].DMAreaT);
	//ExcelRange.SetItem(_variant_t(5), _variant_t(5), _variant_t(str));
	////挖方
	//str.Format(L"%0.3f", road[iroad].DMAreaW);
	//ExcelRange.SetItem(_variant_t(6), _variant_t(5), _variant_t(str));
	////挖石
	//str.Format(L"0");
	//ExcelRange.SetItem(_variant_t(7), _variant_t(5), _variant_t(str));

	////路面面积
	//str.Format(L"%0.3f", road[iroad].LMArea);
	//ExcelRange.SetItem(_variant_t(8), _variant_t(5), _variant_t(str));
	//str.Format(L"%0.3f", road[iroad].LMArea);
	//ExcelRange.SetItem(_variant_t(9), _variant_t(5), _variant_t(str));
	//str.Format(L"0");
	//ExcelRange.SetItem(_variant_t(10), _variant_t(5), _variant_t(str));

	////支挡工程
	//str.Format(L"0");
	//ExcelRange.SetItem(_variant_t(11), _variant_t(5), _variant_t(str));

	////附属工程
	////水沟长度
	//Length = fabs(road[iroad].PSGLength + road[iroad].CGLength + road[iroad].TGLength);
	//if (Length > 0)
	//	str.Format(L"%0.3f", Length);
	//else
	//	str.Format(L"%0.0f", Length);
	//ExcelRange.SetItem(_variant_t(12), _variant_t(5), _variant_t(str));
	////土石方
	//Length = fabs(road[iroad].PSAreaT + road[iroad].PSAreaW);
	//if (Length > 0)
	//	str.Format(L"%0.3f", Length);
	//else
	//	str.Format(L"%0.0f", Length);
	//ExcelRange.SetItem(_variant_t(13), _variant_t(5), _variant_t(str));
	////浆砌片石
	//Length = fabs(road[iroad].PSGJQvolume + road[iroad].CGJQvolume + road[iroad].TGJQvolume);
	//if (Length > 0)
	//	str.Format(L"%0.3f", Length);
	//else
	//	str.Format(L"%0.0f", Length);
	//ExcelRange.SetItem(_variant_t(14), _variant_t(5), _variant_t(str));

	////安全设施
	//str.Format(L"0");
	//ExcelRange.SetItem(_variant_t(15), _variant_t(5), _variant_t(str));
	//str.Format(L"0");
	//ExcelRange.SetItem(_variant_t(16), _variant_t(5), _variant_t(str));

	////绿地面积
	//Length = fabs(road[iroad].L_BPArea + road[iroad].R_BPArea);
	//str.Format(L"%0.3f", Length);
	//ExcelRange.SetItem(_variant_t(17), _variant_t(5), _variant_t(str));

	////排水管涵
	//str.Format(L"0");
	//ExcelRange.SetItem(_variant_t(18), _variant_t(5), _variant_t(str));

	////设置宽度
	//Range Cols;
	//ExcelRange.ReleaseDispatch();
	//LPDISPATCH pd = NULL;
	//ACHAR scp[10];
	//ACHAR fcp[10];
	//_stprintf(scp, L"%s%ld", L"A", 1);
	//_stprintf(fcp, L"%s%ld", L"F", 18);
	//VERIFY(pd = ExcelWorksheet.GetRange(COleVariant(scp), COleVariant(fcp)));
	//ExcelRange.AttachDispatch(pd);
	//Cols = ExcelRange.GetEntireColumn();
	//Cols.AutoFit();

	////断开连接
	//ExcelRange.ReleaseDispatch();

	//ExcelWorksheet.Activate();
	//ExcelApp.SetVisible(true);
	//ExcelApp.SetUserControl(true);   //调用excel表

	//ExcelWorksheet.ReleaseDispatch();
	//ExcelWorksheets.ReleaseDispatch();
	//ExcelWorkBook.ReleaseDispatch();
	//ExcelWorkBooks.ReleaseDispatch();
	//ExcelWorkBook.Close(_variant_t((long)1), _variant_t(), _variant_t());
	//ExcelWorkBooks.Close();

	//ExcelApp.Quit();
	//ExcelApp.ReleaseDispatch();
}
//20200327梁柱，新增路面出表信息
void HdmDes::WriteQuantityToExcel_all(int iroad, bool One_excel, Worksheets m_ExcelWorksheets)
{



	_Worksheet		ExcelWorksheet;		//单个表
	Range			ExcelRange;			//单元格

	
	CString mes;
	
	mes.Format(L"Sheet%d", 1);
	
	
	
	ExcelWorksheet.AttachDispatch(m_ExcelWorksheets.GetItem(_variant_t(mes)), true);
	ExcelWorksheet.SetName(L"工程项目汇总表");
	ExcelRange.AttachDispatch(ExcelWorksheet.GetCells(), true);
	CString name = L"";
	name.Format(L"工程项目汇总表");
	//设置表格
	//第一行
	MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"A", L"C");
	ExcelRange.SetItem(_variant_t(1), _variant_t(1), _variant_t(name));
	MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"D", L"D");
	ExcelRange.SetItem(_variant_t(1), _variant_t(4), _variant_t(L"单位"));
	MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"E", L"E");
	ExcelRange.SetItem(_variant_t(1), _variant_t(5), _variant_t(L"数量"));
	MergeCellInExcel(ExcelWorksheet, ExcelRange, 1, 3, L"F", L"F");
	ExcelRange.SetItem(_variant_t(1), _variant_t(6), _variant_t(L"附注"));
	//左侧信息
	int num = LmLayerInfor.Layername.size() - 3;
	MergeCellInExcel(ExcelWorksheet, ExcelRange, 4, 16+num, L"A", L"A");

	MergeCellInExcel(ExcelWorksheet, ExcelRange, 4, 4, L"B", L"C");
	ExcelRange.SetItem(_variant_t(4), _variant_t(2), _variant_t(L"道路总长度"));
	ExcelRange.SetItem(_variant_t(4), _variant_t(4), _variant_t(L"m"));

	MergeCellInExcel(ExcelWorksheet, ExcelRange, 5, 7, L"B", L"B");
	ExcelRange.SetItem(_variant_t(5), _variant_t(2), _variant_t(L"断面总土石方"));
	ExcelRange.SetItem(_variant_t(5), _variant_t(3), _variant_t(L"总填方（含夯填土）"));
	ExcelRange.SetItem(_variant_t(6), _variant_t(3), _variant_t(L"总挖土"));
	ExcelRange.SetItem(_variant_t(7), _variant_t(3), _variant_t(L"总挖石"));
	for (int Line = 5; Line <= 7; Line++)
		ExcelRange.SetItem(_variant_t(Line), _variant_t(4), _variant_t(L"m³"));
	
	if (LmLayerInfor.Layername.size() >0)
	{
		ACHAR lmnane[40] = L"";
		MergeCellInExcel(ExcelWorksheet, ExcelRange, 8, 10+num, L"B", L"B");
		ExcelRange.SetItem(_variant_t(8), _variant_t(2), _variant_t(L"路面总面积"));
		for (int i = 0; i < LmLayerInfor.Layername.size(); i++)
		{
			_stprintf(lmnane,L"%s(厚%0.3lfm)",LmLayerInfor.Layername.at(i), LmLayerInfor.depth.at(i));
			ExcelRange.SetItem(_variant_t(8+i), _variant_t(3), _variant_t(lmnane));
			ExcelRange.SetItem(_variant_t(8+i), _variant_t(4), _variant_t(L"m²"));
			_tcscpy(lmnane,L"");
		}
	}
	/*MergeCellInExcel(ExcelWorksheet, ExcelRange, 8, 10, L"B", L"B");
	ExcelRange.SetItem(_variant_t(8), _variant_t(2), _variant_t(L"路面总面积"));
	ExcelRange.SetItem(_variant_t(8), _variant_t(3), _variant_t(L"C25混凝土面层（厚0.23m）"));
	ExcelRange.SetItem(_variant_t(9), _variant_t(3), _variant_t(L"5%水泥稳定碎石（厚0.18m）"));
	ExcelRange.SetItem(_variant_t(10), _variant_t(3), _variant_t(L"碎石路面（厚0.18m）"));
	for (int Line = 8; Line <= 10; Line++)
		ExcelRange.SetItem(_variant_t(Line), _variant_t(4), _variant_t(L"m²"));*/

	ExcelRange.SetItem(_variant_t(11+num), _variant_t(2), _variant_t(L"支挡工程"));
	ExcelRange.SetItem(_variant_t(11 + num), _variant_t(3), _variant_t(L"C15片石混凝土"));
	ExcelRange.SetItem(_variant_t(11 + num), _variant_t(4), _variant_t(L"m³"));

	MergeCellInExcel(ExcelWorksheet, ExcelRange, 12 + num, 14 + num, L"B", L"B");
	ExcelRange.SetItem(_variant_t(12 + num), _variant_t(2), _variant_t(L"附属工程"));
	ExcelRange.SetItem(_variant_t(12 + num), _variant_t(3), _variant_t(L"水沟总长度"));
	ExcelRange.SetItem(_variant_t(13 + num), _variant_t(3), _variant_t(L"土石方"));
	ExcelRange.SetItem(_variant_t(14 + num), _variant_t(3), _variant_t(L"M7.5浆砌片石"));
	ExcelRange.SetItem(_variant_t(12 + num), _variant_t(4), _variant_t(L"m"));
	ExcelRange.SetItem(_variant_t(13 + num), _variant_t(4), _variant_t(L"m³"));
	ExcelRange.SetItem(_variant_t(14 + num), _variant_t(4), _variant_t(L"m³"));

	MergeCellInExcel(ExcelWorksheet, ExcelRange, 15 + num, 16 + num, L"B", L"B");
	ExcelRange.SetItem(_variant_t(15 + num), _variant_t(2), _variant_t(L"安全设施"));
	ExcelRange.SetItem(_variant_t(15 + num), _variant_t(3), _variant_t(L"路侧式B级双波波形梁护栏"));
	ExcelRange.SetItem(_variant_t(16 + num), _variant_t(3), _variant_t(L"钢筋混凝土护栏"));
	ExcelRange.SetItem(_variant_t(15 + num), _variant_t(4), _variant_t(L"m"));
	ExcelRange.SetItem(_variant_t(16 + num), _variant_t(4), _variant_t(L"m³"));

	MergeCellInExcel(ExcelWorksheet, ExcelRange, 17 + num, 17 + num, L"A", L"C");
	ExcelRange.SetItem(_variant_t(17 + num), _variant_t(1), _variant_t(L"绿地总面积"));
	ExcelRange.SetItem(_variant_t(17 + num), _variant_t(4), _variant_t(L"m²"));

	MergeCellInExcel(ExcelWorksheet, ExcelRange, 18 + num, 18 + num, L"A", L"C");
	ExcelRange.SetItem(_variant_t(18 + num), _variant_t(1), _variant_t(L"排水涵管总长"));
	ExcelRange.SetItem(_variant_t(18 + num), _variant_t(4), _variant_t(L"m"));

	MergeCellInExcel(ExcelWorksheet, ExcelRange, 19 + num, 19 + num, L"A", L"C");
	ExcelRange.SetItem(_variant_t(19 + num), _variant_t(1), _variant_t(L"路面宽度"));
	ExcelRange.SetItem(_variant_t(19 + num), _variant_t(4), _variant_t(L"m"));

	MergeCellInExcel(ExcelWorksheet, ExcelRange, 20 + num, 20 + num, L"A", L"C");
	ExcelRange.SetItem(_variant_t(20 + num), _variant_t(1), _variant_t(L"用地总面积"));
	ExcelRange.SetItem(_variant_t(20 + num), _variant_t(4), _variant_t(L"亩"));

	//写内容
	//道路长度
	CString str;
	
	str.Format(L"%0.3f", RoadLen);
	ExcelRange.SetItem(_variant_t(4), _variant_t(5), _variant_t(str));

	//断面土石方
	//填方
	str.Format(L"%0.3f", FillEarWok);
	ExcelRange.SetItem(_variant_t(5), _variant_t(5), _variant_t(str));
	//挖方
	str.Format(L"%0.3f", CutEarWok);
	ExcelRange.SetItem(_variant_t(6), _variant_t(5), _variant_t(str));
	//挖石
	str.Format(L"%0.3lf", CutStnWok);
	ExcelRange.SetItem(_variant_t(7), _variant_t(5), _variant_t(str));

	//路面面积
	for (int i = 0; i < LmLayerInfor.aera.size(); i++)
	{
		str.Format(L"%0.3f", LmLayerInfor.aera.at(i));
		ExcelRange.SetItem(_variant_t(8+i), _variant_t(5), _variant_t(str));
	}
	LmLayerInfor.aera.clear();
	LmLayerInfor.depth.clear();
	LmLayerInfor.Layername.clear();
	LmLayerInfor.newlm.clear();
	/*str.Format(L"%0.3f", C25);
	ExcelRange.SetItem(_variant_t(8), _variant_t(5), _variant_t(str));
	str.Format(L"%0.3f", BrkStn);
	ExcelRange.SetItem(_variant_t(9), _variant_t(5), _variant_t(str));
	str.Format(L"%0.3lf",BrkPav);
	ExcelRange.SetItem(_variant_t(10), _variant_t(5), _variant_t(str));*/

	//支挡工程
	str.Format(L"%0.3lf",C15);
	ExcelRange.SetItem(_variant_t(11+num), _variant_t(5), _variant_t(str));

	//附属工程
	//水沟长度

	
	if (GutLen > 0)
		str.Format(L"%0.3f", GutLen);
	else
		str.Format(L"%0.0f", GutLen);
	ExcelRange.SetItem(_variant_t(12 + num), _variant_t(5), _variant_t(str));
	//土石方

	if (EarWok > 0)
		str.Format(L"%0.3f", EarWok);
	else
		str.Format(L"%0.0f", EarWok);
	ExcelRange.SetItem(_variant_t(13 + num), _variant_t(5), _variant_t(str));
	//浆砌片石
	
	 
	if (M75 > 0)
		str.Format(L"%0.3f", M75);
	else
		str.Format(L"%0.0f", M75);
	ExcelRange.SetItem(_variant_t(14 + num), _variant_t(5), _variant_t(str));

	//安全设施
	str.Format(L"%0.3lf",B);
	ExcelRange.SetItem(_variant_t(15 + num), _variant_t(5), _variant_t(str));
	str.Format(L"%0.3lf",Steel);
	ExcelRange.SetItem(_variant_t(16 + num), _variant_t(5), _variant_t(str));

	//绿地面积
	str.Format(L"%0.3f", GreAre);
	ExcelRange.SetItem(_variant_t(17 + num), _variant_t(5), _variant_t(str));

	//排水管涵
	str.Format(L"%0.3lf",HanGuan);
	ExcelRange.SetItem(_variant_t(18 + num), _variant_t(5), _variant_t(str));

	//路面宽度
	/*str.Format(L"%0.3f", 0);
	ExcelRange.SetItem(_variant_t(19 + num), _variant_t(5), _variant_t(str));*/

	//用地面积
	str.Format(L"%0.3lf", YDAllArea);
	ExcelRange.SetItem(_variant_t(20 + num), _variant_t(5), _variant_t(str));

	//设置宽度
	Range Cols;
	ExcelRange.ReleaseDispatch();
	LPDISPATCH pd = NULL;
	ACHAR scp[10];
	ACHAR fcp[10];
	_stprintf(scp, L"%s%ld", L"A", 1);
	_stprintf(fcp, L"%s%ld", L"F", 18);
	VERIFY(pd = ExcelWorksheet.GetRange(COleVariant(scp), COleVariant(fcp)));
	ExcelRange.AttachDispatch(pd);
	Cols = ExcelRange.GetEntireColumn();
	Cols.AutoFit();



	//断开连接
	ExcelRange.ReleaseDispatch();

	ExcelWorksheet.Activate();
	

	ExcelWorksheet.ReleaseDispatch();
	//20200328梁柱
	RoadLen=FillEarWok=CutEarWok=CutStnWok=C25=BrkStn=BrkPav=C15=GutLen=EarWok=M75= B= Steel=GreAre=HanGuan=YDAllArea=0;
}
bool HdmDes::MergeCellInExcel(_Worksheet wsMysheet, Range rgMyRge, long sLine, long eLine, CString sCol, CString eCol)//合并单元格
{
	ACHAR scp[10];
	ACHAR fcp[10];
	LPDISPATCH pd = NULL;

	rgMyRge.ReleaseDispatch();

	_stprintf(scp, L"%s%ld", sCol, sLine);
	_stprintf(fcp, L"%s%ld", eCol, eLine);
	VERIFY(pd = wsMysheet.GetRange(COleVariant(scp), COleVariant(fcp)));
	rgMyRge.AttachDispatch(pd);
	rgMyRge.Merge(_variant_t(false));

	return true;
}

/*===================================================================
函数名:CalMapList
------------------------------------------------------------
函数功能:计算横断面的排版
------------------------------------------------------------
输入:
------------------------------------------------------------
输出:
------------------------------------------------------------
算法描述:	1.计算出每个横断面的排版
			2.计算每个纵列
			3.计算每个纵列的最大宽度
			4.根据每个纵列的最大宽度调整位置和排版
------------------------------------------------------------
编写日期:20190903
------------------------------------------------------------
备注：
=====================================================================*/
void HdmDes::CalMapList(int iroad, double StartMl, double EndMl, double LEarthWid, double REarthWid, int ColNum)
{
	//设置参数
	double wmax = 0;
	int i, j;
	int StartIndex = 0;
	double BoxH = m_FrameHeight - 50.0 * 0.2 * Sfactor, BoxW = m_FrameWid;

	//寻找起始断面
	j = 0;
	while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < StartMl - 0.001)
		j++;
	StartIndex = j;

	//计算每个断面的高度和宽度
	vector<double> WideVec, HighVec;
	while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < EndMl + 1.0)
	{
		//切断地面线
		TrimEarthLine(iroad, j, LEarthWid, REarthWid);
		//计算出每个断面的hi,wi(高度，宽度)
		Calhiwi(iroad, j, road[iroad].hdmdes[j].hi, road[iroad].hdmdes[j].wi, road[iroad].hdmdes[j].Ymin, road[iroad].hdmdes[j].Ymax);//计算出每个断面的高和宽
		WideVec.push_back(road[iroad].hdmdes[j].wi);
		HighVec.push_back(road[iroad].hdmdes[j].hi);
		j++;
	}

	//计算每个列
	vector<vector<int>> AllColIndexRecord;
	vector<int> OneColIndexRecord;
	AllColIndexRecord.clear();
	OneColIndexRecord.clear();
	j = StartIndex;
	while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < EndMl + 0.1)
	{
		bool IfBri = false;
		OneColIndexRecord.clear();
		double H = road[iroad].hdmdes[j].hi;/* * 0.1 * Sfactor;*/
		int Count = 0;
		while (j < road[iroad].NCRS && road[iroad].hdmdes[j].cml < EndMl + 1.0 && (Count == 0 || H < BoxH - 0))
		{
			if (road[iroad].hdmdes[j].Lnpt > 0 || road[iroad].hdmdes[j].Rnpt > 0 ||
				road[iroad].hdmdes[j].Y_Lnpt > 0 || road[iroad].hdmdes[j].Y_Rnpt > 0)
				IfBri = false;
			else
				IfBri = true;

			if (road[iroad].hdmdes[j].IsInsertHdm > 0)//增加断面,2007.9.28.puhao
			{
				IfBri = true;
			}

			if (!IfBri)
				OneColIndexRecord.push_back(j);

			j++;
			if (j < road[iroad].NCRS && !IfBri)
				H += road[iroad].hdmdes[j].hi/* * 0.1 * Sfactor*/;

			Count++;
		}
		AllColIndexRecord.push_back(OneColIndexRecord);
	}

	//计算每列的最大宽度
	vector<double> AllMaxWid;
	AllMaxWid.clear();
	for (int k = 0; k < AllColIndexRecord.size(); k++)
	{
		double MaxWid = 0.0;
		for (int m = 0; m < AllColIndexRecord[k].size(); m++)
		{
			int CurIndex = AllColIndexRecord[k][m];
			if (road[iroad].hdmdes[CurIndex].wi/* * 0.1 * Sfactor*/ > MaxWid)
				MaxWid = road[iroad].hdmdes[CurIndex].wi/* * 0.1 * Sfactor*/;
		}
		AllMaxWid.push_back(MaxWid);
	}

	//定好图幅数量,并计算各种参数
	int imap = 0;
	MAP[imap].SX = StartX;
	MAP[imap].SY = StartY + 100 / 2.0 * 0.1 * Sfactor;	//20190821	修改横断面绘图位置，如需修改需要和DrawHdmMap绘制图框处联合修改
	int CurIndex = 0, FinalIndex = 0;
	double FinalWidth = 0.0;
	while (CurIndex < AllColIndexRecord.size())
	{
		//循环计算一幅图能放下几个
		FinalWidth = 0.0;
		FinalIndex = CurIndex;
		while (FinalWidth < m_FrameWid && FinalIndex < AllColIndexRecord.size() /*&& FinalIndex - CurIndex + 1 <= ColNum*/)
		{
			FinalWidth += AllMaxWid[FinalIndex] + (10.0 + 2.0) * Sfactor;	//计算一个图幅里所有的宽	其中(10.0 + 2.0) * Sfactor中10是横断面信息宽，2是间隔宽
			FinalIndex++;
		}

		if (FinalWidth > m_FrameWid && FinalIndex - CurIndex > 1)
			FinalIndex--;

		//计算间隔宽，这一步是为了保证右边不留太多空白，而是均匀分配到每一列的中间
		double DeltaX = 0.0;
		FinalWidth = 0.0;
		for (int k = CurIndex; k < FinalIndex; k++)
		{
			FinalWidth += AllMaxWid[k] + (10.0 + 2.0) * Sfactor;
		}
		DeltaX = (BoxW - FinalWidth) / (FinalIndex - CurIndex);

		//计算本图幅内横断面数量，记录每个横断面的下标，计算每个横断面的绘制原点
		MAP[imap].ncrs = 0;
		int Count = 0;
		double CurX = MAP[imap].SX;
		double CurY = MAP[imap].SY;
		double TotalHeight = 0.0;
		for (int k = CurIndex; k < FinalIndex; k++)
		{
			double DrawX = CurX + 10.0 * Sfactor + 1.0 * Sfactor;
			double DrawY = MAP[imap].SY;
			double TotalHeight = 0.0;

			//循环为MAP赋值，同时计算所有横断面的总高
			double ColMaxLX = 0.0, ColMaxRX = 0.0;
			MAP[imap].ncrs += AllColIndexRecord[k].size();
			for (int m = 0; m < AllColIndexRecord[k].size(); m++)
			{
				MAP[imap].HDMNO[Count] = AllColIndexRecord[k][m];
				Count++;
				TotalHeight += road[iroad].hdmdes[AllColIndexRecord[k][m]].hi/* * 0.1 * Sfactor*/;

				if (ColMaxLX < road[iroad].hdmdes[AllColIndexRecord[k][m]].Xmin)
					ColMaxLX = road[iroad].hdmdes[AllColIndexRecord[k][m]].Xmin;
				if (ColMaxRX < road[iroad].hdmdes[AllColIndexRecord[k][m]].Xmax)
					ColMaxRX = road[iroad].hdmdes[AllColIndexRecord[k][m]].Xmax;
			}

			//计算左侧最大间隔
			double MaxLX = 0.0;
			for (int m = 0; m < AllColIndexRecord[k].size(); m++)
			{

				int CrossIndex = AllColIndexRecord[k][m];
				if (MaxLX < road[iroad].hdmdes[CrossIndex].Xmin * Sfactor)
					MaxLX = road[iroad].hdmdes[CrossIndex].Xmin * Sfactor;
			}

			DrawX += MaxLX;

			//计算纵向间隔，为每个横断面赋值   
			double DY = (BoxH - TotalHeight) / (Count + 1);

			for (int m = 0; m < AllColIndexRecord[k].size(); m++)
			{

				int CrossIndex = AllColIndexRecord[k][m];
				//20190918	针对一列，将图形摆在中间
				if (FinalIndex - CurIndex == 1 && ColMaxRX * Sfactor < m_FrameWid / 2.0)
				{
					road[iroad].hdmdes[CrossIndex].Xo = MAP[imap].SX + m_FrameWid / 2.0;
					road[iroad].hdmdes[CrossIndex].DX = road[iroad].hdmdes[CrossIndex].Xo - MaxLX - 20 / 2 * Sfactor;
				}
				else
				{
					road[iroad].hdmdes[CrossIndex].Xo = DrawX + 1.0 * Sfactor;
					road[iroad].hdmdes[CrossIndex].DX = DrawX - MaxLX - 10 / 2 * Sfactor;
				}

				road[iroad].hdmdes[CrossIndex].Yo = DrawY;
				road[iroad].hdmdes[CrossIndex].Xmin = ColMaxLX;
				road[iroad].hdmdes[CrossIndex].Xmax = ColMaxRX;
				DrawY += road[iroad].hdmdes[CrossIndex].hi/* * 0.1 * Sfactor*/ + DY;
			}

			CurX += AllMaxWid[k] + (10.0 + 1.0) * Sfactor + DeltaX;
		}

		//检测是否还需要增加图幅
		if (FinalIndex < AllColIndexRecord.size())
		{
			imap++;//增加一幅图
			MAP[imap].SX = MAP[imap - 1].SX + 1000.0;
			MAP[imap].SY = MAP[imap - 1].SY;
			MAP[imap].ncrs = 0;
		}

		CurIndex = FinalIndex;
	}

	MAPSUM = imap + 1;
}


void HdmDes::DrawCrossNet(double DesH, double Xmin, double Xmax, double Ymin, double Ymax, AcGePoint3d* m_DesignPoints, double& CenterY)
{
	double NetLen = 1.0;	//间隔1m

	//绘图原点先暂定为设计点原点
	AcGePoint3d Oript(m_DesignPoints[0]);
	double IntDesH = (DesH - (int)DesH);
	Oript.y -= IntDesH * Sfactor;

	//计算左下角点
	double HeightToMin = (floor(DesH) - Ymin) * Sfactor;
	AcGePoint3d LeftBottomPt(Oript);
	LeftBottomPt.x -= Xmin * Sfactor;
	if (HeightToMin > 0)
		LeftBottomPt.y = LeftBottomPt.y - HeightToMin;
	else
		LeftBottomPt.y -= NetLen * Sfactor;


	//计算右上角点
	double HeightToMax = (Ymax - (int)DesH) * Sfactor;
	AcGePoint3d RightTopPt(Oript);
	RightTopPt.x += Xmax * Sfactor;
	if (HeightToMax > 0)
		RightTopPt.y += HeightToMax;
	else	//如果地面线均在设计标高以下，那么上面自动增加一格
		RightTopPt.y += NetLen * Sfactor;

	CenterY = (LeftBottomPt.y + RightTopPt.y) / 2.0;

	//画横线
	AcGePoint3d StartPt(LeftBottomPt), EndPt(LeftBottomPt);
	AcGePoint3d TextPt;
	CString str;
	ACHAR NumText[256];
	int CurHeight = (HeightToMin <= 0.001) ? floor(DesH) - 1 : Ymin;
	EndPt.x = RightTopPt.x;

	ACHAR LayerName[256];
	_tcscpy(LayerName, L"横断面图-网格线");
	for (double CurY = LeftBottomPt.y; CurY < RightTopPt.y + 1; CurY += NetLen * Sfactor)
	{
		StartPt.y = EndPt.y = CurY;
		if (m_IsDrawHengDuanMianWangGe)
			makeline(StartPt, EndPt, 8, 0, LayerName, L"DOT3");

		TextPt = StartPt;
		TextPt.x -= 0.1 * Sfactor;
		TextPt.y -= 0.2 * Sfactor;
		_stprintf(NumText, L"%d", CurHeight);
		if (m_IsDrawHengDuanMianWangGe)
			maketext(TextPt, NumText, 0.0, 0.4 * Sfactor, 8, 4, L"宋体", LayerName);
		CurHeight++;
	}

	//画竖线
	StartPt = EndPt = LeftBottomPt;
	EndPt.y = RightTopPt.y;
	int CurLen = Xmin;
	bool IsOver = false;
	for (double CurX = LeftBottomPt.x; CurX < RightTopPt.x + 1; CurX += NetLen * Sfactor)
	{
		StartPt.x = EndPt.x = CurX;
		if (m_IsDrawHengDuanMianWangGe)
			makeline(StartPt, EndPt, 8, 0, LayerName, L"DOT3");

		TextPt = StartPt;
		TextPt.y -= 0.4 * Sfactor;
		TextPt.x += 0.2 * Sfactor;

		_stprintf(NumText, L"%d", CurLen);
		if (CurLen > 0 && !IsOver)
		{
			CurLen--;
		}
		else
		{
			CurLen++;
			IsOver = true;
		}
		if (m_IsDrawHengDuanMianWangGe)
			maketext(TextPt, NumText, 0.0, 0.4 * Sfactor, 8, 4, L"宋体", LayerName);
	}
}

/*===================================================================
函数名:CheckLateralGutterExist
------------------------------------------------------------
函数功能:检测侧沟是否存在
------------------------------------------------------------
输入:	CRSDAT&		OneCross		横断面数据
		int			LorR			左侧或右侧
------------------------------------------------------------
输出:
------------------------------------------------------------
算法描述:	通过检测侧沟点数量以及前两个点是否相同判断
------------------------------------------------------------
编写日期:20190906
------------------------------------------------------------
备注：
=====================================================================*/
bool HdmDes::CheckLateralGutterExist(CRSDAT& OneCross, int LorR)
{
	int GutterNum = (LorR == LEFT) ? OneCross.LGouPtNum : OneCross.RGouPtNum;
	if (GutterNum == 0)		//为了兼容老的数据，再检测挖方断面设计点
	{
		double FillOrCut = (LorR == LEFT) ? OneCross.Zt : OneCross.Yt;
		if (FillOrCut < 0.001)
			return false;
		AcGePoint3dArray& ptArray = (LorR == LEFT) ? OneCross.RPTL : OneCross.RPTR;
		double FirstX = ptArray[4].x, FirstY = ptArray[4].y, SecondX = ptArray[5].x, SecondY = ptArray[5].y;
		if (fabs(FirstX - SecondX) < 0.01 && fabs(FirstY - SecondY) < 0.01)
			return false;
	}
	else
	{
		//检测第一个点和第二个点是否重合
		double* Gutter = (LorR == LEFT) ? OneCross.Lgou : OneCross.Rgou;
		double FirstX = Gutter[0], FirstY = Gutter[1], SecondX = Gutter[2], SecondY = Gutter[3];
		if (fabs(FirstX - SecondX) < 0.01 && fabs(FirstY - SecondY) < 0.01)
			return false;
	}

	return true;
}
//计算超高	20190906新增	从CalLMHP中拷贝
void HdmDes::CalSup(double cml, int ncg, CgSZ cg[], double& LMHP, double& YLJHP)
{
	double k;

	LMHP = 0;

	int i;
	for (i = 0; i < ncg; i++)
	{
		if (cml < cg[i].cml + 0.1)
			break;
	}

	if (i == ncg)//搜索不到区间
		LMHP = 0;
	else if (i == 0)
		LMHP = cg[0].cg;
	//////////////////////////////////////////////////////////////////////////
	else if (i > 0 && i < ncg && fabs(cg[i].cml - cg[i - 1].cml)>0.0001)
	{
		k = (cml - cg[i - 1].cml) / (cg[i].cml - cg[i - 1].cml);
		LMHP = cg[i - 1].cg + k * (cg[i].cg - cg[i - 1].cg);
	}
	else
		LMHP = cg[i - 1].cg;

	YLJHP = LMHP;
}

//绘制图框
void HdmDes::DrawTK(double OriX, double OriY, double DFACTOR)
{
	//20190912新增	设置图层
	ACHAR LayerName[256];
	_tcscpy(LayerName, L"工程数量表-图框");

	//定义一些尺寸
	double SpaceLen = 0.0, TypeLen = 0.0, DetailTypeLen = 0.0, UnitLen = 0.0, QuantityLen = 0.0, NoteLen = 0.0, BaseHeight = 0.0;
	SpaceLen = 10 * DFACTOR;
	TypeLen = 25 * DFACTOR;
	DetailTypeLen = 60 * DFACTOR;
	UnitLen = 25 * DFACTOR;
	QuantityLen = NoteLen = 30 * DFACTOR;
	BaseHeight = 5 * DFACTOR;
	double TotalLen = SpaceLen + TypeLen + DetailTypeLen + UnitLen + QuantityLen + NoteLen;
	int ColNum_Title = 3;
	int ColNum_RoadLen = 1;
	int	ColNum_Earth = 3;
	int ColNum_RoadArea = max(road[0].hdmbz.m_RoadLayerArray_L.size(), road[0].hdmbz.m_RoadLayerArray_R.size());
	int ColNum_Supporting = 1;
	int ColNum_Auxiliary = 3;
	int ColNum_Security = 2;
	int ColNum_Other = 4;
	double TotalHeight = BaseHeight * (ColNum_Title + ColNum_RoadLen + ColNum_Earth + ColNum_RoadArea + ColNum_Supporting + ColNum_Auxiliary + ColNum_Security + ColNum_Other);

	//绘制外框
	AcGePoint3d PtStart, PtEnd, PtOri;
	AcGeVector3d VecHori, VecVert;
	VecHori.set(1, 0, 0);
	VecVert.set(0, 1, 0);
	PtStart.set(OriX, OriY, 0.0);
	PtEnd = PtStart + TotalLen * VecHori;
	makeline(PtStart, PtEnd, 0, 0, LayerName);	//顶部横线
	PtStart = PtEnd - TotalHeight * VecVert;
	makeline(PtStart, PtEnd, 0, 0, LayerName);	//右边竖线
	PtEnd = PtStart - TotalLen * VecHori;
	makeline(PtStart, PtEnd, 0, 0, LayerName);	//底部横线
	PtStart = PtEnd + TotalHeight * VecVert;
	makeline(PtStart, PtEnd, 0, 0, LayerName);	//左边竖线

	//画内部横线
	//1.最长横线
	//顶部线
	PtStart.set(OriX, OriY - ColNum_Title * BaseHeight, 0.0);
	PtEnd = PtStart + TotalLen * VecHori;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	//底部线
	PtOri = PtStart - BaseHeight * (ColNum_RoadLen + ColNum_Earth + ColNum_RoadArea + ColNum_Supporting + ColNum_Auxiliary + ColNum_Security) * VecVert;
	for (int i = 0; i <= ColNum_Other; i++)
	{
		PtStart = PtOri - i * BaseHeight * VecVert;
		PtEnd = PtStart + TotalLen * VecHori;
		makeline(PtStart, PtEnd, 0, 0, LayerName);
	}
	//2.各模块线
	double ModLen = TotalLen - SpaceLen;
	PtStart.set(OriX + SpaceLen, OriY - (ColNum_Title + ColNum_RoadLen) * BaseHeight, 0.0);
	PtEnd = PtStart + ModLen * VecHori;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	PtStart = PtStart - ColNum_Earth * BaseHeight * VecVert;
	PtEnd = PtStart + ModLen * VecHori;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	PtStart = PtStart - ColNum_RoadArea * BaseHeight * VecVert;
	PtEnd = PtStart + ModLen * VecHori;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	PtStart = PtStart - ColNum_Supporting * BaseHeight * VecVert;
	PtEnd = PtStart + ModLen * VecHori;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	PtStart = PtStart - ColNum_Auxiliary * BaseHeight * VecVert;
	PtEnd = PtStart + ModLen * VecHori;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	PtStart = PtStart - ColNum_Security * BaseHeight * VecVert;
	PtEnd = PtStart + ModLen * VecHori;
	makeline(PtStart, PtEnd, 0, 0, LayerName);

	

	//3.细部线
	double SpeciLen = ModLen - TypeLen;
	PtOri.set(OriX + SpaceLen + TypeLen, OriY - BaseHeight * (ColNum_Title + ColNum_RoadLen), 0.0);
	for (int i = 0; i <= ColNum_Earth + ColNum_RoadArea + ColNum_Supporting + ColNum_Auxiliary + ColNum_Security; i++)
	{
		PtStart = PtOri - BaseHeight * i * VecVert;
		PtEnd = PtStart + SpeciLen * VecHori;
		makeline(PtStart, PtEnd, 0, 0, LayerName);
	}

	//画竖线
	//1.最长竖线
	PtStart.set(OriX + SpaceLen + TypeLen + DetailTypeLen, OriY, 0.0);
	PtEnd = PtStart - TotalHeight * VecVert;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	PtStart.x = PtEnd.x = PtStart.x + UnitLen;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	PtStart.x = PtEnd.x = PtStart.x + QuantityLen;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	//2.空白区域竖线
	PtStart.set(OriX + SpaceLen, OriY - BaseHeight * (ColNum_Title), 0.0);
	PtEnd = PtStart - BaseHeight * (ColNum_RoadLen + ColNum_Earth + ColNum_RoadArea + ColNum_Supporting + ColNum_Auxiliary + ColNum_Security) * VecVert;
	makeline(PtStart, PtEnd, 0, 0, LayerName);
	//3.详细模块竖线
	PtStart = PtStart + TypeLen * VecHori - BaseHeight * ColNum_RoadLen * VecVert;
	PtEnd = PtStart - BaseHeight * (ColNum_Earth + ColNum_RoadArea + ColNum_Supporting + ColNum_Auxiliary + ColNum_Security) * VecVert;
	makeline(PtStart, PtEnd, 0, 0, LayerName);

	//double Wtab = d1 + d2 + d3 + d2 + 2 * d4;//表长
	//double Htab = 19 * h1;//表高
	////绘制外框
	//AcGePoint3d  ptzs, ptzx, ptyx, ptys;
	//ptzs.x = OriX; ptzs.y = OriY;
	//ptzx.x = OriX; ptzx.y = OriY - Htab;
	//ptyx.x = OriX + Wtab; ptyx.y = OriY - Htab;
	//ptys.x = OriX + Wtab; ptys.y = OriY;
	//makeline(ptzs, ptzx, 0, 0, LayerName);
	//makeline(ptzx, ptyx, 0, 0, LayerName);
	//makeline(ptyx, ptys, 0, 0, LayerName);
	//makeline(ptys, ptzs, 0, 0, LayerName);
	////绘制内部线条
	////横线
	//AcGePoint3d spt, ept;
	//AcGeVector3d vec1, vec2;
	//vec1.set(1, 0, 0);
	//vec2.set(0, -1, 0);
	//spt = ptzs + 3 * h1*vec2;
	//ept = ptys + 3 * h1*vec2;
	//makeline(spt, ept, 0, 0, LayerName);//工程项目
	//spt = spt + d1 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//道路长度
	//spt = spt + d2 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//断面土石方
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//挖土
	//spt = spt - d2 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//挖石
	//spt = spt + d2 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//c25
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//5%
	//spt = spt - d2 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//ss
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//支挡工程
	//spt = spt + d2 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//sgcd
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//tsf
	//spt = spt - d2 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//m7.5
	//spt = spt + d2 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//lcs
	//spt = spt - d2 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//gj
	//spt = spt - d1 * vec1;
	//makeline(spt, ept, 0, 0, LayerName);//gj
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//yd
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//bcz
	//spt = spt + h1 * vec2;
	//ept = ept + h1 * vec2;
	//makeline(spt, ept, 0, 0, LayerName);//pshg
	////竖线
	//spt = ptzs + 3 * h1*vec2;
	//spt = spt + d1 * vec1;
	//ept = ptzx - 3 * h1*vec2;
	//ept = ept + d1 * vec1;
	//makeline(spt, ept, 0, 0, LayerName);
	//spt = spt + d2 * vec1;
	//spt = spt + h1 * vec2;
	//ept = ept + d2 * vec1;
	//makeline(spt, ept, 0, 0, LayerName);
	//spt = spt + d3 * vec1;
	//spt = spt - 4 * h1*vec2;
	//ept = ept + d3 * vec1;
	//ept = ept + 3 * h1*vec2;
	//makeline(spt, ept, 0, 0, LayerName);
	//spt = spt + d2 * vec1;
	//ept = ept + d2 * vec1;
	//makeline(spt, ept, 0, 0, LayerName);
	//spt = spt + d4 * vec1;
	//ept = ept + d4 * vec1;
	//makeline(spt, ept, 0, 0, LayerName);
}
//绘制文字
void HdmDes::DrawWord(double OriX, double OriY, double DFACTOR)
{
	//20190912新增	文字样式	图层名
	ACHAR TextStyle[32], LayerName[256];
	_tcscpy(TextStyle, L"宋体");
	_tcscpy(LayerName, L"工程数量表-文字");

	//20191018	确认存在的路面分层	暂时不考虑左右层不一致，以及厚度不一致的问题
	map<CString, double> RoadLayerMap;
	for (int i = 0; i < road[0].hdmbz.m_RoadLayerArray_L.size(); i++)
		RoadLayerMap[road[0].hdmbz.m_RoadLayerArray_L[i].LayerName] = road[0].hdmbz.m_RoadLayerArray_L[i].LayerThickness;
	for (int i = 0; i < road[0].hdmbz.m_RoadLayerArray_R.size(); i++)
		RoadLayerMap[road[0].hdmbz.m_RoadLayerArray_R[i].LayerName] = road[0].hdmbz.m_RoadLayerArray_R[i].LayerThickness;


	//定义一些尺寸
	double d1, d2, d3, d4, h1;
	double texth;
	d1 = 10 * DFACTOR;
	d2 = 25 * DFACTOR;
	d3 = 60 * DFACTOR;
	d4 = 30 * DFACTOR;
	h1 = 5 * DFACTOR;
	double Wtab = d1 + d2 + d3 + d2 + 2 * d4;//表长
	double Htab = 19 * h1;//表高
	texth = 4 * DFACTOR;
	//外框四点
	AcGePoint3d  ptzs, ptzx, ptyx, ptys;
	ptzs.x = OriX; ptzs.y = OriY;
	ptzx.x = OriX; ptzx.y = OriY - Htab;
	ptyx.x = OriX + Wtab; ptyx.y = OriY - Htab;
	ptys.x = OriX + Wtab; ptys.y = OriY;
	//注字
	AcGePoint3d spt, ept;
	AcGeVector3d vec1, vec2;
	ACHAR chr[32];
	vec1.set(1, 0, 0);
	vec2.set(0, -1, 0);
	_tcscpy(chr, L"工程数量表");
	texth = 10 * DFACTOR;
	spt = ptzs + Wtab / 2 * vec1;
	spt = spt - texth * 3 / 4 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"工程项目");
	texth = 4 * DFACTOR;
	spt = ptzs + 1.5 * h1*vec2;
	spt = spt + (d1 + d2 + d3) / 2 * vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"单位");
	spt = spt + (d1 + 2 * d2 + d3) / 2 * vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"数量");
	spt = spt + (d2 + d4) / 2 * vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"附注");
	spt = spt + d4 * vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"道路长度");
	spt = ptzs + 3.5*h1*vec2;
	spt = spt + (d1 + (d2 + d3) / 2)*vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"m");
	spt = spt + (d2 + d3 / 2)*vec1;
	spt.y = spt.y - 2 * DFACTOR;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"断面土石方");
	spt.y = spt.y + 2 * DFACTOR;
	spt = ptzs + 5.5*h1*vec2;
	spt = spt + (d1 + d2 / 2)*vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);

	//20200329梁柱
	int num = 0;
	if (road[0].hdmbz.m_RoadLayerArray_L.size()|| road[0].hdmbz.m_RoadLayerArray_R.size())
	{
		num= max(road[0].hdmbz.m_RoadLayerArray_L.size(), road[0].hdmbz.m_RoadLayerArray_R.size());
		_tcscpy(chr, L"路面面积");
		spt = spt + (num / 2.0 + 1.5) * h1 * vec2;
		maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	}
	if (num==0)
	{
		num = 3;
	}
	_tcscpy(chr, L"支挡工程");
	spt = spt + (num / 2.0 + 0.5) * h1*vec2;
	//////
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"附属工程");
	spt = spt + 2 * h1*vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"安全设施");
	spt = spt + 2.5 * h1*vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);


	_tcscpy(chr, L"填方（含夯填土）");
	spt = ptzs + 4.5*h1*vec2;
	spt = spt + (d1 + d2 + d3 / 2)*vec1;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"挖土");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"挖石");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);

	map<CString, double>::iterator map_it = RoadLayerMap.begin();
	while (map_it != RoadLayerMap.end())
	{
		_stprintf(chr, L"%s（厚%.3lfm）", map_it->first, map_it->second);
		spt = spt + h1 * vec2;
		maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
		++map_it;
	}

	//_tcscpy(chr, L"C25混凝土面层（厚0.23m）");
	//spt = spt + h1 * vec2;
	//maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//_tcscpy(chr, L"5%水泥稳定碎石（厚0.18m）");
	//spt = spt + h1 * vec2;
	//maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//_tcscpy(chr, L"碎石路面（厚0.18m）");
	//spt = spt + h1 * vec2;
	//maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);


	_tcscpy(chr, L"C15片石混凝土");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"水沟长度");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"土石方");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"M7.5浆砌片石");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"路侧式B级双波波形梁护栏");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"钢筋混凝土护栏");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	//_tcscpy(chr, L"用地");
	//spt = ptzx - 3.5*h1*vec2;
	//spt = spt + (d1 + d2 + d3) / 2 * vec1;
	//maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"绿地面积");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"排水涵管");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);

	_tcscpy(chr, L"路面宽度");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);
	_tcscpy(chr, L"用地面积");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 3, TextStyle, LayerName);

	_tcscpy(chr, L"m³");
	spt = ptzs + 4.5*h1*vec2;
	spt = spt + (d1 + d2 + d3 + d2 / 2) * vec1;
	spt.y = spt.y - 2 * DFACTOR;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"m³");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"m³");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	for (int i = 0; i < RoadLayerMap.size(); i++)
	{
		_tcscpy(chr, L"m²");
		spt = spt + h1 * vec2;
		maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	}

	_tcscpy(chr, L"m³");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"m");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"m³");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"m³");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"m");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"m³");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	//_tcscpy(chr, L"亩");
	//spt = spt + h1 * vec2;
	//maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"m²");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"m");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);

	_tcscpy(chr, L"m");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);
	_tcscpy(chr, L"亩");
	spt = spt + h1 * vec2;
	maketext(spt, chr, 0, texth, 0, 1, TextStyle, LayerName);

}

//修正横断面数组	20190911新增
void HdmDes::ModifyCrossArray(int iroad)
{
	//将横断面数据复制到vector中，方便插入数据
	std::vector<CRSDAT> VecCrossArray;
	for (int i = 0; i < road[iroad].NCRS; i++)
	{
		VecCrossArray.push_back(road[iroad].hdmdes[i]);
	}

	//逐个断面插入
	for (int i = 0; i < m_CrossTypeArray.size(); i++)
	{
		int Count = -1;
		for (int j = 1; j < VecCrossArray.size(); j++)
		{
			if (m_CrossTypeArray[i].Cml > VecCrossArray[j - 1].cml - 0.01 && m_CrossTypeArray[i].Cml < VecCrossArray[j].cml + 0.01)
			{
				Count = j;
				break;
			}
		}

		if (Count == -1)
		{
			AfxMessageBox(L"数据超出道路里程范围！");
			continue;
		}

		CRSDAT tempCross;
		if (fabs(m_CrossTypeArray[i].Cml - VecCrossArray[Count - 1].cml) < fabs(m_CrossTypeArray[i].Cml - VecCrossArray[Count].cml))
			Count = Count - 1;

		tempCross = VecCrossArray[Count];
		tempCross.cml = m_CrossTypeArray[i].Cml;

		switch (m_CrossTypeArray[i].Type)
		{
		case 1:
		case 5:
			tempCross.ZDMXZ = -1;	//桥头、涵洞头
			break;
		case 2:
		case 6:
			tempCross.ZDMXZ = 1;	//桥尾、涵洞尾
			break;
		case 3:
			tempCross.ZDMXZ = -2;
			break;
		case 4:
			tempCross.ZDMXZ = 2;
			break;
		default:
			break;
		}

		VecCrossArray.insert(VecCrossArray.begin() + Count, tempCross);
	}

	//为在范围内的断面赋属性值
	if (m_CrossTypeArray.size() % 2 != 0)
	{
		AfxMessageBox(L"指定桩号存在问题！");
		return;
	}
	for (int i = 0; i * 2 + 1 < m_CrossTypeArray.size(); i++)
	{
		//设置起终里程
		double Scml = m_CrossTypeArray[i * 2].Cml + 0.1;
		double Ecml = m_CrossTypeArray[i * 2 + 1].Cml - 0.1;

		//设置类型
		int Type = 0;
		if (m_CrossTypeArray[i * 2].Type == 1 || m_CrossTypeArray[i * 2].Type == 5)
			Type = 3;	//桥中
		else if (m_CrossTypeArray[i * 2].Type == 3)
			Type = 4;	//隧中

		//修改类型
		for (int j = 0; j < VecCrossArray.size(); j++)
		{
			if (VecCrossArray[j].cml > Scml && VecCrossArray[j].cml < Ecml)
				VecCrossArray[j].ZDMXZ = Type;
		}
	}

	if (road[iroad].hdmdes)
		delete[]road[iroad].hdmdes;

	if (!VecCrossArray.size())
		return;

	for (int i = 0; i < VecCrossArray.size() - 1; i++)
	{
		for (int j = 0; j < VecCrossArray.size() - 1 - i; j++)
		{
			if (VecCrossArray[j].cml > VecCrossArray[j + 1].cml)
			{
				std::swap(VecCrossArray[j], VecCrossArray[j + 1]);
			}
		}
	}

	road[iroad].NCRS = VecCrossArray.size();
	road[iroad].hdmdes = new CRSDAT[VecCrossArray.size()];
	for (int i = 0; i < VecCrossArray.size(); i++)
		road[iroad].hdmdes[i] = VecCrossArray[i];
}

void  HdmDes::DrawHDMOutput(double CenX, double CenY, ACHAR s_ckml[], ACHAR e_ckml[], CString TKname)
{
	//关闭捕捉对象
	BAS_DRAW_FUN::Set_OSMODE(0);
#ifdef VERSION_CAD2016
	acedCommandS(RTNONE);
	acedCommandS(RTSTR, L"setvar", RTSTR, L"cmdecho", RTSHORT, 0, RTNONE);
	acedCommandS(RTSTR, L"BLIPMODE", RTSTR, L"OFF", RTNONE);
	acedCommandS(RTSTR, L"UCSICON", RTSTR, L"OFF", RTNONE);
#endif // VERSION_CAD2016
#ifdef VERSION_CAD2010
	ads_command(RTNONE);
	ads_command(RTSTR, L"setvar", RTSTR, L"cmdecho", RTSHORT, 0, RTNONE);	//命令行提示关
	ads_command(RTSTR, L"BLIPMODE", RTSTR, L"OFF", RTNONE);	//十字架模式关
	ads_command(RTSTR, L"UCSICON", RTSTR, L"OFF", RTNONE);	//设置坐标系
#endif // VERSION_CAD2010
	AcGePoint3d pt;
	pt.x = CenX;
	pt.y = CenY;
	//m_Sdml = m_pm->XLC(m_Scml, SGH); //出图起始连续里程
	//m_Edml = m_pm->XLC(m_Ecml, EGH); //出图终止连续里程
	CString skml, ekml;
	skml = s_ckml;
	ekml = e_ckml;
	STuKuang* TK = NULL;
	TK = new STuKuang[1];

	//TK->StartTYLC = m_Sdml;;
	//TK->EndTYLC = m_Edml;
	//TK->StartXCLC = m_pm->XLC(m_Scml); //起始现场里程
	//TK->EndXCLC = m_pm->XLC(m_Ecml); //终止现场里程

	TK->CenX = pt.x;
	TK->CenY = pt.y;
	TK->LtUpX = TK->CenX - m_FrameWid / 2.0 - 50.0;
	TK->LtUpY = TK->CenY + m_FrameHeight / 2.0 + 10.0;

	TK->LtBmX = TK->CenX - m_FrameWid / 2.0 - 50.0;
	TK->LtBmY = TK->CenY - m_FrameHeight / 2.0 - 30.0;

	TK->RtUpX = TK->CenX + m_FrameWid / 2.0 + 10.0;
	TK->RtUpY = TK->CenY + m_FrameHeight / 2.0 + 10.0;

	TK->RtBmX = TK->CenX + m_FrameWid / 2.0 + 10.0;
	TK->RtBmY = TK->CenY - m_FrameHeight / 2.0 - 30.0;

	TransFormTK_HDM(TK, 411.48 / 2.0, 284.90 / 2.0, 1);

	STuKuang *CurTK = &TK[0];
	ACHAR LayoutName[256];
	_stprintf(LayoutName, L"HDM_%s～%s", skml, ekml);
	CMyLayout::CreateLayout(LayoutName);

#ifdef VERSION_CAD2010 
	ads_command(RTSTR, L"setvar", RTSTR, L"cmdecho", RTSHORT, 0, RTNONE);
	ads_command(RTSTR, L"-OSNAP", RTSTR, L"OFF");
#endif	

#ifdef VERSION_CAD2016
	acedCommandS(RTSTR, L"UCS", RTSTR, L"WORLD", RTNONE);
	acedCommandS(RTSTR, L"ERASE", RTSTR, L"ALL", RTSTR, L"", RTNONE);
#endif // VERSION_CAD2016
#ifdef VERSION_CAD2010
	ads_command(RTSTR, L"UCS", RTSTR, L"WORLD", RTNONE);  //设置坐标系
	ads_command(RTSTR, L"ERASE", RTSTR, L"ALL", RTSTR, L"", RTNONE); //清除布局中所有实体
#endif // VERSION_CAD2010

	ads_point p1, p2, p3, p4, z1, z2, ori, orix, oriy;
	double xmin, xmax, ymin, ymax;
	p1[X] = CurTK->newLtUpX;
	p1[Y] = CurTK->newLtUpY;

	p2[X] = CurTK->newRtUpX;
	p2[Y] = CurTK->newRtUpY;

	p3[X] = CurTK->newRtBmX;
	p3[Y] = CurTK->newRtBmY;

	p4[X] = CurTK->newLtBmX;
	p4[Y] = CurTK->newLtBmY;

	double jiao;
	BAS_DRAW_FUN::xyddaa(CurTK->LtBmX, CurTK->LtBmY, CurTK->RtBmX, CurTK->RtBmY, &jiao);
	jiao += 0.5*PI;
	ori[X] = CurTK->LtBmX;
	ori[Y] = CurTK->LtBmY;

	orix[X] = CurTK->RtBmX;
	orix[Y] = CurTK->RtBmY;

	oriy[X] = ori[X] + 10 * cos(jiao);
	oriy[Y] = ori[Y] + 10 * sin(jiao);

	//BAS_DRAW_FUN::getMinMaxXY(p1,p2,p3,p4,xmin,xmax,ymin,ymax);
	xmin = 0.0;
	xmax = (p3[X] - p4[X]);//*K;
	ymin = 0.0;
	ymax = (p2[Y] - p3[Y]);//*K;

	if (p1[X] < p4[X])xmin -= (p4[X] - p1[X]);//*K;
	if (p2[X] > p3[X])xmax += (p2[X] - p3[X]);//*K;					

	z1[X] = xmin;
	z1[Y] = ymin;
	z2[X] = xmax;
	z2[Y] = ymax;

#ifdef VERSION_CAD2010
	ads_command(RTSTR, L"-VPORTS", RTSTR, L"POLYGONAL", RTPOINT, p1, RTPOINT, p2, RTPOINT, p3, RTPOINT, p4, RTSTR, L"CLOSE", RTNONE);
	ads_command(RTSTR, L"MSPACE", RTNONE);
	ads_command(RTSTR, L"UCS", RTSTR, L"WORLD", RTNONE);

	ads_command(RTSTR, L"UCS", RTSTR, L"NEW", RTSTR, L"3POINT", RTPOINT, ori, RTPOINT, orix, RTPOINT, oriy, RTNONE);
	ads_command(RTSTR, L"PLAN", RTSTR, L"CURRENT", RTNONE);
	ads_command(RTSTR, L"ZOOM", RTSTR, L"WINDOW", RTPOINT, z1, RTPOINT, z2, RTNONE);
	ads_command(RTSTR, L"PSPACE", RTNONE);
	ads_command(RTSTR, L"UCS", RTSTR, L"WORLD", RTNONE);
	ads_command(RTSTR, L"-VPORTS", RTSTR, L"LOCK", RTSTR, L"ON", RTSTR, L"ALL", RTSTR, L"", RTNONE);
	ads_command(RTSTR, L"ZOOM", RTSTR, L"E", RTNONE);
	ads_command(RTNONE);
#endif // VERSION_CAD2010
	ACHAR dwgPath[80];
	_tcscpy(dwgPath, TKname);
	AcDbObjectId pBlockId;
	pBlockId = BAS_DRAW_FUN::CreateBlockFromDwgFile(dwgPath, L"");
	if (pBlockId > 0)
	{
		AcGePoint3d InsertPt(411.48 / 2.0, 284.90 / 2.0, 0.0);
		AcDbBlockReference *pBkRr = new AcDbBlockReference(InsertPt, pBlockId);
		pBkRr->setScaleFactors(AcGeScale3d(1, 1, 1));
		BAS_DRAW_FUN::AddEntityToDbs(pBkRr, 0, 1);
	}
#ifdef VERSION_CAD2016
	acedCommandS(RTSTR, L"-PLOT", RTSTR, L"Y", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"",
		RTSTR, L"E", RTSTR, L"F", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"",
		RTSTR, L"", RTSTR, L"Y", RTSTR, L"N", RTNONE);
	acedCommandS(RTNONE);
#endif // VERSION_CAD2016
#ifdef VERSION_CAD2010
	ads_command(RTSTR, L"-PLOT", RTSTR, L"Y", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"",
		RTSTR, L"E", RTSTR, L"F", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"", RTSTR, L"",
		RTSTR, L"", RTSTR, L"Y", RTSTR, L"N", RTNONE);
	ads_command(RTNONE);
#endif // VERSION_CAD2010

	if (TK)delete[]TK;
}

void  HdmDes::TransFormTK_HDM(STuKuang *TK, double CenX, double CenY, double scale)
{
	AcGeVector3d norm(0, 0, 1);
	norm.normalize();

	STuKuang *CurTK = &TK[0];

	CurTK->newCenX = CenX;
	CurTK->newCenY = CenY;

	AcGeMatrix3d xformR, xformT, xformS;
	double jiao;
	xyddaa(CurTK->LtBmX, CurTK->LtBmY, CurTK->RtBmX, CurTK->RtBmY, &jiao);

	AcGeVector3d  moveBy(CurTK->newCenX - CurTK->CenX, CurTK->newCenY - CurTK->CenY, 0.0);
	AcGePoint3d PP(CurTK->CenX, CurTK->CenY, 0.0);
	xformR.setToRotation(-1.0*jiao, norm, PP);
	xformT.setToTranslation(moveBy);
	CurTK->xform = xformT * xformR;

	AcGePoint3d StPt(CurTK->StX, CurTK->StY, 0.0);
	StPt.transformBy(CurTK->xform);
	CurTK->newStX = StPt.x;
	CurTK->newStY = StPt.y;

	AcGePoint3d EdPt(CurTK->EdX, CurTK->EdY, 0.0);
	EdPt.transformBy(CurTK->xform);
	CurTK->newEdX = EdPt.x;
	CurTK->newEdY = EdPt.y;

	AcGePoint3d LtUpPt(CurTK->LtUpX, CurTK->LtUpY, 0.0);
	LtUpPt.transformBy(CurTK->xform);
	CurTK->newLtUpX = LtUpPt.x;
	CurTK->newLtUpY = LtUpPt.y;

	AcGePoint3d LtBmPt(CurTK->LtBmX, CurTK->LtBmY, 0.0);
	LtBmPt.transformBy(CurTK->xform);
	CurTK->newLtBmX = LtBmPt.x;
	CurTK->newLtBmY = LtBmPt.y;

	AcGePoint3d RtUpPt(CurTK->RtUpX, CurTK->RtUpY, 0.0);
	RtUpPt.transformBy(CurTK->xform);
	CurTK->newRtUpX = RtUpPt.x;
	CurTK->newRtUpY = RtUpPt.y;

	AcGePoint3d RtBmPt(CurTK->RtBmX, CurTK->RtBmY, 0.0);
	RtBmPt.transformBy(CurTK->xform);
	CurTK->newRtBmX = RtBmPt.x;
	CurTK->newRtBmY = RtBmPt.y;
}

//删除横断面水沟
void HdmDes::DeleteGutter(AcDbObjectId EntID)
{
	AcDbObject* pObj = NULL;

	acDocManager->lockDocument(acDocManager->curDocument(), AcAp::kWrite);

	int wErrorStatus = acdbOpenObject(pObj, EntID, AcDb::kForWrite);
	if (wErrorStatus == Acad::eOk)
	{
		if (pObj->isKindOf(DesignLine_ROAD::desc()))
		{
			DesignLine_ROAD* desline = NULL;
			desline = DesignLine_ROAD::cast(pObj);
			desline->assertWriteEnabled();//加响应器修改实体时，不可少
			desline->SetLateralGutterPara(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
			desline->close();
		}
		else if (pObj->isKindOf(LTGOU_ROAD::desc()))
		{
			LTGOU_ROAD* pLTGOU = NULL;
			pLTGOU = LTGOU_ROAD::cast(pObj);
			pLTGOU->assertWriteEnabled();//加响应器修改实体时，不可少
			pLTGOU->DeleteGutter();
			pLTGOU->close();
		}
		else if (pObj->isKindOf(JSGOU_ROAD::desc()))
		{
			JSGOU_ROAD* pJSGOU = NULL;
			pJSGOU = JSGOU_ROAD::cast(pObj);
			pJSGOU->assertWriteEnabled();//加响应器修改实体时，不可少
			pJSGOU->DeleteGutter();
			pJSGOU->close();
		}
	}

	acDocManager->unlockDocument(acDocManager->curDocument());
}

//int HdmDes::CalBasCrossEarthLine()
//{
//	int  LPnum, RPnum, i, j;
//	double x, y, cita, yyt, LLd, RRd;
//	double xl[1000], yl[1000], zl[1000], xr[1000], yr[1000], zr[1000];
//	double Yd;
//	double pt1[3], pt2[3];
//	struct EdgeNode *CrsDmxHead, *Tmp;
//	double Sml, Eml;
//	int NDL;
//	
//	Sml = road[0].pm->QXB[0][0];
//	Eml = road[0].pm->QXB[road[0].pm->JdCenNum - 1][0];
//	road[0].pm->FormLCB(20.0, Sml, Eml);
//	road[0].pm->AddTZDtoLCB();
//
//
//	if (!ptriDTM.DTMHasRead)
//	{
//		if (!ptriDTM.Read_Dtm())
//			return;
//	}
//
//	
//	road[0].NCRS = road[0].pm->NLCB;
//	if (road[0].hdmdes)
//	{
//		delete road[0].hdmdes;
//		road[0].hdmdes = NULL;
//	}
//	road[0].hdmdes = new CRSDAT[road[0].pm->NLCB];
//
//	if (!road[0].hdmdes)
//	{
//		ads_printf(L"断面个数%d, 给横断面数组分配空间失败!\n", road[0].NCRS);
//		return 0;
//	}
//
//	for (i = 0; i < road[0].NCRS; i++)
//	{
//			road[0].hdmdes[i].cml = road[0].pm->pLCB[i].lc;
//		//----------------------------------------------------------------------------------	   
//		//计算地面线
//		//计算左右地面点
//		LLd = 100.0;
//		RRd = 100.0;
//		//LLd = FindIdmxk(road[0].pm, road[0].hdmdmx[i].lc, hdmmdb.NZCRS, hdmmdb.ZCRSWID);//地面线宽
//		//RRd = FindIdmxk(road[0].pm, road[0].hdmdmx[i].lc, hdmmdb.NYCRS, hdmmdb.YCRSWID);//地面线宽
//
//
//		xlpoint PZ;
//		PZ.lc = road[0].hdmdes[i].cml;
//		xlpoint_pz(road[0].pm->XYArray, road[0].pm->XYNum, &PZ);
//
//		pt1[0] = PZ.x, pt1[1] = PZ.y, pt1[2] = 0.0;
//
//		cita = PZ.a;
//		x = PZ.x, y = PZ.y;
//		yyt = cita - 0.5*pi;
//		pt2[0] = x + LLd * cos(yyt);
//		pt2[1] = y + LLd * sin(yyt);
//		pt2[2] = 0.0;
//
//		CrsDmxHead = ptriDTM.FindInterPt(pt1, pt2, LPnum);
//		if (LPnum > 0)//左侧地面线有点
//		{
//			j = 0;
//			while (CrsDmxHead)
//			{
//				xl[j] = CrsDmxHead->pt[0];
//				yl[j] = CrsDmxHead->pt[1];
//				zl[j] = CrsDmxHead->pt[2];
//
//				Tmp = CrsDmxHead;
//				CrsDmxHead = CrsDmxHead->next;
//				free(Tmp);
//				j++;
//			}
//
//			if (j > 0)
//			{
//				Yd = zl[0];
//				if (Yd < 0.1&&j>1)
//				{
//					Yd = zl[1];
//				}
//			}
//
//			for (j = 1; j < LPnum; j++)
//			{
//				xl[j] = sqrt((xl[j] - xl[0])*(xl[j] - xl[0]) + (yl[j] - yl[0])*(yl[j] - yl[0]));
//				if (zl[j] < 0.1)
//				{
//					if (j > 2)
//						zl[j] = zl[j - 1] + (zl[j - 1] - zl[j - 2]);
//					else if (j == 2)
//						zl[j] = zl[j - 1] + (zl[j - 1] - Yd);
//					else
//						zl[j] = Yd;
//				}
//				yl[j] = zl[j] - Yd;
//			}
//		}//至少有一个点
//		else//一个点也没有
//		{
//			LPnum = 2;
//			Yd = 0.0;
//			xl[0] = 0.0;
//			yl[0] = 0.0;
//
//			xl[1] = LLd;
//			yl[1] = 0.0;
//		}
//
//		yyt = cita + 0.5*pi;
//		pt2[0] = x + RRd * cos(yyt);
//		pt2[1] = y + RRd * sin(yyt);
//		pt2[2] = 0.0;
//
//		CrsDmxHead = ptriDTM.FindInterPt(pt1, pt2, RPnum);
//
//		//计算横断面左侧地面点坐标
//		if (RPnum > 0)
//		{
//			j = 0;
//			while (CrsDmxHead)
//			{
//				xr[j] = CrsDmxHead->pt[0];
//				yr[j] = CrsDmxHead->pt[1];
//				zr[j] = CrsDmxHead->pt[2];
//				Tmp = CrsDmxHead;
//				CrsDmxHead = CrsDmxHead->next;
//				free(Tmp);
//				j++;
//			}
//			for (j = 1; j < RPnum; j++)
//			{
//				xr[j] = sqrt((xr[j] - xr[0])*(xr[j] - xr[0]) + (yr[j] - yr[0])*(yr[j] - yr[0]));
//				if (zr[j] < 0.1)
//				{
//					if (j > 2)
//						zr[j] = zr[j - 1] + (zr[j - 1] - zr[j - 2]);
//					else if (j == 2)
//						zr[j] = zr[j - 1] + (zr[j - 1] - Yd);
//					else
//						zr[j] = Yd;
//				}
//				yr[j] = zr[j] - Yd;
//			}
//		}
//		else
//		{
//			RPnum = 2;
//			Yd = 0.0;
//			xr[0] = 0.0;
//			yr[0] = 0.0;
//
//			xr[1] = RRd;
//			yr[1] = 0.0;
//		}
//
//		
//
//		road[0].hdmdes[i].newLYd = Yd;
//		road[0].hdmdes[i].newRYd = Yd;
//
//		//地面线付值
//		road[0].hdmdes[i].Learpt[0] = 0.0;
//		road[0].hdmdes[i].Learpt[1] = 0.0;
//
//		for (j = 1; j <= road[0].hdmdes[i].NumL; j++)
//		{
//			road[0].hdmdes[i].Learpt[j * 2] = xl[j];
//			road[0].hdmdes[i].Learpt[j * 2 + 1] = yl[j];
//		}
//
//		road[0].hdmdes[i].Rearpt[0] = 0.0;
//		road[0].hdmdes[i].Rearpt[1] = 0.0;
//
//		for (j = 1; j <= road[0].hdmdes[i].NumR; j++)
//		{
//			road[0].hdmdes[i].Rearpt[j * 2] = xr[j];
//			road[0].hdmdes[i].Rearpt[j * 2 + 1] = yr[j];
//		}
//	}
//	return 1;
//}

int HdmDes::SimpDesCrossForOpt()//横断面简化设计（优化）
{
	double FillAera;
	double CutAera;

	for (int i = 0; i < road[0].NCRS; i++)
	{
		FillAera = 0.0;
		CutAera = 0.0;

		double cml = road[0].hdmdes[i].cml;
		if (i > 0)
			road[0].hdmdes[i].ZDMXZ = SetDmProperty(cml, road[0].pm, road[0].NZBri, road[0].ZBri,
				road[0].NAllBri, road[0].AllBri,
				road[0].NZTun, road[0].ZTun,
				road[0].NAllTun, road[0].AllTun, -1, road[0].hdmdes[i].BriZZDK, road[0].hdmdes[i - 1].ZDMXZ);
		else
			road[0].hdmdes[i].ZDMXZ = SetDmProperty(cml, road[0].pm, road[0].NZBri, road[0].ZBri,
				road[0].NAllBri, road[0].AllBri,
				road[0].NZTun, road[0].ZTun,
				road[0].NAllTun, road[0].AllTun, -1, road[0].hdmdes[i].BriZZDK, 0);


		if (road[0].hdmdes[i].ZDMXZ == 0)
		{
			double TWG = road[0].hdmdes[i].ZDesH - road[0].hdmdes[i].newLYd;//填挖高
			if (TWG < 0)//路堑
			{

				double SK = road[0].hdmdes[i].RHFL[6] + road[0].hdmdes[i].RHFR[6];//上边宽				
				double XK = SK + 2 * fabs(TWG) / 1.0;//下边宽
				CutAera = (SK + XK)*fabs(TWG) / 2;

			}
			if (TWG > 0)//路堤
			{

				double SK = road[0].hdmdes[i].RHFL[6] + road[0].hdmdes[i].RHFR[6];//上边宽				
				double XK = SK + 2 * fabs(TWG) / 1.0;//下边宽
				FillAera = (SK + XK)*fabs(TWG) / 2;
			}
		}
		road[0].hdmdes[i].aw = CutAera;
		road[0].hdmdes[i].at = FillAera;

	}

	return RTNORM;
}

int HdmDes::Cal_TSFJSBForOpt(int StartIndex, int EndIndex, double &FillSUM, double &CutSUM)
{
	// TODO: Add your control notification handler code here
	struct OriData
	{
		double cml, FillSoilArea, FillRockArea;
		double CutArea[6];
	}  CrsTF, FCrsTF;
	struct output
	{
		ACHAR ckml[80];
		double cml, CutAreaSum, FillSoilArea, FillRockArea, dis;
		double CutVolSum, CutVol[6], CutPer[6];
		double FillVolSum;
		double BZLY[6];//本桩利用
		double TQ;//填缺
		double BZWYF[6], BzwyfSoilSum, BzwyfRockSum;//本桩挖余方
	} CrsData, FCrsData;
	int i, j, m, DelSum, iWFFL, iLTTL;
	double AreaSum, BTinf;

	double K[6], WF[6], WFSUM, SoilORRockPer[6], FillVolSum;
	CString str;

	for (i = 0; i < 6; i++)
		K[i] = 1.0;

	DelSum = 0;
	FillSUM = 0.0;
	CutSUM = 0.0;

	for (i = StartIndex; i <= EndIndex; i++)
	{
		CrsTF.cml = road[0].hdmdes[i].cml;
		CrsTF.FillSoilArea = road[0].hdmdes[i].at;
		CrsTF.FillRockArea = 0.0;
		BTinf = road[0].hdmdes[i].ZDMXZ;

		CrsTF.CutArea[0] = road[0].hdmdes[i].aw;
		for (m = 1; m < 6; m++)
		{
			CrsTF.CutArea[m] = 0.0;//百分比
		}

		if (BTinf == 1.0 || BTinf == 2.0)
		{
			DelSum++;
			continue;
		}

		AreaSum = 0.0;
		AreaSum = road[0].hdmdes[i].aw;

		CrsData.CutAreaSum = AreaSum;
		CrsData.FillSoilArea = CrsTF.FillSoilArea;
		CrsData.FillRockArea = CrsTF.FillRockArea;

		if (i == StartIndex || BTinf == 3.0 || BTinf == 4.0)//桥尾或隧道尾
		{
			CrsData.dis = FCrsData.dis = 0.0;
			CrsData.CutVolSum = FCrsData.CutVolSum = 0.0;
			CrsData.FillVolSum = FCrsData.FillVolSum = 0.0;
			CrsData.TQ = FCrsData.TQ = 0.0;
			CrsData.BzwyfSoilSum = FCrsData.BzwyfSoilSum = 0.0;
			CrsData.BzwyfRockSum = FCrsData.BzwyfRockSum = 0.0;
			for (j = 0; j < 6; j++)
			{
				CrsData.CutVol[j] = FCrsData.CutVol[j] = 0.0;
				CrsData.CutPer[j] = FCrsData.CutPer[j] = 0.0;
				CrsData.BZLY[j] = FCrsData.BZLY[j] = 0.0;
				CrsData.BZWYF[j] = FCrsData.BZWYF[j] = 0.0;
			}
		}
		else
		{
			CrsData.dis = road[0].hdmdes[i].cml - road[0].hdmdes[i - 1].cml;
			CrsData.CutVolSum = 0.5*(CrsData.CutAreaSum + FCrsData.CutAreaSum)*CrsData.dis;
			CrsData.FillVolSum = 0.5*(CrsData.FillSoilArea + CrsData.FillRockArea + FCrsData.FillSoilArea + FCrsData.FillRockArea)*CrsData.dis;
			FillSUM += CrsData.FillVolSum;

			CutSUM += CrsData.CutVolSum;

			for (j = 0; j < 6; j++)
			{
				CrsData.CutVol[j] = 0.5*(CrsTF.CutArea[j] + FCrsTF.CutArea[j])*CrsData.dis;
				if (CrsData.CutVolSum > 0.0)//有挖方
				{
					if (CrsData.CutVol[j] > 0.0)
						CrsData.CutPer[j] = SoilORRockPer[j];
					else
						CrsData.CutPer[j] = 0.0;
				}
				else
					CrsData.CutPer[j] = 0.0;
			}
			//--------------------------计算本桩利用-----------------------
			if (CrsData.FillVolSum > 0.0)//有填方
			{

				for (j = 0; j < 6; j++)
					WF[j] = CrsData.CutVol[j] / K[j];//类石可利用数
				WFSUM = WF[0] + WF[1] + WF[2] + WF[3] + WF[4] + WF[5];

				if (CrsData.FillVolSum > WFSUM)//所有挖方均被利用,且有填缺
				{
					for (j = 0; j < 6; j++)
					{
						CrsData.BZLY[j] = CrsData.CutVol[j];
						CrsData.BZWYF[j] = 0.0;
					}
					CrsData.TQ = CrsData.FillVolSum - WFSUM;
					CrsData.BzwyfSoilSum = 0.0;
					CrsData.BzwyfRockSum = 0.0;
				}
				else////挖方中只有填方部分被利用,且有挖余
				{
					FillVolSum = CrsData.FillVolSum;
					CrsData.BzwyfSoilSum = 0.0;
					for (j = 0; j < 6; j++)
					{
						CrsData.BZLY[j] = 0.0;
						if (CrsData.CutVol[j] > 0.0 && FillVolSum > 0.01)
						{
							if (CrsData.CutVol[j] > FillVolSum*K[j])
								CrsData.BZLY[j] = FillVolSum * K[j];
							else
								CrsData.BZLY[j] = CrsData.CutVol[j];//全部利用

							FillVolSum = FillVolSum - CrsData.BZLY[j] / K[j];//第j类土全部利用后剩余							 	 
						}
						CrsData.BZWYF[j] = CrsData.CutVol[j] - CrsData.BZLY[j];

					}
					CrsData.BzwyfSoilSum += CrsData.BZWYF[0] + CrsData.BZWYF[1] + CrsData.BZWYF[2];
					CrsData.BzwyfRockSum += CrsData.BZWYF[3] + CrsData.BZWYF[4] + CrsData.BZWYF[5];
					CrsData.TQ = 0.0;
				}
			}
			else//无填方
			{
				CrsData.BzwyfSoilSum = 0.0;
				CrsData.BzwyfRockSum = 0.0;
				for (j = 0; j < 6; j++)
				{
					CrsData.BZLY[j] = 0.0;
					CrsData.BZWYF[j] = CrsData.CutVol[j];
					if (j < 3)
						CrsData.BzwyfSoilSum += CrsData.BZWYF[j];
					else
						CrsData.BzwyfRockSum += CrsData.BZWYF[j];
				}
				CrsData.TQ = 0.0;
			}
			//--------------------------计算本桩利用-----------------------
		}

		FCrsTF.cml = CrsTF.cml;
		FCrsTF.FillSoilArea = CrsTF.FillSoilArea;
		FCrsTF.FillRockArea = CrsTF.FillRockArea;
		for (m = 0; m < 6; m++)
			FCrsTF.CutArea[m] = CrsTF.CutArea[m];

		FCrsData.CutAreaSum = CrsData.CutAreaSum;
		FCrsData.FillSoilArea = CrsData.FillSoilArea;
		FCrsData.FillRockArea = CrsData.FillRockArea;
	}
	return RTNORM;
}

double HdmDes::Cal_des_level(double cml)
{
	char       str[80];
	int   j;
	double     z = -1.0, sml, eml;

	//--------------------------------------------------------
	//  sml = pzLinep->DLArray[0].ELC;//起始连续里程
	//  eml = pzLinep->XLLength;
	sml = CM[0];//起始连续里程
	eml = CM[(NCM - 2) * 5];
	// sml = pzLinep->DLArray[0].ELC;//起始连续里程
	// eml = pzLinep->XLLength;
	str[0] = '\0';
	if (cml<sml - 0.001 || cml>eml + 0.01)
	{
		return -1.0;
	}
	double tempDegree = 0.0;
	z = MLToH_Bas(cml, NCM, CM, tempDegree);
	return (z);

}